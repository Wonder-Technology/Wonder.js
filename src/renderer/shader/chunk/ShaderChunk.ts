module wd{
export class ShaderChunk{public static empty:GLSLChunk = {top:"", define:"", varDeclare:"", funcDeclare:"", funcDefine:"", body:""}
public static NULL:number = -1.0;
public static normal_morph_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "vec3 a_normal = a_currentFrameNormal + (a_nextFrameNormal - a_currentFrameNormal) * u_interpolation;\n",}
public static vertice_morph_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "vec3 a_position = a_currentFramePosition + (a_nextFramePosition - a_currentFramePosition) * u_interpolation;\n",}
public static basic_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_color;\n",funcDeclare: "",funcDefine: "",body: "vec4 totalColor = vec4(v_color, 1.0);\n",}
public static basic_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_color;\n",funcDeclare: "",funcDefine: "",body: "v_color = a_color;\n",}
public static end_basic_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "gl_FragColor = vec4(totalColor.rgb, totalColor.a * u_opacity);\n",}
public static common_define:GLSLChunk = {top: "",define: "#define NULL -1.0\n",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static common_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static common_function:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "mat2 transpose(mat2 m) {\n  return mat2(  m[0][0], m[1][0],   // new col 0\n                m[0][1], m[1][1]    // new col 1\n             );\n  }\nmat3 transpose(mat3 m) {\n  return mat3(  m[0][0], m[1][0], m[2][0],  // new col 0\n                m[0][1], m[1][1], m[2][1],  // new col 1\n                m[0][2], m[1][2], m[2][2]   // new col 1\n             );\n  }\n\nbool isRenderListEmpty(int isRenderListEmpty){\n  return isRenderListEmpty == 1;\n}\n",body: "",}
public static common_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static highp_fragment:GLSLChunk = {top: "precision highp float;\nprecision highp int;\n",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static lowp_fragment:GLSLChunk = {top: "precision lowp float;\nprecision lowp int;\n",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static mediump_fragment:GLSLChunk = {top: "precision mediump float;\nprecision mediump int;\n",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static noNormalMap_light_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_normal;\n",funcDeclare: "",funcDefine: "#if POINT_LIGHTS_COUNT > 0\nvec3 getPointLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getPointLightDirByLightPos(u_pointLights[x].position);\n        }\n    }\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvec3 getDirectionLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getDirectionLightDirByLightPos(u_directionLights[x].position);\n        }\n    }\n\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n\nvec3 getViewDir(){\n    return normalize(u_cameraPos - v_worldPosition);\n}\n",body: "",}
public static common_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 flipNormal(vec3 normal){\n    vec3 normalForRefraction = normal;\n    normalForRefraction.y = -normalForRefraction.y;\n    normalForRefraction.z = -normalForRefraction.z;\n\n    return normalForRefraction;\n}\n",body: "",}
public static lightCommon_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_worldPosition;\n#if POINT_LIGHTS_COUNT > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\nstruct DirectionLight {\n    vec3 position;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n",funcDeclare: "",funcDefine: "",body: "",}
public static lightCommon_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_worldPosition;\n#if POINT_LIGHTS_COUNT > 0\n    struct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\n    struct DirectionLight {\n    vec3 position;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n",funcDeclare: "",funcDefine: "",body: "",}
public static lightEnd_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "gl_FragColor = totalColor;\n",}
public static light_common:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "vec3 getDirectionLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition);\n",funcDefine: "vec3 getDirectionLightDirByLightPos(vec3 lightPos){\n    return lightPos - vec3(0.0);\n    //return vec3(0.0) - lightPos;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos){\n    return lightPos - v_worldPosition;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition){\n    return lightPos - worldPosition;\n}\n",body: "",}
public static light_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float getBlinnShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 halfAngle = normalize(lightDir + viewDir);\n        float blinnTerm = dot(normal, halfAngle);\n\n        blinnTerm = clamp(blinnTerm, 0.0, 1.0);\n        blinnTerm = dotResultBetweenNormAndLight != 0.0 ? blinnTerm : 0.0;\n        blinnTerm = pow(blinnTerm, shininess);\n\n        return blinnTerm;\n}\n\nfloat getPhongShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float phongTerm = dot(viewDir, reflectDir);\n\n        phongTerm = clamp(phongTerm, 0.0, 1.0);\n        phongTerm = dotResultBetweenNormAndLight != 0.0 ? phongTerm : 0.0;\n        phongTerm = pow(phongTerm, shininess);\n\n        return phongTerm;\n}\n\nvec4 calcLight(vec3 lightDir, vec3 color, float intensity, float attenuation, vec3 normal, vec3 viewDir)\n{\n        vec3 materialLight = getMaterialLight();\n        vec4 materialDiffuse = getMaterialDiffuse();\n        vec3 materialSpecular = u_specular;\n        vec3 materialEmission = getMaterialEmission();\n\n        float specularStrength = getSpecularStrength();\n\n        float dotResultBetweenNormAndLight = dot(normal, lightDir);\n        float diff = max(dotResultBetweenNormAndLight, 0.0);\n\n        vec3 emissionColor = materialEmission;\n\n        vec3 ambientColor = (u_ambient + materialLight) * materialDiffuse.rgb;\n\n\n        if(u_lightModel == 3){\n            return vec4(emissionColor + ambientColor, 1.0);\n        }\n\n        vec4 diffuseColor = vec4(color * materialDiffuse.rgb * diff * intensity, materialDiffuse.a);\n\n        float spec = 0.0;\n\n        if(u_lightModel == 2){\n                spec = getPhongShininess(u_shininess, normal, lightDir, viewDir, diff);\n        }\n        else if(u_lightModel == 1){\n                spec = getBlinnShininess(u_shininess, normal, lightDir, viewDir, diff);\n        }\n\n        vec3 specularColor = spec * materialSpecular * specularStrength * intensity;\n\n        return vec4(emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor), diffuseColor.a);\n//        return vec4(emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor), 1.0);\n}\n\n\n\n\n#if POINT_LIGHTS_COUNT > 0\n        vec4 calcPointLight(vec3 lightDir, PointLight light, vec3 normal, vec3 viewDir)\n{\n        //lightDir is not normalize computing distance\n        float distance = length(lightDir);\n\n        float attenuation = 0.0;\n\n        if(light.range == NULL || distance < light.range)\n        {\n            attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n        }\n\n        lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\n        vec4 calcDirectionLight(vec3 lightDir, DirectionLight light, vec3 normal, vec3 viewDir)\n{\n        float attenuation = 1.0;\n\n        lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\nvec4 calcTotalLight(vec3 norm, vec3 viewDir){\n    vec4 totalLight = vec4(0.0);\n\n    #if POINT_LIGHTS_COUNT > 0\n                for(int i = 0; i < POINT_LIGHTS_COUNT; i++){\n                totalLight += calcPointLight(getPointLightDir(i), u_pointLights[i], norm, viewDir);\n        }\n    #endif\n\n    #if DIRECTION_LIGHTS_COUNT > 0\n                for(int i = 0; i < DIRECTION_LIGHTS_COUNT; i++){\n                totalLight += calcDirectionLight(getDirectionLightDir(i), u_directionLights[i], norm, viewDir);\n        }\n    #endif\n\n        return totalLight;\n}\n",body: "vec3 normal = normalize(getNormal());\n\n#ifdef BOTH_SIDE\nnormal = normal * (-1.0 + 2.0 * float(gl_FrontFacing));\n#endif\n\nvec3 viewDir = normalize(getViewDir());\n\nvec4 totalColor = calcTotalLight(normal, viewDir);\n\ntotalColor.a *= u_opacity;\n\ntotalColor.rgb = totalColor.rgb * getShadowVisibility();\n",}
public static light_setWorldPosition_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "v_worldPosition = vec3(mMatrix * vec4(a_position, 1.0));\n",}
public static light_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "gl_Position = u_pMatrix * u_vMatrix * vec4(v_worldPosition, 1.0);\n",}
public static map_forBasic_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_mapCoord0;\n",funcDeclare: "",funcDefine: "",body: "totalColor *= texture2D(u_sampler2D0, v_mapCoord0);\n",}
public static map_forBasic_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_mapCoord0;\n",funcDeclare: "",funcDefine: "",body: "vec2 sourceTexCoord0 = a_texCoord * u_map0SourceRegion.zw + u_map0SourceRegion.xy;\n\n    v_mapCoord0 = sourceTexCoord0 * u_map0RepeatRegion.zw + u_map0RepeatRegion.xy;\n",}
public static multi_map_forBasic_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_mapCoord0;\nvarying vec2 v_mapCoord1;\n",funcDeclare: "",funcDefine: "vec4 getMapColor(){\n            vec4 color0 = texture2D(u_sampler2D0, v_mapCoord0);\n            vec4 color1 = texture2D(u_sampler2D1, v_mapCoord1);\n\n            if(u_combineMode == 0){\n                return mix(color0, color1, u_mixRatio);\n            }\n            else if(u_combineMode == 1){\n                return color0 * color1;\n            }\n            else if(u_combineMode == 2){\n                return color0 + color1;\n            }\n\n            /*!\n            solve error in window7 chrome/firefox:\n            not all control paths return a value.\n            failed to create d3d shaders\n            */\n            return vec4(1.0);\n		}\n",body: "totalColor *= getMapColor();\n",}
public static multi_map_forBasic_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_mapCoord1;\n",funcDeclare: "",funcDefine: "",body: "vec2 sourceTexCoord1 = a_texCoord * u_map1SourceRegion.zw + u_map1SourceRegion.xy;\n\n    v_mapCoord1 = sourceTexCoord1 * u_map1RepeatRegion.zw + u_map1RepeatRegion.xy;\n",}
public static skybox_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_dir;\n",funcDeclare: "",funcDefine: "",body: "gl_FragColor = textureCube(u_samplerCube0, v_dir);\n",}
public static skybox_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_dir;\n",funcDeclare: "",funcDefine: "",body: "vec4 pos = u_pMatrix * mat4(mat3(u_vMatrix)) * mMatrix * vec4(a_position, 1.0);\n\n    gl_Position = pos.xyww;\n\n    v_dir = a_position;\n",}
public static basic_forBasic_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_dir;\n",funcDeclare: "",funcDefine: "",body: "totalColor *= textureCube(u_samplerCube0, v_dir);\n",}
public static basic_forBasic_envMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_dir;\n",funcDeclare: "",funcDefine: "",body: "v_dir = a_position;\n",}
public static forBasic_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_normal;\nvarying vec3 v_position;\n",funcDeclare: "",funcDefine: "",body: "vec3 inDir = normalize(v_position - u_cameraPos);\n",}
public static forBasic_envMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_normal;\nvarying vec3 v_position;\n",funcDeclare: "",funcDefine: "",body: "v_normal = normalize( normalMatrix * a_normal);\n    v_position = vec3(mMatrix * vec4(a_position, 1.0));\n",}
public static fresnel_forBasic_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float computeFresnelRatio(vec3 inDir, vec3 normal, float refractionRatio){\n    float f = pow(1.0 - refractionRatio, 2.0) / pow(1.0 + refractionRatio, 2.0);\n    float fresnelPower = 5.0;\n    float ratio = f + (1.0 - f) * pow((1.0 - dot(inDir, normal)), fresnelPower);\n\n    return ratio / 100.0;\n}\nvec4 getEnvMapTotalColor(vec3 inDir, vec3 normal){\n    vec3 reflectDir = reflect(inDir, normal);\n    vec3 refractDir = refract(inDir, flipNormal(normal), u_refractionRatio);\n\n    vec4 reflectColor = textureCube(u_samplerCube0, reflectDir);\n    vec4 refractColor = textureCube(u_samplerCube0, refractDir);\n\n    vec4 totalColor = vec4(0.0);\n\n	if(u_reflectivity != NULL){\n        totalColor = mix(reflectColor, refractColor, u_reflectivity);\n	}\n	else{\n        totalColor = mix(reflectColor, refractColor, computeFresnelRatio(inDir, normal, u_refractionRatio));\n	}\n\n	return totalColor;\n}\n",body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= getEnvMapTotalColor(inDir, normalize(v_normal));\n}\n",}
public static reflection_forBasic_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, reflect(inDir, normalize(v_normal)));\n}\n",}
public static refraction_forBasic_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, refract(inDir, v_normal, u_refractionRatio));\n}\n",}
public static modelMatrix_batch_instance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "mat4 mMatrix = u_mMatrix;\n",}
public static normalMatrix_batch_instance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "mat3 normalMatrix = u_normalMatrix;\n",}
public static basic_forLight_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_basicEnvMap_dir;\n",funcDeclare: "",funcDefine: "",body: "totalColor *= textureCube(u_samplerCube0, v_basicEnvMap_dir);\n",}
public static basic_forLight_envMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_basicEnvMap_dir;\n",funcDeclare: "",funcDefine: "",body: "v_basicEnvMap_dir = a_position;\n",}
public static forLight_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "vec3 inDir = normalize(v_worldPosition - u_cameraPos);\n",}
public static forLight_envMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static fresnel_forLight_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float computeFresnelRatio(vec3 inDir, vec3 normal, float refractionRatio){\n    float f = pow(1.0 - refractionRatio, 2.0) / pow(1.0 + refractionRatio, 2.0);\n    float fresnelPower = 5.0;\n    float ratio = f + (1.0 - f) * pow((1.0 - dot(inDir, normal)), fresnelPower);\n\n    return ratio / 100.0;\n}\n\nvec4 getEnvMapTotalColor(vec3 inDir, vec3 normal){\n    vec3 reflectDir = reflect(inDir, normal);\n\n/*!\n//todo why only fresnel->refraction need flip normal, but refraction don't need?\n*/\n    vec3 refractDir = refract(inDir, flipNormal(normal), u_refractionRatio);\n\n    vec4 reflectColor = textureCube(u_samplerCube0, reflectDir);\n    vec4 refractColor = textureCube(u_samplerCube0, refractDir);\n\n\n    vec4 totalColor = vec4(0.0);\n\n	if(u_reflectivity != NULL){\n        totalColor = mix(reflectColor, refractColor, u_reflectivity);\n	}\n	else{\n        totalColor = mix(reflectColor, refractColor, computeFresnelRatio(inDir, normal, u_refractionRatio));\n	}\n\n	return totalColor;\n}\n",body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n	totalColor *= getEnvMapTotalColor(inDir, normalize(getNormal()));\n}\n",}
public static reflection_forLight_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, reflect(inDir, normalize(getNormal())));\n}\n",}
public static refraction_forLight_envMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, refract(inDir, flipNormal(normal), u_refractionRatio));\n}\n",}
public static modelMatrix_noInstance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "mat4 mMatrix = u_mMatrix;\n",}
public static normalMatrix_noInstance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "mat3 normalMatrix = u_normalMatrix;\n",}
public static modelMatrix_hardware_instance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "mat4 mMatrix = mat4(a_mVec4_0, a_mVec4_1, a_mVec4_2, a_mVec4_3);\n",}
public static normalMatrix_hardware_instance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "mat3 normalMatrix = mat3(a_normalVec4_0, a_normalVec4_1, a_normalVec4_2);\n",}
public static diffuseMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_diffuseMapTexCoord;\n",funcDeclare: "",funcDefine: "vec4 getMaterialDiffuse() {\n        return texture2D(u_diffuseMapSampler, v_diffuseMapTexCoord);\n    }\n",body: "",}
public static diffuseMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_diffuseMapTexCoord;\n",funcDeclare: "",funcDefine: "",body: "//todo optimize(combine, reduce compute numbers)\n    //todo BasicTexture extract textureMatrix\n    vec2 sourceTexCoord = a_texCoord * u_diffuseMapSourceRegion.zw + u_diffuseMapSourceRegion.xy;\n    v_diffuseMapTexCoord = sourceTexCoord * u_diffuseMapRepeatRegion.zw + u_diffuseMapRepeatRegion.xy;\n",}
public static emissionMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_emissionMapTexCoord;\n",funcDeclare: "",funcDefine: "vec3 getMaterialEmission() {\n        return texture2D(u_emissionMapSampler, v_emissionMapTexCoord).rgb;\n    }\n",body: "",}
public static emissionMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_emissionMapTexCoord;\n",funcDeclare: "",funcDefine: "",body: "v_emissionMapTexCoord = a_texCoord;\n",}
public static lightMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_lightMapTexCoord;\n",funcDeclare: "",funcDefine: "vec3 getMaterialLight() {\n        return texture2D(u_lightMapSampler, v_lightMapTexCoord).rgb * u_lightMapIntensity;\n    }\n",body: "",}
public static lightMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_lightMapTexCoord;\n",funcDeclare: "",funcDefine: "",body: "v_lightMapTexCoord = a_texCoord;\n",}
public static noDiffuseMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec4 getMaterialDiffuse() {\n        return vec4(u_diffuse, 1.0);\n    }\n",body: "",}
public static noEmissionMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 getMaterialEmission() {\n        return u_emission;\n    }\n",body: "",}
public static noLightMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 getMaterialLight() {\n        return vec3(0.0);\n    }\n",body: "",}
public static noNormalMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "//varying vec3 v_normal;\n//",funcDeclare: "vec3 getNormal();\n\n",funcDefine: "//#if POINT_LIGHTS_COUNT > 0\n//vec3 getPointLightDir(int index){\n//    //workaround '[] : Index expression must be constant' error\n//    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n//        if(x == index){\n//            return getPointLightDirByLightPos(u_pointLights[x].position);\n//        }\n//    }\n//    /*!\n//    solve error in window7 chrome/firefox:\n//    not all control paths return a value.\n//    failed to create d3d shaders\n//    */\n//    return vec3(0.0);\n//}\n//#endif\n//\n//#if DIRECTION_LIGHTS_COUNT > 0\n//vec3 getDirectionLightDir(int index){\n//    //workaround '[] : Index expression must be constant' error\n//    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n//        if(x == index){\n//            return getDirectionLightDirByLightPos(u_directionLights[x].position);\n//        }\n//    }\n//\n//    /*!\n//    solve error in window7 chrome/firefox:\n//    not all control paths return a value.\n//    failed to create d3d shaders\n//    */\n//    return vec3(0.0);\n//}\n//#endif\n//\n//\n//vec3 getViewDir(){\n//    return normalize(u_cameraPos - v_worldPosition);\n//}\nvec3 getNormal(){\n    return v_normal;\n}\n\n",body: "",}
public static noNormalMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_normal;\n",funcDeclare: "",funcDefine: "",body: "v_normal = normalize(normalMatrix * a_normal);\n",}
public static noSpecularMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float getSpecularStrength() {\n        return 1.0;\n    }\n",body: "",}
public static normalMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_normalMapTexCoord;\nvarying vec3 v_viewDir;\n#if POINT_LIGHTS_COUNT > 0\nvarying vec3 v_pointLightDir[POINT_LIGHTS_COUNT];\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvarying vec3 v_directionLightDir[DIRECTION_LIGHTS_COUNT];\n#endif\n\n",funcDeclare: "vec3 getNormal();\n\nvec3 getLightDir(vec3 lightPos);\n\n",funcDefine: "#if POINT_LIGHTS_COUNT > 0\nvec3 getPointLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return v_pointLightDir[x];\n        }\n    }\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\n\nvec3 getDirectionLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return v_directionLightDir[x];\n        }\n    }\n\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n\nvec3 getViewDir(){\n    return v_viewDir;\n}\nvec3 getNormal(){\n        // Obtain normal from normal map in range [0,1]\n        vec3 normal = texture2D(u_normalMapSampler, v_normalMapTexCoord).rgb;\n\n        // Transform normal vector to range [-1,1]\n        return normalize(normal * 2.0 - 1.0);  // this normal is in tangent space\n}\n",body: "",}
public static normalMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_normalMapTexCoord;\n	varying vec3 v_viewDir;\n\n\n#if POINT_LIGHTS_COUNT > 0\nvarying vec3 v_pointLightDir[POINT_LIGHTS_COUNT];\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvarying vec3 v_directionLightDir[DIRECTION_LIGHTS_COUNT];\n#endif\n\n",funcDeclare: "",funcDefine: "mat3 computeTBN(mat3 normalMatrix){\n            vec3 T = normalize(normalMatrix * a_tangent);\n            vec3 N = normalize(normalMatrix * a_normal);\n            // re-orthogonalize T with respect to N\n            T = normalize(T - dot(T, N) * N);\n            // then retrieve perpendicular vector B with the cross product of T and N\n            vec3 B = cross(T, N);\n\n\n            return transpose(mat3(T, B, N));\n        }\n",body: "mat3 TBN = computeTBN(normalMatrix);\n\n    //v_tangentLightPos = TBN * light.position;\n    //v_tangentCameraPos  = TBN * u_cameraPos;\n    //v_tangentPos  = TBN * v_position;\n\n\n    vec3 tangentPosition = TBN * vec3(mMatrix * vec4(a_position, 1.0));\n\n    v_normalMapTexCoord = a_texCoord;\n\n    v_viewDir = normalize(TBN * u_cameraPos - tangentPosition);\n\n\n#if POINT_LIGHTS_COUNT > 0\n       for(int i = 0; i < POINT_LIGHTS_COUNT; i++){\n            //not normalize for computing distance\n            v_pointLightDir[i] = TBN * getPointLightDirByLightPos(u_pointLights[i].position, tangentPosition);\n       }\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\n       for(int i = 0; i < DIRECTION_LIGHTS_COUNT; i++){\n            v_directionLightDir[i] = normalize(- TBN * getDirectionLightDirByLightPos(u_directionLights[i].position));\n       }\n#endif\n\n",}
public static specularMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_specularMapTexCoord;\n",funcDeclare: "",funcDefine: "float getSpecularStrength() {\n        return texture2D(u_specularMapSampler, v_specularMapTexCoord).r;\n    }\n",body: "",}
public static specularMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_specularMapTexCoord;\n",funcDeclare: "",funcDefine: "",body: "v_specularMapTexCoord = a_texCoord;\n",}
public static buildCubemapShadowMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_worldPosition;\n",funcDeclare: "",funcDefine: "",body: "\n// get distance between fragment and light source\n    float lightDistance = length(v_worldPosition - u_lightPos);\n\n    // map to [0,1] range by dividing by farPlane\n    lightDistance = lightDistance / u_farPlane;\n\n\ngl_FragData[0] = packDepth(lightDistance);\n\n\n//gl_FragColor = vec4(0.5, 0.0, 1.0, 1.0);\n//gl_FragData[0] = vec4(lightDistance, 1.0, 1.0, 1.0);\n",}
public static buildCubemapShadowMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_worldPosition;\n",funcDeclare: "",funcDefine: "",body: "v_worldPosition = vec3(mMatrix * vec4(a_position, 1.0));\n    gl_Position = u_pMatrix * u_vMatrix * vec4(v_worldPosition, 1.0);\n",}
public static buildTwoDShadowMap_depthMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static buildTwoDShadowMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "",}
public static buildTwoDShadowMap_packDepth_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "gl_FragData[0] = packDepth(gl_FragCoord.z);\n",}
public static buildTwoDShadowMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "gl_Position = u_vpMatrixFromLight * mMatrix * vec4(a_position, 1.0);\n",}
public static commonBuildShadowMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "// Packing a float in GLSL with multiplication and mod\nvec4 packDepth(in float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n\n    return res;\n}\n",body: "",}
public static cubemapShadowMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "uniform samplerCube u_cubemapShadowMapSampler[ CUBEMAP_SHADOWMAP_COUNT ];\n\n    uniform int u_isCubemapRenderListEmpty[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform float u_cubemapShadowDarkness[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform float u_cubemapShadowBias[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform float u_farPlane[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform vec3 u_cubemapLightPos[ CUBEMAP_SHADOWMAP_COUNT ];\n",funcDeclare: "",funcDefine: "// PCF\nfloat getCubemapShadowVisibilityByPCF(float currentDepth, vec3 fragToLight, samplerCube cubemapShadowMapSampler, float shadowBias, float farPlane, float shadowDarkness){\n    //only support in opengl es 3.0+\n    //vec3 sampleOffsetDirections[20] = vec3[]\n    //(\n       //vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1),\n       //vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1),\n       //vec3( 1,  1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1,  1,  0),\n       //vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),\n       //vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1)\n    //);\n\n    vec3 sampleOffsetDirections[20];\n\n    sampleOffsetDirections[0] = vec3( 1,  1,  1);\n    sampleOffsetDirections[1] = vec3( 1,  -1,  1);\n    sampleOffsetDirections[2] = vec3( -1,  -1,  1);\n    sampleOffsetDirections[3] = vec3( -1,  1,  1);\n\n    sampleOffsetDirections[4] = vec3( 1,  1,  -1);\n    sampleOffsetDirections[5] = vec3( 1,  -1,  -1);\n    sampleOffsetDirections[6] = vec3( -1,  -1,  -1);\n    sampleOffsetDirections[7] = vec3( -1,  1,  -1);\n\n    sampleOffsetDirections[8] = vec3( 1,  1,  0);\n    sampleOffsetDirections[9] = vec3( 1,  -1,  0);\n    sampleOffsetDirections[10] = vec3( -1,  -1,  0);\n    sampleOffsetDirections[11] = vec3( -1,  1,  0);\n\n    sampleOffsetDirections[12] = vec3( 1,  0,  1);\n    sampleOffsetDirections[13] = vec3( -1,  0,  1);\n    sampleOffsetDirections[14] = vec3( 1,  0,  -1);\n    sampleOffsetDirections[15] = vec3( -1,  0,  -1);\n\n    sampleOffsetDirections[16] = vec3( 0,  1,  1);\n    sampleOffsetDirections[17] = vec3( 0,  -1,  1);\n    sampleOffsetDirections[18] = vec3( 0,  -1,  -1);\n    sampleOffsetDirections[19] = vec3( 0,  1,  -1);\n\n    float shadow = 0.0;\n    int samples = 20;\n\n    //float diskRadius = 0.00000;\n    //Another interesting trick we can apply here is that we can change the diskRadius based on how far the viewer is away from a fragment; this way we can increase the offset radius by the distance to the viewer, making the shadows softer when far away and sharper when close by.\n    float viewDistance = length(u_cameraPos - v_worldPosition);\n    float diskRadius = (1.0 + (viewDistance / farPlane)) / 25.0;\n\n    //for(int i = 0; i < samples; ++i)\n    for(int i = 0; i < 20; ++i)\n    {\n        float pcfDepth = unpackDepth(textureCube(cubemapShadowMapSampler, fragToLight + sampleOffsetDirections[i] * diskRadius));\n        pcfDepth *= farPlane;   // Undo mapping [0;1]\n        shadow += currentDepth - shadowBias > pcfDepth  ? shadowDarkness : 1.0;\n    }\n    shadow /= float(samples);\n\n    return shadow;\n}\n\n\nfloat getCubemapShadowVisibility(vec3 lightDir, samplerCube cubemapShadowMapSampler, vec3 lightPos, float farPlane, float shadowBias, float  shadowDarkness) {\n// Get vector between fragment position and light position\n    vec3 fragToLight= v_worldPosition - lightPos;\n    // Use the light to fragment vector to sample from the depth map\n    // Now get current linear depth as the length between the fragment and light position\n    float currentDepth = length(fragToLight);\n\n    #if defined(SHADOWMAP_TYPE_PCF)\n    return getCubemapShadowVisibilityByPCF(currentDepth, fragToLight, cubemapShadowMapSampler, getShadowBias(lightDir, shadowBias), farPlane, shadowDarkness);\n    #endif\n\n    float closestDepth = unpackDepth(textureCube(cubemapShadowMapSampler, fragToLight));\n\n    // It is currently in linear range between [0,1]. Re-transform back to original value\n    closestDepth *= farPlane;\n\n\n    return float(currentDepth > closestDepth + getShadowBias(lightDir, shadowBias) ? shadowDarkness : 1.0);\n}\n",body: "",}
public static noShadowMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 getShadowVisibility() {\n        return vec3(1.0);\n    }\n",body: "",}
public static totalShadowMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "float getShadowBias(vec3 lightDir, float shadowBias);\nfloat unpackDepth(vec4 rgbaDepth);\n",funcDefine: "float getShadowBias(vec3 lightDir, float shadowBias){\n    float bias = shadowBias;\n\n    if(shadowBias == NULL){\n        bias = 0.005;\n    }\n\n\n     /*!\n     A shadow bias of 0.005 solves the issues of our scene by a large extent, but some surfaces that have a steep angle to the light source might still produce shadow acne. A more solid approach would be to change the amount of bias based on the surface angle towards the light: something we can solve with the dot product:\n     */\n\n     return max(bias * (1.0 - dot(normalize(getNormal()), lightDir)), bias);\n\n    //return bias;\n}\n\nvec3 getShadowVisibility() {\n    vec3 shadowColor = vec3(1.0);\n    vec3 twoDLightDir = vec3(0.0);\n    vec3 cubemapLightDir = vec3(0.0);\n\n\n\n    //to normalMap, the lightDir use the origin one instead of normalMap's lightDir here(the lightDir is used for computing shadowBias, the origin one is enough for it)\n\n    #if TWOD_SHADOWMAP_COUNT > 0\n	for( int i = 0; i < TWOD_SHADOWMAP_COUNT; i ++ ) {\n        if(isRenderListEmpty(u_isTwoDRenderListEmpty[i])){\n            continue;\n        }\n\n        twoDLightDir = getDirectionLightDirByLightPos(u_twoDLightPos[i]);\n\n	////if is opposite to direction of light rays, no shadow\n\n        shadowColor *= getTwoDShadowVisibility(twoDLightDir, u_twoDShadowMapSampler[i], v_positionFromLight[i], u_twoDShadowBias[i], u_twoDShadowDarkness[i], u_twoDShadowSize[i]);\n	}\n	#endif\n\n\n	#if CUBEMAP_SHADOWMAP_COUNT > 0\n\n	for( int i = 0; i < CUBEMAP_SHADOWMAP_COUNT; i ++ ) {\n        if(isRenderListEmpty(u_isCubemapRenderListEmpty[i])){\n            continue;\n        }\n\n	////if is opposite to direction of light rays, no shadow\n\n        shadowColor *= getCubemapShadowVisibility(cubemapLightDir, u_cubemapShadowMapSampler[i], u_cubemapLightPos[i], u_farPlane[i], u_cubemapShadowBias[i], u_cubemapShadowDarkness[i]);\n	}\n	#endif\n\n	return shadowColor;\n}\n\nfloat unpackDepth(vec4 rgbaDepth) {\n    /*! make sure that the visibility from the shadow map which is not builded is always be 1.0 */\n    if(rgbaDepth == vec4(0.0)){\n        return 100000.0;\n    }\n\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n\n",body: "",}
public static twoDShadowMap_depthMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "float handleDepthMap(vec4 rgbaDepth);\n",funcDefine: "float handleDepthMap(vec4 rgbaDepth) {\n    return rgbaDepth.r;\n}\n",body: "",}
public static twoDShadowMap_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec4 v_positionFromLight[ TWOD_SHADOWMAP_COUNT ];\n    uniform int u_isTwoDRenderListEmpty[ TWOD_SHADOWMAP_COUNT ];\n	uniform sampler2D u_twoDShadowMapSampler[ TWOD_SHADOWMAP_COUNT ];\n	uniform float u_twoDShadowDarkness[ TWOD_SHADOWMAP_COUNT ];\n	uniform float u_twoDShadowBias[ TWOD_SHADOWMAP_COUNT ];\n	uniform vec2 u_twoDShadowSize[ TWOD_SHADOWMAP_COUNT ];\n	uniform vec3 u_twoDLightPos[ TWOD_SHADOWMAP_COUNT ];\n",funcDeclare: "",funcDefine: "// PCF\nfloat getTwoDShadowVisibilityByPCF(float currentDepth, vec2 shadowCoord, sampler2D twoDShadowMapSampler, float shadowBias, float shadowDarkness, vec2 shadowMapSize){\n\n    float shadow = 0.0;\n    vec2 texelSize = vec2(1.0 / shadowMapSize[0], 1.0 / shadowMapSize[1]);\n\n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            float pcfDepth = handleDepthMap(texture2D(twoDShadowMapSampler, shadowCoord + vec2(x, y) * texelSize));\n            shadow += currentDepth - shadowBias > pcfDepth  ? shadowDarkness : 1.0;\n        }\n    }\n    shadow /= 9.0;\n\n    return shadow;\n}\n\n\n\nfloat getTwoDShadowVisibility(vec3 lightDir, sampler2D twoDShadowMapSampler, vec4 v_positionFromLight, float shadowBias, float shadowDarkness, vec2 shadowSize) {\n    //project texture\n    vec3 shadowCoord = (v_positionFromLight.xyz / v_positionFromLight.w) / 2.0 + 0.5;\n    //vec3 shadowCoord = vec3(0.5, 0.5, 0.5);\n\n    #ifdef SHADOWMAP_TYPE_PCF\n    // Percentage-close filtering\n    // (9 pixel kernel)\n    return getTwoDShadowVisibilityByPCF(shadowCoord.z, shadowCoord.xy, twoDShadowMapSampler, getShadowBias(lightDir, shadowBias), shadowDarkness, shadowSize);\n\n    #else\n    return shadowCoord.z > handleDepthMap(texture2D(twoDShadowMapSampler, shadowCoord.xy)) + getShadowBias(lightDir, shadowBias) ? shadowDarkness : 1.0;\n    #endif\n}\n",body: "",}
public static twoDShadowMap_unpackDepth_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "float handleDepthMap(vec4 rgbaDepth);\n",funcDefine: "float handleDepthMap(vec4 rgbaDepth) {\n    return unpackDepth(rgbaDepth);\n}\n",body: "",}
public static twoDShadowMap_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec4 v_positionFromLight[ TWOD_SHADOWMAP_COUNT ];\nuniform mat4 u_vpMatrixFromLight[ TWOD_SHADOWMAP_COUNT ];\n",funcDeclare: "",funcDefine: "",body: "for( int i = 0; i < TWOD_SHADOWMAP_COUNT; i ++ ) {\n    v_positionFromLight[i] = u_vpMatrixFromLight[i] * vec4(v_worldPosition, 1.0);\n	}\n",}
public static basic_bitmapFont_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_bitmapCoord;\n",funcDeclare: "",funcDefine: "",body: "totalColor *= texture2D(u_bitmapSampler, v_bitmapCoord);\n",}
public static common_bitmapFont_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_bitmapCoord;\n",funcDeclare: "",funcDefine: "",body: "v_bitmapCoord = a_texCoord;\n",}
public static grass_map_fragment:GLSLChunk = {top: "",define: "",varDeclare: "struct GrassMapData {\n    vec4 sourceRegion;\n};\nuniform GrassMapData u_grassMapDatas[3];\n\n\nvarying vec2 v_grassTexCoord;\nvarying float v_quadIndex;\n",funcDeclare: "",funcDefine: "vec4 getGrassMapColor(in sampler2D grassMapSampler, in GrassMapData grassMapDatas[3]){\n    vec4 sourceRegion;\n\n    if(v_quadIndex == 0.0){\n        sourceRegion = grassMapDatas[0].sourceRegion;\n    }\n    else if(v_quadIndex == 1.0){\n        sourceRegion = grassMapDatas[1].sourceRegion;\n    }\n    else if(v_quadIndex == 2.0){\n        sourceRegion = grassMapDatas[2].sourceRegion;\n    }\n\n    return texture2D(grassMapSampler, v_grassTexCoord * sourceRegion.zw + sourceRegion.xy);\n}\n",body: "totalColor *= getGrassMapColor(u_grassMapSampler, u_grassMapDatas);\n",}
public static grass_map_setWorldPosition_vertex:GLSLChunk = {top: "",define: "",varDeclare: "struct GrassWindData {\n    vec2 direction;\n    float time;\n    float strength;\n};\nuniform GrassWindData u_windData;\n",funcDeclare: "",funcDefine: "bool isTopPartOfGrass(){\n    return a_texCoord.y >= 0.9;\n}\n\nfloat getWindPower(){\n    float windPower = sin(u_windData.time) * u_windData.strength;\n\n    return windPower;\n}\n\nvec3 computeVertexPositionForAnimation(vec3 position, float time, vec2 windDirection){\n    vec2 windData = windDirection * getWindPower();\n    vec3 translation = vec3(windData.x, 0, windData.y);\n\n    return position + translation;\n}\n",body: "vec3 position;\n\n    if(isTopPartOfGrass()){\n        position = computeVertexPositionForAnimation(a_position, u_windData.time, u_windData.direction);\n    }\n    else{\n        position = a_position;\n    }\n\n    v_worldPosition = vec3(mMatrix * vec4(position, 1.0));\n",}
public static grass_map_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_grassTexCoord;\nvarying float v_quadIndex;\n",funcDeclare: "",funcDefine: "",body: "v_grassTexCoord = a_texCoord;\nv_quadIndex = a_quadIndex;\n",}
public static grass_batch_instance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "uniform vec4 a_offset; // {x:x, y:y, z:z, w:rot} (blade's position & rotation)\n	uniform vec4 a_shape; // {x:width, y:height, z:lean, w:curve} (blade's a_shape properties)\n",funcDeclare: "",funcDefine: "",body: "",}
public static grass_common_instance_fragment:GLSLChunk = {top: "",define: "",varDeclare: "//	uniform vec3 fogColor;\n//	uniform float fogNear;\n//	uniform float fogFar;\n//	uniform vec3 grassFogColor;\n//	uniform float grassFogFar;\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n",funcDeclare: "",funcDefine: "",body: "vec4 color = v_color * texture2D(u_grassMapSampler, vec2(v_texCoord.s, v_texCoord.t));\n\n\n//		float depth = gl_FragCoord.z / gl_FragCoord.w;\n//		// apply 'grass fog' first\n//		float fogFactor = smoothstep(fogNear, grassFogFar, depth);\n//		color.rgb = mix(color.rgb, grassFogColor, fogFactor);\n//		// then apply atmosphere fog\n//		fogFactor = smoothstep(fogNear, fogFar, depth);\n//		color.rgb = mix(color.rgb, fogColor, fogFactor);\n		// output\n		gl_FragColor = color;\n",}
public static grass_common_instance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec4 v_color;\n    varying vec2 v_texCoord;\n",funcDeclare: "",funcDefine: "// Rotate by an angle\nvec2 rotate (float x, float y, float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return vec2(x * c - y * s, x * s + y * c);\n}\n\n// Rotate by a vector\nvec2 rotate (float x, float y, vec2 r) {\n    return vec2(x * r.x - y * r.y, x * r.y + y * r.x);\n}\n\nvec3 _getLightDir(){\n/*!\nregard any light as direction light\n*/\n    return getDirectionLightDir(u_lightPos);\n}\n\nvec4 computeLightColor(vec3 normal, float hpct){\n/*!\nonly consider one light\n\nnot consider ambient light\n*/\n    float c = max(-dot(normal, _getLightDir()), 0.0);\n\n    c = max(c - (1.0 - hpct) * 0.75, 0.0);\n    c = 0.3 + 0.7 * c;\n\n    vec4 color = vec4(\n        c * 0.85 + cos(a_offset.x * 80.0) * 0.05,\n        c * 0.95 + sin(a_offset.z * 140.0) * 0.05,\n        c * 0.95 + sin(a_offset.x * 99.0) * 0.05,\n        1.0\n    );\n\n    color.rgb = color.rgb * u_lightColor;\n\n    return color;\n}\n\n",body: "float vi = mod(a_vertexIndex, BLADE_VERTS); // vertex index for this side of the blade\n    float di = floor(vi / 2.0);  // div index (0 .. BLADE_DIVS)\n    float hpct = di / BLADE_SEGS;  // percent of height of blade this vertex is at\n    float bside = floor(a_vertexIndex / BLADE_VERTS);  // front/back side of blade\n    float bedge = mod(vi, 2.0);  // left/right edge (x=0 or x=1)\n    // Vertex position - start with 2D a_shape, no bend applied\n    vec4 pos = vec4(\n        a_shape.x * (bedge - 0.5) * (1.0 - pow(hpct, 3.0)), // taper blade edges as approach tip\n        a_shape.y * di / BLADE_SEGS, // height of vtx, unbent\n        0.0, // flat z, unbent\n        1.0\n    );\n\n\n    // Start computing a normal for this vertex\n    vec3 normal = vec3(rotate(0.0, bside * 2.0 - 1.0, a_offset.w), 0.0);\n\n//vec3 normal = vec3(0.0);\n//\n//if(bside == 0.0){\n//normal.x = -1.0;\n//}\n//else{\n//normal.x = 1.0;\n//}\n\n    // Apply blade's natural curve amount\n    float curve = a_shape.w;\n    // Then add animated curve amount by u_time using this blade's\n    // unique properties to randomize its oscillation\n    curve += a_shape.w + 0.125 * (sin(u_time * 4.0 + a_offset.w * 0.2 * a_shape.y + a_offset.x + a_offset.z));\n    // put lean and curve together\n    float rot = a_shape.z + curve * hpct;\n    vec2 rotv = vec2(cos(rot), sin(rot));\n    pos.zy = rotate(pos.z, pos.y, rotv);\n    normal.zy = rotate(normal.z, normal.y, rotv);\n//    normal.yx = rotate(normal.y, normal.x, rotv);\n\n    // rotation of this blade as a vector\n    rotv = vec2(cos(a_offset.w), sin(a_offset.w));\n    pos.xz = rotate(pos.x, pos.z, rotv);\n    normal.xz = rotate(normal.x, normal.z, rotv);\n\n    pos.x += u_grassRangeWidth / 2.0 - a_offset.x;\n    pos.z += u_grassRangeHeight / 2.0 - a_offset.z;\n\n    pos = u_mMatrix * pos;\n\n\n    pos.y += getHeightFromHeightMap(pos.x, pos.z) * u_terrainScaleY + u_terrainPositionY;\n\n\n\n\n    //todo add wind\n    //todo pass wind direction uniform\n\n    // Compute wind effect\n//    float wind = getHeightFromHeightMap(vec2(heightMapSampleTexCoord.x - u_time / 100.0, heightMapSampleTexCoord.y - u_time / 50.0));\n\n//    wind = (clamp(wind, 0.35, 0.85) - 0.35) * 2.0;\n//    wind = wind * wind * 1.5;\n\n//    wind *= hpct; // min(hpct * a_shape.y / BLADE_HEIGHT_TALL, 1.0); // scale wind by height of blade\n//    wind = -wind;\n//    rotv = vec2(cos(wind), sin(wind));\n    // Wind blows in axis-aligned direction to make things simpler\n//    pos.zy = rotate(pos.z, pos.y, rotv);\n//    normal.yz = rotate(normal.y, normal.z, rotv);\n\n    // Sample the data texture to get altitude for this blade position\n//    float altitude = texture2D(heightMap, heightMapSampleTexCoord).r;\n//    float altclr = (clamp(altitude, 0.45, 0.75) - 0.45) * 3.3333333;\n//    vec3 grassColor = mix(grassColorLow, grassColorHigh, altclr);\n    // Vertex color must be brighter because it is multiplied with blade texture\n//    grassColor = min(vec3(grassColor.r * 1.5, grassColor.g * 1.5, grassColor.b * 0.95), 1.0);\n//    altitude *= heightMapScale.z;\n\n    v_color = computeLightColor(normal, hpct);\n//    v_color.rgb = v_color.rgb * LIGHT_COLOR * grassColor;\n\n\n    // grass texture coordinate for this vertex\n    v_texCoord = vec2(bedge, di * 2.0);\n\n    gl_Position = u_vpMatrix * pos;\n",}
public static grass_hardware_instance_vertex:GLSLChunk = {top: "",define: "",varDeclare: "attribute vec4 a_offset; // {x:x, y:y, z:z, w:rot} (blade's position & rotation)\n	attribute vec4 a_shape; // {x:width, y:height, z:lean, w:curve} (blade's a_shape properties)\n",funcDeclare: "",funcDefine: "",body: "",}
public static terrain_layer_fragment:GLSLChunk = {top: "",define: "",varDeclare: "struct LayerHeightData {\n    float minHeight;\n    float maxHeight;\n    vec4 repeatRegion;\n};\nuniform LayerHeightData u_layerHeightDatas[LAYER_COUNT];\n//sampler2D can't be contained in struct\nuniform sampler2D u_layerSampler2Ds[LAYER_COUNT];\n\n\nvarying vec2 v_layerTexCoord;\n",funcDeclare: "",funcDefine: "vec4 getLayerMapColor(in sampler2D layerSampler2Ds[LAYER_COUNT], in LayerHeightData layerHeightDatas[LAYER_COUNT]){\n    vec4 color = vec4(0.0);\n    bool isInLayer = false;\n\n    float height = v_worldPosition.y;\n\n    for(int i = 0; i < LAYER_COUNT; i++){\n        if(height >= layerHeightDatas[i].minHeight && height < layerHeightDatas[i].maxHeight){\n            vec4 repeatRegion = layerHeightDatas[i].repeatRegion;\n\n            //todo blend color\n            //todo optimize:move 'v_layerTexCoord * repeatRegion.zw + repeatRegion.xy' to vertex shader?\n            color += texture2D(layerSampler2Ds[i], v_layerTexCoord * repeatRegion.zw + repeatRegion.xy);\n\n            isInLayer = true;\n\n            break;\n        }\n    }\n\n    return isInLayer ? color : vec4(1.0);\n}\n",body: "\ntotalColor *= getLayerMapColor(u_layerSampler2Ds, u_layerHeightDatas);\n",}
public static terrain_layer_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_layerTexCoord;\n",funcDeclare: "",funcDefine: "",body: "v_layerTexCoord = a_texCoord;\n",}
public static terrain_mix_bump_cotangentFrame_fallback:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "mat3 cotangentFrame(vec3 normal,vec3 p,vec2 uv)\n{\n    //todo how to implement dFdx,dFdy?\n    vec3 dp1=p;\n    vec3 dp2=p;\n    vec2 duv1=uv;\n    vec2 duv2=uv;\n    vec3 dp2perp=cross(dp2,normal);\n    vec3 dp1perp=cross(normal,dp1);\n    vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\n    vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\n\n    float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\n    return mat3(tangent*invmax,binormal*invmax,normal);\n}\n",body: "",}
public static terrain_mix_bump_cotangentFrame_standardDerivatives:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "mat3 cotangentFrame(vec3 normal,vec3 p,vec2 uv)\n{\n    vec3 dp1=dFdx(p);\n    vec3 dp2=dFdy(p);\n    vec2 duv1=dFdx(uv);\n    vec2 duv2=dFdy(uv);\n    vec3 dp2perp=cross(dp2,normal);\n    vec3 dp1perp=cross(normal,dp1);\n    vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\n    vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\n\n    float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\n    return mat3(tangent*invmax,binormal*invmax,normal);\n}\n",body: "",}
public static terrain_mix_bump_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "vec3 getNormal();\n",funcDefine: "vec3 getNormal(){\n    vec3 viewDir = getViewDir();\n    vec3 mixColor = baseColor.rgb;\n\n    vec3 bump1Color=texture2D(u_bumpMap1Sampler,v_diffuseMap1TexCoord).xyz;\n    vec3 bump2Color=texture2D(u_bumpMap2Sampler,v_diffuseMap2TexCoord).xyz;\n    vec3 bump3Color=texture2D(u_bumpMap3Sampler,v_diffuseMap3TexCoord).xyz;\n    bump1Color.rgb*=mixColor.r;\n    bump2Color.rgb=mix(bump1Color.rgb,bump2Color.rgb,mixColor.g);\n    vec3 map=mix(bump2Color.rgb,bump3Color.rgb,mixColor.b);\n    map=map*255./127.-128./127.;\n\n    mat3 TBN=cotangentFrame(v_normal,-viewDir,v_mixMapTexCoord);\n\n    return normalize(TBN*map);\n}\n",body: "",}
public static terrain_mix_bump_vertex:GLSLChunk = {top: "",define: "",varDeclare: "//varying vec3 v_normal;\n//\n//",funcDeclare: "",funcDefine: "",body: "//    v_normal = normalize(normalMatrix * a_normal);\n//",}
public static terrain_mix_common_fragment:GLSLChunk = {top: "",define: "",varDeclare: "vec4 baseColor;\n",funcDeclare: "",funcDefine: "",body: "baseColor = texture2D(u_mixMapSampler,v_mixMapTexCoord);\n",}
public static terrain_mix_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_mixMapTexCoord;\nvarying vec2 v_diffuseMap1TexCoord;\nvarying vec2 v_diffuseMap2TexCoord;\nvarying vec2 v_diffuseMap3TexCoord;\n",funcDeclare: "",funcDefine: "vec4 getMixMapColor(){\n    vec4 diffuse1Color=texture2D(u_diffuseMap1Sampler,v_diffuseMap1TexCoord);\n    vec4 diffuse2Color=texture2D(u_diffuseMap2Sampler,v_diffuseMap2TexCoord);\n    vec4 diffuse3Color=texture2D(u_diffuseMap3Sampler,v_diffuseMap3TexCoord);\n\n    diffuse1Color.rgb*=baseColor.r;\n    diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,baseColor.g);\n    baseColor.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,baseColor.b);\n\n    return baseColor;\n}\n",body: "totalColor *= getMixMapColor();\n",}
public static terrain_mix_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_mixMapTexCoord;\nvarying vec2 v_diffuseMap1TexCoord;\nvarying vec2 v_diffuseMap2TexCoord;\nvarying vec2 v_diffuseMap3TexCoord;\n",funcDeclare: "",funcDefine: "",body: "v_mixMapTexCoord = a_texCoord;\n\nv_diffuseMap1TexCoord = a_texCoord * u_diffuseMap1RepeatRegion.zw + u_diffuseMap1RepeatRegion.xy;\n\n\nv_diffuseMap2TexCoord = a_texCoord * u_diffuseMap2RepeatRegion.zw + u_diffuseMap2RepeatRegion.xy;\n\n\nv_diffuseMap3TexCoord = a_texCoord * u_diffuseMap3RepeatRegion.zw + u_diffuseMap3RepeatRegion.xy;\n",}
public static multiPages_bitmapFont_fragment:GLSLChunk = {top: "",define: "",varDeclare: "uniform sampler2D u_pageSampler2Ds[PAGE_COUNT];\nvarying vec2 v_bitmapCoord;\nvarying float v_page;\n",funcDeclare: "",funcDefine: "",body: "",}
public static multiPages_bitmapFont_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying float v_page;\n",funcDeclare: "",funcDefine: "",body: "v_page = a_page;\n",}
public static sdf_bitmapFont_smoothStep_fallback:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float sdfSmoothStep(float value) {\n    /*! gl_FragCoord.w is wrong, need fix! */\n    float afwidth = (1.0 / 32.0) * (1.4142135623730951 / (2.0 * gl_FragCoord.w));\n    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);\n}\n",body: "",}
public static sdf_bitmapFont_smoothStep_standardDerivatives:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float sdfSmoothStep(float value) {\n      float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);\n}\n",body: "",}
public static sdf_bitmapFont_smooth_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_bitmapCoord;\n",funcDeclare: "",funcDefine: "",body: "gl_FragColor.a *= sdfSmoothStep(texture2D(u_bitmapSampler, v_bitmapCoord).a);\n",}
public static common_heightMap:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float _getHeightFromHeightMap(vec2 heightMapSampleTexCoord){\nheightMapSampleTexCoord.x /= u_terrainSubdivisions;\nheightMapSampleTexCoord.y =  1.0 - heightMapSampleTexCoord.y / u_terrainSubdivisions;\n\n    vec4 data = texture2D(u_heightMapSampler, heightMapSampleTexCoord);\n    /*!\n     compute gradient from rgb heightMap->r,g,b components\n     */\n    float r = data.r,\n    g = data.g,\n    b = data.b,\n    gradient = r * 0.3 + g * 0.59 + b * 0.11;\n\n    return u_terrainMinHeight + (u_terrainMaxHeight - u_terrainMinHeight) * gradient;\n}\n\n\nfloat _getBilinearInterpolatedHeight(vec2 offset, float heightMinXMinZ, float heightMaxXMinZ, float heightMaxXMaxZ, float heightMinXMaxZ){\n    return (heightMinXMinZ * (1.0 - offset.x) + heightMaxXMinZ * offset.x) * (1.0 - offset.y) + (heightMaxXMaxZ * offset.x + heightMinXMaxZ * (1.0 - offset.x)) * offset.y;\n}\n\n\nfloat getHeightFromHeightMap(float x, float z){\n    x += u_terrainRangeWidth / 2.0;\n    z += u_terrainRangeHeight / 2.0;\n\n    if(x > u_terrainRangeWidth || z > u_terrainRangeHeight || x < 0.0 || z < 0.0){\n        return 0.0;\n    }\n\n\n\n/*!\n1.get grid subdivisions row,col\n2.get grid height\n3.get bilinear interpolated height\n*/\n\n\n\n    float sx = x / u_terrainRangeWidth * u_terrainSubdivisions,\n        sz = z / u_terrainRangeHeight * u_terrainSubdivisions;\n\n    float sFloorX = floor(sx),\n        sFloorZ = floor(sz);\n\n    float sMinX,\n    sMaxX,\n    sMinZ,\n    sMaxZ;\n\n    if(sFloorX < u_terrainSubdivisions){\n        sMinX = sFloorX;\n        sMaxX = sFloorX + 1.0;\n    }\n    else{\n        sMinX = sFloorX - 1.0;\n        sMaxX = sFloorX;\n    }\n\n    if(sFloorZ < u_terrainSubdivisions){\n        sMinZ = sFloorZ;\n        sMaxZ = sFloorZ + 1.0;\n    }\n    else{\n        sMinZ = sFloorZ - 1.0;\n        sMaxZ = sFloorZ;\n    }\n\n    vec2 quadSubdivisionsCoordinateArr[5];\n\n    quadSubdivisionsCoordinateArr[0] = vec2(sMinX, sMinZ);\n    quadSubdivisionsCoordinateArr[1] = vec2(sMaxX, sMinZ);\n    quadSubdivisionsCoordinateArr[2] = vec2(sMaxX, sMaxZ);\n    quadSubdivisionsCoordinateArr[3] = vec2(sMinX, sMaxZ);\n\n    quadSubdivisionsCoordinateArr[4] = vec2(sx - sMinX, sz - sMinZ);\n\n\n    float heightMinXMinZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[0]);\n    float heightMaxXMinZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[1]);\n    float heightMaxXMaxZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[2]);\n    float heightMinXMaxZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[3]);\n\n    return _getBilinearInterpolatedHeight(quadSubdivisionsCoordinateArr[4], heightMinXMinZ, heightMaxXMinZ, heightMaxXMaxZ, heightMinXMaxZ);\n}\n",body: "",}
public static common_light:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 getDirectionLightDir(vec3 lightPos){\n    return normalize(lightPos - vec3(0.0));\n}\n",body: "",}
public static mirror_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec4 v_reflectionMapCoord;\n",funcDeclare: "",funcDefine: "//todo add more blend way to mix reflectionMap color and textureColor\n		float blendOverlay(float base, float blend) {\n			return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n		}\n		vec4 getReflectionMapColor(in vec4 materialColor){\n			vec4 color = texture2DProj(u_reflectionMapSampler, v_reflectionMapCoord);\n\n			color = vec4(blendOverlay(materialColor.r, color.r), blendOverlay(materialColor.g, color.g), blendOverlay(materialColor.b, color.b), 1.0);\n\n			return color;\n		}\n",body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= getReflectionMapColor(totalColor);\n}\n",}
public static mirror_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec4 v_reflectionMapCoord;\n",funcDeclare: "",funcDefine: "",body: "mat4 textureMatrix = mat4(\n                        0.5, 0.0, 0.0, 0.0,\n                        0.0, 0.5, 0.0, 0.0,\n                        0.0, 0.0, 0.5, 0.0,\n                        0.5, 0.5, 0.5, 1.0\n);\n\nv_reflectionMapCoord = textureMatrix * gl_Position;\n",}
public static water_bump_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_bumpTexCoord;\n",funcDeclare: "",funcDefine: "",body: "// fetch bump texture, unpack from [0..1] to [-1..1]\n	vec3 bumpNormal = 2.0 * texture2D(u_bumpMapSampler, v_bumpTexCoord).rgb - 1.0;\n	vec2 perturbation = u_waveData.height * bumpNormal.rg;\n",}
public static water_bump_vertex:GLSLChunk = {top: "",define: "",varDeclare: "struct WaveData {\n    float length;\n    float height;\n};\nuniform WaveData u_waveData;\nvarying vec2 v_bumpTexCoord;\n",funcDeclare: "",funcDefine: "",body: "vec2 bumpTexCoord = vec2(u_windMatrix * vec4(a_texCoord, 0.0, 1.0));\n	v_bumpTexCoord = bumpTexCoord / u_waveData.length;\n",}
public static water_fragment:GLSLChunk = {top: "",define: "",varDeclare: "struct WaveData {\n    float length;\n    float height;\n};\nuniform WaveData u_waveData;\nstruct LevelData {\n    float fresnelLevel;\n    float reflectionLevel;\n    float refractionLevel;\n};\nuniform LevelData u_levelData;\n\nvarying vec4 v_reflectionAndRefractionMapCoord;\n",funcDeclare: "",funcDefine: "",body: "vec2 projectedTexCoords = v_reflectionAndRefractionMapCoord.xy / v_reflectionAndRefractionMapCoord.w + perturbation;\n\n\n\n\n//totalColor = vec4(1.0 - fresnelTerm);\n//totalColor *= vec4(refractionColor, 1.0);\n//totalColor *= vec4(mix(reflectionColor, refractionColor, fresnelTerm), 1.0);\n//totalColor += vec4(reflectionColor * fresnelTerm * u_levelData.reflectionLevel + (1.0 - fresnelTerm) * refractionColor * u_levelData.refractionLevel, 1.0);\n\n//totalColor += vec4(reflectionColor * fresnelTerm * u_levelData.reflectionLevel + (1.0 - fresnelTerm) * refractionColor * u_levelData.refractionLevel, 1.0);\n\ntotalColor += vec4(getLightEffectColor(projectedTexCoords), 1.0);\n\n\n//totalColor *= vec4(mix(reflectionColor, refractionColor, 0.5), 1.0);\n",}
public static water_fresnel_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_position;\n",funcDeclare: "",funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n	vec3 reflectionColor;\n	vec3 refractionColor;\n\n    vec3 inDir = normalize(v_position - u_cameraPos);\n\n	float fresnelTerm = max(dot(inDir, v_normal), 0.0);\n	fresnelTerm = clamp((1.0 - fresnelTerm) * u_levelData.fresnelLevel, 0., 1.);\n\n    if(!isRenderListEmpty(u_isReflectionRenderListEmpty)){\n        reflectionColor = texture2D(u_reflectionMapSampler, projectedTexCoords).rgb;\n        reflectionColor = reflectionColor * fresnelTerm * u_levelData.reflectionLevel;\n	}\n	else{\n        reflectionColor = vec3(0.0);\n	}\n\n    if(!isRenderListEmpty(u_isRefractionRenderListEmpty)){\n        refractionColor = texture2D(u_refractionMapSampler, projectedTexCoords).rgb;\n        refractionColor = (1.0 - fresnelTerm) * refractionColor * u_levelData.refractionLevel;\n	}\n	else{\n        refractionColor = vec3(0.0);\n	}\n\n	return reflectionColor + refractionColor;\n}\n",body: "",}
public static water_fresnel_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec3 v_position;\n",funcDeclare: "",funcDefine: "",body: "v_position = a_position;\n",}
public static water_noBump_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "",body: "vec2 perturbation = vec2(0.0);\n",}
public static water_noLightEffect_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n    return vec3(0.0);\n}\n",body: "",}
public static water_reflection_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n    if(!isRenderListEmpty(u_isReflectionRenderListEmpty)){\n        return texture2D(u_reflectionMapSampler, projectedTexCoords).rgb * u_levelData.reflectionLevel;\n    }\n    return vec3(0.0);\n}\n",body: "",}
public static water_refraction_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n    if(!isRenderListEmpty(u_isRefractionRenderListEmpty)){\n        return texture2D(u_refractionMapSampler, projectedTexCoords).rgb * u_levelData.refractionLevel;\n    }\n    return vec3(0.0);\n}\n",body: "",}
public static water_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec4 v_reflectionAndRefractionMapCoord;\n",funcDeclare: "",funcDefine: "",body: "mat4 textureMatrix = mat4(\n                        0.5, 0.0, 0.0, 0.0,\n                        0.0, 0.5, 0.0, 0.0,\n                        0.0, 0.0, 0.5, 0.0,\n                        0.5, 0.5, 0.5, 1.0\n);\n\nv_reflectionAndRefractionMapCoord = textureMatrix * gl_Position;\n",}
public static brick_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\n",funcDeclare: "",funcDefine: "",body: "float brickW = 1.0 / u_tilesWidthNumber;\n	float brickH = 1.0 / u_tilesWidthNumber;\n	float jointWPercentage = 0.01;\n	float jointHPercentage = 0.05;\n	vec3 color = u_brickColor;\n	float yi = v_texCoord.y / brickH;\n	float nyi = round(yi);\n	float xi = v_texCoord.x / brickW;\n\n	if (mod(floor(yi), 2.0) == 0.0){\n		xi = xi - 0.5;\n	}\n\n	float nxi = round(xi);\n	vec2 brickv_texCoord = vec2((xi - floor(xi)) / brickH, (yi - floor(yi)) /  brickW);\n\n	if (yi < nyi + jointHPercentage && yi > nyi - jointHPercentage){\n		color = mix(u_jointColor, vec3(0.37, 0.25, 0.25), (yi - nyi) / jointHPercentage + 0.2);\n	}\n	else if (xi < nxi + jointWPercentage && xi > nxi - jointWPercentage){\n		color = mix(u_jointColor, vec3(0.44, 0.44, 0.44), (xi - nxi) / jointWPercentage + 0.2);\n	}\n	else {\n		float u_brickColorSwitch = mod(floor(yi) + floor(xi), 3.0);\n\n		if (u_brickColorSwitch == 0.0)\n			color = mix(color, vec3(0.33, 0.33, 0.33), 0.3);\n		else if (u_brickColorSwitch == 2.0)\n			color = mix(color, vec3(0.11, 0.11, 0.11), 0.3);\n	}\n\n	gl_FragColor = vec4(color, 1.0);\n",}
public static cloud_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\n",funcDeclare: "",funcDefine: "",body: "gl_FragColor = mix(u_skyColor, u_cloudColor, fbm(v_texCoord * 12.0));\n",}
public static common_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "",funcDeclare: "",funcDefine: "float rand(vec2 n) {\n	return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n	const vec2 d = vec2(0.0, 1.0);\n	vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n	return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat turbulence(vec2 P)\n{\n	float val = 0.0;\n	float freq = 1.0;\n	for (int i = 0; i < 4; i++)\n	{\n		val += abs(noise(P*freq) / freq);\n		freq *= 2.07;\n	}\n	return val;\n}\n\nfloat fbm(vec2 n) {\n	float total = 0.0, amplitude = 1.0;\n	for (int i = 0; i < 4; i++) {\n		total += noise(n) * amplitude;\n		n += n;\n		amplitude *= 0.5;\n	}\n	return total;\n}\n\nfloat round(float number){\n	return sign(number)*floor(abs(number) + 0.5);\n}\n",body: "",}
public static common_proceduralTexture_vertex:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\nconst vec2 MADD=vec2(0.5,0.5);\n",funcDeclare: "",funcDefine: "",body: "v_texCoord=a_positionVec2*MADD+MADD;\n\n    gl_Position=vec4(a_positionVec2, 0.0 ,1.0);\n",}
public static fire_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\nstruct FireColor {\n    vec3 c1;\n    vec3 c2;\n    vec3 c3;\n    vec3 c4;\n    vec3 c5;\n    vec3 c6;\n};\nuniform FireColor u_fireColor;\n",funcDeclare: "",funcDefine: "",body: "vec2 p = v_texCoord * 8.0;\n	float q = fbm(p - u_time * 0.1);\n	vec2 r = vec2(fbm(p + q + u_time * u_speed.x - p.x - p.y), fbm(p + q - u_time * u_speed.y));\n	vec3 c = mix(u_fireColor.c1, u_fireColor.c2, fbm(p + r)) + mix(u_fireColor.c3, u_fireColor.c4, r.x) - mix(u_fireColor.c5, u_fireColor.c6, r.y);\n	vec3 color = c * cos(u_shift * v_texCoord.y);\n	float luminance = dot(color.rgb, vec3(0.3, 0.59, 0.11));\n\n	gl_FragColor = vec4(color, luminance * u_alphaThreshold + (1.0 - u_alphaThreshold));\n\n",}
public static grass_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\n",funcDeclare: "",funcDefine: "",body: "vec3 color = mix(u_groundColor, u_herb1Color, rand(gl_FragCoord.xy * 4.0));\n	color = mix(color, u_herb2Color, rand(gl_FragCoord.xy * 8.0));\n	color = mix(color, u_herb3Color, rand(gl_FragCoord.xy));\n	color = mix(color, u_herb1Color, fbm(gl_FragCoord.xy * 16.0));\n\n	gl_FragColor = vec4(color, 1.0);\n",}
public static road_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\n",funcDeclare: "",funcDefine: "",body: "float ratioy = mod(gl_FragCoord.y * 100.0 , fbm(v_texCoord * 2.0));\n	vec3 color = u_roadColor * ratioy;\n\n	gl_FragColor = vec4(color, 1.0);\n",}
public static marble_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\nconst vec3 TILE_SIZE = vec3(1.1, 1.0, 1.1);\n//const vec3 TILE_PCT = vec3(0.98, 1.0, 0.98);\n",funcDeclare: "",funcDefine: "vec3 marble_color(float x)\n{\n	vec3 col;\n	x = 0.5*(x + 1.);\n	x = sqrt(x);\n	x = sqrt(x);\n	x = sqrt(x);\n	col = vec3(.2 + .75*x);\n	col.b *= 0.95;\n	return col;\n}\n",body: "vec3 color;\n	float brickW = 1.0 / u_tilesHeightNumber;\n	float brickH = 1.0 / u_tilesWidthNumber;\n	float jointWPercentage = 0.01;\n	float jointHPercentage = 0.01;\n	float yi = v_texCoord.y / brickH;\n	float nyi = round(yi);\n	float xi = v_texCoord.x / brickW;\n\n	if (mod(floor(yi), 2.0) == 0.0){\n		xi = xi - 0.5;\n	}\n\n	float nxi = round(xi);\n	vec2 brickv_texCoord = vec2((xi - floor(xi)) / brickH, (yi - floor(yi)) / brickW);\n\n	if (yi < nyi + jointHPercentage && yi > nyi - jointHPercentage){\n		color = mix(u_jointColor, vec3(0.37, 0.25, 0.25), (yi - nyi) / jointHPercentage + 0.2);\n	}\n	else if (xi < nxi + jointWPercentage && xi > nxi - jointWPercentage){\n		color = mix(u_jointColor, vec3(0.44, 0.44, 0.44), (xi - nxi) / jointWPercentage + 0.2);\n	}\n	else {\n		float t = 6.28 * brickv_texCoord.x / (TILE_SIZE.x + noise(vec2(v_texCoord)*6.0));\n		t += u_amplitude * turbulence(brickv_texCoord.xy);\n		t = sin(t);\n		color = marble_color(t);\n	}\n\n	gl_FragColor = vec4(color, 1.0);\n",}
public static wood_proceduralTexture_fragment:GLSLChunk = {top: "",define: "",varDeclare: "varying vec2 v_texCoord;\n",funcDeclare: "",funcDefine: "",body: "float ratioy = mod(v_texCoord.x * u_ampScale, 2.0 + fbm(v_texCoord * 0.8));\n	vec3 wood = u_woodColor * ratioy;\n\n	gl_FragColor = vec4(wood, 1.0);\n",}
}
export type GLSLChunk = {top?:string;define?:string;varDeclare?:string;funcDeclare?:string;funcDefine?:string;body?:string;}
}