<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>绘制彩色三角形</title>

    <script src="../../../engine/math/Matrix.js" type="text/javascript"></script>
    <script src="../../../engine/math/MatrixUtils.js" type="text/javascript"></script>
    <script src="../../../engine/math/Vector3.js" type="text/javascript"></script>
    <script src="../../../engine/math/Vector4.js" type="text/javascript"></script>
</head>
<body>
<canvas id="canvas" width="600" height="400"></canvas>

<script id="vs" type="x-shader/x-vertex">
attribute vec4 a_position;
uniform mat4 u_mvpMatrix;
attribute vec4 a_color;
varying vec4 v_color;

void main(void){
    gl_Position = u_mvpMatrix * a_position;
    v_color = a_color;
}
        </script>

<script id="fs" type="x-shader/x-fragment">
precision mediump float;
varying vec4 v_color;

void main(void){
    gl_FragColor = v_color;
}
</script>



<script>
    //todo use vertexAttrib4f to send color data

    window.onload = function(){
        var prg = null;
        var c = null;
        var gl = null;

        var mMatrix = Engine3D.Math.Matrix.create();
        var vMatrix = Engine3D.Math.Matrix.create();
        var pMatrix = Engine3D.Math.Matrix.create();
        var mvpMatrix = null;


        c = document.getElementById('canvas');
        gl = c.getContext('webgl') || c.getContext('experimental-webgl');

        prg = initShaders("vs", "fs");

        var vertices = new Float32Array([
            0.0,  2.5,  -5.0,  0.4,  1.0,  0.4,
            -2.5, -2.5,  -5.0,  0.4,  1.0,  0.4,
            2.5, -2.5,  -5.0,  1.0,  0.4,  0.4
        ]);
        var vertices_num = 3;
        var size = 3;
        var FSize = vertices.BYTES_PER_ELEMENT;
        var stride = FSize * 6;


        var vbo = createVBO(vertices);

        var a_position = gl.getAttribLocation(prg, "a_position");
        if (a_position < 0) {
            console.log('Failed to get the storage location of a_position');
            return -1;
        }

        gl.vertexAttribPointer(a_position, size, gl.FLOAT, false, stride, 0);
        gl.enableVertexAttribArray(a_position);


        var a_color = gl.getAttribLocation(prg, "a_color");
        if (a_color < 0) {
            console.log('Failed to get the storage location of a_color');
            return -1;
        }

        gl.vertexAttribPointer(a_color, size, gl.FLOAT, false, stride, FSize * 3);
        gl.enableVertexAttribArray(a_color);


        setMMatrix();
        setLookAt();
        setPerspective();
        mvpMatrix = computeMvpMatrix(pMatrix, vMatrix, mMatrix);

        var uniLocation = gl.getUniformLocation(prg, 'u_mvpMatrix');

        gl.uniformMatrix4fv(uniLocation, false, mvpMatrix);




        gl.clearColor(0, 0, 0, 1);

        draw(vertices_num);




        function draw(vertices_num){
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            //green
            gl.drawArrays(gl.TRIANGLES, 0, vertices_num);
        }

        function setMMatrix(){
            mMatrix.setIdentity();
        }

        function setLookAt(){
            var eyeX = 0,
                    eyeY = 0,
                    eyeZ = 0,
                    centerX = 0,
                    centerY = 0,
                    centerZ = -1,
                    upX = 0,
                    upY = 1,
                    upZ = 0;

            vMatrix.setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
        }

        function setPerspective(){
            var near = 0.1,
                    far = 10,
                    angle = 60,
                    aspect = c.width / c.height;

            pMatrix.setPerspective(angle, aspect, near, far);
        }


        function computeMvpMatrix(pMatrix, vMatrix, mMatrix){
            return mMatrix.copy().applyMatrix(vMatrix).applyMatrix(pMatrix).values;
        }



        function initShaders(vsId, fsId){
            var vs = createShader(vsId),
                    fs = createShader(fsId);

            return createProgram(vs, fs);
        }

// 生成着色器的函数
        function createShader(id){
            // 用来保存着色器的变量
            var shader;

            // 根据id从HTML中获取指定的script标签
            var scriptElement = document.getElementById(id);

            // 如果指定的script标签不存在，则返回
            if(!scriptElement){return;}

            // 判断script标签的type属性
            switch(scriptElement.type){

                // 顶点着色器的时候
                case 'x-shader/x-vertex':
                    shader = gl.createShader(gl.VERTEX_SHADER);
                    break;

                // 片段着色器的时候
                case 'x-shader/x-fragment':
                    shader = gl.createShader(gl.FRAGMENT_SHADER);
                    break;
                default :
                    return;
            }

            // 将标签中的代码分配给生成的着色器
            gl.shaderSource(shader, scriptElement.text);

            // 编译着色器
            gl.compileShader(shader);

            // 判断一下着色器是否编译成功
            if(gl.getShaderParameter(shader, gl.COMPILE_STATUS)){

                // 编译成功，则返回着色器
                return shader;
            }else{

                // 编译失败，弹出错误消息
                alert(gl.getShaderInfoLog(shader));
            }
        }

// 程序对象的生成和着色器连接的函数
        function createProgram(vs, fs){
            // 程序对象的生成
            var program = gl.createProgram();

            // 向程序对象里分配着色器
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);

            // 将着色器连接
            gl.linkProgram(program);

            // 判断着色器的连接是否成功
            if(gl.getProgramParameter(program, gl.LINK_STATUS)){

                // 成功的话，将程序对象设置为有效
                gl.useProgram(program);

                // 返回程序对象
                return program;
            }else{

                // 如果失败，弹出错误信息
                alert(gl.getProgramInfoLog(program));
            }
        }

        function createVBO(data){
            var buffer = gl.createBuffer();

            if (!buffer) {
                console.log('Failed to create the buffer object');
                return -1;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

            return buffer;
        }
    };
</script>
</body>
</html>

