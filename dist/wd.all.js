/*!
 * wonder - 3d html5 game engine
 * @version v0.8.0
 * @link https://github.com/yyc-git/Wonder.js
 * @license MIT
 */

/*!
  * Bowser - a browser detector
  * https://github.com/ded/bowser
  * MIT License | (c) Dustin Diaz 2014
  */

!function (name, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports['browser'] = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else this[name] = definition()
}('bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , result

    if (/opera|opr/i.test(ua)) {
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\s\/](\d+(\.\d+)?)/i)
      }
    }
    else if (/windows phone/i.test(ua)) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      , msie: t
      , version: getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      }
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      }
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier
      }
    }
    else if (/sailfish/i.test(ua)) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/firefox|iceweasel/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel)[ \/](\d+(\.\d+)?)/i)
      }
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t
      }
    }
    else if (/silk/i.test(ua)) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      }
    }
    else if (android) {
      result = {
        name: 'Android'
      , version: versionIdentifier
      }
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      }
    }
    else if (/(web|hpw)os/i.test(ua)) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t)
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/tizen/i.test(ua)) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/safari/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      , version: versionIdentifier
      }
    }
    else result = {}

    // set webkit or gecko flag for browsers based on these engines
    if (/(apple)?webkit/i.test(ua)) {
      result.name = result.name || "Webkit"
      result.webkit = t
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko"
      result.gecko = t
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i)
    }

    // set OS flags for platforms that have multiple browsers
    if (android || result.silk) {
      result.android = t
    } else if (iosdevice) {
      result[iosdevice] = t
      result.ios = t
    }

    // OS version extraction
    var osVersion = '';
    if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = osVersion.split('.')[0];
    if (tablet || iosdevice == 'ipad' || (android && (osMajorVersion == 3 || (osMajorVersion == 4 && !mobile))) || result.silk) {
      result.tablet = t
    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada) {
      result.mobile = t
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if ((result.msie && result.version >= 10) ||
        (result.chrome && result.version >= 20) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        ) {
      result.c = t
    } else result.x = t

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '')


  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chai = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":2}],2:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '3.5.0';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Utility Functions
 */

exports.util = util;

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":3,"./chai/config":4,"./chai/core/assertions":5,"./chai/interface/assert":6,"./chai/interface/expect":7,"./chai/interface/should":8,"./chai/utils":22,"assertion-error":30}],3:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /**
   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String|Function} message or function that returns message to display if expression fails
   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":4}],4:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],5:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - which
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @namespace BDD
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'which', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * `.deep.property` special characters can be escaped
   * by adding two slashes before the `.` or `[]`.
   *
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name deep
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .any
   *
   * Sets the `any` flag, (opposite of the `all` flag)
   * later used in the `keys` assertion.
   *
   *     expect(foo).to.have.any.keys('bar', 'baz');
   *
   * @name any
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('any', function () {
    flag(this, 'any', true);
    flag(this, 'all', false)
  });


  /**
   * ### .all
   *
   * Sets the `all` flag (opposite of the `any` flag)
   * later used by the `keys` assertion.
   *
   *     expect(foo).to.have.all.keys('bar', 'baz');
   *
   * @name all
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('all', function () {
    flag(this, 'all', true);
    flag(this, 'any', false);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *     expect(new Error).to.be.an('error');
   *     expect(new Promise).to.be.a('promise');
   *     expect(new Float32Array()).to.be.a('float32array');
   *     expect(Symbol()).to.be.a('symbol');
   *
   *     // es6 overrides
   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contains` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @alias includes
   * @alias contains
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    _.expectTypes(this, ['array', 'object', 'string']);

    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;

    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {};
      for (var k in val) subset[k] = obj[k];
      expected = _.eql(subset, val);
    } else {
      expected = (obj != undefined) && ~obj.indexOf(val);
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);
  Assertion.addChainableMethod('contains', include, includeChainingBehavior);
  Assertion.addChainableMethod('includes', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everything').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).to.not.be.null;
   *
   * @name null
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .NaN
   * Asserts that the target is `NaN`.
   *
   *     expect('foo').to.be.NaN;
   *     expect(4).not.to.be.NaN;
   *
   * @name NaN
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('NaN', function () {
    this.assert(
        isNaN(flag(this, 'object'))
        , 'expected #{this} to be NaN'
        , 'expected #{this} not to be NaN'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays and strings, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @namespace BDD
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @namespace BDD
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };
   *
   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * Note that dots and bracket in `name` must be backslash-escaped when
   * the `deep` flag is set, while they must NOT be escaped when the `deep`
   * flag is not set.
   *
   *     // simple referencing
   *     var css = { '.link[target]': 42 };
   *     expect(css).to.have.property('.link[target]', 42);
   *
   *     // deep referencing
   *     var deepCss = { '.link': { '[target]': 42 }};
   *     expect(deepCss).to.have.deep.property('\\.link.\\[target\\]', 42);
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var isDeep = !!flag(this, 'deep')
      , descriptor = isDeep ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null
      , hasProperty = isDeep
        ? pathInfo.exists
        : _.hasProperty(name, obj)
      , value = isDeep
        ? pathInfo.value
        : obj[name];

    if (negate && arguments.length > 1) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          hasProperty
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (arguments.length > 1) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .ownPropertyDescriptor(name[, descriptor[, message]])
   *
   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.
   *
   *     expect('test').to.have.ownPropertyDescriptor('length');
   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });
   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });
   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);
   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');
   *
   * @name ownPropertyDescriptor
   * @alias haveOwnPropertyDescriptor
   * @param {String} name
   * @param {Object} descriptor _optional_
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertOwnPropertyDescriptor (name, descriptor, msg) {
    if (typeof descriptor === 'string') {
      msg = descriptor;
      descriptor = null;
    }
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);
    if (actualDescriptor && descriptor) {
      this.assert(
          _.eql(descriptor, actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)
        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)
        , descriptor
        , actualDescriptor
        , true
      );
    } else {
      this.assert(
          actualDescriptor
        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)
        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)
      );
    }
    flag(this, 'object', actualDescriptor);
  }

  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);
  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);

  /**
   * ### .length
   *
   * Sets the `doLength` flag later used as a chain precursor to a value
   * comparison for the `length` property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * *Deprecation notice:* Using `length` as an assertion will be deprecated
   * in version 2.4.0 and removed in 3.0.0. Code using the old style of
   * asserting for `length` property value using `length(value)` should be
   * switched to use `lengthOf(value)` instead.
   *
   * @name length
   * @namespace BDD
   * @api public
   */

  /**
   * ### .lengthOf(value[, message])
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.lengthOf(3);
   *     expect('foobar').to.have.lengthOf(6);
   *
   * @name lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @alias matches
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */
  function assertMatch(re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  }

  Assertion.addMethod('match', assertMatch);
  Assertion.addMethod('matches', assertMatch);

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target contains any or all of the passed-in keys.
   * Use in combination with `any`, `all`, `contains`, or `have` will affect
   * what will pass.
   *
   * When used in conjunction with `any`, at least one key that is passed
   * in must exist in the target object. This is regardless whether or not
   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`
   * should be used in the assertion. If neither are used, the assertion is
   * defaulted to `all`.
   *
   * When both `all` and `contain` are used, the target object must have at
   * least all of the passed-in keys but may have more keys not listed.
   *
   * When both `all` and `have` are used, the target object must both contain
   * all of the passed-in keys AND the number of keys in the target object must
   * match the number of keys passed in (in other words, a target object must
   * have all and only all of the passed-in keys).
   *
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);
   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});
   *
   *
   * @name keys
   * @alias key
   * @param {...String|Array|Object} keys
   * @namespace BDD
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true
      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';

    switch (_.type(keys)) {
      case "array":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        break;
      case "object":
        if (arguments.length > 1) throw (new Error(mixedArgsMsg));
        keys = Object.keys(keys);
        break;
      default:
        keys = Array.prototype.slice.call(arguments);
    }

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length
      , any = flag(this, 'any')
      , all = flag(this, 'all');

    if (!any && !all) {
      all = true;
    }

    // Has any
    if (any) {
      var intersection = expected.filter(function(key) {
        return ~actual.indexOf(key);
      });
      ok = intersection.length > 0;
    }

    // Has all
    if (all) {
      ok = keys.every(function(key){
        return ~actual.indexOf(key);
      });
      if (!flag(this, 'negate') && !flag(this, 'contains')) {
        ok = ok && keys.length == actual.length;
      }
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      if (all) {
        str = keys.join(', ') + ', and ' + last;
      }
      if (any) {
        str = keys.join(', ') + ', or ' + last;
      }
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.slice(0).sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @namespace BDD
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name;
      if (!name || (name === 'Error' && constructor !== Error)) {
        name = constructor.name || (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'error' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @alias respondsTo
   * @param {String} method
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function respondTo (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  }

  Assertion.addMethod('respondTo', respondTo);
  Assertion.addMethod('respondsTo', respondTo);

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @alias satisfies
   * @param {Function} matcher
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function satisfy (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  }

  Assertion.addMethod('satisfy', satisfy);
  Assertion.addMethod('satisfies', satisfy);

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @alias approximately
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function closeTo(expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj, msg).is.a('number');
    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
      throw new Error('the arguments to closeTo or approximately must be numbers');
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  }

  Assertion.addMethod('closeTo', closeTo);
  Assertion.addMethod('approximately', closeTo);

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });

  /**
   * ### .oneOf(list)
   *
   * Assert that a value appears somewhere in the top level of array `list`.
   *
   *     expect('a').to.be.oneOf(['a', 'b', 'c']);
   *     expect(9).to.not.be.oneOf(['z']);
   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);
   *
   *     var three = [3];
   *     // for object-types, contents are not compared
   *     expect(three).to.not.be.oneOf([1, 2, [3]]);
   *     // comparing references works
   *     expect(three).to.be.oneOf([1, 2, three]);
   *
   * @name oneOf
   * @param {Array<*>} list
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function oneOf (list, msg) {
    if (msg) flag(this, 'message', msg);
    var expected = flag(this, 'object');
    new Assertion(list).to.be.an('array');

    this.assert(
        list.indexOf(expected) > -1
      , 'expected #{this} to be one of #{exp}'
      , 'expected #{this} to not be one of #{exp}'
      , list
      , expected
    );
  }

  Assertion.addMethod('oneOf', oneOf);


  /**
   * ### .change(function)
   *
   * Asserts that a function changes an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val += 3 };
   *     var noChangeFn = function() { return 'foo' + 'bar'; }
   *     expect(fn).to.change(obj, 'val');
   *     expect(noChangeFn).to.not.change(obj, 'val')
   *
   * @name change
   * @alias changes
   * @alias Change
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertChanges (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      initial !== object[prop]
      , 'expected .' + prop + ' to change'
      , 'expected .' + prop + ' to not change'
    );
  }

  Assertion.addChainableMethod('change', assertChanges);
  Assertion.addChainableMethod('changes', assertChanges);

  /**
   * ### .increase(function)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     expect(fn).to.increase(obj, 'val');
   *
   * @name increase
   * @alias increases
   * @alias Increase
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertIncreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial > 0
      , 'expected .' + prop + ' to increase'
      , 'expected .' + prop + ' to not increase'
    );
  }

  Assertion.addChainableMethod('increase', assertIncreases);
  Assertion.addChainableMethod('increases', assertIncreases);

  /**
   * ### .decrease(function)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     expect(fn).to.decrease(obj, 'val');
   *
   * @name decrease
   * @alias decreases
   * @alias Decrease
   * @param {String} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace BDD
   * @api public
   */

  function assertDecreases (object, prop, msg) {
    if (msg) flag(this, 'message', msg);
    var fn = flag(this, 'object');
    new Assertion(object, msg).to.have.property(prop);
    new Assertion(fn).is.a('function');

    var initial = object[prop];
    fn();

    this.assert(
      object[prop] - initial < 0
      , 'expected .' + prop + ' to decrease'
      , 'expected .' + prop + ' to not decrease'
    );
  }

  Assertion.addChainableMethod('decrease', assertDecreases);
  Assertion.addChainableMethod('decreases', assertDecreases);

  /**
   * ### .extensible
   *
   * Asserts that the target is extensible (can have new properties added to
   * it).
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect({}).to.be.extensible;
   *     expect(nonExtensibleObject).to.not.be.extensible;
   *     expect(sealedObject).to.not.be.extensible;
   *     expect(frozenObject).to.not.be.extensible;
   *
   * @name extensible
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('extensible', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isExtensible;

    try {
      isExtensible = Object.isExtensible(obj);
    } catch (err) {
      if (err instanceof TypeError) isExtensible = false;
      else throw err;
    }

    this.assert(
      isExtensible
      , 'expected #{this} to be extensible'
      , 'expected #{this} to not be extensible'
    );
  });

  /**
   * ### .sealed
   *
   * Asserts that the target is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freeze({});
   *
   *     expect(sealedObject).to.be.sealed;
   *     expect(frozenObject).to.be.sealed;
   *     expect({}).to.not.be.sealed;
   *
   * @name sealed
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('sealed', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isSealed;

    try {
      isSealed = Object.isSealed(obj);
    } catch (err) {
      if (err instanceof TypeError) isSealed = true;
      else throw err;
    }

    this.assert(
      isSealed
      , 'expected #{this} to be sealed'
      , 'expected #{this} to not be sealed'
    );
  });

  /**
   * ### .frozen
   *
   * Asserts that the target is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *
   *     expect(frozenObject).to.be.frozen;
   *     expect({}).to.not.be.frozen;
   *
   * @name frozen
   * @namespace BDD
   * @api public
   */

  Assertion.addProperty('frozen', function() {
    var obj = flag(this, 'object');

    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.
    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen
    // The following provides ES6 behavior when a TypeError is thrown under ES5.

    var isFrozen;

    try {
      isFrozen = Object.isFrozen(obj);
    } catch (err) {
      if (err instanceof TypeError) isFrozen = true;
      else throw err;
    }

    this.assert(
      isFrozen
      , 'expected #{this} to be frozen'
      , 'expected #{this} to not be frozen'
    );
  });
};

},{}],6:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @namespace Assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Assert
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .isOk(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.isOk('everything', 'everything is ok');
   *     assert.isOk(false, 'this will fail');
   *
   * @name isOk
   * @alias ok
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isOk = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .isNotOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.isNotOk('everything', 'this will fail');
   *     assert.isNotOk(false, 'this will pass');
   *
   * @name isNotOk
   * @alias notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

   /**
   * ### .isAbove(valueToCheck, valueToBeAbove, [message])
   *
   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`
   *
   *     assert.isAbove(5, 2, '5 is strictly greater than 2');
   *
   * @name isAbove
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAbove
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAbove = function (val, abv, msg) {
    new Assertion(val, msg).to.be.above(abv);
  };

   /**
   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])
   *
   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`
   *
   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');
   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');
   *
   * @name isAtLeast
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtLeast
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtLeast = function (val, atlst, msg) {
    new Assertion(val, msg).to.be.least(atlst);
  };

   /**
   * ### .isBelow(valueToCheck, valueToBeBelow, [message])
   *
   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`
   *
   *     assert.isBelow(3, 6, '3 is strictly less than 6');
   *
   * @name isBelow
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeBelow
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBelow = function (val, blw, msg) {
    new Assertion(val, msg).to.be.below(blw);
  };

   /**
   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])
   *
   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`
   *
   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');
   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');
   *
   * @name isAtMost
   * @param {Mixed} valueToCheck
   * @param {Mixed} valueToBeAtMost
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isAtMost = function (val, atmst, msg) {
    new Assertion(val, msg).to.be.most(atmst);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isNotTrue(value, [message])
   *
   * Asserts that `value` is not true.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotTrue(tea, 'great, time for tea!');
   *
   * @name isNotTrue
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotTrue = function (val, msg) {
    new Assertion(val, msg).to.not.equal(true);
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNotFalse(value, [message])
   *
   * Asserts that `value` is not false.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotFalse(tea, 'great, time for tea!');
   *
   * @name isNotFalse
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFalse = function (val, msg) {
    new Assertion(val, msg).to.not.equal(false);
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isNaN
   * Asserts that value is NaN
   *
   *    assert.isNaN('foo', 'foo is NaN');
   *
   * @name isNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNaN = function (val, msg) {
    new Assertion(val, msg).to.be.NaN;
  };

  /**
   * ### .isNotNaN
   * Asserts that value is not NaN
   *
   *    assert.isNotNaN(4, '4 is not NaN');
   *
   * @name isNotNaN
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */
  assert.isNotNaN = function (val, msg) {
    new Assertion(val, msg).not.to.be.NaN;
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).
   * _The assertion does not match subclassed objects._
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 6, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throws(fn, 'function throws a reference error');
   *     assert.throws(fn, /function throws a reference error/);
   *     assert.throws(fn, ReferenceError);
   *     assert.throws(fn, ReferenceError, 'function throws a reference error');
   *     assert.throws(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.throws = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @namespace Assert
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    var ok;
    switch(operator) {
      case '==':
        ok = val == val2;
        break;
      case '===':
        ok = val === val2;
        break;
      case '>':
        ok = val > val2;
        break;
      case '>=':
        ok = val >= val2;
        break;
      case '<':
        ok = val < val2;
        break;
      case '<=':
        ok = val <= val2;
        break;
      case '!=':
        ok = val != val2;
        break;
      case '!==':
        ok = val !== val2;
        break;
      default:
        throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(ok, msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .approximately(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');
   *
   * @name approximately
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.approximately = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.approximately(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .sameDeepMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.
   * Order is not taken into account.
   *
   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');
   *
   * @name sameDeepMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.sameDeepMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.deep.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /**
   * ### .includeDeepMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset` - using deep equality checking.
   * Order is not taken into account.
   * Duplicates are ignored.
   *
   *     assert.includeDeepMembers([ {a: 1}, {b: 2}, {c: 3} ], [ {b: 2}, {a: 1}, {b: 2} ], 'include deep members');
   *
   * @name includeDeepMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.includeDeepMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.deep.members(subset);
  }

  /**
   * ### .oneOf(inList, list, [message])
   *
   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.
   *
   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');
   *
   * @name oneOf
   * @param {*} inList
   * @param {Array<*>} list
   * @param {String} message
   * @namespace Assert
   * @api public
   */

  assert.oneOf = function (inList, list, msg) {
    new Assertion(inList, msg).to.be.oneOf(list);
  }

   /**
   * ### .changes(function, object, property)
   *
   * Asserts that a function changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 22 };
   *     assert.changes(fn, obj, 'val');
   *
   * @name changes
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.changes = function (fn, obj, prop) {
    new Assertion(fn).to.change(obj, prop);
  }

   /**
   * ### .doesNotChange(function, object, property)
   *
   * Asserts that a function does not changes the value of a property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { console.log('foo'); };
   *     assert.doesNotChange(fn, obj, 'val');
   *
   * @name doesNotChange
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotChange = function (fn, obj, prop) {
    new Assertion(fn).to.not.change(obj, prop);
  }

   /**
   * ### .increases(function, object, property)
   *
   * Asserts that a function increases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 13 };
   *     assert.increases(fn, obj, 'val');
   *
   * @name increases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.increases = function (fn, obj, prop) {
    new Assertion(fn).to.increase(obj, prop);
  }

   /**
   * ### .doesNotIncrease(function, object, property)
   *
   * Asserts that a function does not increase object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 8 };
   *     assert.doesNotIncrease(fn, obj, 'val');
   *
   * @name doesNotIncrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotIncrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.increase(obj, prop);
  }

   /**
   * ### .decreases(function, object, property)
   *
   * Asserts that a function decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 5 };
   *     assert.decreases(fn, obj, 'val');
   *
   * @name decreases
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.decreases = function (fn, obj, prop) {
    new Assertion(fn).to.decrease(obj, prop);
  }

   /**
   * ### .doesNotDecrease(function, object, property)
   *
   * Asserts that a function does not decreases an object property
   *
   *     var obj = { val: 10 };
   *     var fn = function() { obj.val = 15 };
   *     assert.doesNotDecrease(fn, obj, 'val');
   *
   * @name doesNotDecrease
   * @param {Function} modifier function
   * @param {Object} object
   * @param {String} property name
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.doesNotDecrease = function (fn, obj, prop) {
    new Assertion(fn).to.not.decrease(obj, prop);
  }

  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */

  assert.ifError = function (val) {
    if (val) {
      throw(val);
    }
  };

  /**
   * ### .isExtensible(object)
   *
   * Asserts that `object` is extensible (can have new properties added to it).
   *
   *     assert.isExtensible({});
   *
   * @name isExtensible
   * @alias extensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.be.extensible;
  };

  /**
   * ### .isNotExtensible(object)
   *
   * Asserts that `object` is _not_ extensible.
   *
   *     var nonExtensibleObject = Object.preventExtensions({});
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.freese({});
   *
   *     assert.isNotExtensible(nonExtensibleObject);
   *     assert.isNotExtensible(sealedObject);
   *     assert.isNotExtensible(frozenObject);
   *
   * @name isNotExtensible
   * @alias notExtensible
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotExtensible = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.extensible;
  };

  /**
   * ### .isSealed(object)
   *
   * Asserts that `object` is sealed (cannot have new properties added to it
   * and its existing properties cannot be removed).
   *
   *     var sealedObject = Object.seal({});
   *     var frozenObject = Object.seal({});
   *
   *     assert.isSealed(sealedObject);
   *     assert.isSealed(frozenObject);
   *
   * @name isSealed
   * @alias sealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isSealed = function (obj, msg) {
    new Assertion(obj, msg).to.be.sealed;
  };

  /**
   * ### .isNotSealed(object)
   *
   * Asserts that `object` is _not_ sealed.
   *
   *     assert.isNotSealed({});
   *
   * @name isNotSealed
   * @alias notSealed
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotSealed = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.sealed;
  };

  /**
   * ### .isFrozen(object)
   *
   * Asserts that `object` is frozen (cannot have new properties added to it
   * and its existing properties cannot be modified).
   *
   *     var frozenObject = Object.freeze({});
   *     assert.frozen(frozenObject);
   *
   * @name isFrozen
   * @alias frozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.be.frozen;
  };

  /**
   * ### .isNotFrozen(object)
   *
   * Asserts that `object` is _not_ frozen.
   *
   *     assert.isNotFrozen({});
   *
   * @name isNotFrozen
   * @alias notFrozen
   * @param {Object} object
   * @param {String} message _optional_
   * @namespace Assert
   * @api public
   */

  assert.isNotFrozen = function (obj, msg) {
    new Assertion(obj, msg).to.not.be.frozen;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('isOk', 'ok')
  ('isNotOk', 'notOk')
  ('throws', 'throw')
  ('throws', 'Throw')
  ('isExtensible', 'extensible')
  ('isNotExtensible', 'notExtensible')
  ('isSealed', 'sealed')
  ('isNotSealed', 'notSealed')
  ('isFrozen', 'frozen')
  ('isNotFrozen', 'notFrozen');
};

},{}],7:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @namespace Expect
   * @api public
   */

  chai.expect.fail = function (actual, expected, message, operator) {
    message = message || 'expect.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, chai.expect.fail);
  };
};

},{}],8:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {
        return new Assertion(this.valueOf(), null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    /**
     * ### .fail(actual, expected, [message], [operator])
     *
     * Throw a failure.
     *
     * @name fail
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @param {String} operator
     * @namespace Should
     * @api public
     */

    should.fail = function (actual, expected, message, operator) {
      message = message || 'should.fail()';
      throw new chai.AssertionError(message, {
          actual: actual
        , expected: expected
        , operator: operator
      }, should.fail);
    };

    /**
     * ### .equal(actual, expected, [message])
     *
     * Asserts non-strict equality (`==`) of `actual` and `expected`.
     *
     *     should.equal(3, '3', '== coerces values to strings');
     *
     * @name equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])
     *
     * Asserts that `function` will throw an error that is an instance of
     * `constructor`, or alternately that it will throw an error with message
     * matching `regexp`.
     *
     *     should.throw(fn, 'function throws a reference error');
     *     should.throw(fn, /function throws a reference error/);
     *     should.throw(fn, ReferenceError);
     *     should.throw(fn, ReferenceError, 'function throws a reference error');
     *     should.throw(fn, ReferenceError, /function throws a reference error/);
     *
     * @name throw
     * @alias Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    /**
     * ### .exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var foo = 'hi';
     *
     *     should.exist(foo, 'foo exists');
     *
     * @name exist
     * @namespace Should
     * @api public
     */

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    /**
     * ### .not.equal(actual, expected, [message])
     *
     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
     *
     *     should.not.equal(3, 4, 'these numbers are not equal');
     *
     * @name not.equal
     * @param {Mixed} actual
     * @param {Mixed} expected
     * @param {String} message
     * @namespace Should
     * @api public
     */

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    /**
     * ### .throw(function, [constructor/regexp], [message])
     *
     * Asserts that `function` will _not_ throw an error that is an instance of
     * `constructor`, or alternately that it will not throw an error with message
     * matching `regexp`.
     *
     *     should.not.throw(fn, Error, 'function does not throw');
     *
     * @name not.throw
     * @alias not.Throw
     * @param {Function} function
     * @param {ErrorConstructor} constructor
     * @param {RegExp} regexp
     * @param {String} message
     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
     * @namespace Should
     * @api public
     */

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    /**
     * ### .not.exist
     *
     * Asserts that the target is neither `null` nor `undefined`.
     *
     *     var bar = null;
     *
     *     should.not.exist(bar, 'bar does not exist');
     *
     * @name not.exist
     * @namespace Should
     * @api public
     */

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],9:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @namespace Utils
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":4,"./flag":13,"./transferFlags":29}],10:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @namespace Utils
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":4,"./flag":13}],11:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');
var flag = require('./flag');

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @namespace Utils
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function addProperty() {
        var old_ssfi = flag(this, 'ssfi');
        if (old_ssfi && config.includeStack === false)
          flag(this, 'ssfi', addProperty);

        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{"../config":4,"./flag":13}],12:[function(require,module,exports){
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### expectTypes(obj, types)
 *
 * Ensures that the object being tested against is of a valid type.
 *
 *     utils.expectTypes(this, ['array', 'object', 'string']);
 *
 * @param {Mixed} obj constructed Assertion
 * @param {Array} type A list of allowed types for this assertion
 * @namespace Utils
 * @name expectTypes
 * @api public
 */

var AssertionError = require('assertion-error');
var flag = require('./flag');
var type = require('type-detect');

module.exports = function (obj, types) {
  var obj = flag(obj, 'object');
  types = types.map(function (t) { return t.toLowerCase(); });
  types.sort();

  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'
  var str = types.map(function (t, index) {
    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';
    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';
    return or + art + ' ' + t;
  }).join(', ');

  if (!types.some(function (expected) { return type(obj) === expected; })) {
    throw new AssertionError(
      'object tested must be ' + str + ', but ' + type(obj) + ' given'
    );
  }
};

},{"./flag":13,"assertion-error":30,"type-detect":35}],13:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object, key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @namespace Utils
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],14:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getActual
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],15:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],16:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#\{this\}/g, function () { return objDisplay(val); })
    .replace(/#\{act\}/g, function () { return objDisplay(actual); })
    .replace(/#\{exp\}/g, function () { return objDisplay(expected); });

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":13,"./getActual":14,"./inspect":23,"./objDisplay":24}],17:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 * @namespace Utils
 * @name getName
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],18:[function(require,module,exports){
/*!
 * Chai - getPathInfo utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var hasProperty = require('./hasProperty');

/**
 * ### .getPathInfo(path, object)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

module.exports = function getPathInfo(path, obj) {
  var parsed = parsePath(path),
      last = parsed[parsed.length - 1];

  var info = {
    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: _getPathValue(parsed, obj)
  };
  info.exists = hasProperty(info.name, info.parent);

  return info;
};


/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/([^\\])\[/g, '$1.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /^\[(\d+)\]$/
      , mArr = re.exec(value);
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value.replace(/\\([.\[\]])/g, '$1') };
  });
}


/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @param {Number} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj, index) {
  var tmp = obj
    , res;

  index = (index === undefined ? parsed.length : index);

  for (var i = 0, l = index; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
}

},{"./hasProperty":21}],19:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

var getPathInfo = require('./getPathInfo');

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */
module.exports = function(path, obj) {
  var info = getPathInfo(path, obj);
  return info.value;
};

},{"./getPathInfo":18}],20:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @namespace Utils
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(object);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(object);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],21:[function(require,module,exports){
/*!
 * Chai - hasProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var type = require('type-detect');

/**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has
 * named property or numeric array index.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with natives
 * and null/undefined values.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty('str', obj);  // true
 *     hasProperty('constructor', obj);  // true
 *     hasProperty('bar', obj);  // false
 *
 *     hasProperty('length', obj.str); // true
 *     hasProperty(1, obj.str);  // true
 *     hasProperty(5, obj.str);  // false
 *
 *     hasProperty('length', obj.arr);  // true
 *     hasProperty(2, obj.arr);  // true
 *     hasProperty(3, obj.arr);  // false
 *
 * @param {Objuect} object
 * @param {String|Number} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */

var literals = {
    'number': Number
  , 'string': String
};

module.exports = function hasProperty(name, obj) {
  var ot = type(obj);

  // Bad Object, obviously no props at all
  if(ot === 'null' || ot === 'undefined')
    return false;

  // The `in` operator does not work with certain literals
  // box these before the check
  if(literals[ot] && typeof obj !== 'object')
    obj = new literals[ot](obj);

  return name in obj;
};

},{"type-detect":35}],22:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('type-detect');

/*!
 * expectTypes utility
 */
exports.expectTypes = require('./expectTypes');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Deep path info
 */

exports.getPathInfo = require('./getPathInfo');

/*!
 * Check if a property exists
 */

exports.hasProperty = require('./hasProperty');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');

},{"./addChainableMethod":9,"./addMethod":10,"./addProperty":11,"./expectTypes":12,"./flag":13,"./getActual":14,"./getMessage":16,"./getName":17,"./getPathInfo":18,"./getPathValue":19,"./hasProperty":21,"./inspect":23,"./objDisplay":24,"./overwriteChainableMethod":25,"./overwriteMethod":26,"./overwriteProperty":27,"./test":28,"./transferFlags":29,"deep-eql":31,"type-detect":35}],23:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 * @namespace Utils
 * @name inspect
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      if (value === 0 && (1/value) === -Infinity) {
        return ctx.stylize('-0', 'number');
      }
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":15,"./getName":17,"./getProperties":20}],24:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @namespace Utils
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":4,"./inspect":23}],25:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @namespace Utils
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @namespace Utils
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],27:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @namespace Utils
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],28:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @namespace Utils
 * @name test
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":13}],29:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags to; usually a new assertion
 * @param {Boolean} includeAll
 * @namespace Utils
 * @name transferFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],30:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  } else {
    this.stack = new Error().stack;
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],31:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":32}],32:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":undefined,"type-detect":33}],33:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":34}],34:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],35:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"./lib/type":36,"dup":33}],36:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */
var objectTypeRegexp = /^\[object (.*)\]$/;

function getType(obj) {
  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();
  // Let "new String('')" return 'object'
  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';
  // PhantomJS has type "DOMWindow" for null
  if (obj === null) return 'null';
  // PhantomJS has type "DOMWindow" for undefined
  if (obj === undefined) return 'undefined';
  return type;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library() {
  if (!(this instanceof Library)) return new Library();
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function(type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function(obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}]},{},[1])(1)
});
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   3.0.18
 */

(function() {
    "use strict";
    function lib$rsvp$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$rsvp$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$rsvp$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$rsvp$utils$$_isArray;
    if (!Array.isArray) {
      lib$rsvp$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$rsvp$utils$$_isArray = Array.isArray;
    }

    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;

    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };

    function lib$rsvp$utils$$F() { }

    var lib$rsvp$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      lib$rsvp$utils$$F.prototype = o;
      return new lib$rsvp$utils$$F();
    });
    function lib$rsvp$events$$indexOf(callbacks, callback) {
      for (var i=0, l=callbacks.length; i<l; i++) {
        if (callbacks[i] === callback) { return i; }
      }

      return -1;
    }

    function lib$rsvp$events$$callbacksFor(object) {
      var callbacks = object._promiseCallbacks;

      if (!callbacks) {
        callbacks = object._promiseCallbacks = {};
      }

      return callbacks;
    }

    var lib$rsvp$events$$default = {

      /**
        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
        Example:

        ```javascript
        var object = {};

        RSVP.EventTarget.mixin(object);

        object.on('finished', function(event) {
          // handle event
        });

        object.trigger('finished', { detail: value });
        ```

        `EventTarget.mixin` also works with prototypes:

        ```javascript
        var Person = function() {};
        RSVP.EventTarget.mixin(Person.prototype);

        var yehuda = new Person();
        var tom = new Person();

        yehuda.on('poke', function(event) {
          console.log('Yehuda says OW');
        });

        tom.on('poke', function(event) {
          console.log('Tom says OW');
        });

        yehuda.trigger('poke');
        tom.trigger('poke');
        ```

        @method mixin
        @for RSVP.EventTarget
        @private
        @param {Object} object object to extend with EventTarget methods
      */
      'mixin': function(object) {
        object['on']      = this['on'];
        object['off']     = this['off'];
        object['trigger'] = this['trigger'];
        object._promiseCallbacks = undefined;
        return object;
      },

      /**
        Registers a callback to be executed when `eventName` is triggered

        ```javascript
        object.on('event', function(eventInfo){
          // handle the event
        });

        object.trigger('event');
        ```

        @method on
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to listen for
        @param {Function} callback function to be called when the event is triggered.
      */
      'on': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;

        callbacks = allCallbacks[eventName];

        if (!callbacks) {
          callbacks = allCallbacks[eventName] = [];
        }

        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {
          callbacks.push(callback);
        }
      },

      /**
        You can use `off` to stop firing a particular callback for an event:

        ```javascript
        function doStuff() { // do stuff! }
        object.on('stuff', doStuff);

        object.trigger('stuff'); // doStuff will be called

        // Unregister ONLY the doStuff callback
        object.off('stuff', doStuff);
        object.trigger('stuff'); // doStuff will NOT be called
        ```

        If you don't pass a `callback` argument to `off`, ALL callbacks for the
        event will not be executed when the event fires. For example:

        ```javascript
        var callback1 = function(){};
        var callback2 = function(){};

        object.on('stuff', callback1);
        object.on('stuff', callback2);

        object.trigger('stuff'); // callback1 and callback2 will be executed.

        object.off('stuff');
        object.trigger('stuff'); // callback1 and callback2 will not be executed!
        ```

        @method off
        @for RSVP.EventTarget
        @private
        @param {String} eventName event to stop listening to
        @param {Function} callback optional argument. If given, only the function
        given will be removed from the event's callback queue. If no `callback`
        argument is given, all callbacks will be removed from the event's callback
        queue.
      */
      'off': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;

        if (!callback) {
          allCallbacks[eventName] = [];
          return;
        }

        callbacks = allCallbacks[eventName];

        index = lib$rsvp$events$$indexOf(callbacks, callback);

        if (index !== -1) { callbacks.splice(index, 1); }
      },

      /**
        Use `trigger` to fire custom events. For example:

        ```javascript
        object.on('foo', function(){
          console.log('foo event happened!');
        });
        object.trigger('foo');
        // 'foo event happened!' logged to the console
        ```

        You can also pass a value as a second argument to `trigger` that will be
        passed as an argument to all event listeners for the event:

        ```javascript
        object.on('foo', function(value){
          console.log(value.name);
        });

        object.trigger('foo', { name: 'bar' });
        // 'bar' logged to the console
        ```

        @method trigger
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to be triggered
        @param {Any} options optional value to be passed to any event handlers for
        the given `eventName`
      */
      'trigger': function(eventName, options) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;

        if (callbacks = allCallbacks[eventName]) {
          // Don't cache the callbacks.length since it may grow
          for (var i=0; i<callbacks.length; i++) {
            callback = callbacks[i];

            callback(options);
          }
        }
      }
    };

    var lib$rsvp$config$$config = {
      instrument: false
    };

    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);

    function lib$rsvp$config$$configure(name, value) {
      if (name === 'onerror') {
        // handle for legacy users that expect the actual
        // error to be passed to their function added via
        // `RSVP.configure('onerror', someFunctionHere);`
        lib$rsvp$config$$config['on']('error', value);
        return;
      }

      if (arguments.length === 2) {
        lib$rsvp$config$$config[name] = value;
      } else {
        return lib$rsvp$config$$config[name];
      }
    }

    var lib$rsvp$instrument$$queue = [];

    function lib$rsvp$instrument$$scheduleFlush() {
      setTimeout(function() {
        var entry;
        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {
          entry = lib$rsvp$instrument$$queue[i];

          var payload = entry.payload;

          payload.guid = payload.key + payload.id;
          payload.childGuid = payload.key + payload.childId;
          if (payload.error) {
            payload.stack = payload.error.stack;
          }

          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);
        }
        lib$rsvp$instrument$$queue.length = 0;
      }, 50);
    }

    function lib$rsvp$instrument$$instrument(eventName, promise, child) {
      if (1 === lib$rsvp$instrument$$queue.push({
          name: eventName,
          payload: {
            key: promise._guidKey,
            id:  promise._id,
            eventName: eventName,
            detail: promise._result,
            childId: child && child._id,
            label: promise._label,
            timeStamp: lib$rsvp$utils$$now(),
            error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null
          }})) {
            lib$rsvp$instrument$$scheduleFlush();
          }
      }
    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;

    function  lib$rsvp$$internal$$withOwnPromise() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$rsvp$$internal$$noop() {}

    var lib$rsvp$$internal$$PENDING   = void 0;
    var lib$rsvp$$internal$$FULFILLED = 1;
    var lib$rsvp$$internal$$REJECTED  = 2;

    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;
        return lib$rsvp$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {
      lib$rsvp$config$$config.async(function(promise) {
        var sealed = false;
        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$rsvp$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$rsvp$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {
        thenable._onError = null;
        lib$rsvp$$internal$$reject(promise, thenable._result);
      } else {
        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          lib$rsvp$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$rsvp$$internal$$getThen(maybeThenable);

        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$rsvp$utils$$isFunction(then)) {
          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$rsvp$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (lib$rsvp$utils$$objectOrFunction(value)) {
        lib$rsvp$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$rsvp$$internal$$fulfill(promise, value);
      }
    }

    function lib$rsvp$$internal$$publishRejection(promise) {
      if (promise._onError) {
        promise._onError(promise._result);
      }

      lib$rsvp$$internal$$publish(promise);
    }

    function lib$rsvp$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$rsvp$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('fulfilled', promise);
        }
      } else {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);
      }
    }

    function lib$rsvp$$internal$$reject(promise, reason) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }
      promise._state = lib$rsvp$$internal$$REJECTED;
      promise._result = reason;
      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);
    }

    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onError = null;

      subscribers[length] = child;
      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);
      }
    }

    function lib$rsvp$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);
      }

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$rsvp$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$rsvp$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$rsvp$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$rsvp$$internal$$tryCatch(callback, detail);

        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$rsvp$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$rsvp$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$rsvp$$internal$$reject(promise, error);
      } else if (settled === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (settled === lib$rsvp$$internal$$REJECTED) {
        lib$rsvp$$internal$$reject(promise, value);
      }
    }

    function lib$rsvp$$internal$$initializePromise(promise, resolver) {
      var resolved = false;
      try {
        resolver(function resolvePromise(value){
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$rsvp$$internal$$reject(promise, e);
      }
    }

    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {
      if (state === lib$rsvp$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
        return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(lib$rsvp$$internal$$noop, label);
      this._abortOnReject = abortOnReject;

      if (this._validateInput(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._init();

        if (this.length === 0) {
          lib$rsvp$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            lib$rsvp$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        lib$rsvp$$internal$$reject(this.promise, this._validationError());
      }
    }

    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;

    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$rsvp$utils$$isArray(input);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var promise = this.promise;
      var input   = this._input;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      if (lib$rsvp$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {
          entry._onError = null;
          this._settledAt(entry._state, i, entry._result);
        } else {
          this._willSettleAt(c.resolve(entry), i);
        }
      } else {
        this._remaining--;
        this._result[i] = this._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === lib$rsvp$$internal$$PENDING) {
        this._remaining--;

        if (this._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {
          lib$rsvp$$internal$$reject(promise, value);
        } else {
          this._result[i] = this._makeResult(state, i, value);
        }
      }

      if (this._remaining === 0) {
        lib$rsvp$$internal$$fulfill(promise, this._result);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);
      });
    };
    function lib$rsvp$promise$all$$all(entries, label) {
      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    }
    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;
    function lib$rsvp$promise$race$$race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);

      if (!lib$rsvp$utils$$isArray(entries)) {
        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$rsvp$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$rsvp$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;
    function lib$rsvp$promise$resolve$$resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;
    function lib$rsvp$promise$reject$$reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;

    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';
    var lib$rsvp$promise$$counter = 0;

    function lib$rsvp$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$rsvp$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promises eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class RSVP.Promise
      @param {function} resolver
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @constructor
    */
    function lib$rsvp$promise$$Promise(resolver, label) {
      this._id = lib$rsvp$promise$$counter++;
      this._label = label;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default('created', this);
      }

      if (lib$rsvp$$internal$$noop !== resolver) {
        if (!lib$rsvp$utils$$isFunction(resolver)) {
          lib$rsvp$promise$$needsResolver();
        }

        if (!(this instanceof lib$rsvp$promise$$Promise)) {
          lib$rsvp$promise$$needsNew();
        }

        lib$rsvp$$internal$$initializePromise(this, resolver);
      }
    }

    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;

    // deprecated
    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;
    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;
    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;

    lib$rsvp$promise$$Promise.prototype = {
      constructor: lib$rsvp$promise$$Promise,

      _guidKey: lib$rsvp$promise$$guidKey,

      _onError: function (reason) {
        lib$rsvp$config$$config.async(function(promise) {
          setTimeout(function() {
            if (promise._onError) {
              lib$rsvp$config$$config['trigger']('error', reason);
            }
          }, 0);
        }, this);
      },

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection, label) {
        var parent = this;
        var state = parent._state;

        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {
          if (lib$rsvp$config$$config.instrument) {
            lib$rsvp$instrument$$default('chained', this, this);
          }
          return this;
        }

        parent._onError = null;

        var child = new this.constructor(lib$rsvp$$internal$$noop, label);
        var result = parent._result;

        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('chained', parent, child);
        }

        if (state) {
          var callback = arguments[state - 1];
          lib$rsvp$config$$config.async(function(){
            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection, label) {
        return this.then(null, onRejection, label);
      },

    /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves

      Synchronous example:

      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }

      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuther();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```

      Asynchronous example:

      ```js
      findAuthor().catch(function(reason){
        return findOtherAuther();
      }).finally(function(){
        // author was either found, or not
      });
      ```

      @method finally
      @param {Function} callback
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'finally': function(callback, label) {
        var constructor = this.constructor;

        return this.then(function(value) {
          return constructor.resolve(callback()).then(function(){
            return value;
          });
        }, function(reason) {
          return constructor.resolve(callback()).then(function(){
            throw reason;
          });
        }, label);
      }
    };

    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {
      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);
    }

    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {
      return new Error('allSettled must be called with an array');
    };

    function lib$rsvp$all$settled$$allSettled(entries, label) {
      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;
    }
    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;
    function lib$rsvp$all$$all(array, label) {
      return lib$rsvp$promise$$default.all(array, label);
    }
    var lib$rsvp$all$$default = lib$rsvp$all$$all;
    var lib$rsvp$asap$$len = 0;
    var lib$rsvp$asap$$toString = {}.toString;
    var lib$rsvp$asap$$vertxNext;
    function lib$rsvp$asap$$asap(callback, arg) {
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;
      lib$rsvp$asap$$len += 2;
      if (lib$rsvp$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        lib$rsvp$asap$$scheduleFlush();
      }
    }

    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;

    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};
    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;
    var lib$rsvp$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$rsvp$asap$$useNextTick() {
      var nextTick = process.nextTick;
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // setImmediate should be used instead instead
      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
        nextTick = setImmediate;
      }
      return function() {
        nextTick(lib$rsvp$asap$$flush);
      };
    }

    // vertx
    function lib$rsvp$asap$$useVertxTimer() {
      return function() {
        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);
      };
    }

    function lib$rsvp$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$rsvp$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$rsvp$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$rsvp$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$rsvp$asap$$flush, 1);
      };
    }

    var lib$rsvp$asap$$queue = new Array(1000);
    function lib$rsvp$asap$$flush() {
      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {
        var callback = lib$rsvp$asap$$queue[i];
        var arg = lib$rsvp$asap$$queue[i+1];

        callback(arg);

        lib$rsvp$asap$$queue[i] = undefined;
        lib$rsvp$asap$$queue[i+1] = undefined;
      }

      lib$rsvp$asap$$len = 0;
    }

    function lib$rsvp$asap$$attemptVertex() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$rsvp$asap$$useVertxTimer();
      } catch(e) {
        return lib$rsvp$asap$$useSetTimeout();
      }
    }

    var lib$rsvp$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$rsvp$asap$$isNode) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();
    } else if (lib$rsvp$asap$$BrowserMutationObserver) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();
    } else if (lib$rsvp$asap$$isWorker) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();
    } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();
    } else {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();
    }
    function lib$rsvp$defer$$defer(label) {
      var deferred = { };

      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {
        deferred['resolve'] = resolve;
        deferred['reject'] = reject;
      }, label);

      return deferred;
    }
    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;
    function lib$rsvp$filter$$filter(promises, filterFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(filterFn)) {
          throw new TypeError("You must pass a function as filter's second argument.");
        }

        var length = values.length;
        var filtered = new Array(length);

        for (var i = 0; i < length; i++) {
          filtered[i] = filterFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {
          var results = new Array(length);
          var newLength = 0;

          for (var i = 0; i < length; i++) {
            if (filtered[i]) {
              results[newLength] = values[i];
              newLength++;
            }
          }

          results.length = newLength;

          return results;
        });
      });
    }
    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;

    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {
      this._superConstructor(Constructor, object, true, label);
    }

    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;

    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {
      this._result = {};
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {
      return input && typeof input === 'object';
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {
      return new Error('Promise.hash must be called with an object');
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {
      var promise = this.promise;
      var input   = this._input;
      var results = [];

      for (var key in input) {
        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {
          results.push({
            position: key,
            entry: input[key]
          });
        }
      }

      var length = results.length;
      this._remaining = length;
      var result;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        result = results[i];
        this._eachEntry(result.entry, result.position);
      }
    };

    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {
      this._superConstructor(Constructor, object, false, label);
    }

    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);
    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;

    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {
      return new Error('hashSettled must be called with an object');
    };

    function lib$rsvp$hash$settled$$hashSettled(object, label) {
      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;
    function lib$rsvp$hash$$hash(object, label) {
      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;
    function lib$rsvp$map$$map(promises, mapFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(mapFn)) {
          throw new TypeError("You must pass a function as map's second argument.");
        }

        var length = values.length;
        var results = new Array(length);

        for (var i = 0; i < length; i++) {
          results[i] = mapFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(results, label);
      });
    }
    var lib$rsvp$map$$default = lib$rsvp$map$$map;

    function lib$rsvp$node$$Result() {
      this.value = undefined;
    }

    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();
    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();

    function lib$rsvp$node$$getThen(obj) {
      try {
       return obj.then;
      } catch(error) {
        lib$rsvp$node$$ERROR.value= error;
        return lib$rsvp$node$$ERROR;
      }
    }


    function lib$rsvp$node$$tryApply(f, s, a) {
      try {
        f.apply(s, a);
      } catch(error) {
        lib$rsvp$node$$ERROR.value = error;
        return lib$rsvp$node$$ERROR;
      }
    }

    function lib$rsvp$node$$makeObject(_, argumentNames) {
      var obj = {};
      var name;
      var i;
      var length = _.length;
      var args = new Array(length);

      for (var x = 0; x < length; x++) {
        args[x] = _[x];
      }

      for (i = 0; i < argumentNames.length; i++) {
        name = argumentNames[i];
        obj[name] = args[i + 1];
      }

      return obj;
    }

    function lib$rsvp$node$$arrayResult(_) {
      var length = _.length;
      var args = new Array(length - 1);

      for (var i = 1; i < length; i++) {
        args[i - 1] = _[i];
      }

      return args;
    }

    function lib$rsvp$node$$wrapThenable(then, promise) {
      return {
        then: function(onFulFillment, onRejection) {
          return then.call(promise, onFulFillment, onRejection);
        }
      };
    }

    function lib$rsvp$node$$denodeify(nodeFunc, options) {
      var fn = function() {
        var self = this;
        var l = arguments.length;
        var args = new Array(l + 1);
        var arg;
        var promiseInput = false;

        for (var i = 0; i < l; ++i) {
          arg = arguments[i];

          if (!promiseInput) {
            // TODO: clean this up
            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);
            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {
              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);
              return p;
            } else if (promiseInput && promiseInput !== true) {
              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);
            }
          }
          args[i] = arg;
        }

        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);

        args[l] = function(err, val) {
          if (err)
            lib$rsvp$$internal$$reject(promise, err);
          else if (options === undefined)
            lib$rsvp$$internal$$resolve(promise, val);
          else if (options === true)
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));
          else if (lib$rsvp$utils$$isArray(options))
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));
          else
            lib$rsvp$$internal$$resolve(promise, val);
        };

        if (promiseInput) {
          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);
        } else {
          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);
        }
      };

      fn.__proto__ = nodeFunc;

      return fn;
    }

    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;

    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {
      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
      if (result === lib$rsvp$node$$ERROR) {
        lib$rsvp$$internal$$reject(promise, result.value);
      }
      return promise;
    }

    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){
      return lib$rsvp$promise$$default.all(args).then(function(args){
        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
        if (result === lib$rsvp$node$$ERROR) {
          lib$rsvp$$internal$$reject(promise, result.value);
        }
        return promise;
      });
    }

    function lib$rsvp$node$$needsPromiseInput(arg) {
      if (arg && typeof arg === 'object') {
        if (arg.constructor === lib$rsvp$promise$$default) {
          return true;
        } else {
          return lib$rsvp$node$$getThen(arg);
        }
      } else {
        return false;
      }
    }
    function lib$rsvp$race$$race(array, label) {
      return lib$rsvp$promise$$default.race(array, label);
    }
    var lib$rsvp$race$$default = lib$rsvp$race$$race;
    function lib$rsvp$reject$$reject(reason, label) {
      return lib$rsvp$promise$$default.reject(reason, label);
    }
    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;
    function lib$rsvp$resolve$$resolve(value, label) {
      return lib$rsvp$promise$$default.resolve(value, label);
    }
    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;
    function lib$rsvp$rethrow$$rethrow(reason) {
      setTimeout(function() {
        throw reason;
      });
      throw reason;
    }
    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;

    // default async is asap;
    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;
    var lib$rsvp$$cast = lib$rsvp$resolve$$default;
    function lib$rsvp$$async(callback, arg) {
      lib$rsvp$config$$config.async(callback, arg);
    }

    function lib$rsvp$$on() {
      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);
    }

    function lib$rsvp$$off() {
      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);
    }

    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];
      lib$rsvp$config$$configure('instrument', true);
      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {
        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {
          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);
        }
      }
    }

    var lib$rsvp$umd$$RSVP = {
      'race': lib$rsvp$race$$default,
      'Promise': lib$rsvp$promise$$default,
      'allSettled': lib$rsvp$all$settled$$default,
      'hash': lib$rsvp$hash$$default,
      'hashSettled': lib$rsvp$hash$settled$$default,
      'denodeify': lib$rsvp$node$$default,
      'on': lib$rsvp$$on,
      'off': lib$rsvp$$off,
      'map': lib$rsvp$map$$default,
      'filter': lib$rsvp$filter$$default,
      'resolve': lib$rsvp$resolve$$default,
      'reject': lib$rsvp$reject$$default,
      'all': lib$rsvp$all$$default,
      'rethrow': lib$rsvp$rethrow$$default,
      'defer': lib$rsvp$defer$$default,
      'EventTarget': lib$rsvp$events$$default,
      'configure': lib$rsvp$config$$configure,
      'async': lib$rsvp$$async
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$rsvp$umd$$RSVP; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$rsvp$umd$$RSVP;
    } else if (typeof this !== 'undefined') {
      this['RSVP'] = lib$rsvp$umd$$RSVP;
    }
}).call(this);


var wdCb;
(function (wdCb) {
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var JudgeUtils = (function () {
        function JudgeUtils() {
        }
        JudgeUtils.isArray = function (arr) {
            var length = arr && arr.length;
            return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
        };
        JudgeUtils.isArrayExactly = function (arr) {
            return Object.prototype.toString.call(arr) === "[object Array]";
        };
        JudgeUtils.isNumber = function (num) {
            return typeof num == "number";
        };
        JudgeUtils.isNumberExactly = function (num) {
            return Object.prototype.toString.call(num) === "[object Number]";
        };
        JudgeUtils.isString = function (str) {
            return typeof str == "string";
        };
        JudgeUtils.isStringExactly = function (str) {
            return Object.prototype.toString.call(str) === "[object String]";
        };
        JudgeUtils.isBoolean = function (bool) {
            return bool === true || bool === false || toString.call(bool) === '[boolect Boolean]';
        };
        JudgeUtils.isDom = function (obj) {
            return !!(obj && obj.nodeType === 1);
        };
        JudgeUtils.isObject = function (obj) {
            var type = typeof obj;
            return type === 'function' || type === 'object' && !!obj;
        };
        JudgeUtils.isDirectObject = function (obj) {
            return Object.prototype.toString.call(obj) === "[object Object]";
        };
        JudgeUtils.isHostMethod = function (object, property) {
            var type = typeof object[property];
            return type === "function" ||
                (type === "object" && !!object[property]) ||
                type === "unknown";
        };
        JudgeUtils.isNodeJs = function () {
            return ((typeof global != "undefined" && global.module) || (typeof module != "undefined")) && typeof module.exports != "undefined";
        };
        JudgeUtils.isFunction = function (func) {
            return true;
        };
        return JudgeUtils;
    }());
    wdCb.JudgeUtils = JudgeUtils;
    if (typeof /./ != 'function' && typeof Int8Array != 'object') {
        JudgeUtils.isFunction = function (func) {
            return typeof func == 'function';
        };
    }
    else {
        JudgeUtils.isFunction = function (func) {
            return Object.prototype.toString.call(func) === "[object Function]";
        };
    }
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    if (wdCb.JudgeUtils.isNodeJs() && typeof global != "undefined") {
        wdCb.root = global;
    }
    else {
        wdCb.root = window;
    }
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    if ('performance' in wdCb.root === false) {
        wdCb.root.performance = {};
    }
    Date.now = (Date.now || function () {
        return new Date().getTime();
    });
    if ('now' in wdCb.root.performance === false) {
        var offset = wdCb.root.performance.timing && wdCb.root.performance.timing.navigationStart ? performance.timing.navigationStart
            : Date.now();
        wdCb.root.performance.now = function () {
            return Date.now() - offset;
        };
    }
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    wdCb.$BREAK = {
        break: true
    };
    wdCb.$REMOVE = void 0;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var Log = (function () {
        function Log() {
        }
        Log.log = function () {
            var messages = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                messages[_i - 0] = arguments[_i];
            }
            if (!this._exec("log", messages)) {
                wdCb.root.alert(messages.join(","));
            }
            this._exec("trace", messages);
        };
        Log.assert = function (cond) {
            var messages = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                messages[_i - 1] = arguments[_i];
            }
            if (cond) {
                if (!this._exec("assert", arguments, 1)) {
                    this.log.apply(this, Array.prototype.slice.call(arguments, 1));
                }
            }
        };
        Log.error = function (cond) {
            var message = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                message[_i - 1] = arguments[_i];
            }
            if (cond) {
                throw new Error(Array.prototype.slice.call(arguments, 1).join("\n"));
            }
        };
        Log.warn = function () {
            var message = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                message[_i - 0] = arguments[_i];
            }
            var result = this._exec("warn", arguments);
            if (!result) {
                this.log.apply(this, arguments);
            }
            else {
                this._exec("trace", ["warn trace"]);
            }
        };
        Log._exec = function (consoleMethod, args, sliceBegin) {
            if (sliceBegin === void 0) { sliceBegin = 0; }
            if (wdCb.root.console && wdCb.root.console[consoleMethod]) {
                wdCb.root.console[consoleMethod].apply(wdCb.root.console, Array.prototype.slice.call(args, sliceBegin));
                return true;
            }
            return false;
        };
        Log.info = {
            INVALID_PARAM: "invalid parameter",
            helperFunc: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var result = "";
                args.forEach(function (val) {
                    result += String(val) + " ";
                });
                return result.slice(0, -1);
            },
            assertion: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (args.length === 2) {
                    return this.helperFunc(args[0], args[1]);
                }
                else if (args.length === 3) {
                    return this.helperFunc(args[1], args[0], args[2]);
                }
                else {
                    throw new Error("args.length must <= 3");
                }
            },
            FUNC_INVALID: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("invalid");
                return this.assertion.apply(this, args);
            },
            FUNC_MUST: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("must");
                return this.assertion.apply(this, args);
            },
            FUNC_MUST_BE: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("must be");
                return this.assertion.apply(this, args);
            },
            FUNC_MUST_NOT_BE: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("must not be");
                return this.assertion.apply(this, args);
            },
            FUNC_SHOULD: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("should");
                return this.assertion.apply(this, args);
            },
            FUNC_SHOULD_NOT: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("should not");
                return this.assertion.apply(this, args);
            },
            FUNC_SUPPORT: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("support");
                return this.assertion.apply(this, args);
            },
            FUNC_NOT_SUPPORT: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("not support");
                return this.assertion.apply(this, args);
            },
            FUNC_MUST_DEFINE: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("must define");
                return this.assertion.apply(this, args);
            },
            FUNC_MUST_NOT_DEFINE: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("must not define");
                return this.assertion.apply(this, args);
            },
            FUNC_UNKNOW: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("unknow");
                return this.assertion.apply(this, args);
            },
            FUNC_EXPECT: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("expect");
                return this.assertion.apply(this, args);
            },
            FUNC_UNEXPECT: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("unexpect");
                return this.assertion.apply(this, args);
            },
            FUNC_EXIST: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("exist");
                return this.assertion.apply(this, args);
            },
            FUNC_NOT_EXIST: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("not exist");
                return this.assertion.apply(this, args);
            },
            FUNC_ONLY: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("only");
                return this.assertion.apply(this, args);
            },
            FUNC_CAN_NOT: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                args.unshift("can't");
                return this.assertion.apply(this, args);
            }
        };
        return Log;
    }());
    wdCb.Log = Log;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var List = (function () {
        function List() {
            this.children = null;
        }
        List.prototype.getCount = function () {
            return this.children.length;
        };
        List.prototype.hasChild = function (child) {
            var c = null, children = this.children;
            for (var i = 0, len = children.length; i < len; i++) {
                c = children[i];
                if (child.uid && c.uid && child.uid == c.uid) {
                    return true;
                }
                else if (child === c) {
                    return true;
                }
            }
            return false;
        };
        List.prototype.hasChildWithFunc = function (func) {
            for (var i = 0, len = this.children.length; i < len; i++) {
                if (func(this.children[i], i)) {
                    return true;
                }
            }
            return false;
        };
        List.prototype.getChildren = function () {
            return this.children;
        };
        List.prototype.getChild = function (index) {
            return this.children[index];
        };
        List.prototype.addChild = function (child) {
            this.children.push(child);
            return this;
        };
        List.prototype.addChildren = function (arg) {
            if (wdCb.JudgeUtils.isArray(arg)) {
                var children = arg;
                this.children = this.children.concat(children);
            }
            else if (arg instanceof List) {
                var children = arg;
                this.children = this.children.concat(children.getChildren());
            }
            else {
                var child = arg;
                this.addChild(child);
            }
            return this;
        };
        List.prototype.setChildren = function (children) {
            this.children = children;
            return this;
        };
        List.prototype.unShiftChild = function (child) {
            this.children.unshift(child);
        };
        List.prototype.removeAllChildren = function () {
            this.children = [];
            return this;
        };
        List.prototype.forEach = function (func, context) {
            this._forEach(this.children, func, context);
            return this;
        };
        List.prototype.toArray = function () {
            return this.children;
        };
        List.prototype.copyChildren = function () {
            return this.children.slice(0);
        };
        List.prototype.removeChildHelper = function (arg) {
            var result = null;
            if (wdCb.JudgeUtils.isFunction(arg)) {
                var func = arg;
                result = this._removeChild(this.children, func);
            }
            else if (arg.uid) {
                result = this._removeChild(this.children, function (e) {
                    if (!e.uid) {
                        return false;
                    }
                    return e.uid === arg.uid;
                });
            }
            else {
                result = this._removeChild(this.children, function (e) {
                    return e === arg;
                });
            }
            return result;
        };
        List.prototype._forEach = function (arr, func, context) {
            var scope = context, i = 0, len = arr.length;
            for (i = 0; i < len; i++) {
                if (func.call(scope, arr[i], i) === wdCb.$BREAK) {
                    break;
                }
            }
        };
        List.prototype._removeChild = function (arr, func) {
            var self = this, removedElementArr = [], remainElementArr = [];
            this._forEach(arr, function (e, index) {
                if (!!func.call(self, e)) {
                    removedElementArr.push(e);
                }
                else {
                    remainElementArr.push(e);
                }
            });
            this.children = remainElementArr;
            return removedElementArr;
        };
        return List;
    }());
    wdCb.List = List;
})(wdCb || (wdCb = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdCb;
(function (wdCb) {
    var Collection = (function (_super) {
        __extends(Collection, _super);
        function Collection(children) {
            if (children === void 0) { children = []; }
            _super.call(this);
            this.children = children;
        }
        Collection.create = function (children) {
            if (children === void 0) { children = []; }
            var obj = new this(children);
            return obj;
        };
        Collection.prototype.clone = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var target = null, isDeep = null;
            if (args.length === 0) {
                isDeep = false;
                target = Collection.create();
            }
            else if (args.length === 1) {
                if (wdCb.JudgeUtils.isBoolean(args[0])) {
                    target = Collection.create();
                    isDeep = args[0];
                }
                else {
                    target = args[0];
                    isDeep = false;
                }
            }
            else {
                target = args[0];
                isDeep = args[1];
            }
            if (isDeep === true) {
                target.setChildren(wdCb.ExtendUtils.extendDeep(this.children));
            }
            else {
                target.setChildren(wdCb.ExtendUtils.extend([], this.children));
            }
            return target;
        };
        Collection.prototype.filter = function (func) {
            var children = this.children, result = [], value = null;
            for (var i = 0, len = children.length; i < len; i++) {
                value = children[i];
                if (func.call(children, value, i)) {
                    result.push(value);
                }
            }
            return Collection.create(result);
        };
        Collection.prototype.findOne = function (func) {
            var scope = this.children, result = null;
            this.forEach(function (value, index) {
                if (!func.call(scope, value, index)) {
                    return;
                }
                result = value;
                return wdCb.$BREAK;
            });
            return result;
        };
        Collection.prototype.reverse = function () {
            return Collection.create(this.copyChildren().reverse());
        };
        Collection.prototype.removeChild = function (arg) {
            return Collection.create(this.removeChildHelper(arg));
        };
        Collection.prototype.sort = function (func, isSortSelf) {
            if (isSortSelf === void 0) { isSortSelf = false; }
            if (isSortSelf) {
                this.children.sort(func);
                return this;
            }
            return Collection.create(this.copyChildren().sort(func));
        };
        Collection.prototype.map = function (func) {
            var resultArr = [];
            this.forEach(function (e, index) {
                var result = func(e, index);
                if (result !== wdCb.$REMOVE) {
                    resultArr.push(result);
                }
            });
            return Collection.create(resultArr);
        };
        Collection.prototype.removeRepeatItems = function () {
            var noRepeatList = Collection.create();
            this.forEach(function (item) {
                if (noRepeatList.hasChild(item)) {
                    return;
                }
                noRepeatList.addChild(item);
            });
            return noRepeatList;
        };
        Collection.prototype.hasRepeatItems = function () {
            var noRepeatList = Collection.create(), hasRepeat = false;
            this.forEach(function (item) {
                if (noRepeatList.hasChild(item)) {
                    hasRepeat = true;
                    return wdCb.$BREAK;
                }
                noRepeatList.addChild(item);
            });
            return hasRepeat;
        };
        return Collection;
    }(wdCb.List));
    wdCb.Collection = Collection;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var Hash = (function () {
        function Hash(children) {
            if (children === void 0) { children = {}; }
            this._children = null;
            this._children = children;
        }
        Hash.create = function (children) {
            if (children === void 0) { children = {}; }
            var obj = new this(children);
            return obj;
        };
        Hash.prototype.getChildren = function () {
            return this._children;
        };
        Hash.prototype.getCount = function () {
            var result = 0, children = this._children, key = null;
            for (key in children) {
                if (children.hasOwnProperty(key)) {
                    result++;
                }
            }
            return result;
        };
        Hash.prototype.getKeys = function () {
            var result = wdCb.Collection.create(), children = this._children, key = null;
            for (key in children) {
                if (children.hasOwnProperty(key)) {
                    result.addChild(key);
                }
            }
            return result;
        };
        Hash.prototype.getValues = function () {
            var result = wdCb.Collection.create(), children = this._children, key = null;
            for (key in children) {
                if (children.hasOwnProperty(key)) {
                    result.addChild(children[key]);
                }
            }
            return result;
        };
        Hash.prototype.getChild = function (key) {
            return this._children[key];
        };
        Hash.prototype.setValue = function (key, value) {
            this._children[key] = value;
            return this;
        };
        Hash.prototype.addChild = function (key, value) {
            this._children[key] = value;
            return this;
        };
        Hash.prototype.addChildren = function (arg) {
            var i = null, children = null;
            if (arg instanceof Hash) {
                children = arg.getChildren();
            }
            else {
                children = arg;
            }
            for (i in children) {
                if (children.hasOwnProperty(i)) {
                    this.addChild(i, children[i]);
                }
            }
            return this;
        };
        Hash.prototype.appendChild = function (key, value) {
            if (this._children[key] instanceof wdCb.Collection) {
                var c = (this._children[key]);
                c.addChild(value);
            }
            else {
                this._children[key] = (wdCb.Collection.create().addChild(value));
            }
            return this;
        };
        Hash.prototype.setChildren = function (children) {
            this._children = children;
        };
        Hash.prototype.removeChild = function (arg) {
            var result = [];
            if (wdCb.JudgeUtils.isString(arg)) {
                var key = arg;
                result.push(this._children[key]);
                this._children[key] = void 0;
                delete this._children[key];
            }
            else if (wdCb.JudgeUtils.isFunction(arg)) {
                var func_1 = arg, self_1 = this;
                this.forEach(function (val, key) {
                    if (func_1(val, key)) {
                        result.push(self_1._children[key]);
                        self_1._children[key] = void 0;
                        delete self_1._children[key];
                    }
                });
            }
            return wdCb.Collection.create(result);
        };
        Hash.prototype.removeAllChildren = function () {
            this._children = {};
        };
        Hash.prototype.hasChild = function (key) {
            return this._children[key] !== void 0;
        };
        Hash.prototype.hasChildWithFunc = function (func) {
            var result = false;
            this.forEach(function (val, key) {
                if (func(val, key)) {
                    result = true;
                    return wdCb.$BREAK;
                }
            });
            return result;
        };
        Hash.prototype.forEach = function (func, context) {
            var children = this._children;
            for (var i in children) {
                if (children.hasOwnProperty(i)) {
                    if (func.call(context, children[i], i) === wdCb.$BREAK) {
                        break;
                    }
                }
            }
            return this;
        };
        Hash.prototype.filter = function (func) {
            var result = {}, children = this._children, value = null;
            for (var key in children) {
                if (children.hasOwnProperty(key)) {
                    value = children[key];
                    if (func.call(children, value, key)) {
                        result[key] = value;
                    }
                }
            }
            return Hash.create(result);
        };
        Hash.prototype.findOne = function (func) {
            var result = [], self = this, scope = this._children;
            this.forEach(function (val, key) {
                if (!func.call(scope, val, key)) {
                    return;
                }
                result = [key, self.getChild(key)];
                return wdCb.$BREAK;
            });
            return result;
        };
        Hash.prototype.map = function (func) {
            var resultMap = {};
            this.forEach(function (val, key) {
                var result = func(val, key);
                if (result !== wdCb.$REMOVE) {
                    wdCb.Log.error(!wdCb.JudgeUtils.isArray(result) || result.length !== 2, wdCb.Log.info.FUNC_MUST_BE("iterator", "[key, value]"));
                    resultMap[result[0]] = result[1];
                }
            });
            return Hash.create(resultMap);
        };
        Hash.prototype.toCollection = function () {
            var result = wdCb.Collection.create();
            this.forEach(function (val, key) {
                if (val instanceof wdCb.Collection) {
                    result.addChildren(val);
                }
                else {
                    result.addChild(val);
                }
            });
            return result;
        };
        Hash.prototype.toArray = function () {
            var result = [];
            this.forEach(function (val, key) {
                if (val instanceof wdCb.Collection) {
                    result = result.concat(val.getChildren());
                }
                else {
                    result.push(val);
                }
            });
            return result;
        };
        Hash.prototype.clone = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var target = null, isDeep = null;
            if (args.length === 0) {
                isDeep = false;
                target = Hash.create();
            }
            else if (args.length === 1) {
                if (wdCb.JudgeUtils.isBoolean(args[0])) {
                    target = Hash.create();
                    isDeep = args[0];
                }
                else {
                    target = args[0];
                    isDeep = false;
                }
            }
            else {
                target = args[0];
                isDeep = args[1];
            }
            if (isDeep === true) {
                target.setChildren(wdCb.ExtendUtils.extendDeep(this._children));
            }
            else {
                target.setChildren(wdCb.ExtendUtils.extend({}, this._children));
            }
            return target;
        };
        return Hash;
    }());
    wdCb.Hash = Hash;
})(wdCb || (wdCb = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdCb;
(function (wdCb) {
    var Queue = (function (_super) {
        __extends(Queue, _super);
        function Queue(children) {
            if (children === void 0) { children = []; }
            _super.call(this);
            this.children = children;
        }
        Queue.create = function (children) {
            if (children === void 0) { children = []; }
            var obj = new this(children);
            return obj;
        };
        Object.defineProperty(Queue.prototype, "front", {
            get: function () {
                return this.children[this.children.length - 1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Queue.prototype, "rear", {
            get: function () {
                return this.children[0];
            },
            enumerable: true,
            configurable: true
        });
        Queue.prototype.push = function (element) {
            this.children.unshift(element);
        };
        Queue.prototype.pop = function () {
            return this.children.pop();
        };
        Queue.prototype.clear = function () {
            this.removeAllChildren();
        };
        return Queue;
    }(wdCb.List));
    wdCb.Queue = Queue;
})(wdCb || (wdCb = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdCb;
(function (wdCb) {
    var Stack = (function (_super) {
        __extends(Stack, _super);
        function Stack(children) {
            if (children === void 0) { children = []; }
            _super.call(this);
            this.children = children;
        }
        Stack.create = function (children) {
            if (children === void 0) { children = []; }
            var obj = new this(children);
            return obj;
        };
        Object.defineProperty(Stack.prototype, "top", {
            get: function () {
                return this.children[this.children.length - 1];
            },
            enumerable: true,
            configurable: true
        });
        Stack.prototype.push = function (element) {
            this.children.push(element);
        };
        Stack.prototype.pop = function () {
            return this.children.pop();
        };
        Stack.prototype.clear = function () {
            this.removeAllChildren();
        };
        Stack.prototype.clone = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var target = null, isDeep = null;
            if (args.length === 0) {
                isDeep = false;
                target = Stack.create();
            }
            else if (args.length === 1) {
                if (wdCb.JudgeUtils.isBoolean(args[0])) {
                    target = Stack.create();
                    isDeep = args[0];
                }
                else {
                    target = args[0];
                    isDeep = false;
                }
            }
            else {
                target = args[0];
                isDeep = args[1];
            }
            if (isDeep === true) {
                target.setChildren(wdCb.ExtendUtils.extendDeep(this.children));
            }
            else {
                target.setChildren(wdCb.ExtendUtils.extend([], this.children));
            }
            return target;
        };
        Stack.prototype.filter = function (func) {
            var children = this.children, result = [], value = null;
            for (var i = 0, len = children.length; i < len; i++) {
                value = children[i];
                if (func.call(children, value, i)) {
                    result.push(value);
                }
            }
            return wdCb.Collection.create(result);
        };
        Stack.prototype.findOne = function (func) {
            var scope = this.children, result = null;
            this.forEach(function (value, index) {
                if (!func.call(scope, value, index)) {
                    return;
                }
                result = value;
                return wdCb.$BREAK;
            });
            return result;
        };
        Stack.prototype.reverse = function () {
            return wdCb.Collection.create(this.copyChildren().reverse());
        };
        Stack.prototype.removeChild = function (arg) {
            return wdCb.Collection.create(this.removeChildHelper(arg));
        };
        Stack.prototype.sort = function (func, isSortSelf) {
            if (isSortSelf === void 0) { isSortSelf = false; }
            if (isSortSelf) {
                this.children.sort(func);
                return this;
            }
            return wdCb.Collection.create(this.copyChildren().sort(func));
        };
        Stack.prototype.map = function (func) {
            var resultArr = [];
            this.forEach(function (e, index) {
                var result = func(e, index);
                if (result !== wdCb.$REMOVE) {
                    resultArr.push(result);
                }
            });
            return wdCb.Collection.create(resultArr);
        };
        Stack.prototype.removeRepeatItems = function () {
            var noRepeatList = wdCb.Collection.create();
            this.forEach(function (item) {
                if (noRepeatList.hasChild(item)) {
                    return;
                }
                noRepeatList.addChild(item);
            });
            return noRepeatList;
        };
        Stack.prototype.hasRepeatItems = function () {
            var noRepeatList = wdCb.Collection.create(), hasRepeat = false;
            this.forEach(function (item) {
                if (noRepeatList.hasChild(item)) {
                    hasRepeat = true;
                    return wdCb.$BREAK;
                }
                noRepeatList.addChild(item);
            });
            return hasRepeat;
        };
        return Stack;
    }(wdCb.List));
    wdCb.Stack = Stack;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var AjaxUtils = (function () {
        function AjaxUtils() {
        }
        AjaxUtils.ajax = function (conf) {
            var type = conf.type;
            var url = conf.url;
            var data = conf.data;
            var dataType = conf.dataType;
            var success = conf.success;
            var error = conf.error;
            var xhr = null;
            var self = this;
            if (type === null) {
                type = "get";
            }
            if (dataType === null) {
                dataType = "text";
            }
            xhr = this._createAjax(error);
            if (!xhr) {
                return;
            }
            try {
                xhr.open(type, url, true);
                if (this._isSoundFile(dataType)) {
                    xhr.responseType = "arraybuffer";
                }
                if (type === "GET" || type === "get") {
                    xhr.send(null);
                }
                else if (type === "POST" || type === "post") {
                    xhr.setRequestHeader("content-type", "application/x-www-form-urlencoded");
                    xhr.send(data);
                }
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4
                        && (xhr.status === 200 || self._isLocalFile(xhr.status))) {
                        if (dataType === "text" || dataType === "TEXT") {
                            if (success !== null) {
                                success(xhr.responseText);
                            }
                        }
                        else if (dataType === "xml" || dataType === "XML") {
                            if (success !== null) {
                                success(xhr.responseXML);
                            }
                        }
                        else if (dataType === "json" || dataType === "JSON") {
                            if (success !== null) {
                                success(eval("(" + xhr.responseText + ")"));
                            }
                        }
                        else if (self._isSoundFile(dataType)) {
                            if (success !== null) {
                                success(xhr.response);
                            }
                        }
                    }
                };
            }
            catch (e) {
                error(xhr, e);
            }
        };
        AjaxUtils._createAjax = function (error) {
            var xhr = null;
            try {
                xhr = new ActiveXObject("microsoft.xmlhttp");
            }
            catch (e1) {
                try {
                    xhr = new XMLHttpRequest();
                }
                catch (e2) {
                    error(xhr, { message: "ajax" });
                    return null;
                }
            }
            return xhr;
        };
        AjaxUtils._isLocalFile = function (status) {
            return document.URL.contain("file://") && status === 0;
        };
        AjaxUtils._isSoundFile = function (dataType) {
            return dataType === "arraybuffer";
        };
        return AjaxUtils;
    }());
    wdCb.AjaxUtils = AjaxUtils;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var ArrayUtils = (function () {
        function ArrayUtils() {
        }
        ArrayUtils.removeRepeatItems = function (arr, isEqual) {
            if (isEqual === void 0) { isEqual = function (a, b) {
                return a === b;
            }; }
            var resultArr = [], self = this;
            arr.forEach(function (ele) {
                if (self.contain(resultArr, function (val) {
                    return isEqual(val, ele);
                })) {
                    return;
                }
                resultArr.push(ele);
            });
            return resultArr;
        };
        ArrayUtils.contain = function (arr, ele) {
            if (wdCb.JudgeUtils.isFunction(ele)) {
                var func = ele;
                for (var i = 0, len = arr.length; i < len; i++) {
                    var value = arr[i];
                    if (!!func.call(null, value, i)) {
                        return true;
                    }
                }
            }
            else {
                for (var i = 0, len = arr.length; i < len; i++) {
                    var value = arr[i];
                    if (ele === value || (value.contain && value.contain(ele))) {
                        return true;
                    }
                }
            }
            return false;
        };
        ;
        return ArrayUtils;
    }());
    wdCb.ArrayUtils = ArrayUtils;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var ConvertUtils = (function () {
        function ConvertUtils() {
        }
        ConvertUtils.toString = function (obj) {
            if (wdCb.JudgeUtils.isNumber(obj)) {
                return String(obj);
            }
            if (wdCb.JudgeUtils.isFunction(obj)) {
                return this._convertCodeToString(obj);
            }
            if (wdCb.JudgeUtils.isDirectObject(obj) || wdCb.JudgeUtils.isArray(obj)) {
                return JSON.stringify(obj);
            }
            return String(obj);
        };
        ConvertUtils._convertCodeToString = function (fn) {
            return fn.toString().split('\n').slice(1, -1).join('\n') + '\n';
        };
        return ConvertUtils;
    }());
    wdCb.ConvertUtils = ConvertUtils;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var EventUtils = (function () {
        function EventUtils() {
        }
        EventUtils.bindEvent = function (context, func) {
            return function (event) {
                return func.call(context, event);
            };
        };
        EventUtils.addEvent = function (dom, eventName, handler) {
            if (wdCb.JudgeUtils.isHostMethod(dom, "addEventListener")) {
                dom.addEventListener(eventName, handler, false);
            }
            else if (wdCb.JudgeUtils.isHostMethod(dom, "attachEvent")) {
                dom.attachEvent("on" + eventName, handler);
            }
            else {
                dom["on" + eventName] = handler;
            }
        };
        EventUtils.removeEvent = function (dom, eventName, handler) {
            if (wdCb.JudgeUtils.isHostMethod(dom, "removeEventListener")) {
                dom.removeEventListener(eventName, handler, false);
            }
            else if (wdCb.JudgeUtils.isHostMethod(dom, "detachEvent")) {
                dom.detachEvent("on" + eventName, handler);
            }
            else {
                dom["on" + eventName] = null;
            }
        };
        return EventUtils;
    }());
    wdCb.EventUtils = EventUtils;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var ExtendUtils = (function () {
        function ExtendUtils() {
        }
        ExtendUtils.extendDeep = function (parent, child, filter) {
            if (filter === void 0) { filter = function (val, i) { return true; }; }
            var i = null, len = 0, toStr = Object.prototype.toString, sArr = "[object Array]", sOb = "[object Object]", type = "", _child = null;
            if (toStr.call(parent) === sArr) {
                _child = child || [];
                for (i = 0, len = parent.length; i < len; i++) {
                    var member = parent[i];
                    if (!filter(member, i)) {
                        continue;
                    }
                    if (member.clone) {
                        _child[i] = member.clone();
                        continue;
                    }
                    type = toStr.call(member);
                    if (type === sArr || type === sOb) {
                        _child[i] = type === sArr ? [] : {};
                        ExtendUtils.extendDeep(member, _child[i]);
                    }
                    else {
                        _child[i] = member;
                    }
                }
            }
            else if (toStr.call(parent) === sOb) {
                _child = child || {};
                for (i in parent) {
                    var member = parent[i];
                    if (!filter(member, i)) {
                        continue;
                    }
                    if (member.clone) {
                        _child[i] = member.clone();
                        continue;
                    }
                    type = toStr.call(member);
                    if (type === sArr || type === sOb) {
                        _child[i] = type === sArr ? [] : {};
                        ExtendUtils.extendDeep(member, _child[i]);
                    }
                    else {
                        _child[i] = member;
                    }
                }
            }
            else {
                _child = parent;
            }
            return _child;
        };
        ExtendUtils.extend = function (destination, source) {
            var property = "";
            for (property in source) {
                destination[property] = source[property];
            }
            return destination;
        };
        ExtendUtils.copyPublicAttri = function (source) {
            var property = null, destination = {};
            this.extendDeep(source, destination, function (item, property) {
                return property.slice(0, 1) !== "_"
                    && !wdCb.JudgeUtils.isFunction(item);
            });
            return destination;
        };
        return ExtendUtils;
    }());
    wdCb.ExtendUtils = ExtendUtils;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var SPLITPATH_REGEX = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    var PathUtils = (function () {
        function PathUtils() {
        }
        PathUtils.basename = function (path, ext) {
            var f = this._splitPath(path)[2];
            if (ext && f.substr(-1 * ext.length) === ext) {
                f = f.substr(0, f.length - ext.length);
            }
            return f;
        };
        PathUtils.changeExtname = function (pathStr, extname) {
            var extname = extname || "", index = pathStr.indexOf("?"), tempStr = "";
            if (index > 0) {
                tempStr = pathStr.substring(index);
                pathStr = pathStr.substring(0, index);
            }
            index = pathStr.lastIndexOf(".");
            if (index < 0) {
                return pathStr + extname + tempStr;
            }
            return pathStr.substring(0, index) + extname + tempStr;
        };
        PathUtils.changeBasename = function (pathStr, basename, isSameExt) {
            if (isSameExt === void 0) { isSameExt = false; }
            var index = null, tempStr = null, ext = null;
            if (basename.indexOf(".") == 0) {
                return this.changeExtname(pathStr, basename);
            }
            index = pathStr.indexOf("?");
            tempStr = "";
            ext = isSameExt ? this.extname(pathStr) : "";
            if (index > 0) {
                tempStr = pathStr.substring(index);
                pathStr = pathStr.substring(0, index);
            }
            index = pathStr.lastIndexOf("/");
            index = index <= 0 ? 0 : index + 1;
            return pathStr.substring(0, index) + basename + ext + tempStr;
        };
        PathUtils.extname = function (path) {
            return this._splitPath(path)[3];
        };
        PathUtils.dirname = function (path) {
            var result = this._splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
                return '.';
            }
            if (dir) {
                dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
        };
        PathUtils._splitPath = function (fileName) {
            return SPLITPATH_REGEX.exec(fileName).slice(1);
        };
        return PathUtils;
    }());
    wdCb.PathUtils = PathUtils;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var FunctionUtils = (function () {
        function FunctionUtils() {
        }
        FunctionUtils.bind = function (object, func) {
            return function () {
                return func.apply(object, arguments);
            };
        };
        return FunctionUtils;
    }());
    wdCb.FunctionUtils = FunctionUtils;
})(wdCb || (wdCb = {}));

var wdCb;
(function (wdCb) {
    var DomQuery = (function () {
        function DomQuery() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._doms = null;
            if (wdCb.JudgeUtils.isDom(args[0])) {
                this._doms = [args[0]];
            }
            else if (this._isDomEleStr(args[0])) {
                this._doms = [this._buildDom(args[0])];
            }
            else {
                this._doms = document.querySelectorAll(args[0]);
            }
            return this;
        }
        DomQuery.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var obj = new this(args[0]);
            return obj;
        };
        DomQuery.prototype.get = function (index) {
            return this._doms[index];
        };
        DomQuery.prototype.prepend = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var targetDom = null;
            targetDom = this._buildDom(args[0]);
            for (var _a = 0, _b = this._doms; _a < _b.length; _a++) {
                var dom = _b[_a];
                if (dom.nodeType === 1) {
                    dom.insertBefore(targetDom, dom.firstChild);
                }
            }
            return this;
        };
        DomQuery.prototype.prependTo = function (eleStr) {
            var targetDom = null;
            targetDom = DomQuery.create(eleStr);
            for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
                var dom = _a[_i];
                if (dom.nodeType === 1) {
                    targetDom.prepend(dom);
                }
            }
            return this;
        };
        DomQuery.prototype.remove = function () {
            for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
                var dom = _a[_i];
                if (dom && dom.parentNode && dom.tagName != 'BODY') {
                    dom.parentNode.removeChild(dom);
                }
            }
            return this;
        };
        DomQuery.prototype.css = function (property, value) {
            for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
                var dom = _a[_i];
                dom.style[property] = value;
            }
        };
        DomQuery.prototype.attr = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1) {
                var name_1 = args[0];
                return this.get(0).getAttribute(name_1);
            }
            else {
                var name_2 = args[0], value = args[1];
                for (var _a = 0, _b = this._doms; _a < _b.length; _a++) {
                    var dom = _b[_a];
                    dom.setAttribute(name_2, value);
                }
            }
        };
        DomQuery.prototype.text = function (str) {
            var dom = this.get(0);
            if (str !== void 0) {
                if (dom.textContent !== void 0) {
                    dom.textContent = str;
                }
                else {
                    dom.innerText = str;
                }
            }
            else {
                return dom.textContent !== void 0 ? dom.textContent : dom.innerText;
            }
        };
        DomQuery.prototype._isDomEleStr = function (eleStr) {
            return eleStr.match(/<(\w+)[^>]*><\/\1>/) !== null;
        };
        DomQuery.prototype._buildDom = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (wdCb.JudgeUtils.isString(args[0])) {
                var div = this._createElement("div"), eleStr = args[0];
                div.innerHTML = eleStr;
                return div.firstChild;
            }
            return args[0];
        };
        DomQuery.prototype._createElement = function (eleStr) {
            return document.createElement(eleStr);
        };
        return DomQuery;
    }());
    wdCb.DomQuery = DomQuery;
})(wdCb || (wdCb = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var JudgeUtils = (function (_super) {
        __extends(JudgeUtils, _super);
        function JudgeUtils() {
            _super.apply(this, arguments);
        }
        JudgeUtils.isPromise = function (obj) {
            return !!obj
                && !_super.isFunction.call(this, obj.subscribe)
                && _super.isFunction.call(this, obj.then);
        };
        JudgeUtils.isEqual = function (ob1, ob2) {
            return ob1.uid === ob2.uid;
        };
        JudgeUtils.isIObserver = function (i) {
            return i.next && i.error && i.completed;
        };
        return JudgeUtils;
    }(wdCb.JudgeUtils));
    wdFrp.JudgeUtils = JudgeUtils;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    wdFrp.fromNodeCallback = function (func, context) {
        return function () {
            var funcArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                funcArgs[_i - 0] = arguments[_i];
            }
            return wdFrp.createStream(function (observer) {
                var hander = function (err) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (err) {
                        observer.error(err);
                        return;
                    }
                    if (args.length <= 1) {
                        observer.next.apply(observer, args);
                    }
                    else {
                        observer.next(args);
                    }
                    observer.completed();
                };
                funcArgs.push(hander);
                func.apply(context, funcArgs);
            });
        };
    };
    wdFrp.fromStream = function (stream, finishEventName) {
        if (finishEventName === void 0) { finishEventName = "end"; }
        if (stream.pause) {
            stream.pause();
        }
        return wdFrp.createStream(function (observer) {
            var dataHandler = function (data) {
                observer.next(data);
            }, errorHandler = function (err) {
                observer.error(err);
            }, endHandler = function () {
                observer.completed();
            };
            stream.addListener("data", dataHandler);
            stream.addListener("error", errorHandler);
            stream.addListener(finishEventName, endHandler);
            if (stream.resume) {
                stream.resume();
            }
            return function () {
                stream.removeListener("data", dataHandler);
                stream.removeListener("error", errorHandler);
                stream.removeListener(finishEventName, endHandler);
            };
        });
    };
    wdFrp.fromReadableStream = function (stream) {
        return wdFrp.fromStream(stream, "end");
    };
    wdFrp.fromWritableStream = function (stream) {
        return wdFrp.fromStream(stream, "finish");
    };
    wdFrp.fromTransformStream = function (stream) {
        return wdFrp.fromStream(stream, "finish");
    };
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var Entity = (function () {
        function Entity(uidPre) {
            this._uid = null;
            this._uid = uidPre + String(Entity.UID++);
        }
        Object.defineProperty(Entity.prototype, "uid", {
            get: function () {
                return this._uid;
            },
            set: function (uid) {
                this._uid = uid;
            },
            enumerable: true,
            configurable: true
        });
        Entity.UID = 1;
        return Entity;
    }());
    wdFrp.Entity = Entity;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var Main = (function () {
        function Main() {
        }
        Main.isTest = false;
        return Main;
    }());
    wdFrp.Main = Main;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var Log = wdCb.Log;
    function assert(cond, message) {
        if (message === void 0) { message = "contract error"; }
        Log.error(!cond, message);
    }
    wdFrp.assert = assert;
    function require(InFunc) {
        return function (target, name, descriptor) {
            var value = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (wdFrp.Main.isTest) {
                    InFunc.apply(this, args);
                }
                return value.apply(this, args);
            };
            return descriptor;
        };
    }
    wdFrp.require = require;
    function ensure(OutFunc) {
        return function (target, name, descriptor) {
            var value = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var result = value.apply(this, args), params = [result].concat(args);
                if (wdFrp.Main.isTest) {
                    OutFunc.apply(this, params);
                }
                return result;
            };
            return descriptor;
        };
    }
    wdFrp.ensure = ensure;
    function requireGetter(InFunc) {
        return function (target, name, descriptor) {
            var getter = descriptor.get;
            descriptor.get = function () {
                if (wdFrp.Main.isTest) {
                    InFunc.call(this);
                }
                return getter.call(this);
            };
            return descriptor;
        };
    }
    wdFrp.requireGetter = requireGetter;
    function requireSetter(InFunc) {
        return function (target, name, descriptor) {
            var setter = descriptor.set;
            descriptor.set = function (val) {
                if (wdFrp.Main.isTest) {
                    InFunc.call(this, val);
                }
                setter.call(this, val);
            };
            return descriptor;
        };
    }
    wdFrp.requireSetter = requireSetter;
    function ensureGetter(OutFunc) {
        return function (target, name, descriptor) {
            var getter = descriptor.get;
            descriptor.get = function () {
                var result = getter.call(this);
                if (wdFrp.Main.isTest) {
                    OutFunc.call(this, result);
                }
                return result;
            };
            return descriptor;
        };
    }
    wdFrp.ensureGetter = ensureGetter;
    function ensureSetter(OutFunc) {
        return function (target, name, descriptor) {
            var setter = descriptor.set;
            descriptor.set = function (val) {
                var result = setter.call(this, val), params = [result, val];
                if (wdFrp.Main.isTest) {
                    OutFunc.apply(this, params);
                }
            };
            return descriptor;
        };
    }
    wdFrp.ensureSetter = ensureSetter;
    function invariant(func) {
        return function (target) {
            if (wdFrp.Main.isTest) {
                func(target);
            }
        };
    }
    wdFrp.invariant = invariant;
})(wdFrp || (wdFrp = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var SingleDisposable = (function (_super) {
        __extends(SingleDisposable, _super);
        function SingleDisposable(disposeHandler) {
            _super.call(this, "SingleDisposable");
            this._disposeHandler = null;
            this._isDisposed = false;
            this._disposeHandler = disposeHandler;
        }
        SingleDisposable.create = function (disposeHandler) {
            if (disposeHandler === void 0) { disposeHandler = function () { }; }
            var obj = new this(disposeHandler);
            return obj;
        };
        SingleDisposable.prototype.setDisposeHandler = function (handler) {
            this._disposeHandler = handler;
        };
        SingleDisposable.prototype.dispose = function () {
            if (this._isDisposed) {
                return;
            }
            this._isDisposed = true;
            this._disposeHandler();
        };
        return SingleDisposable;
    }(wdFrp.Entity));
    wdFrp.SingleDisposable = SingleDisposable;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var GroupDisposable = (function (_super) {
        __extends(GroupDisposable, _super);
        function GroupDisposable(disposable) {
            _super.call(this, "GroupDisposable");
            this._group = wdCb.Collection.create();
            this._isDisposed = false;
            if (disposable) {
                this._group.addChild(disposable);
            }
        }
        GroupDisposable.create = function (disposable) {
            var obj = new this(disposable);
            return obj;
        };
        GroupDisposable.prototype.add = function (disposable) {
            this._group.addChild(disposable);
            return this;
        };
        GroupDisposable.prototype.remove = function (disposable) {
            this._group.removeChild(disposable);
            return this;
        };
        GroupDisposable.prototype.dispose = function () {
            if (this._isDisposed) {
                return;
            }
            this._isDisposed = true;
            this._group.forEach(function (disposable) {
                disposable.dispose();
            });
        };
        return GroupDisposable;
    }(wdFrp.Entity));
    wdFrp.GroupDisposable = GroupDisposable;
})(wdFrp || (wdFrp = {}));


var wdFrp;
(function (wdFrp) {
    var InnerSubscription = (function () {
        function InnerSubscription(subject, observer) {
            this._subject = null;
            this._observer = null;
            this._subject = subject;
            this._observer = observer;
        }
        InnerSubscription.create = function (subject, observer) {
            var obj = new this(subject, observer);
            return obj;
        };
        InnerSubscription.prototype.dispose = function () {
            this._subject.remove(this._observer);
            this._observer.dispose();
        };
        return InnerSubscription;
    }());
    wdFrp.InnerSubscription = InnerSubscription;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var InnerSubscriptionGroup = (function () {
        function InnerSubscriptionGroup() {
            this._container = wdCb.Collection.create();
        }
        InnerSubscriptionGroup.create = function () {
            var obj = new this();
            return obj;
        };
        InnerSubscriptionGroup.prototype.addChild = function (child) {
            this._container.addChild(child);
        };
        InnerSubscriptionGroup.prototype.dispose = function () {
            this._container.forEach(function (child) {
                child.dispose();
            });
        };
        return InnerSubscriptionGroup;
    }());
    wdFrp.InnerSubscriptionGroup = InnerSubscriptionGroup;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    if (wdFrp.JudgeUtils.isNodeJs() && typeof global != "undefined") {
        wdFrp.root = global;
    }
    else {
        wdFrp.root = window;
    }
})(wdFrp || (wdFrp = {}));


var wdFrp;
(function (wdFrp) {
    if (wdFrp.root.RSVP) {
        wdFrp.root.RSVP.onerror = function (e) {
            throw e;
        };
        wdFrp.root.RSVP.on('error', wdFrp.root.RSVP.onerror);
    }
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    wdFrp.root.requestNextAnimationFrame = (function () {
        var originalRequestAnimationFrame = undefined, wrapper = undefined, callback = undefined, geckoVersion = null, userAgent = wdFrp.root.navigator && wdFrp.root.navigator.userAgent, index = 0, self = this;
        wrapper = function (time) {
            time = wdFrp.root.performance.now();
            self.callback(time);
        };
        if (wdFrp.root.requestAnimationFrame) {
            return requestAnimationFrame;
        }
        if (wdFrp.root.webkitRequestAnimationFrame) {
            originalRequestAnimationFrame = wdFrp.root.webkitRequestAnimationFrame;
            wdFrp.root.webkitRequestAnimationFrame = function (callback, element) {
                self.callback = callback;
                return originalRequestAnimationFrame(wrapper, element);
            };
        }
        if (wdFrp.root.msRequestAnimationFrame) {
            originalRequestAnimationFrame = wdFrp.root.msRequestAnimationFrame;
            wdFrp.root.msRequestAnimationFrame = function (callback) {
                self.callback = callback;
                return originalRequestAnimationFrame(wrapper);
            };
        }
        if (wdFrp.root.mozRequestAnimationFrame) {
            index = userAgent.indexOf('rv:');
            if (userAgent.indexOf('Gecko') != -1) {
                geckoVersion = userAgent.substr(index + 3, 3);
                if (geckoVersion === '2.0') {
                    wdFrp.root.mozRequestAnimationFrame = undefined;
                }
            }
        }
        return wdFrp.root.webkitRequestAnimationFrame ||
            wdFrp.root.mozRequestAnimationFrame ||
            wdFrp.root.oRequestAnimationFrame ||
            wdFrp.root.msRequestAnimationFrame ||
            function (callback, element) {
                var start, finish;
                wdFrp.root.setTimeout(function () {
                    start = wdFrp.root.performance.now();
                    callback(start);
                    finish = wdFrp.root.performance.now();
                    self.timeout = 1000 / 60 - (finish - start);
                }, self.timeout);
            };
    }());
    wdFrp.root.cancelNextRequestAnimationFrame = wdFrp.root.cancelRequestAnimationFrame
        || wdFrp.root.webkitCancelAnimationFrame
        || wdFrp.root.webkitCancelRequestAnimationFrame
        || wdFrp.root.mozCancelRequestAnimationFrame
        || wdFrp.root.oCancelRequestAnimationFrame
        || wdFrp.root.msCancelRequestAnimationFrame
        || clearTimeout;
})(wdFrp || (wdFrp = {}));
;

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var wdFrp;
(function (wdFrp) {
    var Log = wdCb.Log;
    var Stream = (function (_super) {
        __extends(Stream, _super);
        function Stream(subscribeFunc) {
            _super.call(this, "Stream");
            this.scheduler = null;
            this.subscribeFunc = null;
            this.subscribeFunc = subscribeFunc || function () { };
        }
        Stream.prototype.buildStream = function (observer) {
            return wdFrp.SingleDisposable.create((this.subscribeFunc(observer) || function () { }));
        };
        Stream.prototype.do = function (onNext, onError, onCompleted) {
            return wdFrp.DoStream.create(this, onNext, onError, onCompleted);
        };
        Stream.prototype.map = function (selector) {
            return wdFrp.MapStream.create(this, selector);
        };
        Stream.prototype.flatMap = function (selector) {
            return this.map(selector).mergeAll();
        };
        Stream.prototype.concatMap = function (selector) {
            return this.map(selector).concatAll();
        };
        Stream.prototype.mergeAll = function () {
            return wdFrp.MergeAllStream.create(this);
        };
        Stream.prototype.concatAll = function () {
            return this.merge(1);
        };
        Stream.prototype.skipUntil = function (otherStream) {
            return wdFrp.SkipUntilStream.create(this, otherStream);
        };
        Stream.prototype.takeUntil = function (otherStream) {
            return wdFrp.TakeUntilStream.create(this, otherStream);
        };
        Stream.prototype.take = function (count) {
            if (count === void 0) { count = 1; }
            var self = this;
            if (count === 0) {
                return wdFrp.empty();
            }
            return wdFrp.createStream(function (observer) {
                self.subscribe(function (value) {
                    if (count > 0) {
                        observer.next(value);
                    }
                    count--;
                    if (count <= 0) {
                        observer.completed();
                    }
                }, function (e) {
                    observer.error(e);
                }, function () {
                    observer.completed();
                });
            });
        };
        Stream.prototype.takeLast = function (count) {
            if (count === void 0) { count = 1; }
            var self = this;
            if (count === 0) {
                return wdFrp.empty();
            }
            return wdFrp.createStream(function (observer) {
                var queue = [];
                self.subscribe(function (value) {
                    queue.push(value);
                    if (queue.length > count) {
                        queue.shift();
                    }
                }, function (e) {
                    observer.error(e);
                }, function () {
                    while (queue.length > 0) {
                        observer.next(queue.shift());
                    }
                    observer.completed();
                });
            });
        };
        Stream.prototype.takeWhile = function (predicate, thisArg) {
            if (thisArg === void 0) { thisArg = this; }
            var self = this, bindPredicate = null;
            bindPredicate = wdCb.FunctionUtils.bind(thisArg, predicate);
            return wdFrp.createStream(function (observer) {
                var i = 0, isStart = false;
                self.subscribe(function (value) {
                    if (bindPredicate(value, i++, self)) {
                        try {
                            observer.next(value);
                            isStart = true;
                        }
                        catch (e) {
                            observer.error(e);
                            return;
                        }
                    }
                    else {
                        if (isStart) {
                            observer.completed();
                        }
                    }
                }, function (e) {
                    observer.error(e);
                }, function () {
                    observer.completed();
                });
            });
        };
        Stream.prototype.lastOrDefault = function (defaultValue) {
            if (defaultValue === void 0) { defaultValue = null; }
            var self = this;
            return wdFrp.createStream(function (observer) {
                var queue = [];
                self.subscribe(function (value) {
                    queue.push(value);
                    if (queue.length > 1) {
                        queue.shift();
                    }
                }, function (e) {
                    observer.error(e);
                }, function () {
                    if (queue.length === 0) {
                        observer.next(defaultValue);
                    }
                    else {
                        while (queue.length > 0) {
                            observer.next(queue.shift());
                        }
                    }
                    observer.completed();
                });
            });
        };
        Stream.prototype.filter = function (predicate, thisArg) {
            if (thisArg === void 0) { thisArg = this; }
            if (this instanceof wdFrp.FilterStream) {
                var self_1 = this;
                return self_1.internalFilter(predicate, thisArg);
            }
            return wdFrp.FilterStream.create(this, predicate, thisArg);
        };
        Stream.prototype.filterWithState = function (predicate, thisArg) {
            if (thisArg === void 0) { thisArg = this; }
            if (this instanceof wdFrp.FilterStream) {
                var self_2 = this;
                return self_2.internalFilter(predicate, thisArg);
            }
            return wdFrp.FilterWithStateStream.create(this, predicate, thisArg);
        };
        Stream.prototype.concat = function () {
            var args = null;
            if (wdFrp.JudgeUtils.isArray(arguments[0])) {
                args = arguments[0];
            }
            else {
                args = Array.prototype.slice.call(arguments, 0);
            }
            args.unshift(this);
            return wdFrp.ConcatStream.create(args);
        };
        Stream.prototype.merge = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (wdFrp.JudgeUtils.isNumber(args[0])) {
                var maxConcurrent = args[0];
                return wdFrp.MergeStream.create(this, maxConcurrent);
            }
            if (wdFrp.JudgeUtils.isArray(args[0])) {
                args = arguments[0];
            }
            else {
            }
            var stream = null;
            args.unshift(this);
            stream = wdFrp.fromArray(args).mergeAll();
            return stream;
        };
        Stream.prototype.repeat = function (count) {
            if (count === void 0) { count = -1; }
            return wdFrp.RepeatStream.create(this, count);
        };
        Stream.prototype.ignoreElements = function () {
            return wdFrp.IgnoreElementsStream.create(this);
        };
        Stream.prototype.handleSubject = function (subject) {
            if (this._isSubject(subject)) {
                this._setSubject(subject);
                return true;
            }
            return false;
        };
        Stream.prototype._isSubject = function (subject) {
            return subject instanceof wdFrp.Subject;
        };
        Stream.prototype._setSubject = function (subject) {
            subject.source = this;
        };
        __decorate([
            wdFrp.require(function (count) {
                if (count === void 0) { count = 1; }
                wdFrp.assert(count >= 0, Log.info.FUNC_SHOULD("count", ">= 0"));
            })
        ], Stream.prototype, "take", null);
        __decorate([
            wdFrp.require(function (count) {
                if (count === void 0) { count = 1; }
                wdFrp.assert(count >= 0, Log.info.FUNC_SHOULD("count", ">= 0"));
            })
        ], Stream.prototype, "takeLast", null);
        return Stream;
    }(wdFrp.Entity));
    wdFrp.Stream = Stream;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var Scheduler = (function () {
        function Scheduler() {
            this._requestLoopId = null;
        }
        Scheduler.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var obj = new this();
            return obj;
        };
        Object.defineProperty(Scheduler.prototype, "requestLoopId", {
            get: function () {
                return this._requestLoopId;
            },
            set: function (requestLoopId) {
                this._requestLoopId = requestLoopId;
            },
            enumerable: true,
            configurable: true
        });
        Scheduler.prototype.publishRecursive = function (observer, initial, action) {
            action(initial);
        };
        Scheduler.prototype.publishInterval = function (observer, initial, interval, action) {
            return wdFrp.root.setInterval(function () {
                initial = action(initial);
            }, interval);
        };
        Scheduler.prototype.publishIntervalRequest = function (observer, action) {
            var self = this, loop = function (time) {
                var isEnd = action(time);
                if (isEnd) {
                    return;
                }
                self._requestLoopId = wdFrp.root.requestNextAnimationFrame(loop);
            };
            this._requestLoopId = wdFrp.root.requestNextAnimationFrame(loop);
        };
        Scheduler.prototype.publishTimeout = function (observer, time, action) {
            return wdFrp.root.setTimeout(function () {
                action(time);
                observer.completed();
            }, time);
        };
        return Scheduler;
    }());
    wdFrp.Scheduler = Scheduler;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var Observer = (function (_super) {
        __extends(Observer, _super);
        function Observer() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            _super.call(this, "Observer");
            this._isDisposed = null;
            this.onUserNext = null;
            this.onUserError = null;
            this.onUserCompleted = null;
            this._isStop = false;
            this._disposable = null;
            if (args.length === 1) {
                var observer_1 = args[0];
                this.onUserNext = function (v) {
                    observer_1.next(v);
                };
                this.onUserError = function (e) {
                    observer_1.error(e);
                };
                this.onUserCompleted = function () {
                    observer_1.completed();
                };
            }
            else {
                var onNext = args[0], onError = args[1], onCompleted = args[2];
                this.onUserNext = onNext || function (v) { };
                this.onUserError = onError || function (e) {
                    throw e;
                };
                this.onUserCompleted = onCompleted || function () { };
            }
        }
        Object.defineProperty(Observer.prototype, "isDisposed", {
            get: function () {
                return this._isDisposed;
            },
            set: function (isDisposed) {
                this._isDisposed = isDisposed;
            },
            enumerable: true,
            configurable: true
        });
        Observer.prototype.next = function (value) {
            if (!this._isStop) {
                return this.onNext(value);
            }
        };
        Observer.prototype.error = function (error) {
            if (!this._isStop) {
                this._isStop = true;
                this.onError(error);
            }
        };
        Observer.prototype.completed = function () {
            if (!this._isStop) {
                this._isStop = true;
                this.onCompleted();
            }
        };
        Observer.prototype.dispose = function () {
            this._isStop = true;
            this._isDisposed = true;
            if (this._disposable) {
                this._disposable.dispose();
            }
        };
        Observer.prototype.setDisposable = function (disposable) {
            this._disposable = disposable;
        };
        return Observer;
    }(wdFrp.Entity));
    wdFrp.Observer = Observer;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var Subject = (function () {
        function Subject() {
            this._source = null;
            this._observer = new wdFrp.SubjectObserver();
        }
        Subject.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(Subject.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (source) {
                this._source = source;
            },
            enumerable: true,
            configurable: true
        });
        Subject.prototype.subscribe = function (arg1, onError, onCompleted) {
            var observer = arg1 instanceof wdFrp.Observer
                ? arg1
                : wdFrp.AutoDetachObserver.create(arg1, onError, onCompleted);
            this._observer.addChild(observer);
            return wdFrp.InnerSubscription.create(this, observer);
        };
        Subject.prototype.next = function (value) {
            this._observer.next(value);
        };
        Subject.prototype.error = function (error) {
            this._observer.error(error);
        };
        Subject.prototype.completed = function () {
            this._observer.completed();
        };
        Subject.prototype.start = function () {
            if (!this._source) {
                return;
            }
            this._observer.setDisposable(this._source.buildStream(this));
        };
        Subject.prototype.remove = function (observer) {
            this._observer.removeChild(observer);
        };
        Subject.prototype.dispose = function () {
            this._observer.dispose();
        };
        return Subject;
    }());
    wdFrp.Subject = Subject;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var GeneratorSubject = (function (_super) {
        __extends(GeneratorSubject, _super);
        function GeneratorSubject() {
            _super.call(this, "GeneratorSubject");
            this._isStart = false;
            this.observer = new wdFrp.SubjectObserver();
        }
        GeneratorSubject.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(GeneratorSubject.prototype, "isStart", {
            get: function () {
                return this._isStart;
            },
            set: function (isStart) {
                this._isStart = isStart;
            },
            enumerable: true,
            configurable: true
        });
        GeneratorSubject.prototype.onBeforeNext = function (value) {
        };
        GeneratorSubject.prototype.onAfterNext = function (value) {
        };
        GeneratorSubject.prototype.onIsCompleted = function (value) {
            return false;
        };
        GeneratorSubject.prototype.onBeforeError = function (error) {
        };
        GeneratorSubject.prototype.onAfterError = function (error) {
        };
        GeneratorSubject.prototype.onBeforeCompleted = function () {
        };
        GeneratorSubject.prototype.onAfterCompleted = function () {
        };
        GeneratorSubject.prototype.subscribe = function (arg1, onError, onCompleted) {
            var observer = arg1 instanceof wdFrp.Observer
                ? arg1
                : wdFrp.AutoDetachObserver.create(arg1, onError, onCompleted);
            this.observer.addChild(observer);
            return wdFrp.InnerSubscription.create(this, observer);
        };
        GeneratorSubject.prototype.next = function (value) {
            if (!this._isStart || this.observer.isEmpty()) {
                return;
            }
            try {
                this.onBeforeNext(value);
                this.observer.next(value);
                this.onAfterNext(value);
                if (this.onIsCompleted(value)) {
                    this.completed();
                }
            }
            catch (e) {
                this.error(e);
            }
        };
        GeneratorSubject.prototype.error = function (error) {
            if (!this._isStart || this.observer.isEmpty()) {
                return;
            }
            this.onBeforeError(error);
            this.observer.error(error);
            this.onAfterError(error);
        };
        GeneratorSubject.prototype.completed = function () {
            if (!this._isStart || this.observer.isEmpty()) {
                return;
            }
            this.onBeforeCompleted();
            this.observer.completed();
            this.onAfterCompleted();
        };
        GeneratorSubject.prototype.toStream = function () {
            var self = this, stream = null;
            stream = wdFrp.AnonymousStream.create(function (observer) {
                self.subscribe(observer);
            });
            return stream;
        };
        GeneratorSubject.prototype.start = function () {
            var self = this;
            this._isStart = true;
            this.observer.setDisposable(wdFrp.SingleDisposable.create(function () {
                self.dispose();
            }));
        };
        GeneratorSubject.prototype.stop = function () {
            this._isStart = false;
        };
        GeneratorSubject.prototype.remove = function (observer) {
            this.observer.removeChild(observer);
        };
        GeneratorSubject.prototype.dispose = function () {
            this.observer.dispose();
        };
        return GeneratorSubject;
    }(wdFrp.Entity));
    wdFrp.GeneratorSubject = GeneratorSubject;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var AnonymousObserver = (function (_super) {
        __extends(AnonymousObserver, _super);
        function AnonymousObserver() {
            _super.apply(this, arguments);
        }
        AnonymousObserver.create = function (onNext, onError, onCompleted) {
            return new this(onNext, onError, onCompleted);
        };
        AnonymousObserver.prototype.onNext = function (value) {
            this.onUserNext(value);
        };
        AnonymousObserver.prototype.onError = function (error) {
            this.onUserError(error);
        };
        AnonymousObserver.prototype.onCompleted = function () {
            this.onUserCompleted();
        };
        return AnonymousObserver;
    }(wdFrp.Observer));
    wdFrp.AnonymousObserver = AnonymousObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var wdFrp;
(function (wdFrp) {
    var AutoDetachObserver = (function (_super) {
        __extends(AutoDetachObserver, _super);
        function AutoDetachObserver() {
            _super.apply(this, arguments);
        }
        AutoDetachObserver.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1) {
                return new this(args[0]);
            }
            else {
                return new this(args[0], args[1], args[2]);
            }
        };
        AutoDetachObserver.prototype.dispose = function () {
            if (this.isDisposed) {
                return;
            }
            _super.prototype.dispose.call(this);
        };
        AutoDetachObserver.prototype.onNext = function (value) {
            try {
                this.onUserNext(value);
            }
            catch (e) {
                this.onError(e);
            }
        };
        AutoDetachObserver.prototype.onError = function (error) {
            try {
                this.onUserError(error);
            }
            catch (e) {
                throw e;
            }
            finally {
                this.dispose();
            }
        };
        AutoDetachObserver.prototype.onCompleted = function () {
            try {
                this.onUserCompleted();
                this.dispose();
            }
            catch (e) {
                throw e;
            }
        };
        __decorate([
            wdFrp.require(function () {
                if (this.isDisposed) {
                    wdCb.Log.warn("only can dispose once");
                }
            })
        ], AutoDetachObserver.prototype, "dispose", null);
        return AutoDetachObserver;
    }(wdFrp.Observer));
    wdFrp.AutoDetachObserver = AutoDetachObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var MapObserver = (function (_super) {
        __extends(MapObserver, _super);
        function MapObserver(currentObserver, selector) {
            _super.call(this, null, null, null);
            this._currentObserver = null;
            this._selector = null;
            this._currentObserver = currentObserver;
            this._selector = selector;
        }
        MapObserver.create = function (currentObserver, selector) {
            return new this(currentObserver, selector);
        };
        MapObserver.prototype.onNext = function (value) {
            var result = null;
            try {
                result = this._selector(value);
            }
            catch (e) {
                this._currentObserver.error(e);
            }
            finally {
                this._currentObserver.next(result);
            }
        };
        MapObserver.prototype.onError = function (error) {
            this._currentObserver.error(error);
        };
        MapObserver.prototype.onCompleted = function () {
            this._currentObserver.completed();
        };
        return MapObserver;
    }(wdFrp.Observer));
    wdFrp.MapObserver = MapObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var DoObserver = (function (_super) {
        __extends(DoObserver, _super);
        function DoObserver(currentObserver, prevObserver) {
            _super.call(this, null, null, null);
            this._currentObserver = null;
            this._prevObserver = null;
            this._currentObserver = currentObserver;
            this._prevObserver = prevObserver;
        }
        DoObserver.create = function (currentObserver, prevObserver) {
            return new this(currentObserver, prevObserver);
        };
        DoObserver.prototype.onNext = function (value) {
            try {
                this._prevObserver.next(value);
            }
            catch (e) {
                this._prevObserver.error(e);
                this._currentObserver.error(e);
            }
            finally {
                this._currentObserver.next(value);
            }
        };
        DoObserver.prototype.onError = function (error) {
            try {
                this._prevObserver.error(error);
            }
            catch (e) {
            }
            finally {
                this._currentObserver.error(error);
            }
        };
        DoObserver.prototype.onCompleted = function () {
            try {
                this._prevObserver.completed();
            }
            catch (e) {
                this._prevObserver.error(e);
                this._currentObserver.error(e);
            }
            finally {
                this._currentObserver.completed();
            }
        };
        return DoObserver;
    }(wdFrp.Observer));
    wdFrp.DoObserver = DoObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var wdFrp;
(function (wdFrp) {
    var Log = wdCb.Log;
    var MergeAllObserver = (function (_super) {
        __extends(MergeAllObserver, _super);
        function MergeAllObserver(currentObserver, streamGroup, groupDisposable) {
            _super.call(this, null, null, null);
            this.done = false;
            this.currentObserver = null;
            this._streamGroup = null;
            this._groupDisposable = null;
            this.currentObserver = currentObserver;
            this._streamGroup = streamGroup;
            this._groupDisposable = groupDisposable;
        }
        MergeAllObserver.create = function (currentObserver, streamGroup, groupDisposable) {
            return new this(currentObserver, streamGroup, groupDisposable);
        };
        MergeAllObserver.prototype.onNext = function (innerSource) {
            if (wdFrp.JudgeUtils.isPromise(innerSource)) {
                innerSource = wdFrp.fromPromise(innerSource);
            }
            this._streamGroup.addChild(innerSource);
            this._groupDisposable.add(innerSource.buildStream(InnerObserver.create(this, this._streamGroup, innerSource)));
        };
        MergeAllObserver.prototype.onError = function (error) {
            this.currentObserver.error(error);
        };
        MergeAllObserver.prototype.onCompleted = function () {
            this.done = true;
            if (this._streamGroup.getCount() === 0) {
                this.currentObserver.completed();
            }
        };
        __decorate([
            wdFrp.require(function (innerSource) {
                wdFrp.assert(innerSource instanceof wdFrp.Stream || wdFrp.JudgeUtils.isPromise(innerSource), Log.info.FUNC_MUST_BE("innerSource", "Stream or Promise"));
            })
        ], MergeAllObserver.prototype, "onNext", null);
        return MergeAllObserver;
    }(wdFrp.Observer));
    wdFrp.MergeAllObserver = MergeAllObserver;
    var InnerObserver = (function (_super) {
        __extends(InnerObserver, _super);
        function InnerObserver(parent, streamGroup, currentStream) {
            _super.call(this, null, null, null);
            this._parent = null;
            this._streamGroup = null;
            this._currentStream = null;
            this._parent = parent;
            this._streamGroup = streamGroup;
            this._currentStream = currentStream;
        }
        InnerObserver.create = function (parent, streamGroup, currentStream) {
            var obj = new this(parent, streamGroup, currentStream);
            return obj;
        };
        InnerObserver.prototype.onNext = function (value) {
            this._parent.currentObserver.next(value);
        };
        InnerObserver.prototype.onError = function (error) {
            this._parent.currentObserver.error(error);
        };
        InnerObserver.prototype.onCompleted = function () {
            var currentStream = this._currentStream, parent = this._parent;
            this._streamGroup.removeChild(function (stream) {
                return wdFrp.JudgeUtils.isEqual(stream, currentStream);
            });
            if (this._isAsync() && this._streamGroup.getCount() === 0) {
                parent.currentObserver.completed();
            }
        };
        InnerObserver.prototype._isAsync = function () {
            return this._parent.done;
        };
        return InnerObserver;
    }(wdFrp.Observer));
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var wdFrp;
(function (wdFrp) {
    var Log = wdCb.Log;
    var MergeObserver = (function (_super) {
        __extends(MergeObserver, _super);
        function MergeObserver(currentObserver, maxConcurrent, streamGroup, groupDisposable) {
            _super.call(this, null, null, null);
            this.done = false;
            this.currentObserver = null;
            this.activeCount = 0;
            this.q = [];
            this._maxConcurrent = null;
            this._groupDisposable = null;
            this._streamGroup = null;
            this.currentObserver = currentObserver;
            this._maxConcurrent = maxConcurrent;
            this._streamGroup = streamGroup;
            this._groupDisposable = groupDisposable;
        }
        MergeObserver.create = function (currentObserver, maxConcurrent, streamGroup, groupDisposable) {
            return new this(currentObserver, maxConcurrent, streamGroup, groupDisposable);
        };
        MergeObserver.prototype.handleSubscribe = function (innerSource) {
            if (wdFrp.JudgeUtils.isPromise(innerSource)) {
                innerSource = wdFrp.fromPromise(innerSource);
            }
            this._streamGroup.addChild(innerSource);
            this._groupDisposable.add(innerSource.buildStream(InnerObserver.create(this, this._streamGroup, innerSource)));
        };
        MergeObserver.prototype.onNext = function (innerSource) {
            if (this._isReachMaxConcurrent()) {
                this.activeCount++;
                this.handleSubscribe(innerSource);
                return;
            }
            this.q.push(innerSource);
        };
        MergeObserver.prototype.onError = function (error) {
            this.currentObserver.error(error);
        };
        MergeObserver.prototype.onCompleted = function () {
            this.done = true;
            if (this._streamGroup.getCount() === 0) {
                this.currentObserver.completed();
            }
        };
        MergeObserver.prototype._isReachMaxConcurrent = function () {
            return this.activeCount < this._maxConcurrent;
        };
        __decorate([
            wdFrp.require(function (innerSource) {
                wdFrp.assert(innerSource instanceof wdFrp.Stream || wdFrp.JudgeUtils.isPromise(innerSource), Log.info.FUNC_MUST_BE("innerSource", "Stream or Promise"));
            })
        ], MergeObserver.prototype, "onNext", null);
        return MergeObserver;
    }(wdFrp.Observer));
    wdFrp.MergeObserver = MergeObserver;
    var InnerObserver = (function (_super) {
        __extends(InnerObserver, _super);
        function InnerObserver(parent, streamGroup, currentStream) {
            _super.call(this, null, null, null);
            this._parent = null;
            this._streamGroup = null;
            this._currentStream = null;
            this._parent = parent;
            this._streamGroup = streamGroup;
            this._currentStream = currentStream;
        }
        InnerObserver.create = function (parent, streamGroup, currentStream) {
            var obj = new this(parent, streamGroup, currentStream);
            return obj;
        };
        InnerObserver.prototype.onNext = function (value) {
            this._parent.currentObserver.next(value);
        };
        InnerObserver.prototype.onError = function (error) {
            this._parent.currentObserver.error(error);
        };
        InnerObserver.prototype.onCompleted = function () {
            var parent = this._parent;
            this._streamGroup.removeChild(this._currentStream);
            if (parent.q.length > 0) {
                parent.activeCount = 0;
                parent.handleSubscribe(parent.q.shift());
            }
            else {
                if (this._isAsync() && this._streamGroup.getCount() === 0) {
                    parent.currentObserver.completed();
                }
            }
        };
        InnerObserver.prototype._isAsync = function () {
            return this._parent.done;
        };
        return InnerObserver;
    }(wdFrp.Observer));
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var TakeUntilObserver = (function (_super) {
        __extends(TakeUntilObserver, _super);
        function TakeUntilObserver(prevObserver) {
            _super.call(this, null, null, null);
            this._prevObserver = null;
            this._prevObserver = prevObserver;
        }
        TakeUntilObserver.create = function (prevObserver) {
            return new this(prevObserver);
        };
        TakeUntilObserver.prototype.onNext = function (value) {
            this._prevObserver.completed();
        };
        TakeUntilObserver.prototype.onError = function (error) {
            this._prevObserver.error(error);
        };
        TakeUntilObserver.prototype.onCompleted = function () {
        };
        return TakeUntilObserver;
    }(wdFrp.Observer));
    wdFrp.TakeUntilObserver = TakeUntilObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var SkipUntilSourceObserver = (function (_super) {
        __extends(SkipUntilSourceObserver, _super);
        function SkipUntilSourceObserver(prevObserver, skipUntilStream) {
            _super.call(this, null, null, null);
            this._prevObserver = null;
            this._skipUntilStream = null;
            this._prevObserver = prevObserver;
            this._skipUntilStream = skipUntilStream;
        }
        SkipUntilSourceObserver.create = function (prevObserver, skipUntilStream) {
            return new this(prevObserver, skipUntilStream);
        };
        SkipUntilSourceObserver.prototype.onNext = function (value) {
            if (this._skipUntilStream.isOpen) {
                this._prevObserver.next(value);
            }
        };
        SkipUntilSourceObserver.prototype.onError = function (error) {
            this._prevObserver.error(error);
        };
        SkipUntilSourceObserver.prototype.onCompleted = function () {
            if (this._skipUntilStream.isOpen) {
                this._prevObserver.completed();
            }
        };
        return SkipUntilSourceObserver;
    }(wdFrp.Observer));
    wdFrp.SkipUntilSourceObserver = SkipUntilSourceObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var SkipUntilOtherObserver = (function (_super) {
        __extends(SkipUntilOtherObserver, _super);
        function SkipUntilOtherObserver(prevObserver, skipUntilStream) {
            _super.call(this, null, null, null);
            this.otherDisposable = null;
            this._prevObserver = null;
            this._skipUntilStream = null;
            this._prevObserver = prevObserver;
            this._skipUntilStream = skipUntilStream;
        }
        SkipUntilOtherObserver.create = function (prevObserver, skipUntilStream) {
            return new this(prevObserver, skipUntilStream);
        };
        SkipUntilOtherObserver.prototype.onNext = function (value) {
            this._skipUntilStream.isOpen = true;
            this.otherDisposable.dispose();
        };
        SkipUntilOtherObserver.prototype.onError = function (error) {
            this._prevObserver.error(error);
        };
        SkipUntilOtherObserver.prototype.onCompleted = function () {
            this.otherDisposable.dispose();
        };
        return SkipUntilOtherObserver;
    }(wdFrp.Observer));
    wdFrp.SkipUntilOtherObserver = SkipUntilOtherObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var ConcatObserver = (function (_super) {
        __extends(ConcatObserver, _super);
        function ConcatObserver(currentObserver, startNextStream) {
            _super.call(this, null, null, null);
            this.currentObserver = null;
            this._startNextStream = null;
            this.currentObserver = currentObserver;
            this._startNextStream = startNextStream;
        }
        ConcatObserver.create = function (currentObserver, startNextStream) {
            return new this(currentObserver, startNextStream);
        };
        ConcatObserver.prototype.onNext = function (value) {
            this.currentObserver.next(value);
        };
        ConcatObserver.prototype.onError = function (error) {
            this.currentObserver.error(error);
        };
        ConcatObserver.prototype.onCompleted = function () {
            this._startNextStream();
        };
        return ConcatObserver;
    }(wdFrp.Observer));
    wdFrp.ConcatObserver = ConcatObserver;
})(wdFrp || (wdFrp = {}));


var wdFrp;
(function (wdFrp) {
    var SubjectObserver = (function () {
        function SubjectObserver() {
            this.observers = wdCb.Collection.create();
            this._disposable = null;
        }
        SubjectObserver.prototype.isEmpty = function () {
            return this.observers.getCount() === 0;
        };
        SubjectObserver.prototype.next = function (value) {
            this.observers.forEach(function (ob) {
                ob.next(value);
            });
        };
        SubjectObserver.prototype.error = function (error) {
            this.observers.forEach(function (ob) {
                ob.error(error);
            });
        };
        SubjectObserver.prototype.completed = function () {
            this.observers.forEach(function (ob) {
                ob.completed();
            });
        };
        SubjectObserver.prototype.addChild = function (observer) {
            this.observers.addChild(observer);
            observer.setDisposable(this._disposable);
        };
        SubjectObserver.prototype.removeChild = function (observer) {
            this.observers.removeChild(function (ob) {
                return wdFrp.JudgeUtils.isEqual(ob, observer);
            });
        };
        SubjectObserver.prototype.dispose = function () {
            this.observers.forEach(function (ob) {
                ob.dispose();
            });
            this.observers.removeAllChildren();
        };
        SubjectObserver.prototype.setDisposable = function (disposable) {
            this.observers.forEach(function (observer) {
                observer.setDisposable(disposable);
            });
            this._disposable = disposable;
        };
        return SubjectObserver;
    }());
    wdFrp.SubjectObserver = SubjectObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var IgnoreElementsObserver = (function (_super) {
        __extends(IgnoreElementsObserver, _super);
        function IgnoreElementsObserver(currentObserver) {
            _super.call(this, null, null, null);
            this._currentObserver = null;
            this._currentObserver = currentObserver;
        }
        IgnoreElementsObserver.create = function (currentObserver) {
            return new this(currentObserver);
        };
        IgnoreElementsObserver.prototype.onNext = function (value) {
        };
        IgnoreElementsObserver.prototype.onError = function (error) {
            this._currentObserver.error(error);
        };
        IgnoreElementsObserver.prototype.onCompleted = function () {
            this._currentObserver.completed();
        };
        return IgnoreElementsObserver;
    }(wdFrp.Observer));
    wdFrp.IgnoreElementsObserver = IgnoreElementsObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var FilterObserver = (function (_super) {
        __extends(FilterObserver, _super);
        function FilterObserver(prevObserver, predicate, source) {
            _super.call(this, null, null, null);
            this.prevObserver = null;
            this.source = null;
            this.i = 0;
            this.predicate = null;
            this.prevObserver = prevObserver;
            this.predicate = predicate;
            this.source = source;
        }
        FilterObserver.create = function (prevObserver, predicate, source) {
            return new this(prevObserver, predicate, source);
        };
        FilterObserver.prototype.onNext = function (value) {
            try {
                if (this.predicate(value, this.i++, this.source)) {
                    this.prevObserver.next(value);
                }
            }
            catch (e) {
                this.prevObserver.error(e);
            }
        };
        FilterObserver.prototype.onError = function (error) {
            this.prevObserver.error(error);
        };
        FilterObserver.prototype.onCompleted = function () {
            this.prevObserver.completed();
        };
        return FilterObserver;
    }(wdFrp.Observer));
    wdFrp.FilterObserver = FilterObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var FilterWithStateObserver = (function (_super) {
        __extends(FilterWithStateObserver, _super);
        function FilterWithStateObserver() {
            _super.apply(this, arguments);
            this._isTrigger = false;
        }
        FilterWithStateObserver.create = function (prevObserver, predicate, source) {
            return new this(prevObserver, predicate, source);
        };
        FilterWithStateObserver.prototype.onNext = function (value) {
            var data = null;
            try {
                if (this.predicate(value, this.i++, this.source)) {
                    if (!this._isTrigger) {
                        data = {
                            value: value,
                            state: wdFrp.FilterState.ENTER
                        };
                    }
                    else {
                        data = {
                            value: value,
                            state: wdFrp.FilterState.TRIGGER
                        };
                    }
                    this.prevObserver.next(data);
                    this._isTrigger = true;
                }
                else {
                    if (this._isTrigger) {
                        data = {
                            value: value,
                            state: wdFrp.FilterState.LEAVE
                        };
                        this.prevObserver.next(data);
                    }
                    this._isTrigger = false;
                }
            }
            catch (e) {
                this.prevObserver.error(e);
            }
        };
        return FilterWithStateObserver;
    }(wdFrp.FilterObserver));
    wdFrp.FilterWithStateObserver = FilterWithStateObserver;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var BaseStream = (function (_super) {
        __extends(BaseStream, _super);
        function BaseStream() {
            _super.apply(this, arguments);
        }
        BaseStream.prototype.subscribe = function (arg1, onError, onCompleted) {
            var observer = null;
            if (this.handleSubject(arg1)) {
                return;
            }
            observer = arg1 instanceof wdFrp.Observer
                ? wdFrp.AutoDetachObserver.create(arg1)
                : wdFrp.AutoDetachObserver.create(arg1, onError, onCompleted);
            observer.setDisposable(this.buildStream(observer));
            return observer;
        };
        BaseStream.prototype.buildStream = function (observer) {
            _super.prototype.buildStream.call(this, observer);
            return this.subscribeCore(observer);
        };
        return BaseStream;
    }(wdFrp.Stream));
    wdFrp.BaseStream = BaseStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var DoStream = (function (_super) {
        __extends(DoStream, _super);
        function DoStream(source, onNext, onError, onCompleted) {
            _super.call(this, null);
            this._source = null;
            this._observer = null;
            this._source = source;
            this._observer = wdFrp.AnonymousObserver.create(onNext, onError, onCompleted);
            this.scheduler = this._source.scheduler;
        }
        DoStream.create = function (source, onNext, onError, onCompleted) {
            var obj = new this(source, onNext, onError, onCompleted);
            return obj;
        };
        DoStream.prototype.subscribeCore = function (observer) {
            return this._source.buildStream(wdFrp.DoObserver.create(observer, this._observer));
        };
        return DoStream;
    }(wdFrp.BaseStream));
    wdFrp.DoStream = DoStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var MapStream = (function (_super) {
        __extends(MapStream, _super);
        function MapStream(source, selector) {
            _super.call(this, null);
            this._source = null;
            this._selector = null;
            this._source = source;
            this.scheduler = this._source.scheduler;
            this._selector = selector;
        }
        MapStream.create = function (source, selector) {
            var obj = new this(source, selector);
            return obj;
        };
        MapStream.prototype.subscribeCore = function (observer) {
            return this._source.buildStream(wdFrp.MapObserver.create(observer, this._selector));
        };
        return MapStream;
    }(wdFrp.BaseStream));
    wdFrp.MapStream = MapStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var FromArrayStream = (function (_super) {
        __extends(FromArrayStream, _super);
        function FromArrayStream(array, scheduler) {
            _super.call(this, null);
            this._array = null;
            this._array = array;
            this.scheduler = scheduler;
        }
        FromArrayStream.create = function (array, scheduler) {
            var obj = new this(array, scheduler);
            return obj;
        };
        FromArrayStream.prototype.subscribeCore = function (observer) {
            var array = this._array, len = array.length;
            function loopRecursive(i) {
                if (i < len) {
                    observer.next(array[i]);
                    loopRecursive(i + 1);
                }
                else {
                    observer.completed();
                }
            }
            this.scheduler.publishRecursive(observer, 0, loopRecursive);
            return wdFrp.SingleDisposable.create();
        };
        return FromArrayStream;
    }(wdFrp.BaseStream));
    wdFrp.FromArrayStream = FromArrayStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var FromPromiseStream = (function (_super) {
        __extends(FromPromiseStream, _super);
        function FromPromiseStream(promise, scheduler) {
            _super.call(this, null);
            this._promise = null;
            this._promise = promise;
            this.scheduler = scheduler;
        }
        FromPromiseStream.create = function (promise, scheduler) {
            var obj = new this(promise, scheduler);
            return obj;
        };
        FromPromiseStream.prototype.subscribeCore = function (observer) {
            this._promise.then(function (data) {
                observer.next(data);
                observer.completed();
            }, function (err) {
                observer.error(err);
            }, observer);
            return wdFrp.SingleDisposable.create();
        };
        return FromPromiseStream;
    }(wdFrp.BaseStream));
    wdFrp.FromPromiseStream = FromPromiseStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var FromEventPatternStream = (function (_super) {
        __extends(FromEventPatternStream, _super);
        function FromEventPatternStream(addHandler, removeHandler) {
            _super.call(this, null);
            this._addHandler = null;
            this._removeHandler = null;
            this._addHandler = addHandler;
            this._removeHandler = removeHandler;
        }
        FromEventPatternStream.create = function (addHandler, removeHandler) {
            var obj = new this(addHandler, removeHandler);
            return obj;
        };
        FromEventPatternStream.prototype.subscribeCore = function (observer) {
            var self = this;
            function innerHandler(event) {
                observer.next(event);
            }
            this._addHandler(innerHandler);
            return wdFrp.SingleDisposable.create(function () {
                self._removeHandler(innerHandler);
            });
        };
        return FromEventPatternStream;
    }(wdFrp.BaseStream));
    wdFrp.FromEventPatternStream = FromEventPatternStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var AnonymousStream = (function (_super) {
        __extends(AnonymousStream, _super);
        function AnonymousStream(subscribeFunc) {
            _super.call(this, subscribeFunc);
            this.scheduler = wdFrp.Scheduler.create();
        }
        AnonymousStream.create = function (subscribeFunc) {
            var obj = new this(subscribeFunc);
            return obj;
        };
        AnonymousStream.prototype.subscribe = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var observer = null;
            if (args[0] instanceof wdFrp.Subject) {
                var subject = args[0];
                this.handleSubject(subject);
                return;
            }
            else if (wdFrp.JudgeUtils.isIObserver(args[0])) {
                observer = wdFrp.AutoDetachObserver.create(args[0]);
            }
            else {
                var onNext = args[0], onError = args[1] || null, onCompleted = args[2] || null;
                observer = wdFrp.AutoDetachObserver.create(onNext, onError, onCompleted);
            }
            observer.setDisposable(this.buildStream(observer));
            return observer;
        };
        return AnonymousStream;
    }(wdFrp.Stream));
    wdFrp.AnonymousStream = AnonymousStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var IntervalStream = (function (_super) {
        __extends(IntervalStream, _super);
        function IntervalStream(interval, scheduler) {
            _super.call(this, null);
            this._interval = null;
            this._interval = interval;
            this.scheduler = scheduler;
        }
        IntervalStream.create = function (interval, scheduler) {
            var obj = new this(interval, scheduler);
            obj.initWhenCreate();
            return obj;
        };
        IntervalStream.prototype.initWhenCreate = function () {
            this._interval = this._interval <= 0 ? 1 : this._interval;
        };
        IntervalStream.prototype.subscribeCore = function (observer) {
            var self = this, id = null;
            id = this.scheduler.publishInterval(observer, 0, this._interval, function (count) {
                observer.next(count);
                return count + 1;
            });
            return wdFrp.SingleDisposable.create(function () {
                wdFrp.root.clearInterval(id);
            });
        };
        return IntervalStream;
    }(wdFrp.BaseStream));
    wdFrp.IntervalStream = IntervalStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var IntervalRequestStream = (function (_super) {
        __extends(IntervalRequestStream, _super);
        function IntervalRequestStream(scheduler) {
            _super.call(this, null);
            this._isEnd = false;
            this.scheduler = scheduler;
        }
        IntervalRequestStream.create = function (scheduler) {
            var obj = new this(scheduler);
            return obj;
        };
        IntervalRequestStream.prototype.subscribeCore = function (observer) {
            var self = this;
            this.scheduler.publishIntervalRequest(observer, function (time) {
                observer.next(time);
                return self._isEnd;
            });
            return wdFrp.SingleDisposable.create(function () {
                wdFrp.root.cancelNextRequestAnimationFrame(self.scheduler.requestLoopId);
                self._isEnd = true;
            });
        };
        return IntervalRequestStream;
    }(wdFrp.BaseStream));
    wdFrp.IntervalRequestStream = IntervalRequestStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var wdFrp;
(function (wdFrp) {
    var Log = wdCb.Log;
    var TimeoutStream = (function (_super) {
        __extends(TimeoutStream, _super);
        function TimeoutStream(time, scheduler) {
            _super.call(this, null);
            this._time = null;
            this._time = time;
            this.scheduler = scheduler;
        }
        TimeoutStream.create = function (time, scheduler) {
            var obj = new this(time, scheduler);
            return obj;
        };
        TimeoutStream.prototype.subscribeCore = function (observer) {
            var id = null;
            id = this.scheduler.publishTimeout(observer, this._time, function (time) {
                observer.next(time);
            });
            return wdFrp.SingleDisposable.create(function () {
                wdFrp.root.clearTimeout(id);
            });
        };
        __decorate([
            wdFrp.require(function (time, scheduler) {
                wdFrp.assert(time > 0, Log.info.FUNC_SHOULD("time", "> 0"));
            })
        ], TimeoutStream, "create", null);
        return TimeoutStream;
    }(wdFrp.BaseStream));
    wdFrp.TimeoutStream = TimeoutStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var MergeAllStream = (function (_super) {
        __extends(MergeAllStream, _super);
        function MergeAllStream(source) {
            _super.call(this, null);
            this._source = null;
            this._observer = null;
            this._source = source;
            this.scheduler = this._source.scheduler;
        }
        MergeAllStream.create = function (source) {
            var obj = new this(source);
            return obj;
        };
        MergeAllStream.prototype.subscribeCore = function (observer) {
            var streamGroup = wdCb.Collection.create(), groupDisposable = wdFrp.GroupDisposable.create();
            this._source.buildStream(wdFrp.MergeAllObserver.create(observer, streamGroup, groupDisposable));
            return groupDisposable;
        };
        return MergeAllStream;
    }(wdFrp.BaseStream));
    wdFrp.MergeAllStream = MergeAllStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var MergeStream = (function (_super) {
        __extends(MergeStream, _super);
        function MergeStream(source, maxConcurrent) {
            _super.call(this, null);
            this._source = null;
            this._maxConcurrent = null;
            this._source = source;
            this._maxConcurrent = maxConcurrent;
            this.scheduler = this._source.scheduler;
        }
        MergeStream.create = function (source, maxConcurrent) {
            var obj = new this(source, maxConcurrent);
            return obj;
        };
        MergeStream.prototype.subscribeCore = function (observer) {
            var streamGroup = wdCb.Collection.create(), groupDisposable = wdFrp.GroupDisposable.create();
            this._source.buildStream(wdFrp.MergeObserver.create(observer, this._maxConcurrent, streamGroup, groupDisposable));
            return groupDisposable;
        };
        return MergeStream;
    }(wdFrp.BaseStream));
    wdFrp.MergeStream = MergeStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var TakeUntilStream = (function (_super) {
        __extends(TakeUntilStream, _super);
        function TakeUntilStream(source, otherStream) {
            _super.call(this, null);
            this._source = null;
            this._otherStream = null;
            this._source = source;
            this._otherStream = wdFrp.JudgeUtils.isPromise(otherStream) ? wdFrp.fromPromise(otherStream) : otherStream;
            this.scheduler = this._source.scheduler;
        }
        TakeUntilStream.create = function (source, otherSteam) {
            var obj = new this(source, otherSteam);
            return obj;
        };
        TakeUntilStream.prototype.subscribeCore = function (observer) {
            var group = wdFrp.GroupDisposable.create(), autoDetachObserver = wdFrp.AutoDetachObserver.create(observer), sourceDisposable = null;
            sourceDisposable = this._source.buildStream(observer);
            group.add(sourceDisposable);
            autoDetachObserver.setDisposable(sourceDisposable);
            group.add(this._otherStream.buildStream(wdFrp.TakeUntilObserver.create(autoDetachObserver)));
            return group;
        };
        return TakeUntilStream;
    }(wdFrp.BaseStream));
    wdFrp.TakeUntilStream = TakeUntilStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var SkipUntilStream = (function (_super) {
        __extends(SkipUntilStream, _super);
        function SkipUntilStream(source, otherStream) {
            _super.call(this, null);
            this.isOpen = false;
            this._source = null;
            this._otherStream = null;
            this._source = source;
            this._otherStream = wdFrp.JudgeUtils.isPromise(otherStream) ? wdFrp.fromPromise(otherStream) : otherStream;
            this.scheduler = this._source.scheduler;
        }
        SkipUntilStream.create = function (source, otherSteam) {
            var obj = new this(source, otherSteam);
            return obj;
        };
        SkipUntilStream.prototype.subscribeCore = function (observer) {
            var group = wdFrp.GroupDisposable.create(), otherDisposable = null, skipUntilOtherObserver = null;
            group.add(this._source.buildStream(wdFrp.SkipUntilSourceObserver.create(observer, this)));
            skipUntilOtherObserver = wdFrp.SkipUntilOtherObserver.create(observer, this);
            otherDisposable = this._otherStream.buildStream(skipUntilOtherObserver);
            skipUntilOtherObserver.otherDisposable = otherDisposable;
            group.add(otherDisposable);
            return group;
        };
        return SkipUntilStream;
    }(wdFrp.BaseStream));
    wdFrp.SkipUntilStream = SkipUntilStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var ConcatStream = (function (_super) {
        __extends(ConcatStream, _super);
        function ConcatStream(sources) {
            _super.call(this, null);
            this._sources = wdCb.Collection.create();
            var self = this;
            this.scheduler = sources[0].scheduler;
            sources.forEach(function (source) {
                if (wdFrp.JudgeUtils.isPromise(source)) {
                    self._sources.addChild(wdFrp.fromPromise(source));
                }
                else {
                    self._sources.addChild(source);
                }
            });
        }
        ConcatStream.create = function (sources) {
            var obj = new this(sources);
            return obj;
        };
        ConcatStream.prototype.subscribeCore = function (observer) {
            var self = this, count = this._sources.getCount(), d = wdFrp.GroupDisposable.create();
            function loopRecursive(i) {
                if (i === count) {
                    observer.completed();
                    return;
                }
                d.add(self._sources.getChild(i).buildStream(wdFrp.ConcatObserver.create(observer, function () {
                    loopRecursive(i + 1);
                })));
            }
            this.scheduler.publishRecursive(observer, 0, loopRecursive);
            return wdFrp.GroupDisposable.create(d);
        };
        return ConcatStream;
    }(wdFrp.BaseStream));
    wdFrp.ConcatStream = ConcatStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var RepeatStream = (function (_super) {
        __extends(RepeatStream, _super);
        function RepeatStream(source, count) {
            _super.call(this, null);
            this._source = null;
            this._count = null;
            this._source = source;
            this._count = count;
            this.scheduler = this._source.scheduler;
        }
        RepeatStream.create = function (source, count) {
            var obj = new this(source, count);
            return obj;
        };
        RepeatStream.prototype.subscribeCore = function (observer) {
            var self = this, d = wdFrp.GroupDisposable.create();
            function loopRecursive(count) {
                if (count === 0) {
                    observer.completed();
                    return;
                }
                d.add(self._source.buildStream(wdFrp.ConcatObserver.create(observer, function () {
                    loopRecursive(count - 1);
                })));
            }
            this.scheduler.publishRecursive(observer, this._count, loopRecursive);
            return wdFrp.GroupDisposable.create(d);
        };
        return RepeatStream;
    }(wdFrp.BaseStream));
    wdFrp.RepeatStream = RepeatStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var IgnoreElementsStream = (function (_super) {
        __extends(IgnoreElementsStream, _super);
        function IgnoreElementsStream(source) {
            _super.call(this, null);
            this._source = null;
            this._source = source;
            this.scheduler = this._source.scheduler;
        }
        IgnoreElementsStream.create = function (source) {
            var obj = new this(source);
            return obj;
        };
        IgnoreElementsStream.prototype.subscribeCore = function (observer) {
            return this._source.buildStream(wdFrp.IgnoreElementsObserver.create(observer));
        };
        return IgnoreElementsStream;
    }(wdFrp.BaseStream));
    wdFrp.IgnoreElementsStream = IgnoreElementsStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var DeferStream = (function (_super) {
        __extends(DeferStream, _super);
        function DeferStream(buildStreamFunc) {
            _super.call(this, null);
            this._buildStreamFunc = null;
            this._buildStreamFunc = buildStreamFunc;
        }
        DeferStream.create = function (buildStreamFunc) {
            var obj = new this(buildStreamFunc);
            return obj;
        };
        DeferStream.prototype.subscribeCore = function (observer) {
            var group = wdFrp.GroupDisposable.create();
            group.add(this._buildStreamFunc().buildStream(observer));
            return group;
        };
        return DeferStream;
    }(wdFrp.BaseStream));
    wdFrp.DeferStream = DeferStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var FilterStream = (function (_super) {
        __extends(FilterStream, _super);
        function FilterStream(source, predicate, thisArg) {
            _super.call(this, null);
            this.predicate = null;
            this._source = null;
            this._source = source;
            this.predicate = wdCb.FunctionUtils.bind(thisArg, predicate);
        }
        FilterStream.create = function (source, predicate, thisArg) {
            var obj = new this(source, predicate, thisArg);
            return obj;
        };
        FilterStream.prototype.subscribeCore = function (observer) {
            return this._source.subscribe(this.createObserver(observer));
        };
        FilterStream.prototype.internalFilter = function (predicate, thisArg) {
            return this.createStreamForInternalFilter(this._source, this._innerPredicate(predicate, this), thisArg);
        };
        FilterStream.prototype.createObserver = function (observer) {
            return wdFrp.FilterObserver.create(observer, this.predicate, this);
        };
        FilterStream.prototype.createStreamForInternalFilter = function (source, innerPredicate, thisArg) {
            return FilterStream.create(source, innerPredicate, thisArg);
        };
        FilterStream.prototype._innerPredicate = function (predicate, self) {
            var _this = this;
            return function (value, i, o) {
                return self.predicate(value, i, o) && predicate.call(_this, value, i, o);
            };
        };
        return FilterStream;
    }(wdFrp.BaseStream));
    wdFrp.FilterStream = FilterStream;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var FilterWithStateStream = (function (_super) {
        __extends(FilterWithStateStream, _super);
        function FilterWithStateStream() {
            _super.apply(this, arguments);
        }
        FilterWithStateStream.create = function (source, predicate, thisArg) {
            var obj = new this(source, predicate, thisArg);
            return obj;
        };
        FilterWithStateStream.prototype.createObserver = function (observer) {
            return wdFrp.FilterWithStateObserver.create(observer, this.predicate, this);
        };
        FilterWithStateStream.prototype.createStreamForInternalFilter = function (source, innerPredicate, thisArg) {
            return FilterWithStateStream.create(source, innerPredicate, thisArg);
        };
        return FilterWithStateStream;
    }(wdFrp.FilterStream));
    wdFrp.FilterWithStateStream = FilterWithStateStream;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    wdFrp.createStream = function (subscribeFunc) {
        return wdFrp.AnonymousStream.create(subscribeFunc);
    };
    wdFrp.fromArray = function (array, scheduler) {
        if (scheduler === void 0) { scheduler = wdFrp.Scheduler.create(); }
        return wdFrp.FromArrayStream.create(array, scheduler);
    };
    wdFrp.fromPromise = function (promise, scheduler) {
        if (scheduler === void 0) { scheduler = wdFrp.Scheduler.create(); }
        return wdFrp.FromPromiseStream.create(promise, scheduler);
    };
    wdFrp.fromEventPattern = function (addHandler, removeHandler) {
        return wdFrp.FromEventPatternStream.create(addHandler, removeHandler);
    };
    wdFrp.interval = function (interval, scheduler) {
        if (scheduler === void 0) { scheduler = wdFrp.Scheduler.create(); }
        return wdFrp.IntervalStream.create(interval, scheduler);
    };
    wdFrp.intervalRequest = function (scheduler) {
        if (scheduler === void 0) { scheduler = wdFrp.Scheduler.create(); }
        return wdFrp.IntervalRequestStream.create(scheduler);
    };
    wdFrp.timeout = function (time, scheduler) {
        if (scheduler === void 0) { scheduler = wdFrp.Scheduler.create(); }
        return wdFrp.TimeoutStream.create(time, scheduler);
    };
    wdFrp.empty = function () {
        return wdFrp.createStream(function (observer) {
            observer.completed();
        });
    };
    wdFrp.callFunc = function (func, context) {
        if (context === void 0) { context = wdFrp.root; }
        return wdFrp.createStream(function (observer) {
            try {
                observer.next(func.call(context, null));
            }
            catch (e) {
                observer.error(e);
            }
            observer.completed();
        });
    };
    wdFrp.judge = function (condition, thenSource, elseSource) {
        return condition() ? thenSource() : elseSource();
    };
    wdFrp.defer = function (buildStreamFunc) {
        return wdFrp.DeferStream.create(buildStreamFunc);
    };
    wdFrp.just = function (returnValue) {
        return wdFrp.createStream(function (observer) {
            observer.next(returnValue);
            observer.completed();
        });
    };
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    (function (FilterState) {
        FilterState[FilterState["TRIGGER"] = 0] = "TRIGGER";
        FilterState[FilterState["ENTER"] = 1] = "ENTER";
        FilterState[FilterState["LEAVE"] = 2] = "LEAVE";
    })(wdFrp.FilterState || (wdFrp.FilterState = {}));
    var FilterState = wdFrp.FilterState;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var defaultIsEqual = function (a, b) {
        return a === b;
    };
    var Record = (function () {
        function Record(time, value, actionType, comparer) {
            this._time = null;
            this._value = null;
            this._actionType = null;
            this._comparer = null;
            this._time = time;
            this._value = value;
            this._actionType = actionType;
            this._comparer = comparer || defaultIsEqual;
        }
        Record.create = function (time, value, actionType, comparer) {
            var obj = new this(time, value, actionType, comparer);
            return obj;
        };
        Object.defineProperty(Record.prototype, "time", {
            get: function () {
                return this._time;
            },
            set: function (time) {
                this._time = time;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Record.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Record.prototype, "actionType", {
            get: function () {
                return this._actionType;
            },
            set: function (actionType) {
                this._actionType = actionType;
            },
            enumerable: true,
            configurable: true
        });
        Record.prototype.equals = function (other) {
            return this._time === other.time && this._comparer(this._value, other.value);
        };
        return Record;
    }());
    wdFrp.Record = Record;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var MockObserver = (function (_super) {
        __extends(MockObserver, _super);
        function MockObserver(scheduler) {
            _super.call(this, null, null, null);
            this._messages = [];
            this._scheduler = null;
            this._scheduler = scheduler;
        }
        MockObserver.create = function (scheduler) {
            var obj = new this(scheduler);
            return obj;
        };
        Object.defineProperty(MockObserver.prototype, "messages", {
            get: function () {
                return this._messages;
            },
            set: function (messages) {
                this._messages = messages;
            },
            enumerable: true,
            configurable: true
        });
        MockObserver.prototype.onNext = function (value) {
            var record = null;
            if (wdFrp.JudgeUtils.isDirectObject(value)) {
                record = wdFrp.Record.create(this._scheduler.clock, value, wdFrp.ActionType.NEXT, function (a, b) {
                    var result = true;
                    for (var i in a) {
                        if (a.hasOwnProperty(i)) {
                            if (a[i] !== b[i]) {
                                result = false;
                                break;
                            }
                        }
                    }
                    return result;
                });
            }
            else {
                record = wdFrp.Record.create(this._scheduler.clock, value, wdFrp.ActionType.NEXT);
            }
            this._messages.push(record);
        };
        MockObserver.prototype.onError = function (error) {
            this._messages.push(wdFrp.Record.create(this._scheduler.clock, error, wdFrp.ActionType.ERROR));
        };
        MockObserver.prototype.onCompleted = function () {
            this._messages.push(wdFrp.Record.create(this._scheduler.clock, null, wdFrp.ActionType.COMPLETED));
        };
        MockObserver.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._scheduler.remove(this);
        };
        MockObserver.prototype.clone = function () {
            var result = MockObserver.create(this._scheduler);
            result.messages = this._messages;
            return result;
        };
        return MockObserver;
    }(wdFrp.Observer));
    wdFrp.MockObserver = MockObserver;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    var MockPromise = (function () {
        function MockPromise(scheduler, messages) {
            this._messages = [];
            this._scheduler = null;
            this._scheduler = scheduler;
            this._messages = messages;
        }
        MockPromise.create = function (scheduler, messages) {
            var obj = new this(scheduler, messages);
            return obj;
        };
        MockPromise.prototype.then = function (successCb, errorCb, observer) {
            this._scheduler.setStreamMap(observer, this._messages);
        };
        return MockPromise;
    }());
    wdFrp.MockPromise = MockPromise;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var SUBSCRIBE_TIME = 200;
    var DISPOSE_TIME = 1000;
    var TestScheduler = (function (_super) {
        __extends(TestScheduler, _super);
        function TestScheduler(isReset) {
            _super.call(this);
            this._clock = null;
            this._isReset = false;
            this._isDisposed = false;
            this._timerMap = wdCb.Hash.create();
            this._streamMap = wdCb.Hash.create();
            this._subscribedTime = null;
            this._disposedTime = null;
            this._observer = null;
            this._isReset = isReset;
        }
        TestScheduler.next = function (tick, value) {
            if (wdFrp.JudgeUtils.isDirectObject(value)) {
                return wdFrp.Record.create(tick, value, wdFrp.ActionType.NEXT, function (a, b) {
                    var result = true;
                    for (var i in a) {
                        if (a.hasOwnProperty(i)) {
                            if (a[i] !== b[i]) {
                                result = false;
                                break;
                            }
                        }
                    }
                    return result;
                });
            }
            else {
                return wdFrp.Record.create(tick, value, wdFrp.ActionType.NEXT);
            }
        };
        TestScheduler.error = function (tick, error) {
            return wdFrp.Record.create(tick, error, wdFrp.ActionType.ERROR);
        };
        TestScheduler.completed = function (tick) {
            return wdFrp.Record.create(tick, null, wdFrp.ActionType.COMPLETED);
        };
        TestScheduler.create = function (isReset) {
            if (isReset === void 0) { isReset = false; }
            var obj = new this(isReset);
            return obj;
        };
        Object.defineProperty(TestScheduler.prototype, "clock", {
            get: function () {
                return this._clock;
            },
            set: function (clock) {
                this._clock = clock;
            },
            enumerable: true,
            configurable: true
        });
        TestScheduler.prototype.setStreamMap = function (observer, messages) {
            var self = this;
            messages.forEach(function (record) {
                var func = null;
                switch (record.actionType) {
                    case wdFrp.ActionType.NEXT:
                        func = function () {
                            observer.next(record.value);
                        };
                        break;
                    case wdFrp.ActionType.ERROR:
                        func = function () {
                            observer.error(record.value);
                        };
                        break;
                    case wdFrp.ActionType.COMPLETED:
                        func = function () {
                            observer.completed();
                        };
                        break;
                    default:
                        wdCb.Log.error(true, wdCb.Log.info.FUNC_UNKNOW("actionType"));
                        break;
                }
                self._streamMap.addChild(String(record.time), func);
            });
        };
        TestScheduler.prototype.remove = function (observer) {
            this._isDisposed = true;
        };
        TestScheduler.prototype.publishRecursive = function (observer, initial, recursiveFunc) {
            var self = this, next = null, completed = null;
            this._setClock();
            next = observer.next;
            completed = observer.completed;
            observer.next = function (value) {
                next.call(observer, value);
                self._tick(1);
            };
            observer.completed = function () {
                completed.call(observer);
                self._tick(1);
            };
            recursiveFunc(initial);
        };
        TestScheduler.prototype.publishInterval = function (observer, initial, interval, action) {
            var COUNT = 10, messages = [];
            this._setClock();
            while (COUNT > 0 && !this._isDisposed) {
                this._tick(interval);
                messages.push(TestScheduler.next(this._clock, initial));
                initial++;
                COUNT--;
            }
            this.setStreamMap(observer, messages);
            return NaN;
        };
        TestScheduler.prototype.publishIntervalRequest = function (observer, action) {
            var COUNT = 10, messages = [], interval = 100, num = 0;
            this._setClock();
            while (COUNT > 0 && !this._isDisposed) {
                this._tick(interval);
                messages.push(TestScheduler.next(this._clock, num));
                num++;
                COUNT--;
            }
            this.setStreamMap(observer, messages);
            return NaN;
        };
        TestScheduler.prototype.publishTimeout = function (observer, time, action) {
            var messages = [];
            this._setClock();
            this._tick(time);
            messages.push(TestScheduler.next(this._clock, time), TestScheduler.completed(this._clock + 1));
            this.setStreamMap(observer, messages);
            return NaN;
        };
        TestScheduler.prototype._setClock = function () {
            if (this._isReset) {
                this._clock = this._subscribedTime;
            }
        };
        TestScheduler.prototype.startWithTime = function (create, subscribedTime, disposedTime) {
            var observer = this.createObserver(), source, subscription, self = this;
            this._subscribedTime = subscribedTime;
            this._disposedTime = disposedTime;
            this._clock = subscribedTime;
            this._runAt(subscribedTime, function () {
                source = create();
                subscription = source.subscribe(observer);
            });
            this._runAt(disposedTime, function () {
                subscription.dispose();
                self._isDisposed = true;
            });
            this._observer = observer;
            this.start();
            return observer;
        };
        TestScheduler.prototype.startWithSubscribe = function (create, subscribedTime) {
            if (subscribedTime === void 0) { subscribedTime = SUBSCRIBE_TIME; }
            return this.startWithTime(create, subscribedTime, DISPOSE_TIME);
        };
        TestScheduler.prototype.startWithDispose = function (create, disposedTime) {
            if (disposedTime === void 0) { disposedTime = DISPOSE_TIME; }
            return this.startWithTime(create, SUBSCRIBE_TIME, disposedTime);
        };
        TestScheduler.prototype.publicAbsolute = function (time, handler) {
            this._runAt(time, function () {
                handler();
            });
        };
        TestScheduler.prototype.start = function () {
            var extremeNumArr = this._getMinAndMaxTime(), min = extremeNumArr[0], max = extremeNumArr[1], time = min;
            while (time <= max) {
                this._clock = time;
                this._exec(time, this._timerMap);
                this._clock = time;
                this._runStream(time);
                time++;
                max = this._getMinAndMaxTime()[1];
            }
        };
        TestScheduler.prototype.createStream = function (args) {
            return wdFrp.TestStream.create(Array.prototype.slice.call(arguments, 0), this);
        };
        TestScheduler.prototype.createObserver = function () {
            return wdFrp.MockObserver.create(this);
        };
        TestScheduler.prototype.createResolvedPromise = function (time, value) {
            return wdFrp.MockPromise.create(this, [TestScheduler.next(time, value), TestScheduler.completed(time + 1)]);
        };
        TestScheduler.prototype.createRejectPromise = function (time, error) {
            return wdFrp.MockPromise.create(this, [TestScheduler.error(time, error)]);
        };
        TestScheduler.prototype._getMinAndMaxTime = function () {
            var timeArr = (this._timerMap.getKeys().addChildren(this._streamMap.getKeys()));
            timeArr = timeArr.map(function (key) {
                return Number(key);
            }).toArray();
            return [Math.min.apply(Math, timeArr), Math.max.apply(Math, timeArr)];
        };
        TestScheduler.prototype._exec = function (time, map) {
            var handler = map.getChild(String(time));
            if (handler) {
                handler();
            }
        };
        TestScheduler.prototype._runStream = function (time) {
            var handler = this._streamMap.getChild(String(time));
            if (handler) {
                handler();
            }
        };
        TestScheduler.prototype._runAt = function (time, callback) {
            this._timerMap.addChild(String(time), callback);
        };
        TestScheduler.prototype._tick = function (time) {
            this._clock += time;
        };
        return TestScheduler;
    }(wdFrp.Scheduler));
    wdFrp.TestScheduler = TestScheduler;
})(wdFrp || (wdFrp = {}));

var wdFrp;
(function (wdFrp) {
    (function (ActionType) {
        ActionType[ActionType["NEXT"] = 0] = "NEXT";
        ActionType[ActionType["ERROR"] = 1] = "ERROR";
        ActionType[ActionType["COMPLETED"] = 2] = "COMPLETED";
    })(wdFrp.ActionType || (wdFrp.ActionType = {}));
    var ActionType = wdFrp.ActionType;
})(wdFrp || (wdFrp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wdFrp;
(function (wdFrp) {
    var TestStream = (function (_super) {
        __extends(TestStream, _super);
        function TestStream(messages, scheduler) {
            _super.call(this, null);
            this.scheduler = null;
            this._messages = null;
            this._messages = messages;
            this.scheduler = scheduler;
        }
        TestStream.create = function (messages, scheduler) {
            var obj = new this(messages, scheduler);
            return obj;
        };
        TestStream.prototype.subscribeCore = function (observer) {
            this.scheduler.setStreamMap(observer, this._messages);
            return wdFrp.SingleDisposable.create();
        };
        return TestStream;
    }(wdFrp.BaseStream));
    wdFrp.TestStream = TestStream;
})(wdFrp || (wdFrp = {}));

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var wd;
(function (wd) {
    wd.DebugConfig = {
        isTest: false,
        debugCollision: false,
        showDebugPanel: false
    };
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DebugStatistics = (function () {
        function DebugStatistics() {
        }
        DebugStatistics.resetData = function () {
            this.count.renderGameObjects = 0;
            this.count.drawCalls = 0;
        };
        DebugStatistics.init = function () {
            var self = this;
            this._panelBuilder = wd.DebugPanelBuilder.create();
            if (!wd.DebugConfig.showDebugPanel) {
                return;
            }
            this._panelBuilder.createDebugPanel();
            this._panelBuilder.show();
            this._startLoopSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.STARTLOOP)
                .subscribe(function () {
                self._updateDebugInfo();
                self.resetData();
            });
        };
        DebugStatistics.dispose = function () {
            this._startLoopSubscription.dispose();
            this._panelBuilder.dispose();
        };
        DebugStatistics._updateDebugInfo = function () {
            var UPDATE_RATE = 10;
            if (this._updateCount === UPDATE_RATE) {
                this._updateCount = 0;
            }
            else {
                if (this._updateCount === 0) {
                    this._panelBuilder.updateDebugInfo(this.count, this.during);
                }
                this._updateCount++;
            }
        };
        DebugStatistics.count = {
            get totalGameObjects() {
                var count = 0;
                wd.Director.getInstance().scene.getChildren().forEach(function (child) {
                    if (wd.ClassUtils.hasComponent(child, "SpacePartition")) {
                        count += child.getComponent(wd.ClassUtils.getClass("SpacePartition")).getChildren().getCount();
                        return;
                    }
                    count++;
                });
                return count;
            },
            renderGameObjects: 0,
            drawCalls: 0
        };
        DebugStatistics.during = {
            get fps() {
                return wd.Director.getInstance().fps;
            }
        };
        DebugStatistics._startLoopSubscription = null;
        DebugStatistics._panelBuilder = null;
        DebugStatistics._updateCount = 0;
        return DebugStatistics;
    }());
    wd.DebugStatistics = DebugStatistics;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DebugPanelBuilder = (function () {
        function DebugPanelBuilder() {
            this._panel = null;
            this._fps = null;
            this._totalGameObjects = null;
            this._renderGameObjects = null;
            this._renderer = null;
        }
        DebugPanelBuilder.create = function () {
            var obj = new this();
            return obj;
        };
        DebugPanelBuilder.prototype.createDebugPanel = function () {
            var renderer = wd.UIRenderer.create();
            renderer.zIndex = 30;
            this._panel = this._createPanel(renderer);
            this._panel.name = "panel";
            this._fps = this._createFont(renderer, wd.Vector2.create(0.2, 0.8), wd.Vector2.create(0.1, 0.3));
            this._totalGameObjects = this._createFont(renderer, wd.Vector2.create(0.2, 0.8), wd.Vector2.create(0.3, 0.6));
            this._renderGameObjects = this._createFont(renderer, wd.Vector2.create(0.2, 0.8), wd.Vector2.create(0.6, 0.9));
            this._renderer = renderer;
            this._panel.addChild(this._fps);
            this._panel.addChild(this._totalGameObjects);
            this._panel.addChild(this._renderGameObjects);
            wd.Director.getInstance().scene.addChild(this._panel);
        };
        DebugPanelBuilder.prototype.updateDebugInfo = function (count, during) {
            this._fps.getComponent(wd.PlainFont).text = "fps:" + Math.floor(during.fps);
            this._totalGameObjects.getComponent(wd.PlainFont).text = "totalGameObjects:" + Math.floor(count.totalGameObjects);
            this._renderGameObjects.getComponent(wd.PlainFont).text = "renderGameObjects:" + Math.floor(count.renderGameObjects);
        };
        DebugPanelBuilder.prototype.show = function () {
            this._panel.isVisible = true;
        };
        DebugPanelBuilder.prototype.hide = function () {
            this._panel.isVisible = false;
        };
        DebugPanelBuilder.prototype.dispose = function () {
            this._panel.dispose();
            this._renderer.dispose();
        };
        DebugPanelBuilder.prototype._createFont = function (renderer, anchorX, anchorY) {
            var font = wd.PlainFont.create(), uiObject = wd.UIObject.create();
            if (bowser.mobile) {
                font.fontSize = 30;
            }
            else {
                font.fontSize = 50;
            }
            font.enableFill("yellow");
            font.xAlignment = wd.EFontXAlignment.CENTER;
            font.yAlignment = wd.EFontYAlignment.TOP;
            uiObject.addComponent(font);
            uiObject.addComponent(renderer);
            uiObject.transform.anchorX = anchorX;
            uiObject.transform.anchorY = anchorY;
            return uiObject;
        };
        DebugPanelBuilder.prototype._createPanel = function (renderer) {
            var view = wd.DeviceManager.getInstance().view, uiObject = wd.UIObject.create();
            uiObject.transform.width = view.width;
            uiObject.transform.height = view.height;
            uiObject.addComponent(renderer);
            return uiObject;
        };
        return DebugPanelBuilder;
    }());
    wd.DebugPanelBuilder = DebugPanelBuilder;
})(wd || (wd = {}));
var wdFrp;
(function (wdFrp) {
    wdFrp.fromCollection = function (collection, scheduler) {
        if (scheduler === void 0) { scheduler = wdFrp.Scheduler.create(); }
        var arr = collection.toArray();
        return arr.length === 0 ? wdFrp.empty() : wdFrp.fromArray(arr, scheduler);
    };
})(wdFrp || (wdFrp = {}));
var wd;
(function (wd) {
    wd.CompileConfig = {
        isCompileTest: true,
        closeContractTest: false
    };
})(wd || (wd = {}));
var wd;
(function (wd) {
    var _describeContext = null;
    function assert(cond, message) {
        if (message === void 0) { message = "contract error"; }
        wd.Log.error(!cond, message);
    }
    wd.assert = assert;
    function describe(message, func, preCondition, context) {
        if (preCondition === void 0) { preCondition = function () { return true; }; }
        if (context === void 0) { context = this; }
        if (preCondition.call(context, null)) {
            _describeContext = context;
            try {
                func.call(context, null);
            }
            catch (e) {
                assert(false, message + "->" + e.message);
            }
            finally {
                _describeContext = null;
            }
        }
    }
    wd.describe = describe;
    function it(message, func, context) {
        try {
            if (arguments.length === 3) {
                func.call(context, null);
            }
            else {
                if (_describeContext) {
                    func.call(_describeContext, null);
                }
                else {
                    func();
                }
            }
        }
        catch (e) {
            assert(false, message + "->" + e.message);
        }
    }
    wd.it = it;
    function require(inFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var value_1 = descriptor.value;
                descriptor.value = function (args) {
                    if (wd.Main.isTest) {
                        inFunc.apply(this, arguments);
                    }
                    return value_1.apply(this, arguments);
                };
            }
            return descriptor;
        };
    }
    wd.require = require;
    function ensure(outFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var value_2 = descriptor.value;
                descriptor.value = function (args) {
                    var result = value_2.apply(this, arguments);
                    if (wd.Main.isTest) {
                        var params = [result];
                        for (var i = 0, len = arguments.length; i < len; i++) {
                            params[i + 1] = arguments[i];
                        }
                        outFunc.apply(this, params);
                    }
                    return result;
                };
            }
            return descriptor;
        };
    }
    wd.ensure = ensure;
    function requireGetterAndSetter(inGetterFunc, inSetterFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var getter_1 = descriptor.get, setter_1 = descriptor.set;
                descriptor.get = function () {
                    if (wd.Main.isTest) {
                        inGetterFunc.call(this);
                    }
                    return getter_1.call(this);
                };
                descriptor.set = function (val) {
                    if (wd.Main.isTest) {
                        inSetterFunc.call(this, val);
                    }
                    setter_1.call(this, val);
                };
            }
            return descriptor;
        };
    }
    wd.requireGetterAndSetter = requireGetterAndSetter;
    function requireGetter(inFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var getter_2 = descriptor.get;
                descriptor.get = function () {
                    if (wd.Main.isTest) {
                        inFunc.call(this);
                    }
                    return getter_2.call(this);
                };
            }
            return descriptor;
        };
    }
    wd.requireGetter = requireGetter;
    function requireSetter(inFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var setter_2 = descriptor.set;
                descriptor.set = function (val) {
                    if (wd.Main.isTest) {
                        inFunc.call(this, val);
                    }
                    setter_2.call(this, val);
                };
            }
            return descriptor;
        };
    }
    wd.requireSetter = requireSetter;
    function ensureGetterAndSetter(outGetterFunc, outSetterFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var getter_3 = descriptor.get, setter_3 = descriptor.set;
                descriptor.get = function () {
                    var result = getter_3.call(this);
                    if (wd.Main.isTest) {
                        outGetterFunc.call(this, result);
                    }
                    return result;
                };
                descriptor.set = function (val) {
                    var result = setter_3.call(this, val);
                    if (wd.Main.isTest) {
                        var params = [result, val];
                        outSetterFunc.apply(this, params);
                    }
                };
            }
            return descriptor;
        };
    }
    wd.ensureGetterAndSetter = ensureGetterAndSetter;
    function ensureGetter(outFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var getter_4 = descriptor.get;
                descriptor.get = function () {
                    var result = getter_4.call(this);
                    if (wd.Main.isTest) {
                        outFunc.call(this, result);
                    }
                    return result;
                };
            }
            return descriptor;
        };
    }
    wd.ensureGetter = ensureGetter;
    function ensureSetter(outFunc) {
        return function (target, name, descriptor) {
            if (wd.CompileConfig.isCompileTest) {
                var setter_4 = descriptor.set;
                descriptor.set = function (val) {
                    var result = setter_4.call(this, val);
                    if (wd.Main.isTest) {
                        var params = [result, val];
                        outFunc.apply(this, params);
                    }
                };
            }
            return descriptor;
        };
    }
    wd.ensureSetter = ensureSetter;
    function invariant(func) {
        return function (target) {
            if (wd.CompileConfig.isCompileTest) {
                if (wd.Main.isTest) {
                    func(target);
                }
            }
        };
    }
    wd.invariant = invariant;
})(wd || (wd = {}));
var wd;
(function (wd) {
    function singleton(isInitWhenCreate) {
        if (isInitWhenCreate === void 0) { isInitWhenCreate = false; }
        return function (target) {
            target._instance = null;
            if (isInitWhenCreate) {
                target.getInstance = function () {
                    if (target._instance === null) {
                        var instance = new target();
                        target._instance = instance;
                        instance.initWhenCreate();
                    }
                    return target._instance;
                };
            }
            else {
                target.getInstance = function () {
                    if (target._instance === null) {
                        target._instance = new target();
                    }
                    return target._instance;
                };
            }
        };
    }
    wd.singleton = singleton;
})(wd || (wd = {}));
var wd;
(function (wd) {
    function cacheGetter(judgeFunc, returnCacheValueFunc, setCacheFunc) {
        return function (target, name, descriptor) {
            var getter = descriptor.get;
            descriptor.get = function () {
                var result = null;
                if (judgeFunc.call(this)) {
                    return returnCacheValueFunc.call(this);
                }
                result = getter.call(this);
                setCacheFunc.call(this, result);
                return result;
            };
            return descriptor;
        };
    }
    wd.cacheGetter = cacheGetter;
    function cache(judgeFunc, returnCacheValueFunc, setCacheFunc) {
        return function (target, name, descriptor) {
            var value = descriptor.value;
            descriptor.value = function (args) {
                var result = null, setArgs = null;
                if (judgeFunc.apply(this, arguments)) {
                    return returnCacheValueFunc.apply(this, arguments);
                }
                result = value.apply(this, arguments);
                setArgs = [result];
                for (var i = 0, len = arguments.length; i < len; i++) {
                    setArgs[i + 1] = arguments[i];
                }
                setCacheFunc.apply(this, setArgs);
                return result;
            };
            return descriptor;
        };
    }
    wd.cache = cache;
    function cacheBufferForBufferContainer() {
        return function (target, name, descriptor) {
            var value = descriptor.value;
            descriptor.value = function (dataName) {
                var result = null;
                if (this.container.hasChild(dataName)) {
                    return this.container.getChild(dataName);
                }
                result = value.call(this, dataName);
                this.container.addChild(dataName, result);
                return result;
            };
            return descriptor;
        };
    }
    wd.cacheBufferForBufferContainer = cacheBufferForBufferContainer;
    function cacheBufferForBufferContainerWithFuncParam(setDataNameFuncName) {
        return function (target, name, descriptor) {
            var value = descriptor.value;
            descriptor.value = function (dataName) {
                var result = null, settedDataName = this[setDataNameFuncName](dataName);
                if (this.container.hasChild(settedDataName)) {
                    return this.container.getChild(settedDataName);
                }
                result = value.call(this, dataName);
                this.container.addChild(settedDataName, result);
                return result;
            };
            return descriptor;
        };
    }
    wd.cacheBufferForBufferContainerWithFuncParam = cacheBufferForBufferContainerWithFuncParam;
})(wd || (wd = {}));
var wd;
(function (wd) {
    function virtual(target, name, descriptor) {
        return descriptor;
    }
    wd.virtual = virtual;
})(wd || (wd = {}));
var wd;
(function (wd) {
    function operateBodyDataGetterAndSetter(dataName) {
        return function (target, name, descriptor) {
            var getter = descriptor.get, setter = descriptor.set;
            descriptor.get = function () {
                var data = this.getPhysicsComponentContainerAdapter()[("get" + dataName)](this.entityObject);
                return data !== null ? data : this[("_" + lowerFirstChar(dataName))];
            };
            descriptor.set = function (val) {
                setter.call(this, val);
                this.getPhysicsComponentContainerAdapter()[("set" + dataName)](this.entityObject, val);
            };
            return descriptor;
        };
    }
    wd.operateBodyDataGetterAndSetter = operateBodyDataGetterAndSetter;
    function operateWorldDataGetterAndSetter(dataName) {
        return function (target, name, descriptor) {
            var getter = descriptor.get, setter = descriptor.set;
            descriptor.get = function () {
                var physicsEngineAdapter = wd.PhysicsComponentContainer.getInstance().physicsEngineAdapter;
                if (isWorldDefined(physicsEngineAdapter)) {
                    var data = physicsEngineAdapter[("get" + dataName)]();
                    return data !== null ? data : this[("_" + lowerFirstChar(dataName))];
                }
                return getter.call(this);
            };
            descriptor.set = function (val) {
                var physicsEngineAdapter = wd.PhysicsComponentContainer.getInstance().physicsEngineAdapter;
                setter.call(this, val);
                if (isWorldDefined(physicsEngineAdapter)) {
                    physicsEngineAdapter[("set" + dataName)](val);
                }
            };
            return descriptor;
        };
    }
    wd.operateWorldDataGetterAndSetter = operateWorldDataGetterAndSetter;
    function isWorldDefined(physicsEngineAdapter) {
        return physicsEngineAdapter && physicsEngineAdapter.world;
    }
    function lowerFirstChar(str) {
        var firstChar = str.slice(0, 1);
        return "" + firstChar.toLowerCase() + str.slice(1);
    }
})(wd || (wd = {}));
var wd;
(function (wd) {
    function script(scriptName) {
        return function (target) {
            wd.Script.addScript(scriptName, target);
        };
    }
    wd.script = script;
})(wd || (wd = {}));
var wd;
(function (wd) {
    function execOnlyOnce(flagName) {
        return function (target, name, descriptor) {
            var value = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var result = null;
                if (this[flagName]) {
                    return;
                }
                this[flagName] = true;
                return value.apply(this, args);
            };
            return descriptor;
        };
    }
    wd.execOnlyOnce = execOnlyOnce;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NOT_CLONE_TAG = "not_clone";
    var getCloneAttributeMembers = function (obj) {
        return obj[buildMemberContainerAttributeName(obj)];
    };
    var setCloneAttributeMembers = function (obj, members) {
        obj[buildMemberContainerAttributeName(obj)] = members;
    };
    var searchCloneAttributeMembers = function (obj) {
        var CLONE_MEMBER_PREFIX = "__decorator_clone";
        var result = null;
        for (var memberName in obj) {
            if (obj.hasOwnProperty(memberName)) {
                if (memberName.indexOf(CLONE_MEMBER_PREFIX) > -1) {
                    result = obj[memberName];
                    break;
                }
            }
        }
        return result;
    };
    var getAllCloneAttributeMembers = function (obj) {
        var IS_GATHERED_ATTRIBUTE_NAME = "__decorator_clone_isGathered_" + wd.ClassUtils.getClassName(obj) + "_cloneAttributeMembers";
        var result = wdCb.Collection.create();
        var gather = function (obj) {
            if (!obj) {
                return;
            }
            if (obj[IS_GATHERED_ATTRIBUTE_NAME]) {
                var members_1 = getCloneAttributeMembers(obj);
                wd.assert(members_1, wd.Log.info.FUNC_NOT_EXIST("" + buildMemberContainerAttributeName(obj)));
                result.addChildren(members_1);
                return;
            }
            gather(obj.__proto__);
            var members = searchCloneAttributeMembers(obj);
            if (members) {
                result.addChildren(members);
            }
        }, setGatheredResult = function () {
            setCloneAttributeMembers(obj.__proto__, result);
            obj.__proto__[IS_GATHERED_ATTRIBUTE_NAME] = true;
        };
        gather(obj.__proto__);
        setGatheredResult();
        return getCloneAttributeMembers(obj);
    };
    var initCloneAttributeMembers = function (obj) {
        setCloneAttributeMembers(obj, wdCb.Collection.create());
    };
    var buildMemberContainerAttributeName = function (obj) {
        return "__decorator_clone_" + wd.ClassUtils.getClassName(obj) + "_cloneAttributeMembers";
    };
    var generateCloneableMember = function (cloneType) {
        var cloneDataArr = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            cloneDataArr[_i - 1] = arguments[_i];
        }
        return function (target, memberName) {
            if (!getCloneAttributeMembers(target)) {
                initCloneAttributeMembers(target);
            }
            if (cloneDataArr.length === 1) {
                getCloneAttributeMembers(target).addChild({
                    memberName: memberName,
                    cloneType: cloneType,
                    configData: cloneDataArr[0]
                });
            }
            else if (cloneDataArr.length === 2) {
                getCloneAttributeMembers(target).addChild({
                    memberName: memberName,
                    cloneType: cloneType,
                    cloneFunc: cloneDataArr[0],
                    configData: cloneDataArr[1]
                });
            }
        };
    };
    function cloneAttributeAsBasicType(configData) {
        return generateCloneableMember(CloneType.BASIC, wdCb.ExtendUtils.extend({
            order: 0
        }, configData));
    }
    wd.cloneAttributeAsBasicType = cloneAttributeAsBasicType;
    function cloneAttributeAsCloneable(configData) {
        return generateCloneableMember(CloneType.CLONEABLE, wdCb.ExtendUtils.extend({
            order: 0
        }, configData));
    }
    wd.cloneAttributeAsCloneable = cloneAttributeAsCloneable;
    function cloneAttributeAsCustomType(cloneFunc, configData) {
        return generateCloneableMember(CloneType.CUSTOM, cloneFunc, wdCb.ExtendUtils.extend({
            order: 0
        }, configData));
    }
    wd.cloneAttributeAsCustomType = cloneAttributeAsCustomType;
    var CloneUtils = (function () {
        function CloneUtils() {
        }
        CloneUtils.clone = function (source, cloneData, createDataArr, target) {
            if (cloneData === void 0) { cloneData = null; }
            if (createDataArr === void 0) { createDataArr = null; }
            if (target === void 0) { target = null; }
            var cloneAttributeMembers = getAllCloneAttributeMembers(source)
                .sort(function (memberDataA, memberDataB) {
                return memberDataA.configData.order - memberDataB.configData.order;
            }), className = wd.ClassUtils.getClassName(source);
            if (target === null) {
                if (createDataArr) {
                    target = wd[className].create.apply(wd[className], createDataArr);
                }
                else {
                    target = wd[className].create();
                }
            }
            if (!cloneAttributeMembers) {
                return target;
            }
            cloneAttributeMembers.forEach(function (memberData) {
                var cloneType = memberData.cloneType, memberName = memberData.memberName;
                switch (cloneType) {
                    case CloneType.CLONEABLE:
                        if (source[memberName] !== null && source[memberName] !== void 0) {
                            if (target[memberName] !== null) {
                                target[memberName] = source[memberName].clone(target[memberName]);
                            }
                            else {
                                target[memberName] = source[memberName].clone();
                            }
                        }
                        break;
                    case CloneType.BASIC:
                        target[memberName] = source[memberName];
                        break;
                    case CloneType.CUSTOM:
                        var cloneFunc = memberData.cloneFunc;
                        cloneFunc.call(target, source, target, memberName, cloneData);
                        break;
                }
            });
            return target;
        };
        CloneUtils.cloneArray = function (arr, isDeep) {
            if (isDeep === void 0) { isDeep = false; }
            if (arr === null) {
                return null;
            }
            if (isDeep) {
                return wdCb.ExtendUtils.extendDeep(arr);
            }
            return [].concat(arr);
        };
        CloneUtils.markNotClone = function (entityObject) {
            if (!entityObject.hasTag(NOT_CLONE_TAG)) {
                entityObject.addTag(NOT_CLONE_TAG);
            }
        };
        CloneUtils.isNotClone = function (entityObject) {
            return entityObject.hasTag(NOT_CLONE_TAG);
        };
        __decorate([
            wd.require(function (source, cloneData, createDataArr) {
                if (cloneData === void 0) { cloneData = null; }
                if (createDataArr === void 0) { createDataArr = null; }
                if (createDataArr) {
                    wd.assert(wd.JudgeUtils.isArrayExactly(createDataArr), wd.Log.info.FUNC_MUST_BE("param:createDataArr", "be arr"));
                }
            })
        ], CloneUtils, "clone", null);
        return CloneUtils;
    }());
    wd.CloneUtils = CloneUtils;
    (function (CloneType) {
        CloneType[CloneType["CLONEABLE"] = 0] = "CLONEABLE";
        CloneType[CloneType["BASIC"] = 1] = "BASIC";
        CloneType[CloneType["CUSTOM"] = 2] = "CUSTOM";
    })(wd.CloneType || (wd.CloneType = {}));
    var CloneType = wd.CloneType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var AngleUtils = (function () {
        function AngleUtils() {
        }
        AngleUtils.convertDegreeToRadians = function (angle) {
            return angle * Math.PI / 180;
        };
        AngleUtils.convertRadiansToDegree = function (angle) {
            return angle * 180 / Math.PI;
        };
        return AngleUtils;
    }());
    wd.AngleUtils = AngleUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ArrayUtils = (function (_super) {
        __extends(ArrayUtils, _super);
        function ArrayUtils() {
            _super.apply(this, arguments);
        }
        ArrayUtils.hasRepeatItems = function (arr) {
            var noRepeatArr = [], hasRepeat = false;
            for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                var item = arr_1[_i];
                if (!item) {
                    continue;
                }
                if (this.contain(noRepeatArr, item)) {
                    hasRepeat = true;
                    break;
                }
                noRepeatArr.push(item);
            }
            return hasRepeat;
        };
        ArrayUtils.contain = function (arr, item) {
            var c = null;
            for (var i = 0, len = arr.length; i < len; i++) {
                c = arr[i];
                if (item.uid && c.uid && item.uid == c.uid) {
                    return true;
                }
                else if (item === c) {
                    return true;
                }
            }
            return false;
        };
        return ArrayUtils;
    }(wdCb.ArrayUtils));
    wd.ArrayUtils = ArrayUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BufferUtils = (function () {
        function BufferUtils() {
        }
        BufferUtils.convertArrayToArrayBuffer = function (type, value) {
            var size = this._getBufferSize(type);
            return wd.ArrayBuffer.create(value, size, wd.EBufferType.FLOAT);
        };
        BufferUtils._getBufferSize = function (type) {
            var size = null;
            switch (type) {
                case wd.EVariableType.FLOAT_1:
                case wd.EVariableType.NUMBER_1:
                    size = 1;
                    break;
                case wd.EVariableType.FLOAT_2:
                    size = 2;
                    break;
                case wd.EVariableType.FLOAT_3:
                    size = 3;
                    break;
                case wd.EVariableType.FLOAT_4:
                    size = 4;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("EVariableType", type));
                    break;
            }
            return size;
        };
        __decorate([
            wd.require(function (type, value) {
                wd.it("value:" + value + " should be array", function () {
                    wd.expect(wd.JudgeUtils.isArrayExactly(value)).true;
                });
            })
        ], BufferUtils, "convertArrayToArrayBuffer", null);
        return BufferUtils;
    }());
    wd.BufferUtils = BufferUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ClassUtils = (function () {
        function ClassUtils() {
        }
        ClassUtils.getClassName = function (objInstance) {
            return objInstance.constructor.name;
        };
        ClassUtils.getClass = function (className) {
            return wd[className];
        };
        ClassUtils.hasComponent = function (entityObject, className) {
            var _class = this.getClass(className);
            if (_class === void 0) {
                return false;
            }
            return entityObject.hasComponent(_class);
        };
        ClassUtils.createClassInstance = function (className) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _class = ClassUtils.getClass(className);
            if (!!_class) {
                return _class.create.apply(_class, args);
            }
            return null;
        };
        ClassUtils.createClassInstanceOrEmpty = function (className, emptyClassName) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var _class = ClassUtils.getClass(className);
            if (_class === void 0) {
                _class = ClassUtils.getClass(emptyClassName);
            }
            return _class.create.apply(_class, args);
        };
        ClassUtils.execSingletonMethod = function (className, method) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var Engine = this.getClass(className);
            if (!!Engine) {
                var instance = Engine.getInstance();
                instance[method].apply(instance, args);
            }
        };
        __decorate([
            wd.ensure(function (className) {
                wd.it("should get class name from objInstance.className", function () {
                    wd.expect(className).exist;
                    wd.expect(className !== "").true;
                });
            })
        ], ClassUtils, "getClassName", null);
        __decorate([
            wd.require(function (className, emptyClassName) {
                var _this = this;
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                wd.it("should exist empty class if class not exist", function () {
                    if (_this.getClass(className) === void 0) {
                        wd.expect(_this.getClass(emptyClassName)).exist;
                    }
                }, this);
            })
        ], ClassUtils, "createClassInstanceOrEmpty", null);
        return ClassUtils;
    }());
    wd.ClassUtils = ClassUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CoordinateUtils = (function () {
        function CoordinateUtils() {
        }
        CoordinateUtils.convertWebGLPositionToCanvasPosition = function (position) {
            var view = wd.DeviceManager.getInstance().view;
            return wd.Vector2.create(view.width / 2 + position.x, view.height / 2 - position.y);
        };
        CoordinateUtils.convertCanvasPositionToWebGLPosition = function (position) {
            var view = wd.DeviceManager.getInstance().view;
            return wd.Vector3.create(position.x - view.width / 2, view.height / 2 - position.y, 0);
        };
        CoordinateUtils.convertLeftCornerPositionToCenterPositionInWebGL = function (position, width, height) {
            return wd.Vector2.create(this.convertLeftCornerPositionXToCenterPositionXInWebGL(position.x, width), this.convertLeftCornerPositionYToCenterPositionYInWebGL(position.y, height));
        };
        CoordinateUtils.convertLeftCornerPositionXToCenterPositionXInWebGL = function (positionX, width) {
            return positionX - width / 2;
        };
        CoordinateUtils.convertLeftCornerPositionYToCenterPositionYInWebGL = function (positionY, height) {
            return positionY - height / 2;
        };
        CoordinateUtils.convertLeftCornerPositionToCenterPositionInCanvas = function (position, width, height) {
            return wd.Vector2.create(this.convertLeftCornerPositionXToCenterPositionXInCanvas(position.x, width), this.convertLeftCornerPositionYToCenterPositionYInCanvas(position.y, height));
        };
        CoordinateUtils.convertLeftCornerPositionXToCenterPositionXInCanvas = function (positionX, width) {
            return positionX + width / 2;
        };
        CoordinateUtils.convertLeftCornerPositionYToCenterPositionYInCanvas = function (positionY, height) {
            return positionY + height / 2;
        };
        __decorate([
            wd.require(function () {
                wd.assert(!!wd.DeviceManager.getInstance().view, wd.Log.info.FUNC_SHOULD("set view"));
            })
        ], CoordinateUtils, "convertWebGLPositionToCanvasPosition", null);
        __decorate([
            wd.require(function () {
                wd.assert(!!wd.DeviceManager.getInstance().view, wd.Log.info.FUNC_SHOULD("set view"));
            })
        ], CoordinateUtils, "convertCanvasPositionToWebGLPosition", null);
        return CoordinateUtils;
    }());
    wd.CoordinateUtils = CoordinateUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GlobalGeometryUtils = (function () {
        function GlobalGeometryUtils() {
        }
        GlobalGeometryUtils.hasMorphAnimation = function (geometry) {
            if (geometry instanceof wd.ModelGeometry) {
                return geometry.hasMorphAnimation();
            }
            return false;
        };
        GlobalGeometryUtils.hasSkinSkeletonAnimation = function (geometry) {
            if (geometry instanceof wd.ModelGeometry) {
                return geometry.hasSkinSkeletonAnimation();
            }
            return false;
        };
        return GlobalGeometryUtils;
    }());
    wd.GlobalGeometryUtils = GlobalGeometryUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GlobalScriptUtils = (function () {
        function GlobalScriptUtils() {
        }
        GlobalScriptUtils.addScriptToEntityObject = function (entityObject, data) {
            wd.ScriptComponentContainer.getInstance().addChild(entityObject, data.name, new data.class(entityObject));
        };
        return GlobalScriptUtils;
    }());
    wd.GlobalScriptUtils = GlobalScriptUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GlobalTextureUtils = (function () {
        function GlobalTextureUtils() {
        }
        GlobalTextureUtils.convertSourceRegionCanvasMapToUV = function (sourceRegion, textureWidth, textureHeight) {
            var region = null;
            region = wd.RectRegion.create(sourceRegion.x / textureWidth, sourceRegion.y / textureHeight, sourceRegion.width / textureWidth, sourceRegion.height / textureHeight);
            region.y = 1 - region.y - region.height;
            return region;
        };
        return GlobalTextureUtils;
    }());
    wd.GlobalTextureUtils = GlobalTextureUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var InstanceUtils = (function () {
        function InstanceUtils() {
        }
        InstanceUtils.isHardwareSupport = function () {
            return wd.GPUDetector.getInstance().extensionInstancedArrays !== null;
        };
        InstanceUtils.isInstance = function (gameObject) {
            return gameObject.hasComponent(wd.Instance);
        };
        InstanceUtils.isSourceInstance = function (gameObject) {
            return gameObject.hasComponent(wd.SourceInstance);
        };
        InstanceUtils.isOneToOneSourceInstance = function (gameObject) {
            return gameObject.hasComponent(wd.OneToOneSourceInstance);
        };
        InstanceUtils.isOneToManySourceInstance = function (gameObject) {
            return gameObject.hasComponent(wd.OneToManySourceInstance);
        };
        InstanceUtils.isObjectInstance = function (gameObject) {
            return gameObject.hasComponent(wd.ObjectInstance);
        };
        InstanceUtils.addModelMatrixShaderLib = function (shader, gameObject) {
            if (!gameObject) {
                return;
            }
            if (InstanceUtils.isInstance(gameObject)) {
                if (InstanceUtils.isHardwareSupport()) {
                    shader.addLib(wd.ModelMatrixHardwareInstanceShaderLib.create());
                    return;
                }
                shader.addLib(wd.ModelMatrixBatchInstanceShaderLib.create());
                return;
            }
            shader.addLib(wd.ModelMatrixNoInstanceShaderLib.create());
        };
        InstanceUtils.addNormalModelMatrixShaderLib = function (shader, gameObject) {
            if (!gameObject) {
                return;
            }
            if (InstanceUtils.isInstance(gameObject)) {
                if (InstanceUtils.isHardwareSupport()) {
                    shader.addLib(wd.NormalMatrixHardwareInstanceShaderLib.create());
                    return;
                }
                shader.addLib(wd.NormalMatrixBatchInstanceShaderLib.create());
                return;
            }
            shader.addLib(wd.NormalMatrixNoInstanceShaderLib.create());
        };
        return InstanceUtils;
    }());
    wd.InstanceUtils = InstanceUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var IterateUtils = (function () {
        function IterateUtils() {
        }
        IterateUtils.forEachAll = function (entityObject, handler) {
            var func = function (entityObject) {
                handler(entityObject);
                entityObject.forEach(function (child) {
                    func(child);
                });
            };
            func(entityObject);
        };
        return IterateUtils;
    }());
    wd.IterateUtils = IterateUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var JudgeUtils = (function (_super) {
        __extends(JudgeUtils, _super);
        function JudgeUtils() {
            _super.apply(this, arguments);
        }
        JudgeUtils.isView = function (obj) {
            return !!obj && obj.offset && obj.width && obj.height && this.isFunction(obj.getContext);
        };
        JudgeUtils.isEqual = function (target1, target2) {
            if ((!target1 && target2) || (target1 && !target2)) {
                return false;
            }
            if (target1.uid && target2.uid) {
                return target1.uid === target2.uid;
            }
            return target1 === target2;
        };
        JudgeUtils.isPowerOfTwo = function (value) {
            return (value & (value - 1)) === 0 && value !== 0;
        };
        JudgeUtils.isFloatArray = function (data) {
            return Object.prototype.toString.call(data) === "[object Float32Array]" || Object.prototype.toString.call(data) === "[object Float16Array]";
        };
        JudgeUtils.isInterface = function (target, memberOfInterface) {
            return !!target[memberOfInterface];
        };
        JudgeUtils.isSpacePartitionObject = function (entityObject) {
            return wd.ClassUtils.hasComponent(entityObject, "SpacePartition");
        };
        JudgeUtils.isSelf = function (self, entityObject) {
            return self.uid === entityObject.uid;
        };
        JudgeUtils.isComponenet = function (component) {
            return component.entityObject !== void 0;
        };
        JudgeUtils.isDom = function (obj) {
            return Object.prototype.toString.call(obj).match(/\[object HTML\w+/) !== null;
        };
        JudgeUtils.isCollection = function (list) {
            return list instanceof wdCb.Collection;
        };
        JudgeUtils.isClass = function (objInstance, className) {
            return objInstance.constructor.name === className;
        };
        return JudgeUtils;
    }(wdCb.JudgeUtils));
    wd.JudgeUtils = JudgeUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightUtils = (function () {
        function LightUtils() {
        }
        LightUtils.getPointLightPosition = function (lightComponent) {
            return lightComponent.position;
        };
        LightUtils.getDirectionLightPosition = function (lightComponent) {
            if (this._isZero(lightComponent.position)) {
                return wd.DirectionLight.defaultPosition;
            }
            return lightComponent.position;
        };
        LightUtils._isZero = function (position) {
            var val = position.values;
            return val[0] === 0 && val[1] === 0 && val[2] === 0;
        };
        return LightUtils;
    }());
    wd.LightUtils = LightUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Log = (function (_super) {
        __extends(Log, _super);
        function Log() {
            _super.apply(this, arguments);
        }
        return Log;
    }(wdCb.Log));
    wd.Log = Log;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MathUtils = (function () {
        function MathUtils() {
        }
        MathUtils.clamp = function (num, below, up) {
            if (num < below) {
                return below;
            }
            else if (num > up) {
                return up;
            }
            return num;
        };
        MathUtils.bigThan = function (num, below) {
            return num < below ? below : num;
        };
        MathUtils.generateZeroToOne = function () {
            return Math.random();
        };
        MathUtils.generateMinToMax = function (min, max) {
            return Math.random() * (max + 1 - min) + min;
        };
        MathUtils.generateInteger = function (min, max) {
            return Math.floor(this.generateMinToMax(min, max));
        };
        MathUtils.mod = function (a, b) {
            var n = Math.floor(a / b);
            a -= n * b;
            if (a < 0) {
                a += b;
            }
            return a;
        };
        MathUtils.maxFloorIntegralMultiple = function (a, b) {
            if (b == 0) {
                return a;
            }
            if (a < b) {
                return 0;
            }
            return Math.floor(a / b) * b;
        };
        __decorate([
            wd.require(function (min, max) {
                wd.it("min should <= max", function () {
                    wd.expect(min).lte(max);
                });
            })
        ], MathUtils, "generateMinToMax", null);
        __decorate([
            wd.ensure(function (val) {
                wd.it("result should >= 0", function () {
                    wd.expect(val).gte(0);
                });
            })
        ], MathUtils, "mod", null);
        __decorate([
            wd.require(function (a, b) {
                wd.it("a,b should >= 0", function () {
                    wd.expect(a).gte(0);
                    wd.expect(b).gte(0);
                });
            }),
            wd.ensure(function (val) {
                wd.it("result should >= 0", function () {
                    wd.expect(val).gte(0);
                });
            })
        ], MathUtils, "maxFloorIntegralMultiple", null);
        return MathUtils;
    }());
    wd.MathUtils = MathUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RenderUtils = (function () {
        function RenderUtils() {
        }
        RenderUtils.getGameObjectRenderList = function (sourceList) {
            var _this = this;
            var renderList = [];
            sourceList.forEach(function (child) {
                var GameObjectLOD = wd.ClassUtils.getClass("GameObjectLOD"), activeGameObject = null;
                if (GameObjectLOD !== void 0) {
                    var gameObjectLOD = child.getComponent(GameObjectLOD);
                    activeGameObject = _this._getActiveGameObject(child, gameObjectLOD);
                    if (activeGameObject === null) {
                        return wdCb.Collection.create();
                    }
                }
                else {
                    activeGameObject = child;
                }
                if (activeGameObject.isVisible && !wd.InstanceUtils.isObjectInstance(activeGameObject)) {
                    renderList.push(activeGameObject);
                }
            });
            return wdCb.Collection.create(renderList);
        };
        RenderUtils.getGameObjectRenderListForOctree = function (sourceList) {
            var _this = this;
            var renderList = [];
            sourceList.forEach(function (child) {
                var GameObjectLOD = wd.ClassUtils.getClass("GameObjectLOD"), activeGameObject = null;
                if (GameObjectLOD !== void 0) {
                    var gameObjectLOD = child.getComponent(GameObjectLOD);
                    activeGameObject = _this._getActiveGameObject(child, gameObjectLOD);
                    if (activeGameObject === null) {
                        return wdCb.Collection.create();
                    }
                }
                else {
                    activeGameObject = child;
                }
                if (activeGameObject.isVisible) {
                    renderList.push(activeGameObject);
                }
            });
            return wdCb.Collection.create(renderList);
        };
        RenderUtils._getActiveGameObject = function (source, gameObjectLOD) {
            if (!!gameObjectLOD) {
                return gameObjectLOD.activeGameObject;
            }
            return source;
        };
        return RenderUtils;
    }());
    wd.RenderUtils = RenderUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShaderLibUtils = (function () {
        function ShaderLibUtils() {
        }
        ShaderLibUtils.addVerticeShaderLib = function (geometry, shader) {
            if (wd.GlobalGeometryUtils.hasMorphAnimation(geometry)) {
                shader.addLib(wd.ClassUtils.getClass("CommonMorphShaderLib").create());
                shader.addLib(wd.ClassUtils.getClass("VerticeMorphShaderLib").create());
            }
            else if (wd.GlobalGeometryUtils.hasSkinSkeletonAnimation(geometry)) {
                shader.addLib(wd.VerticeCommonShaderLib.create());
                shader.addLib(wd.ClassUtils.getClass("VerticeSkinSkeletonShaderLib").create());
            }
            else {
                shader.addLib(wd.VerticeCommonShaderLib.create());
            }
        };
        return ShaderLibUtils;
    }());
    wd.ShaderLibUtils = ShaderLibUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SortUtils = (function () {
        function SortUtils() {
        }
        SortUtils.insertSort = function (targetArr, compareFunc, isChangeSelf) {
            if (isChangeSelf === void 0) { isChangeSelf = false; }
            var resultArr = isChangeSelf ? targetArr : wdCb.ExtendUtils.extend([], targetArr);
            for (var i = 1, len = resultArr.length; i < len; i++) {
                for (var j = i; j > 0 && compareFunc(resultArr[j], resultArr[j - 1]); j--) {
                    this._swap(resultArr, j - 1, j);
                }
            }
            return resultArr;
        };
        SortUtils.quickSort = function (targetArr, compareFunc, isChangeSelf) {
            if (isChangeSelf === void 0) { isChangeSelf = false; }
            var resultArr = isChangeSelf ? targetArr : wdCb.ExtendUtils.extend([], targetArr);
            var sort = function (l, r) {
                if (l >= r) {
                    return;
                }
                var i = l, j = r, x = resultArr[l];
                while (i < j) {
                    while (i < j && compareFunc(x, resultArr[j])) {
                        j--;
                    }
                    if (i < j) {
                        resultArr[i++] = resultArr[j];
                    }
                    while (i < j && compareFunc(resultArr[i], x)) {
                        i++;
                    }
                    if (i < j) {
                        resultArr[j--] = resultArr[i];
                    }
                }
                resultArr[i] = x;
                sort(l, i - 1);
                sort(i + 1, r);
            };
            sort(0, resultArr.length - 1);
            return resultArr;
        };
        SortUtils._swap = function (children, i, j) {
            var t = null;
            t = children[i];
            children[i] = children[j];
            children[j] = t;
        };
        return SortUtils;
    }());
    wd.SortUtils = SortUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TimeController = (function () {
        function TimeController() {
            this.elapsed = null;
            this.pauseElapsed = 0;
            this.pauseTime = null;
            this.startTime = null;
        }
        TimeController.prototype.start = function () {
            this.startTime = this.getNow();
            this.pauseElapsed = null;
        };
        TimeController.prototype.stop = function () {
            this.startTime = null;
        };
        TimeController.prototype.pause = function () {
            this.pauseTime = this.getNow();
        };
        TimeController.prototype.resume = function () {
            this.pauseElapsed += this.getNow() - this.pauseTime;
            this.pauseTime = null;
        };
        TimeController.prototype.computeElapseTime = function (time) {
            if (this.pauseElapsed) {
                this.elapsed = time - this.pauseElapsed - this.startTime;
            }
            else {
                this.elapsed = time - this.startTime;
            }
            if (this.elapsed < 0) {
                this.elapsed = 0;
            }
            return this.elapsed;
        };
        __decorate([
            wd.ensure(function () {
                wd.assert(this.elapsed >= 0, wd.Log.info.FUNC_SHOULD("elapsed:" + this.elapsed, ">= 0"));
            })
        ], TimeController.prototype, "computeElapseTime", null);
        return TimeController;
    }());
    wd.TimeController = TimeController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var STARTING_FPS = 60, GAMETIME_SCALE = 1000;
    var DirectorTimeController = (function (_super) {
        __extends(DirectorTimeController, _super);
        function DirectorTimeController() {
            _super.apply(this, arguments);
            this.gameTime = null;
            this.fps = null;
            this.isTimeChange = false;
            this.deltaTime = null;
            this._lastTime = null;
        }
        DirectorTimeController.create = function () {
            var obj = new this();
            return obj;
        };
        DirectorTimeController.prototype.tick = function (time) {
            this.deltaTime = this._lastTime !== null ? time - this._lastTime : time;
            this._updateFps(this.deltaTime);
            this.gameTime = time / GAMETIME_SCALE;
            this._lastTime = time;
        };
        DirectorTimeController.prototype.start = function () {
            _super.prototype.start.call(this);
            this.isTimeChange = true;
            this.elapsed = 0;
        };
        DirectorTimeController.prototype.resume = function () {
            _super.prototype.resume.call(this);
            this.isTimeChange = true;
        };
        DirectorTimeController.prototype.getNow = function () {
            return wd.root.performance.now();
        };
        DirectorTimeController.prototype._updateFps = function (deltaTime) {
            if (this._lastTime === null) {
                this.fps = STARTING_FPS;
            }
            else {
                this.fps = 1000 / deltaTime;
            }
        };
        return DirectorTimeController;
    }(wd.TimeController));
    wd.DirectorTimeController = DirectorTimeController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonTimeController = (function (_super) {
        __extends(CommonTimeController, _super);
        function CommonTimeController() {
            _super.apply(this, arguments);
        }
        CommonTimeController.create = function () {
            var obj = new this();
            return obj;
        };
        CommonTimeController.prototype.getNow = function () {
            if (wd.Director.getInstance().isTimeChange) {
                return wd.Director.getInstance().elapsed;
            }
            return wd.root.performance.now();
        };
        return CommonTimeController;
    }(wd.TimeController));
    wd.CommonTimeController = CommonTimeController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    wd.DEG_TO_RAD = Math.PI / 180;
    wd.RAD_TO_DEG = 180 / Math.PI;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Vector2 = (function () {
        function Vector2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.values = new Float32Array(2);
            if (args.length > 0) {
                this.values[0] = args[0];
                this.values[1] = args[1];
            }
        }
        Vector2.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var m = null;
            if (args.length === 0) {
                m = new this();
            }
            else {
                m = new this(args[0], args[1]);
            }
            return m;
        };
        Object.defineProperty(Vector2.prototype, "x", {
            get: function () {
                return this.values[0];
            },
            set: function (x) {
                this.values[0] = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "y", {
            get: function () {
                return this.values[1];
            },
            set: function (y) {
                this.values[1] = y;
            },
            enumerable: true,
            configurable: true
        });
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
        };
        Vector2.prototype.add = function (v) {
            this.values[0] = this.values[0] + v.values[0];
            this.values[1] = this.values[1] + v.values[1];
            return this;
        };
        Vector2.prototype.mul = function (v) {
            this.values[0] = this.values[0] * v.values[0];
            this.values[1] = this.values[1] * v.values[1];
            return this;
        };
        Vector2.prototype.isEqual = function (v) {
            return this.x === v.x && this.y === v.y;
        };
        Vector2.prototype.clone = function () {
            return Vector2.create(this.x, this.y);
        };
        return Vector2;
    }());
    wd.Vector2 = Vector2;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Vector3 = (function () {
        function Vector3() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.values = null;
            this.values = new Float32Array(3);
            if (args.length > 0) {
                this.values[0] = args[0];
                this.values[1] = args[1];
                this.values[2] = args[2];
            }
        }
        Vector3.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var m = null;
            if (args.length === 0) {
                m = new this();
            }
            else {
                m = new this(args[0], args[1], args[2]);
            }
            return m;
        };
        Object.defineProperty(Vector3.prototype, "x", {
            get: function () {
                return this.values[0];
            },
            set: function (x) {
                this.values[0] = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "y", {
            get: function () {
                return this.values[1];
            },
            set: function (y) {
                this.values[1] = y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "z", {
            get: function () {
                return this.values[2];
            },
            set: function (z) {
                this.values[2] = z;
            },
            enumerable: true,
            configurable: true
        });
        Vector3.prototype.normalize = function () {
            var v = this.values;
            var d = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            if (d === 0) {
                v[0] = 0;
                v[1] = 0;
                v[2] = 0;
                return this;
            }
            v[0] = v[0] / d;
            v[1] = v[1] / d;
            v[2] = v[2] / d;
            if (v[0] === -0) {
                v[0] = 0;
            }
            if (v[1] === -0) {
                v[1] = 0;
            }
            if (v[2] === -0) {
                v[2] = 0;
            }
            return this;
        };
        Vector3.prototype.isZero = function () {
            var v = this.values;
            return v[0] === 0 && v[1] === 0 && v[2] === 0;
        };
        Vector3.prototype.scale = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var v = this.values;
            if (args.length === 1) {
                var scalar = args[0];
                v[0] *= scalar;
                v[1] *= scalar;
                v[2] *= scalar;
            }
            else if (args.length === 3) {
                var x = args[0], y = args[1], z = args[2];
                v[0] *= x;
                v[1] *= y;
                v[2] *= z;
            }
            return this;
        };
        Vector3.prototype.set = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 3) {
                this.x = args[0];
                this.y = args[1];
                this.z = args[2];
            }
            else {
                var v = args[0];
                this.x = v.x;
                this.y = v.y;
                this.z = v.z;
            }
        };
        Vector3.prototype.sub = function (v) {
            this.values[0] = this.values[0] - v.values[0];
            this.values[1] = this.values[1] - v.values[1];
            this.values[2] = this.values[2] - v.values[2];
            return this;
        };
        Vector3.prototype.sub2 = function (v1, v2) {
            this.values[0] = v1.values[0] - v2.values[0];
            this.values[1] = v1.values[1] - v2.values[1];
            this.values[2] = v1.values[2] - v2.values[2];
            return this;
        };
        Vector3.prototype.add = function (v) {
            this.values[0] = this.values[0] + v.values[0];
            this.values[1] = this.values[1] + v.values[1];
            this.values[2] = this.values[2] + v.values[2];
            return this;
        };
        Vector3.prototype.add2 = function (v1, v2) {
            this.values[0] = v1.values[0] + v2.values[0];
            this.values[1] = v1.values[1] + v2.values[1];
            this.values[2] = v1.values[2] + v2.values[2];
            return this;
        };
        Vector3.prototype.mul = function (v) {
            this.values[0] = this.values[0] * v.values[0];
            this.values[1] = this.values[1] * v.values[1];
            this.values[2] = this.values[2] * v.values[2];
            return this;
        };
        Vector3.prototype.mul2 = function (v1, v2) {
            this.values[0] = v1.values[0] * v2.values[0];
            this.values[1] = v1.values[1] * v2.values[1];
            this.values[2] = v1.values[2] * v2.values[2];
            return this;
        };
        Vector3.prototype.reverse = function () {
            this.values[0] = -this.values[0];
            this.values[1] = -this.values[1];
            this.values[2] = -this.values[2];
            return this;
        };
        Vector3.prototype.clone = function () {
            var result = Vector3.create(), i = 0, len = this.values.length;
            for (i = 0; i < len; i++) {
                result.values[i] = this.values[i];
            }
            return result;
        };
        Vector3.prototype.toVector4 = function () {
            return wd.Vector4.create(this.values[0], this.values[1], this.values[2], 1.0);
        };
        Vector3.prototype.length = function () {
            var v = this.values;
            return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        };
        Vector3.prototype.cross = function (lhs, rhs) {
            var a, b, r, ax, ay, az, bx, by, bz;
            a = lhs.values;
            b = rhs.values;
            r = this.values;
            ax = a[0];
            ay = a[1];
            az = a[2];
            bx = b[0];
            by = b[1];
            bz = b[2];
            r[0] = ay * bz - by * az;
            r[1] = az * bx - bz * ax;
            r[2] = ax * by - bx * ay;
            return this;
        };
        Vector3.prototype.lerp = function (lhs, rhs, alpha) {
            var a = lhs.values, b = rhs.values, r = this.values;
            r[0] = a[0] + alpha * (b[0] - a[0]);
            r[1] = a[1] + alpha * (b[1] - a[1]);
            r[2] = a[2] + alpha * (b[2] - a[2]);
            return this;
        };
        Vector3.prototype.dot = function (rhs) {
            var a = this.values, b = rhs.values;
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        };
        Vector3.prototype.calAngleCos = function (v1) {
            var l = this.length() * v1.length();
            if (l === 0) {
                return NaN;
            }
            return this.dot(v1) / l;
        };
        Vector3.prototype.min = function (v) {
            if (this.x > v.x) {
                this.x = v.x;
            }
            if (this.y > v.y) {
                this.y = v.y;
            }
            if (this.z > v.z) {
                this.z = v.z;
            }
            return this;
        };
        Vector3.prototype.max = function (v) {
            if (this.x < v.x) {
                this.x = v.x;
            }
            if (this.y < v.y) {
                this.y = v.y;
            }
            if (this.z < v.z) {
                this.z = v.z;
            }
            return this;
        };
        Vector3.prototype.isEqual = function (v) {
            return this.x === v.x && this.y === v.y && this.z === v.z;
        };
        Vector3.prototype.toArray = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.applyMatrix3 = function (m) {
            var x = this.x, y = this.y, z = this.z, e = m.values;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        };
        Vector3.prototype.applyMatrix4 = function (m) {
            var x = this.x, y = this.y, z = this.z, e = m.values;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
            return this;
        };
        Vector3.prototype.distanceTo = function (v) {
            return Math.sqrt(this.distanceToSquared(v));
        };
        Vector3.prototype.distanceToSquared = function (v) {
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
            return Math.pow(dx, 2) + Math.pow(dy, 2) + Math.pow(dz, 2);
        };
        Vector3.up = Vector3.create(0, 1, 0);
        Vector3.forward = Vector3.create(0, 0, 1);
        Vector3.right = Vector3.create(1, 0, 0);
        return Vector3;
    }());
    wd.Vector3 = Vector3;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Vector4 = (function () {
        function Vector4() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.values = new Float32Array(4);
            if (args.length > 0) {
                this.values[0] = args[0];
                this.values[1] = args[1];
                this.values[2] = args[2];
                this.values[3] = args[3];
            }
        }
        Vector4.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var m = null;
            if (args.length === 0) {
                m = new this();
            }
            else {
                m = new this(args[0], args[1], args[2], args[3]);
            }
            return m;
        };
        Object.defineProperty(Vector4.prototype, "x", {
            get: function () {
                return this.values[0];
            },
            set: function (x) {
                this.values[0] = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "y", {
            get: function () {
                return this.values[1];
            },
            set: function (y) {
                this.values[1] = y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "z", {
            get: function () {
                return this.values[2];
            },
            set: function (z) {
                this.values[2] = z;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "w", {
            get: function () {
                return this.values[3];
            },
            set: function (w) {
                this.values[3] = w;
            },
            enumerable: true,
            configurable: true
        });
        Vector4.prototype.normalize = function () {
            var v = this.values;
            var d = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3]);
            if (d === 0) {
                return Vector4.create(0, 0, 0, 0);
            }
            v[0] = v[0] / d;
            v[1] = v[1] / d;
            v[2] = v[2] / d;
            v[3] = v[3] / d;
            return this;
        };
        Vector4.prototype.isEqual = function (v) {
            return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
        };
        Vector4.prototype.clone = function () {
            return this.copyHelper(Vector4.create());
        };
        Vector4.prototype.toVector3 = function () {
            return wd.Vector3.create(this.values[0], this.values[1], this.values[2]);
        };
        Vector4.prototype.lengthManhattan = function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        };
        Vector4.prototype.multiplyScalar = function (scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
            return this;
        };
        Vector4.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        };
        Vector4.prototype.copyHelper = function (vector4) {
            var result = vector4, i = 0, len = this.values.length;
            for (i = 0; i < len; i++) {
                result.values[i] = this.values[i];
            }
            return result;
        };
        return Vector4;
    }());
    wd.Vector4 = Vector4;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Matrix4 = (function () {
        function Matrix4() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.values = null;
            this._matrixArr = null;
            if (args.length === 1) {
                this.values = args[0];
            }
            else {
                this.values = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }
            this._matrixArr = [];
        }
        Matrix4.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var m = null;
            if (args.length === 0) {
                m = new this();
            }
            else {
                m = new this(args[0]);
            }
            return m;
        };
        Matrix4.prototype.push = function () {
            this._matrixArr.push(this.values);
        };
        Matrix4.prototype.pop = function () {
            this.values = this._matrixArr.pop();
        };
        Matrix4.prototype.set = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var te = this.values, values = null;
            if (args.length === 1) {
                var matrix = args[0];
                values = matrix.values;
            }
            else {
                values = [
                    args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9], args[10], args[11], args[12], args[13], args[14], args[15]
                ];
            }
            te[0] = values[0];
            te[1] = values[1];
            te[2] = values[2];
            te[3] = values[3];
            te[4] = values[4];
            te[5] = values[5];
            te[6] = values[6];
            te[7] = values[7];
            te[8] = values[8];
            te[9] = values[9];
            te[10] = values[10];
            te[11] = values[11];
            te[12] = values[12];
            te[13] = values[13];
            te[14] = values[14];
            te[15] = values[15];
            return this;
        };
        Matrix4.prototype.setIdentity = function () {
            var e = this.values;
            e[0] = 1;
            e[4] = 0;
            e[8] = 0;
            e[12] = 0;
            e[1] = 0;
            e[5] = 1;
            e[9] = 0;
            e[13] = 0;
            e[2] = 0;
            e[6] = 0;
            e[10] = 1;
            e[14] = 0;
            e[3] = 0;
            e[7] = 0;
            e[11] = 0;
            e[15] = 1;
            return this;
        };
        Matrix4.prototype.invert = function () {
            var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, invDet, m;
            m = this.values;
            a00 = m[0];
            a01 = m[1];
            a02 = m[2];
            a03 = m[3];
            a10 = m[4];
            a11 = m[5];
            a12 = m[6];
            a13 = m[7];
            a20 = m[8];
            a21 = m[9];
            a22 = m[10];
            a23 = m[11];
            a30 = m[12];
            a31 = m[13];
            a32 = m[14];
            a33 = m[15];
            b00 = a00 * a11 - a01 * a10;
            b01 = a00 * a12 - a02 * a10;
            b02 = a00 * a13 - a03 * a10;
            b03 = a01 * a12 - a02 * a11;
            b04 = a01 * a13 - a03 * a11;
            b05 = a02 * a13 - a03 * a12;
            b06 = a20 * a31 - a21 * a30;
            b07 = a20 * a32 - a22 * a30;
            b08 = a20 * a33 - a23 * a30;
            b09 = a21 * a32 - a22 * a31;
            b10 = a21 * a33 - a23 * a31;
            b11 = a22 * a33 - a23 * a32;
            invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);
            m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
            m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
            m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
            m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
            m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
            m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
            m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
            m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
            m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
            m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
            m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
            m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
            m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
            m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
            m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
            m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
            return this;
        };
        Matrix4.prototype.invertTo3x3 = function () {
            var a11, a21, a31, a12, a22, a32, a13, a23, a33, m, r, det, idet;
            var mat3 = wd.Matrix3.create();
            m = this.values;
            r = mat3.values;
            a11 = m[10] * m[5] - m[6] * m[9];
            a21 = -m[10] * m[1] + m[2] * m[9];
            a31 = m[6] * m[1] - m[2] * m[5];
            a12 = -m[10] * m[4] + m[6] * m[8];
            a22 = m[10] * m[0] - m[2] * m[8];
            a32 = -m[6] * m[0] + m[2] * m[4];
            a13 = m[9] * m[4] - m[5] * m[8];
            a23 = -m[9] * m[0] + m[1] * m[8];
            a33 = m[5] * m[0] - m[1] * m[4];
            det = m[0] * a11 + m[1] * a12 + m[2] * a13;
            if (det === 0) {
                wd.Log.warn("can't invert matrix, determinant is 0");
                return mat3;
            }
            idet = 1 / det;
            r[0] = idet * a11;
            r[1] = idet * a21;
            r[2] = idet * a31;
            r[3] = idet * a12;
            r[4] = idet * a22;
            r[5] = idet * a32;
            r[6] = idet * a13;
            r[7] = idet * a23;
            r[8] = idet * a33;
            return mat3;
        };
        Matrix4.prototype.transpose = function () {
            var te = this.values;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        };
        Matrix4.prototype.setTranslate = function (x, y, z) {
            var e = this.values;
            e[0] = 1;
            e[4] = 0;
            e[8] = 0;
            e[12] = x;
            e[1] = 0;
            e[5] = 1;
            e[9] = 0;
            e[13] = y;
            e[2] = 0;
            e[6] = 0;
            e[10] = 1;
            e[14] = z;
            e[3] = 0;
            e[7] = 0;
            e[11] = 0;
            e[15] = 1;
            return this;
        };
        Matrix4.prototype.translate = function (x, y, z) {
            this.applyMatrix(Matrix4.create().setTranslate(x, y, z));
            return this;
        };
        Matrix4.prototype.setRotate = function (angle, x, y, z) {
            var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;
            var angle = Math.PI * angle / 180;
            e = this.values;
            s = Math.sin(angle);
            c = Math.cos(angle);
            if (0 !== x && 0 === y && 0 === z) {
                if (x < 0) {
                    s = -s;
                }
                e[0] = 1;
                e[4] = 0;
                e[8] = 0;
                e[12] = 0;
                e[1] = 0;
                e[5] = c;
                e[9] = -s;
                e[13] = 0;
                e[2] = 0;
                e[6] = s;
                e[10] = c;
                e[14] = 0;
                e[3] = 0;
                e[7] = 0;
                e[11] = 0;
                e[15] = 1;
            }
            else if (0 === x && 0 !== y && 0 === z) {
                if (y < 0) {
                    s = -s;
                }
                e[0] = c;
                e[4] = 0;
                e[8] = s;
                e[12] = 0;
                e[1] = 0;
                e[5] = 1;
                e[9] = 0;
                e[13] = 0;
                e[2] = -s;
                e[6] = 0;
                e[10] = c;
                e[14] = 0;
                e[3] = 0;
                e[7] = 0;
                e[11] = 0;
                e[15] = 1;
            }
            else if (0 === x && 0 === y && 0 !== z) {
                if (z < 0) {
                    s = -s;
                }
                e[0] = c;
                e[4] = -s;
                e[8] = 0;
                e[12] = 0;
                e[1] = s;
                e[5] = c;
                e[9] = 0;
                e[13] = 0;
                e[2] = 0;
                e[6] = 0;
                e[10] = 1;
                e[14] = 0;
                e[3] = 0;
                e[7] = 0;
                e[11] = 0;
                e[15] = 1;
            }
            else {
                len = Math.sqrt(x * x + y * y + z * z);
                if (len !== 1) {
                    rlen = 1 / len;
                    x *= rlen;
                    y *= rlen;
                    z *= rlen;
                }
                nc = 1 - c;
                xy = x * y;
                yz = y * z;
                zx = z * x;
                xs = x * s;
                ys = y * s;
                zs = z * s;
                e[0] = x * x * nc + c;
                e[1] = xy * nc + zs;
                e[2] = zx * nc - ys;
                e[3] = 0;
                e[4] = xy * nc - zs;
                e[5] = y * y * nc + c;
                e[6] = yz * nc + xs;
                e[7] = 0;
                e[8] = zx * nc + ys;
                e[9] = yz * nc - xs;
                e[10] = z * z * nc + c;
                e[11] = 0;
                e[12] = 0;
                e[13] = 0;
                e[14] = 0;
                e[15] = 1;
            }
            return this;
        };
        Matrix4.prototype.rotate = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var angle = args[0];
            if (args.length === 2) {
                var vector3 = args[1];
                this.applyMatrix(Matrix4.create().setRotate(angle, vector3.values[0], vector3.values[1], vector3.values[2]));
            }
            else if (args.length === 4) {
                var x = args[1], y = args[2], z = args[3];
                this.applyMatrix(Matrix4.create().setRotate(angle, x, y, z));
            }
            return this;
        };
        Matrix4.prototype.setScale = function (x, y, z) {
            var e = this.values;
            e[0] = x;
            e[4] = 0;
            e[8] = 0;
            e[12] = 0;
            e[1] = 0;
            e[5] = y;
            e[9] = 0;
            e[13] = 0;
            e[2] = 0;
            e[6] = 0;
            e[10] = z;
            e[14] = 0;
            e[3] = 0;
            e[7] = 0;
            e[11] = 0;
            e[15] = 1;
            return this;
        };
        Matrix4.prototype.scale = function (x, y, z) {
            this.applyMatrix(Matrix4.create().setScale(x, y, z));
            return this;
        };
        Matrix4.prototype.setLookAt = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var x, y, z, eye, center, up;
            if (args.length === 3) {
                eye = args[0];
                center = args[1];
                up = args[2];
            }
            else if (args.length === 9) {
                eye = wd.Vector3.create(args[0], args[1], args[2]);
                center = wd.Vector3.create(args[3], args[4], args[5]);
                up = wd.Vector3.create(args[6], args[7], args[8]);
            }
            x = wd.Vector3.create();
            z = eye.clone().sub(center).normalize();
            y = up.clone().normalize();
            x.cross(y, z).normalize();
            y.cross(z, x);
            var r = this.values;
            r[0] = x.x;
            r[1] = x.y;
            r[2] = x.z;
            r[3] = 0;
            r[4] = y.x;
            r[5] = y.y;
            r[6] = y.z;
            r[7] = 0;
            r[8] = z.x;
            r[9] = z.y;
            r[10] = z.z;
            r[11] = 0;
            r[12] = eye.x;
            r[13] = eye.y;
            r[14] = eye.z;
            r[15] = 1;
            return this;
        };
        Matrix4.prototype.lookAt = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var matrix = Matrix4.create();
            this.applyMatrix(matrix.setLookAt.apply(matrix, args));
            return this;
        };
        Matrix4.prototype.setOrtho = function (left, right, bottom, top, near, far) {
            var e = this.values, rw, rh, rd;
            rw = 1 / (right - left);
            rh = 1 / (top - bottom);
            rd = 1 / (far - near);
            e[0] = 2 * rw;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = 2 * rh;
            e[6] = 0;
            e[7] = 0;
            e[8] = 0;
            e[9] = 0;
            e[10] = -2 * rd;
            e[11] = 0;
            e[12] = -(right + left) * rw;
            e[13] = -(top + bottom) * rh;
            e[14] = -(far + near) * rd;
            e[15] = 1;
            return this;
        };
        Matrix4.prototype.ortho = function (left, right, bottom, top, near, far) {
            this.applyMatrix(Matrix4.create().setOrtho(left, right, bottom, top, near, far));
            return this;
        };
        Matrix4.prototype.setPerspective = function (fovy, aspect, near, far) {
            var e = null, rd = null, s = null, ct = null, fovy = Math.PI * fovy / 180 / 2;
            s = Math.sin(fovy);
            wd.Log.error(s === 0, wd.Log.info.FUNC_MUST_NOT_BE("frustum", "null"));
            rd = 1 / (far - near);
            ct = Math.cos(fovy) / s;
            e = this.values;
            e[0] = ct / aspect;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = ct;
            e[6] = 0;
            e[7] = 0;
            e[8] = 0;
            e[9] = 0;
            e[10] = -(far + near) * rd;
            e[11] = -1;
            e[12] = 0;
            e[13] = 0;
            e[14] = -2 * near * far * rd;
            e[15] = 0;
            return this;
        };
        Matrix4.prototype.perspective = function (fovy, aspect, near, far) {
            this.applyMatrix(Matrix4.create().setPerspective(fovy, aspect, near, far));
            return this;
        };
        Matrix4.prototype.applyMatrix = function (other, notChangeSelf) {
            if (notChangeSelf === void 0) { notChangeSelf = false; }
            var a = this, b = other.clone();
            if (notChangeSelf) {
                return b.multiply(a);
            }
            this.values = b.multiply(a).values;
            return this;
        };
        Matrix4.prototype.multiply = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var mat1 = null, mat2 = null, result = null;
            result = this.values;
            if (args.length === 1) {
                mat1 = this.values;
                mat2 = args[0].values;
            }
            else if (args.length === 2) {
                mat1 = args[0].values;
                mat2 = args[1].values;
            }
            var a = mat1[0], b = mat1[1], c = mat1[2], d = mat1[3], e = mat1[4], f = mat1[5], g = mat1[6], h = mat1[7], i = mat1[8], j = mat1[9], k = mat1[10], l = mat1[11], m = mat1[12], n = mat1[13], o = mat1[14], p = mat1[15], A = mat2[0], B = mat2[1], C = mat2[2], D = mat2[3], E = mat2[4], F = mat2[5], G = mat2[6], H = mat2[7], I = mat2[8], J = mat2[9], K = mat2[10], L = mat2[11], M = mat2[12], N = mat2[13], O = mat2[14], P = mat2[15];
            result[0] = A * a + B * e + C * i + D * m;
            result[1] = A * b + B * f + C * j + D * n;
            result[2] = A * c + B * g + C * k + D * o;
            result[3] = A * d + B * h + C * l + D * p;
            result[4] = E * a + F * e + G * i + H * m;
            result[5] = E * b + F * f + G * j + H * n;
            result[6] = E * c + F * g + G * k + H * o;
            result[7] = E * d + F * h + G * l + H * p;
            result[8] = I * a + J * e + K * i + L * m;
            result[9] = I * b + J * f + K * j + L * n;
            result[10] = I * c + J * g + K * k + L * o;
            result[11] = I * d + J * h + K * l + L * p;
            result[12] = M * a + N * e + O * i + P * m;
            result[13] = M * b + N * f + O * j + P * n;
            result[14] = M * c + N * g + O * k + P * o;
            result[15] = M * d + N * h + O * l + P * p;
            return this;
        };
        Matrix4.prototype.multiplyVector4 = function (vector) {
            var mat1 = this.values, vec4 = vector.values;
            var result = [];
            result[0] = vec4[0] * mat1[0] + vec4[1] * mat1[4] + vec4[2] * mat1[8] + vec4[3] * mat1[12];
            result[1] = vec4[0] * mat1[1] + vec4[1] * mat1[5] + vec4[2] * mat1[9] + vec4[3] * mat1[13];
            result[2] = vec4[0] * mat1[2] + vec4[1] * mat1[6] + vec4[2] * mat1[10] + vec4[3] * mat1[14];
            result[3] = vec4[0] * mat1[3] + vec4[1] * mat1[7] + vec4[2] * mat1[11] + vec4[3] * mat1[15];
            return wd.Vector4.create(result[0], result[1], result[2], result[3]);
        };
        Matrix4.prototype.multiplyVector3 = function (vector) {
            var mat1 = this.values, vec3 = vector.values;
            var result = [];
            result[0] = vec3[0] * mat1[0] + vec3[1] * mat1[4] + vec3[2] * mat1[8];
            result[1] = vec3[0] * mat1[1] + vec3[1] * mat1[5] + vec3[2] * mat1[9];
            result[2] = vec3[0] * mat1[2] + vec3[1] * mat1[6] + vec3[2] * mat1[10];
            return wd.Vector3.create(result[0], result[1], result[2]);
        };
        Matrix4.prototype.multiplyPoint = function (vector) {
            var mat1 = this.values, vec3 = vector.values;
            var result = [];
            result[0] = vec3[0] * mat1[0] + vec3[1] * mat1[4] + vec3[2] * mat1[8] + mat1[12];
            result[1] = vec3[0] * mat1[1] + vec3[1] * mat1[5] + vec3[2] * mat1[9] + mat1[13];
            result[2] = vec3[0] * mat1[2] + vec3[1] * mat1[6] + vec3[2] * mat1[10] + mat1[14];
            return wd.Vector3.create(result[0], result[1], result[2]);
        };
        Matrix4.prototype.clone = function () {
            var result = Matrix4.create(), i = 0, len = this.values.length;
            for (i = 0; i < len; i++) {
                result.values[i] = this.values[i];
            }
            return result;
        };
        Matrix4.prototype.cloneToArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            var values = this.values;
            for (var index = 0; index < 16; index++) {
                array[offset + index] = values[index];
            }
            return this;
        };
        Matrix4.prototype.getX = function () {
            return wd.Vector3.create(this.values[0], this.values[1], this.values[2]);
        };
        Matrix4.prototype.getY = function () {
            return wd.Vector3.create(this.values[4], this.values[5], this.values[6]);
        };
        Matrix4.prototype.getZ = function () {
            return wd.Vector3.create(this.values[8], this.values[9], this.values[10]);
        };
        Matrix4.prototype.getTranslation = function () {
            return wd.Vector3.create(this.values[12], this.values[13], this.values[14]);
        };
        Matrix4.prototype.getScale = function () {
            return wd.Vector3.create(this.getX().length(), this.getY().length(), this.getZ().length());
        };
        Matrix4.prototype.getRotation = function () {
            return wd.Quaternion.create().setFromMatrix(this);
        };
        Matrix4.prototype.getEulerAngles = function () {
            var x, y, z, sx, sy, sz, m, halfPi;
            var scale = this.getScale();
            sx = scale.x;
            sy = scale.y;
            sz = scale.z;
            m = this.values;
            y = Math.asin(-m[2] / sx);
            halfPi = Math.PI * 0.5;
            if (y < halfPi) {
                if (y > -halfPi) {
                    x = Math.atan2(m[6] / sy, m[10] / sz);
                    z = Math.atan2(m[1] / sx, m[0] / sx);
                }
                else {
                    z = 0;
                    x = -Math.atan2(m[4] / sy, m[5] / sy);
                }
            }
            else {
                z = 0;
                x = Math.atan2(m[4] / sy, m[5] / sy);
            }
            return wd.Vector3.create(x, y, z).scale(wd.RAD_TO_DEG);
        };
        Matrix4.prototype.setTRS = function (t, r, s) {
            var tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, x2, y2, z2, xx, xy, xz, yy, yz, zz, wx, wy, wz, m;
            tx = t.x;
            ty = t.y;
            tz = t.z;
            qx = r.x;
            qy = r.y;
            qz = r.z;
            qw = r.w;
            sx = s.x;
            sy = s.y;
            sz = s.z;
            x2 = qx + qx;
            y2 = qy + qy;
            z2 = qz + qz;
            xx = qx * x2;
            xy = qx * y2;
            xz = qx * z2;
            yy = qy * y2;
            yz = qy * z2;
            zz = qz * z2;
            wx = qw * x2;
            wy = qw * y2;
            wz = qw * z2;
            m = this.values;
            m[0] = (1 - (yy + zz)) * sx;
            m[1] = (xy + wz) * sx;
            m[2] = (xz - wy) * sx;
            m[3] = 0;
            m[4] = (xy - wz) * sy;
            m[5] = (1 - (xx + zz)) * sy;
            m[6] = (yz + wx) * sy;
            m[7] = 0;
            m[8] = (xz + wy) * sz;
            m[9] = (yz - wx) * sz;
            m[10] = (1 - (xx + yy)) * sz;
            m[11] = 0;
            m[12] = tx;
            m[13] = ty;
            m[14] = tz;
            m[15] = 1;
            return this;
        };
        __decorate([
            wd.require(function (angle, x, y, z) {
                wd.it("axis's component shouldn't all be zero", function () {
                    wd.expect(x === 0 && y === 0 && z === 0).false;
                });
            })
        ], Matrix4.prototype, "setRotate", null);
        __decorate([
            wd.require(function (left, right, bottom, top, near, far) {
                wd.assert(left !== right && bottom !== top && near !== far, wd.Log.info.FUNC_MUST_NOT_BE("frustum", "null"));
            })
        ], Matrix4.prototype, "setOrtho", null);
        __decorate([
            wd.require(function (fovy, aspect, near, far) {
                wd.assert(near !== far && aspect !== 0, wd.Log.info.FUNC_MUST_NOT_BE("frustum", "null"));
                wd.assert(near > 0, wd.Log.info.FUNC_MUST("near", "> 0"));
                wd.assert(far > 0, wd.Log.info.FUNC_MUST("far", "> 0"));
            })
        ], Matrix4.prototype, "setPerspective", null);
        return Matrix4;
    }());
    wd.Matrix4 = Matrix4;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Matrix3 = (function () {
        function Matrix3() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.values = null;
            if (args.length === 1) {
                this.values = args[0];
            }
            else {
                this.values = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            }
        }
        Matrix3.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var m = null;
            if (args.length === 0) {
                m = new this();
            }
            else {
                m = new this(args[0]);
            }
            return m;
        };
        Object.defineProperty(Matrix3.prototype, "a", {
            get: function () {
                return this.values[0];
            },
            set: function (a) {
                this.values[0] = a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3.prototype, "c", {
            get: function () {
                return this.values[1];
            },
            set: function (c) {
                this.values[1] = c;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3.prototype, "b", {
            get: function () {
                return this.values[3];
            },
            set: function (b) {
                this.values[3] = b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3.prototype, "d", {
            get: function () {
                return this.values[4];
            },
            set: function (d) {
                this.values[4] = d;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3.prototype, "tx", {
            get: function () {
                return this.values[6];
            },
            set: function (tx) {
                this.values[6] = tx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3.prototype, "ty", {
            get: function () {
                return this.values[7];
            },
            set: function (ty) {
                this.values[7] = ty;
            },
            enumerable: true,
            configurable: true
        });
        Matrix3.prototype.setIdentity = function () {
            var e = this.values;
            e[0] = 1;
            e[3] = 0;
            e[6] = 0;
            e[1] = 0;
            e[4] = 1;
            e[7] = 0;
            e[2] = 0;
            e[5] = 0;
            e[8] = 1;
            return this;
        };
        Matrix3.prototype.invert = function () {
            var a1 = this.values[0];
            var b1 = this.values[1];
            var c1 = this.values[3];
            var d1 = this.values[4];
            var tx1 = this.values[6];
            var ty1 = this.values[7];
            var n = a1 * d1 - b1 * c1;
            this.values[0] = d1 / n;
            this.values[1] = -b1 / n;
            this.values[3] = -c1 / n;
            this.values[4] = a1 / n;
            this.values[6] = (c1 * ty1 - d1 * tx1) / n;
            this.values[7] = -(a1 * ty1 - b1 * tx1) / n;
            return this;
        };
        Matrix3.prototype.multiplyScalar = function (s) {
            var te = this.values;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        };
        Matrix3.prototype.multiplyVector2 = function (vector) {
            var x = vector.x, y = vector.y, result = wd.Vector2.create(), e = this.values;
            result.x = e[0] * x + e[3] * y;
            result.y = e[1] * x + e[4] * y;
            return result;
        };
        Matrix3.prototype.multiplyPoint = function (vector) {
            var x = vector.x, y = vector.y, result = wd.Vector2.create(), e = this.values;
            result.x = e[0] * x + e[3] * y + this.tx;
            result.y = e[1] * x + e[4] * y + this.ty;
            return result;
        };
        Matrix3.prototype.multiply = function (matrix) {
            var m11 = this.a * matrix.a + this.c * matrix.b;
            var m12 = this.b * matrix.a + this.d * matrix.b;
            var m21 = this.a * matrix.c + this.c * matrix.d;
            var m22 = this.b * matrix.c + this.d * matrix.d;
            var dx = this.a * matrix.tx + this.c * matrix.ty + this.tx;
            var dy = this.b * matrix.tx + this.d * matrix.ty + this.ty;
            this.a = m11;
            this.b = m12;
            this.c = m21;
            this.d = m22;
            this.tx = dx;
            this.ty = dy;
            return this;
        };
        Matrix3.prototype.transpose = function () {
            var tmp, m = this.values;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        };
        Matrix3.prototype.clone = function () {
            return Matrix3.create().set(this);
        };
        Matrix3.prototype.cloneToArray = function (array, offset) {
            if (offset === void 0) { offset = 0; }
            var values = this.values;
            for (var index = 0; index < 9; index++) {
                array[offset + index] = values[index];
            }
            return this;
        };
        Matrix3.prototype.set = function (matrix) {
            var te = this.values, values = matrix.values;
            te[0] = values[0];
            te[3] = values[3];
            te[6] = values[6];
            te[1] = values[1];
            te[4] = values[4];
            te[7] = values[7];
            te[2] = values[2];
            te[5] = values[5];
            te[8] = values[8];
            return this;
        };
        Matrix3.prototype.setTS = function (t, s) {
            this.setPosition(t.x, t.y);
            this.setScale(s.x, s.y);
        };
        Matrix3.prototype.rotate = function (angle) {
            var rad = angle * wd.DEG_TO_RAD;
            var c = Math.cos(rad);
            var s = Math.sin(rad);
            var m11 = this.a * c + this.c * s;
            var m12 = this.b * c + this.d * s;
            var m21 = this.a * -s + this.c * c;
            var m22 = this.b * -s + this.d * c;
            this.a = m11;
            this.b = m12;
            this.c = m21;
            this.d = m22;
            return this;
        };
        Matrix3.prototype.setRotation = function (angle) {
            var rad = angle * wd.DEG_TO_RAD;
            var cos_a = Math.cos(rad);
            var sin_a = Math.sin(rad);
            var values = this.values;
            values[0] = cos_a;
            values[1] = -sin_a;
            values[3] = sin_a;
            values[4] = cos_a;
            return this;
        };
        Matrix3.prototype.translate = function (x, y) {
            this.tx += this.a * x + this.c * y;
            this.ty += this.b * x + this.d * y;
        };
        Matrix3.prototype.setPosition = function (x, y) {
            this.tx = x;
            this.ty = y;
        };
        Matrix3.prototype.scale = function (x, y) {
            this.a *= x;
            this.b *= x;
            this.c *= y;
            this.d *= y;
            return this;
        };
        Matrix3.prototype.setScale = function (x, y) {
            var values = this.values;
            values[0] = x;
            values[4] = y;
            return this;
        };
        Matrix3.prototype.getTranslation = function () {
            return wd.Vector2.create(this.tx, this.ty);
        };
        Matrix3.prototype.getScale = function () {
            return wd.Vector2.create(Math.sqrt(this.a * this.a + this.b * this.b), Math.sqrt(this.c * this.c + this.d * this.d));
        };
        Matrix3.prototype.getRotation = function () {
            return this._getSkewX();
        };
        Matrix3.prototype.getSkew = function () {
            return wd.Vector2.create(this._getSkewX(), this._getSkewY());
        };
        Matrix3.prototype._getDeltaTransformPoint = function (matrix, point) {
            return {
                x: point.x * matrix.a + point.y * matrix.c + 0,
                y: point.x * matrix.b + point.y * matrix.d + 0
            };
        };
        Matrix3.prototype._getSkewX = function () {
            var px = this._getDeltaTransformPoint(this, { x: 0, y: 1 });
            return ((180 / Math.PI) * Math.atan2(px.y, px.x) - 90);
        };
        Matrix3.prototype._getSkewY = function () {
            var py = this._getDeltaTransformPoint(this, { x: 1, y: 0 });
            return ((180 / Math.PI) * Math.atan2(py.y, py.x));
        };
        return Matrix3;
    }());
    wd.Matrix3 = Matrix3;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Quaternion = (function () {
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (z === void 0) { z = 0; }
            if (w === void 0) { w = 1; }
            this.x = null;
            this.y = null;
            this.z = null;
            this.w = null;
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Quaternion.create = function (x, y, z, w) {
            var obj = new this(x, y, z, w);
            return obj;
        };
        Quaternion.prototype.setFromEulerAngles = function (eulerAngles) {
            var sx, cx, sy, cy, sz, cz, halfToRad, ex = eulerAngles.x, ey = eulerAngles.y, ez = eulerAngles.z;
            halfToRad = 0.5 * wd.DEG_TO_RAD;
            ex *= halfToRad;
            ey *= halfToRad;
            ez *= halfToRad;
            sx = Math.sin(ex);
            cx = Math.cos(ex);
            sy = Math.sin(ey);
            cy = Math.cos(ey);
            sz = Math.sin(ez);
            cz = Math.cos(ez);
            this.x = sx * cy * cz - cx * sy * sz;
            this.y = cx * sy * cz + sx * cy * sz;
            this.z = cx * cy * sz - sx * sy * cz;
            this.w = cx * cy * cz + sx * sy * sz;
            return this;
        };
        Quaternion.prototype.multiply = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w, rhs1, rhs2, result = this;
            if (args.length === 1) {
                rhs1 = this;
                rhs2 = args[0];
            }
            else if (args.length === 2) {
                rhs1 = args[0];
                rhs2 = args[1];
            }
            q1x = rhs1.x;
            q1y = rhs1.y;
            q1z = rhs1.z;
            q1w = rhs1.w;
            q2x = rhs2.x;
            q2y = rhs2.y;
            q2z = rhs2.z;
            q2w = rhs2.w;
            result.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
            result.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
            result.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
            result.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
            return result;
        };
        Quaternion.prototype.setFromMatrix = function (matrix) {
            var m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz, m;
            m = matrix.values;
            m00 = m[0];
            m01 = m[1];
            m02 = m[2];
            m10 = m[4];
            m11 = m[5];
            m12 = m[6];
            m20 = m[8];
            m21 = m[9];
            m22 = m[10];
            lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
            ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
            lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);
            m00 *= lx;
            m01 *= lx;
            m02 *= lx;
            m10 *= ly;
            m11 *= ly;
            m12 *= ly;
            m20 *= lz;
            m21 *= lz;
            m22 *= lz;
            tr = m00 + m11 + m22;
            if (tr >= 0) {
                s = Math.sqrt(tr + 1);
                this.w = s * 0.5;
                s = 0.5 / s;
                this.x = (m12 - m21) * s;
                this.y = (m20 - m02) * s;
                this.z = (m01 - m10) * s;
            }
            else {
                if (m00 > m11) {
                    if (m00 > m22) {
                        rs = (m00 - (m11 + m22)) + 1;
                        rs = Math.sqrt(rs);
                        this.x = rs * 0.5;
                        rs = 0.5 / rs;
                        this.w = (m12 - m21) * rs;
                        this.y = (m01 + m10) * rs;
                        this.z = (m02 + m20) * rs;
                    }
                    else {
                        rs = (m22 - (m00 + m11)) + 1;
                        rs = Math.sqrt(rs);
                        this.z = rs * 0.5;
                        rs = 0.5 / rs;
                        this.w = (m01 - m10) * rs;
                        this.x = (m20 + m02) * rs;
                        this.y = (m21 + m12) * rs;
                    }
                }
                else if (m11 > m22) {
                    rs = (m11 - (m22 + m00)) + 1;
                    rs = Math.sqrt(rs);
                    this.y = rs * 0.5;
                    rs = 0.5 / rs;
                    this.w = (m20 - m02) * rs;
                    this.z = (m12 + m21) * rs;
                    this.x = (m10 + m01) * rs;
                }
                else {
                    rs = (m22 - (m00 + m11)) + 1;
                    rs = Math.sqrt(rs);
                    this.z = rs * 0.5;
                    rs = 0.5 / rs;
                    this.w = (m01 - m10) * rs;
                    this.x = (m20 + m02) * rs;
                    this.y = (m21 + m12) * rs;
                }
            }
            return this;
        };
        Quaternion.prototype.setFromAxisAngle = function (angle, axis) {
            var sa, ca;
            axis = axis.normalize();
            angle *= 0.5 * wd.DEG_TO_RAD;
            sa = Math.sin(angle);
            ca = Math.cos(angle);
            this.x = sa * axis.x;
            this.y = sa * axis.y;
            this.z = sa * axis.z;
            this.w = ca;
            return this;
        };
        Quaternion.prototype.invert = function () {
            return this.conjugate().normalize();
        };
        Quaternion.prototype.conjugate = function () {
            this.x *= -1;
            this.y *= -1;
            this.z *= -1;
            return this;
        };
        Quaternion.prototype.clone = function () {
            return Quaternion.create(this.x, this.y, this.z, this.w);
        };
        Quaternion.prototype.normalize = function () {
            var len = this.length();
            if (len === 0) {
                this.x = this.y = this.z = 0;
                this.w = 1;
            }
            else {
                len = 1 / len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
                this.w *= len;
            }
            return this;
        };
        Quaternion.prototype.length = function () {
            var x, y, z, w;
            x = this.x;
            y = this.y;
            z = this.z;
            w = this.w;
            return Math.sqrt(x * x + y * y + z * z + w * w);
        };
        Quaternion.prototype.multiplyVector3 = function (vector) {
            var q = this;
            var x = vector.x;
            var y = vector.y;
            var z = vector.z;
            var qx = q.x;
            var qy = q.y;
            var qz = q.z;
            var qw = q.w;
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            return wd.Vector3.create(ix * qw + iw * -qx + iy * -qz - iz * -qy, iy * qw + iw * -qy + iz * -qx - ix * -qz, iz * qw + iw * -qz + ix * -qy - iy * -qx);
        };
        Quaternion.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        };
        Quaternion.prototype.sub = function (quat) {
            var result = quat.clone().invert().multiply(this);
            this.set(result.x, result.y, result.z, result.w);
            return this;
        };
        Quaternion.prototype.getEulerAngles = function () {
            var x, y, z, qx, qy, qz, qw, a2;
            qx = this.x;
            qy = this.y;
            qz = this.z;
            qw = this.w;
            a2 = 2 * (qw * qy - qx * qz);
            if (a2 <= -0.99999) {
                x = 2 * Math.atan2(qx, qw);
                y = -Math.PI / 2;
                z = 0;
            }
            else if (a2 >= 0.99999) {
                x = 2 * Math.atan2(qx, qw);
                y = Math.PI / 2;
                z = 0;
            }
            else {
                x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
                y = Math.asin(a2);
                z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
            }
            return wd.Vector3.create(x, y, z).scale(wd.RAD_TO_DEG);
        };
        Quaternion.prototype.slerp = function (left, right, amount) {
            if (amount === 0) {
                this.set(left.x, left.y, left.z, left.w);
                return this;
            }
            else if (amount === 1) {
                this.set(right.x, right.y, right.z, right.w);
                return this;
            }
            var num2;
            var num3;
            var num = amount;
            var num4 = (((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w);
            var flag = false;
            if (num4 < 0) {
                flag = true;
                num4 = -num4;
            }
            if (num4 > 0.999999) {
                num3 = 1 - num;
                num2 = flag ? -num : num;
            }
            else {
                var num5 = Math.acos(num4);
                var num6 = (1.0 / Math.sin(num5));
                num3 = (Math.sin((1.0 - num) * num5)) * num6;
                num2 = flag ? ((-Math.sin(num * num5)) * num6) : ((Math.sin(num * num5)) * num6);
            }
            this.set((num3 * left.x) + (num2 * right.x), (num3 * left.y) + (num2 * right.y), (num3 * left.z) + (num2 * right.z), (num3 * left.w) + (num2 * right.w));
            return this;
        };
        return Quaternion;
    }());
    wd.Quaternion = Quaternion;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Plane = (function () {
        function Plane(a, b, c, d) {
            this.normal = wd.Vector3.create(0, 1, 0);
            this.d = 0;
            this.normal = wd.Vector3.create(a, b, c);
            this.d = d;
        }
        Plane.create = function (a, b, c, d) {
            var obj = new this(a, b, c, d);
            return obj;
        };
        Plane.prototype.getReflectionMatrix = function () {
            this.normalize();
            var x = this.normal.x;
            var y = this.normal.y;
            var z = this.normal.z;
            var temp = -2 * x;
            var temp2 = -2 * y;
            var temp3 = -2 * z;
            var result = wd.Matrix4.create();
            result.values[0] = (temp * x) + 1;
            result.values[1] = temp2 * x;
            result.values[2] = temp3 * x;
            result.values[3] = 0.0;
            result.values[4] = temp * y;
            result.values[5] = (temp2 * y) + 1;
            result.values[6] = temp3 * y;
            result.values[7] = 0.0;
            result.values[8] = temp * z;
            result.values[9] = temp2 * z;
            result.values[10] = (temp3 * z) + 1;
            result.values[11] = 0.0;
            result.values[12] = temp * this.d;
            result.values[13] = temp2 * this.d;
            result.values[14] = temp3 * this.d;
            result.values[15] = 1.0;
            return result;
        };
        Plane.prototype.normalize = function () {
            var norm = (Math.sqrt((this.normal.x * this.normal.x) + (this.normal.y * this.normal.y) + (this.normal.z * this.normal.z)));
            var magnitude = 0;
            if (norm !== 0) {
                magnitude = 1.0 / norm;
            }
            this.normal.x *= magnitude;
            this.normal.y *= magnitude;
            this.normal.z *= magnitude;
            this.d *= magnitude;
            return this;
        };
        Plane.prototype.clone = function () {
            return Plane.create(this.normal.x, this.normal.y, this.normal.z, this.d);
        };
        Plane.prototype.dotCoordinate = function (point) {
            return ((((this.normal.x * point.x) + (this.normal.y * point.y)) + (this.normal.z * point.z)) + this.d);
        };
        return Plane;
    }());
    wd.Plane = Plane;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Ray = (function () {
        function Ray(origin, direction) {
            this._origin = null;
            this._direction = null;
            this._origin = origin;
            this._direction = direction;
        }
        Ray.create = function (origin, direction) {
            var obj = new this(origin, direction);
            return obj;
        };
        Ray.prototype.isIntersectWithAABB = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var center = null, halfExtends = null, diff = wd.Vector3.create(), absDiff = null, absDir = null, cross = wd.Vector3.create(), prod = wd.Vector3.create(), rayOrigin = this._origin, rayDir = this._direction;
            if (args.length === 1) {
                var aabb = args[0];
                center = aabb.center;
                halfExtends = aabb.halfExtents;
            }
            else if (args.length === 2) {
                var minPoint = args[0], maxPoint = args[1];
                center = wd.AABBShape.getCenter(minPoint, maxPoint);
                halfExtends = wd.AABBShape.getHalfExtents(minPoint, maxPoint);
            }
            diff.sub2(rayOrigin, center);
            absDiff = wd.Vector3.create(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
            prod.mul2(diff, rayDir);
            if (absDiff.x > halfExtends.x && prod.x >= 0) {
                return false;
            }
            if (absDiff.y > halfExtends.y && prod.y >= 0) {
                return false;
            }
            if (absDiff.z > halfExtends.z && prod.z >= 0) {
                return false;
            }
            absDir = wd.Vector3.create(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
            cross.cross(rayDir, diff);
            cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
            if (cross.x > halfExtends.y * absDir.z + halfExtends.z * absDir.y) {
                return false;
            }
            if (cross.y > halfExtends.x * absDir.z + halfExtends.z * absDir.x) {
                return false;
            }
            if (cross.z > halfExtends.x * absDir.y + halfExtends.y * absDir.x) {
                return false;
            }
            return true;
        };
        Ray.prototype.isIntersectWithSphere = function (sphere) {
            var center = sphere.center, radius = sphere.radius, diff = wd.Vector3.create(), a = 0, b = 0, c = 0, discr = 0, rayOrigin = this._origin, rayDir = this._direction;
            diff.sub2(rayOrigin, center);
            if (diff.dot(diff) < radius * radius) {
                return true;
            }
            a = rayDir.dot(rayDir);
            b = 2 * rayDir.dot(diff);
            c = center.dot(center);
            c += rayOrigin.dot(rayOrigin);
            c -= 2 * center.dot(rayOrigin);
            c -= radius * radius;
            discr = (b * b) - (4 * a * c);
            if (discr < 0) {
                return false;
            }
            return true;
        };
        return Ray;
    }());
    wd.Ray = Ray;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Entity = (function () {
        function Entity() {
            this.uid = null;
            this.data = null;
            this._tagList = wdCb.Collection.create();
            this.uid = Entity._count;
            Entity._count += 1;
        }
        Entity.prototype.addTag = function (tag) {
            this._tagList.addChild(tag);
        };
        Entity.prototype.removeTag = function (tag) {
            this._tagList.removeChild(tag);
        };
        Entity.prototype.getTagList = function () {
            return this._tagList;
        };
        Entity.prototype.hasTag = function (tag) {
            return this._tagList.hasChild(tag);
        };
        Entity.prototype.containTag = function (tag) {
            return this._tagList.hasChildWithFunc(function (t) {
                return t.indexOf(tag) > -1;
            });
        };
        Entity._count = 1;
        return Entity;
    }());
    wd.Entity = Entity;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Component = (function (_super) {
        __extends(Component, _super);
        function Component() {
            _super.apply(this, arguments);
            this.entityObject = null;
        }
        Object.defineProperty(Component.prototype, "transform", {
            get: function () {
                if (!this.entityObject) {
                    return null;
                }
                return this.entityObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        Component.prototype.init = function () {
        };
        Component.prototype.dispose = function () {
        };
        Component.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Component.prototype.addToObject = function (entityObject, isShareComponent) {
            if (isShareComponent === void 0) { isShareComponent = false; }
            if (isShareComponent) {
                return;
            }
            if (this.entityObject) {
                this.entityObject.removeComponent(this);
            }
            this.entityObject = entityObject;
            this.addToComponentContainer();
        };
        Component.prototype.addToComponentContainer = function () {
        };
        Component.prototype.removeFromObject = function (entityObject) {
            this.removeFromComponentContainer();
        };
        Component.prototype.removeFromComponentContainer = function () {
        };
        __decorate([
            wd.virtual
        ], Component.prototype, "init", null);
        __decorate([
            wd.virtual
        ], Component.prototype, "dispose", null);
        __decorate([
            wd.virtual
        ], Component.prototype, "clone", null);
        __decorate([
            wd.virtual
        ], Component.prototype, "addToObject", null);
        __decorate([
            wd.virtual
        ], Component.prototype, "addToComponentContainer", null);
        __decorate([
            wd.virtual
        ], Component.prototype, "removeFromObject", null);
        __decorate([
            wd.virtual
        ], Component.prototype, "removeFromComponentContainer", null);
        return Component;
    }(wd.Entity));
    wd.Component = Component;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Scheduler = (function () {
        function Scheduler() {
            this._scheduleCount = 0;
            this._schedules = wdCb.Hash.create();
        }
        Scheduler.create = function () {
            var obj = new this();
            return obj;
        };
        Scheduler.prototype.update = function (elapsed) {
            var _this = this;
            this._schedules.forEach(function (scheduleItem, scheduleId) {
                if (scheduleItem.isStop || scheduleItem.isPause) {
                    return;
                }
                scheduleItem.update(elapsed);
                if (scheduleItem.isFinish) {
                    _this.remove(scheduleId);
                }
            });
        };
        Scheduler.prototype.scheduleLoop = function (task, args) {
            if (args === void 0) { args = []; }
            return this._schedule(LoopScheduleItem, Array.prototype.slice.call(arguments, 0));
        };
        Scheduler.prototype.scheduleFrame = function (task, frame, args) {
            if (frame === void 0) { frame = 1; }
            return this._schedule(FrameScheduleItem, Array.prototype.slice.call(arguments, 0));
        };
        Scheduler.prototype.scheduleInterval = function (task, time, args) {
            if (time === void 0) { time = 0; }
            return this._schedule(IntervalScheduleItem, Array.prototype.slice.call(arguments, 0));
        };
        Scheduler.prototype.scheduleTime = function (task, time, args) {
            if (time === void 0) { time = 0; }
            return this._schedule(TimeScheduleItem, Array.prototype.slice.call(arguments, 0));
        };
        Scheduler.prototype.pause = function (scheduleId) {
            if (arguments.length === 0) {
                var self_1 = this;
                this._schedules.forEach(function (scheduleItem, scheduleId) {
                    self_1.pause(scheduleId);
                });
            }
            else if (arguments.length === 1) {
                var scheduleItem = this._schedules.getChild(arguments[0]);
                scheduleItem.pause();
            }
        };
        Scheduler.prototype.resume = function (scheduleId) {
            if (arguments.length === 0) {
                var self_2 = this;
                this._schedules.forEach(function (scheduleItem, scheduleId) {
                    self_2.resume(scheduleId);
                });
            }
            else if (arguments.length === 1) {
                var scheduleItem = this._schedules.getChild(arguments[0]);
                scheduleItem.resume();
            }
        };
        Scheduler.prototype.start = function (scheduleId) {
            if (arguments.length === 0) {
                var self_3 = this;
                this._schedules.forEach(function (scheduleItem, scheduleId) {
                    self_3.start(scheduleId);
                });
            }
            else if (arguments.length === 1) {
                var scheduleItem = this._schedules.getChild(arguments[0]);
                scheduleItem.start();
            }
        };
        Scheduler.prototype.stop = function (scheduleId) {
            if (arguments.length === 0) {
                var self_4 = this;
                this._schedules.forEach(function (scheduleItem, scheduleId) {
                    self_4.stop(scheduleId);
                });
            }
            else if (arguments.length === 1) {
                var scheduleItem = this._schedules.getChild(arguments[0]);
                scheduleItem.stop();
            }
        };
        Scheduler.prototype.has = function (scheduleId) {
            return !!this._schedules.hasChild(scheduleId);
        };
        Scheduler.prototype.remove = function (scheduleId) {
            this._schedules.removeChild(scheduleId);
        };
        Scheduler.prototype.removeAll = function () {
            this._schedules.removeAllChildren();
        };
        Scheduler.prototype._schedule = function (_class, args) {
            var scheduleId = this._buildId();
            this._schedules.setValue(scheduleId, _class.create.apply(_class, args));
            return scheduleId;
        };
        Scheduler.prototype._buildId = function () {
            return 'Schedule_' + (this._scheduleCount++);
        };
        return Scheduler;
    }());
    wd.Scheduler = Scheduler;
    var ScheduleItem = (function () {
        function ScheduleItem(task, args) {
            this.isPause = false;
            this.isStop = false;
            this.pauseTime = null;
            this.pauseElapsed = null;
            this.startTime = null;
            this.isFinish = false;
            this.task = null;
            this.args = null;
            this.timeController = wd.CommonTimeController.create();
            this.task = task;
            this.args = args;
        }
        ScheduleItem.prototype.pause = function () {
            this.isPause = true;
            this.timeController.pause();
        };
        ScheduleItem.prototype.resume = function () {
            this.isPause = false;
            this.timeController.resume();
        };
        ScheduleItem.prototype.start = function () {
            this.isStop = false;
            this.timeController.start();
        };
        ScheduleItem.prototype.stop = function () {
            this.isStop = true;
            this.timeController.stop();
        };
        ScheduleItem.prototype.finish = function () {
            this.isFinish = true;
        };
        return ScheduleItem;
    }());
    var TimeScheduleItem = (function (_super) {
        __extends(TimeScheduleItem, _super);
        function TimeScheduleItem(task, time, args) {
            if (time === void 0) { time = 0; }
            if (args === void 0) { args = []; }
            _super.call(this, task, args);
            this._time = null;
            this._time = time;
        }
        TimeScheduleItem.create = function (task, time, args) {
            if (time === void 0) { time = 0; }
            if (args === void 0) { args = []; }
            var obj = new this(task, time, args);
            return obj;
        };
        TimeScheduleItem.prototype.update = function (elapsed) {
            var elapsed = this.timeController.computeElapseTime(elapsed);
            if (elapsed >= this._time) {
                this.task.apply(this, this.args);
                this.finish();
            }
        };
        return TimeScheduleItem;
    }(ScheduleItem));
    var IntervalScheduleItem = (function (_super) {
        __extends(IntervalScheduleItem, _super);
        function IntervalScheduleItem(task, time, args) {
            if (time === void 0) { time = 0; }
            if (args === void 0) { args = []; }
            _super.call(this, task, args);
            this._intervalTime = null;
            this._elapsed = 0;
            this._intervalTime = time;
        }
        IntervalScheduleItem.create = function (task, time, args) {
            if (time === void 0) { time = 0; }
            if (args === void 0) { args = []; }
            var obj = new this(task, time, args);
            return obj;
        };
        IntervalScheduleItem.prototype.update = function (elapsed) {
            var elapsed = this.timeController.computeElapseTime(elapsed);
            if (elapsed - this._elapsed >= this._intervalTime) {
                this.task.apply(this, this.args);
                this._elapsed = elapsed;
            }
        };
        IntervalScheduleItem.prototype.start = function () {
            _super.prototype.start.call(this);
            this._elapsed = 0;
        };
        return IntervalScheduleItem;
    }(ScheduleItem));
    var LoopScheduleItem = (function (_super) {
        __extends(LoopScheduleItem, _super);
        function LoopScheduleItem() {
            _super.apply(this, arguments);
        }
        LoopScheduleItem.create = function (task, args) {
            if (args === void 0) { args = []; }
            var obj = new this(task, args);
            return obj;
        };
        LoopScheduleItem.prototype.update = function (elapsed) {
            this.task.apply(this, this.args);
        };
        return LoopScheduleItem;
    }(ScheduleItem));
    var FrameScheduleItem = (function (_super) {
        __extends(FrameScheduleItem, _super);
        function FrameScheduleItem(task, frame, args) {
            if (frame === void 0) { frame = 1; }
            if (args === void 0) { args = []; }
            _super.call(this, task, args);
            this._frame = null;
            this._frame = frame;
        }
        FrameScheduleItem.create = function (task, frame, args) {
            if (frame === void 0) { frame = 1; }
            if (args === void 0) { args = []; }
            var obj = new this(task, frame, args);
            return obj;
        };
        FrameScheduleItem.prototype.update = function (elapsed) {
            this._frame--;
            if (this._frame <= 0) {
                this.task.apply(this, this.args);
                this.finish();
            }
        };
        return FrameScheduleItem;
    }(ScheduleItem));
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EGameState;
    (function (EGameState) {
        EGameState[EGameState["NORMAL"] = 0] = "NORMAL";
        EGameState[EGameState["STOP"] = 1] = "STOP";
        EGameState[EGameState["PAUSE"] = 2] = "PAUSE";
    })(EGameState || (EGameState = {}));
    var Director = (function () {
        function Director() {
            this.scene = null;
            this.scheduler = null;
            this.renderer = null;
            this.domEventManager = wd.DomEventManager.create();
            this._gameLoop = null;
            this._eventSubscription = null;
            this._gameState = EGameState.NORMAL;
            this._timeController = wd.DirectorTimeController.create();
        }
        Director.getInstance = function () { };
        ;
        Object.defineProperty(Director.prototype, "gameTime", {
            get: function () {
                return this._timeController.gameTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Director.prototype, "fps", {
            get: function () {
                return this._timeController.fps;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Director.prototype, "isNormal", {
            get: function () {
                return this._gameState === EGameState.NORMAL;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Director.prototype, "isStop", {
            get: function () {
                return this._gameState === EGameState.STOP;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Director.prototype, "isPause", {
            get: function () {
                return this._gameState === EGameState.PAUSE;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Director.prototype, "isTimeChange", {
            get: function () {
                return this._timeController.isTimeChange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Director.prototype, "elapsed", {
            get: function () {
                return this._timeController.elapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Director.prototype, "view", {
            get: function () {
                return wd.DeviceManager.getInstance().view;
            },
            enumerable: true,
            configurable: true
        });
        Director.prototype.initWhenCreate = function () {
            this.scene = wd.SceneDispatcher.create();
            this.scheduler = wd.Scheduler.create();
            this.renderer = wd.WebGLRenderer.create();
        };
        Director.prototype.start = function () {
            this._gameState = EGameState.NORMAL;
            this._startLoop();
        };
        Director.prototype.stop = function () {
            this._gameLoop && this._gameLoop.dispose();
            this._gameState = EGameState.STOP;
            this._timeController.stop();
            this.scheduler.stop();
            this._eventSubscription && this._eventSubscription.dispose();
        };
        Director.prototype.pause = function () {
            if (this._gameState === EGameState.PAUSE) {
                return;
            }
            this._gameState = EGameState.PAUSE;
            this._timeController.pause();
            this.scheduler.pause();
        };
        Director.prototype.resume = function () {
            this._gameState = EGameState.NORMAL;
            this._timeController.resume();
            this.scheduler.resume();
        };
        Director.prototype.getDeltaTime = function () {
            return this._timeController.deltaTime;
        };
        Director.prototype.initUIObjectScene = function () {
            var uiObjectScene = this.scene.uiObjectScene;
            this._initDomEvent();
            if (uiObjectScene === null) {
                return;
            }
            uiObjectScene.onEnter();
            uiObjectScene.init();
        };
        Director.prototype.runUIObjectScene = function (elapsed) {
            var uiObjectScene = this.scene.uiObjectScene;
            if (uiObjectScene === null) {
                return;
            }
            wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.STARTLOOP));
            wd.ScriptComponentContainer.getInstance().execScript("onStartLoop");
            uiObjectScene.update(elapsed);
            uiObjectScene.render();
            wd.ScriptComponentContainer.getInstance().execScript("onEndLoop");
            wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.ENDLOOP));
        };
        Director.prototype._startLoop = function () {
            var self = this;
            this._gameLoop = this._buildInitStream()
                .ignoreElements()
                .concat(this._buildLoopStream())
                .subscribe(function (time) {
                self._loopBody(time);
            });
        };
        Director.prototype._buildInitStream = function () {
            var _this = this;
            return wdFrp.callFunc(function () {
                _this._init();
            }, this);
        };
        Director.prototype._init = function () {
            var DebugStatistics = wd.ClassUtils.getClass("DebugStatistics");
            if (!!DebugStatistics) {
                DebugStatistics.init();
            }
            this._initGameObjectScene();
            this.initUIObjectScene();
        };
        Director.prototype._initGameObjectScene = function () {
            var gameObjectScene = this.scene.gameObjectScene;
            this._initDomEvent();
            gameObjectScene.onEnter();
            gameObjectScene.init();
            this.renderer.init();
            this._timeController.start();
            this.scheduler.start();
        };
        Director.prototype._buildLoopStream = function () {
            return wdFrp.intervalRequest();
        };
        Director.prototype._loopBody = function (time) {
            var elapsed = null;
            if (this._gameState === EGameState.PAUSE || this._gameState === EGameState.STOP) {
                return false;
            }
            elapsed = this._timeController.computeElapseTime(time);
            this._run(elapsed);
            return true;
        };
        Director.prototype._run = function (elapsed) {
            this._timeController.tick(elapsed);
            wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.STARTLOOP));
            wd.ScriptComponentContainer.getInstance().execScript("onStartLoop");
            this._update(elapsed);
            this._render();
            wd.ScriptComponentContainer.getInstance().execScript("onEndLoop");
            wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.ENDLOOP));
        };
        Director.prototype._update = function (elapsed) {
            this.scheduler.update(elapsed);
            wd.ScriptComponentContainer.getInstance().execScriptWithData("update", elapsed);
            wd.ClassUtils.execSingletonMethod("ActionComponentContainer", "update", elapsed);
            this.scene.gameObjectScene.update(elapsed);
            if (this.scene.uiObjectScene !== null) {
                this.scene.uiObjectScene.update(elapsed);
            }
        };
        Director.prototype._render = function () {
            this.scene.gameObjectScene.render(this.renderer);
            this.renderer.clear();
            if (this.renderer.hasCommand()) {
                this.renderer.webglState = wd.BasicState.create();
                this.renderer.render();
            }
            if (this.scene.uiObjectScene !== null) {
                this.scene.uiObjectScene.render();
            }
        };
        Director.prototype._initDomEvent = function () {
            this._eventSubscription = this.domEventManager.initDomEvent();
        };
        __decorate([
            wd.execOnlyOnce("_isInitUIScene")
        ], Director.prototype, "initUIObjectScene", null);
        __decorate([
            wd.execOnlyOnce("_isInitDomEvent")
        ], Director.prototype, "_initDomEvent", null);
        Director = __decorate([
            wd.singleton(true)
        ], Director);
        return Director;
    }());
    wd.Director = Director;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Main = (function () {
        function Main() {
        }
        Object.defineProperty(Main, "isTest", {
            get: function () {
                return this._isTest;
            },
            set: function (isTest) {
                this._isTest = isTest;
                wdFrp.Main.isTest = isTest;
            },
            enumerable: true,
            configurable: true
        });
        Main.setConfig = function (_a) {
            var _b = _a.canvasId, canvasId = _b === void 0 ? null : _b, _c = _a.isTest, isTest = _c === void 0 ? wd.DebugConfig.isTest : _c, _d = _a.screenSize, screenSize = _d === void 0 ? wd.EScreenSize.FULL : _d, _e = _a.useDevicePixelRatio, useDevicePixelRatio = _e === void 0 ? false : _e, _f = _a.contextConfig, contextConfig = _f === void 0 ? {
                options: {
                    alpha: true,
                    depth: true,
                    stencil: false,
                    antialias: true,
                    premultipliedAlpha: true,
                    preserveDrawingBuffer: false
                }
            } : _f;
            this.screenSize = screenSize;
            this._canvasId = canvasId;
            this._useDevicePixelRatio = useDevicePixelRatio;
            this._contextConfig = {
                options: wdCb.ExtendUtils.extend({
                    alpha: true,
                    depth: true,
                    stencil: false,
                    antialias: true,
                    premultipliedAlpha: true,
                    preserveDrawingBuffer: false
                }, contextConfig.options)
            };
            this._setIsTest(isTest);
            return this;
        };
        Main.init = function () {
            wd.DeviceManager.getInstance().createGL(this._canvasId, this._contextConfig, this._useDevicePixelRatio);
            wd.DeviceManager.getInstance().setScreen();
            wd.GPUDetector.getInstance().detect();
            return this;
        };
        Main._setIsTest = function (isTestFromDebugConfig) {
            if (wd.CompileConfig.closeContractTest) {
                this.isTest = false;
            }
            else {
                this.isTest = isTestFromDebugConfig;
            }
        };
        Main._isTest = false;
        Main.screenSize = null;
        Main._canvasId = null;
        Main._contextConfig = null;
        Main._useDevicePixelRatio = null;
        return Main;
    }());
    wd.Main = Main;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DomEventManager = (function () {
        function DomEventManager() {
            this.designatedTriggerList = null;
            this._lastTriggerList = null;
            this._isDragEventTriggering = false;
            this._triggerListOfDragEvent = null;
            this._pointEventBinder = wd.PointEventBinder.create();
        }
        DomEventManager.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(DomEventManager.prototype, "scene", {
            get: function () {
                return wd.Director.getInstance().scene;
            },
            enumerable: true,
            configurable: true
        });
        DomEventManager.prototype.initDomEvent = function () {
            var self = this;
            this._pointEventBinder.initPointEvent();
            return wdFrp.fromArray([
                wd.EventManager.fromEvent(wd.EEngineEvent.POINT_TAP),
                wd.EventManager.fromEvent(wd.EEngineEvent.POINT_DOWN),
                wd.EventManager.fromEvent(wd.EEngineEvent.POINT_UP),
                wd.EventManager.fromEvent(wd.EEngineEvent.POINT_SCALE),
                this._buildPointDragStream()
            ])
                .mergeAll()
                .map(function (e) {
                return e.userData;
            })
                .filter(function (e) {
                return !wd.Director.getInstance().isPause;
            })
                .map(function (e) {
                var triggerList = self._getPointEventTriggerList(e);
                if (self._isDragEventTriggering) {
                    self._triggerListOfDragEvent = triggerList;
                }
                return self._getPointEventTriggerListData(e, triggerList);
            })
                .merge(this._buildPointMoveStream())
                .subscribe(function (_a) {
                var triggerList = _a[0], e = _a[1];
                triggerList.forEach(function (entityObject) {
                    self._trigger(e.clone(), entityObject);
                });
            });
        };
        DomEventManager.prototype.dispose = function () {
            this._pointEventBinder.dispose();
        };
        DomEventManager.prototype._buildPointDragStream = function () {
            var self = this;
            return wd.EventManager.fromEvent(wd.EEngineEvent.POINT_DOWN)
                .flatMap(function (e) {
                return wd.EventManager.fromEvent(wd.EEngineEvent.POINT_MOVE)
                    .takeUntil(wd.EventManager.fromEvent(wd.EEngineEvent.POINT_UP)
                    .do(function (e) {
                    self._isDragEventTriggering = false;
                }));
            })
                .map(function (e) {
                e.name = wd.EEngineEvent.POINT_DRAG;
                e.userData.name = wd.EEngineEvent.POINT_DRAG;
                if (self._isDragEventFirstTriggered()) {
                    self._resetLastPosition(e.userData);
                }
                self._isDragEventTriggering = true;
                return e;
            });
        };
        DomEventManager.prototype._resetLastPosition = function (e) {
            e.lastX = null;
            e.lastY = null;
        };
        DomEventManager.prototype._isDragEventFirstTriggered = function () {
            return this._isDragEventTriggering === false;
        };
        DomEventManager.prototype._buildPointMoveStream = function () {
            var self = this;
            return wd.EventManager.fromEvent(wd.EEngineEvent.POINT_MOVE)
                .map(function (e) {
                return e.userData;
            })
                .filter(function (e) {
                return !wd.Director.getInstance().isPause;
            })
                .map(function (e) {
                var triggerList = null;
                if (self.designatedTriggerList) {
                    triggerList = self.designatedTriggerList;
                }
                else if (self._isDragEventTriggering) {
                    triggerList = self._triggerListOfDragEvent;
                }
                else {
                    triggerList = self._getPointEventTriggerList(e);
                }
                var _a = self._getPointOverAndPointOutObject(triggerList, self._lastTriggerList), pointoverObjects = _a.pointoverObjects, pointoutObjects = _a.pointoutObjects;
                self._setPointOverTag(pointoverObjects);
                self._setPointOutTag(pointoutObjects);
                self._lastTriggerList = triggerList.clone();
                triggerList = pointoutObjects.addChildren(triggerList);
                return self._getPointEventTriggerListData(e, triggerList);
            });
        };
        DomEventManager.prototype._getPointOverAndPointOutObject = function (currentTriggerList, lastTriggerList) {
            var pointoverObjects = wdCb.Collection.create(), pointoutObjects = wdCb.Collection.create();
            if (!lastTriggerList) {
                pointoverObjects = currentTriggerList;
            }
            else {
                lastTriggerList.forEach(function (lastObject) {
                    if (!currentTriggerList.hasChildWithFunc(function (currentObject) {
                        return wd.JudgeUtils.isEqual(currentObject, lastObject);
                    })) {
                        pointoutObjects.addChild(lastObject);
                    }
                });
                currentTriggerList.forEach(function (currentObject) {
                    if (!lastTriggerList.hasChildWithFunc(function (lastObject) {
                        return wd.JudgeUtils.isEqual(currentObject, lastObject);
                    })) {
                        pointoverObjects.addChild(currentObject);
                    }
                });
            }
            return {
                pointoverObjects: pointoverObjects,
                pointoutObjects: pointoutObjects
            };
        };
        DomEventManager.prototype._setPointOverTag = function (objects) {
            objects.forEach(function (object) {
                object.addTag(EEventTag.POINT_OVER);
            });
        };
        DomEventManager.prototype._setPointOutTag = function (objects) {
            objects.forEach(function (object) {
                object.addTag(EEventTag.POINT_OUT);
            });
        };
        DomEventManager.prototype._setEventNameByEventTag = function (object, e) {
            if (object.hasTag(EEventTag.POINT_OVER)) {
                e.name = wd.EEngineEvent.POINT_OVER;
            }
            else if (object.hasTag(EEventTag.POINT_OUT)) {
                e.name = wd.EEngineEvent.POINT_OUT;
            }
            return e;
        };
        DomEventManager.prototype._removeEventTag = function (object) {
            object.removeTag(EEventTag.POINT_OVER);
            object.removeTag(EEventTag.POINT_OUT);
        };
        DomEventManager.prototype._trigger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var e = args[0], entityObject = args[1], notSetTarget = false, event = null, customEvent = null, handlerName = null;
            if (args.length === 3 && args[2]) {
                notSetTarget = true;
                event = e;
            }
            else {
                event = this._setEventNameByEventTag(entityObject, e);
                this._removeEventTag(entityObject);
            }
            handlerName = wd.EventTriggerTable.getScriptHandlerName(event.name);
            customEvent = wd.CustomEvent.create(event.name, event);
            customEvent.getDataFromDomEvent(event);
            wd.EventManager.trigger(entityObject, customEvent, notSetTarget);
            event.getDataFromCustomEvent(customEvent);
            wd.ScriptComponentContainer.getInstance().execEntityObjectEventScriptWithData(entityObject, handlerName, event);
            if (!event.isStopPropagation && entityObject.bubbleParent) {
                this._trigger(event.clone(), entityObject.bubbleParent, true);
            }
        };
        DomEventManager.prototype._getPointEventTriggerList = function (e) {
            var topGameObject = null, topUIObject = null, triggerList = null;
            if (this.designatedTriggerList) {
                return this.designatedTriggerList;
            }
            triggerList = wdCb.Collection.create();
            topGameObject = this._findTopGameObject(e, this.scene.gameObjectScene);
            topUIObject = this._findTopUIObject(e, this.scene.uiObjectScene);
            if (!!topGameObject) {
                triggerList.addChild(topGameObject);
            }
            if (!!topUIObject) {
                triggerList.addChild(topUIObject);
            }
            if (this._isSceneAsTopOne(e, triggerList)) {
                triggerList.addChild(this.scene);
            }
            return triggerList;
        };
        DomEventManager.prototype._isSceneAsTopOne = function (e, triggerList) {
            return this._isTriggerScene(e) && triggerList.getCount() === 0;
        };
        DomEventManager.prototype._findTopGameObject = function (e, gameObjectScene) {
            var self = this;
            return this._findTriggerGameObjectList(e, gameObjectScene).sort(function (a, b) {
                return self._getDistanceToCamera(a) - self._getDistanceToCamera(b);
            })
                .getChild(0);
        };
        DomEventManager.prototype._getDistanceToCamera = function (obj) {
            return obj.transform.position.clone().sub(wd.Director.getInstance().scene.currentCamera.transform.position).length();
        };
        DomEventManager.prototype._findTopUIObject = function (e, uiObjectScene) {
            if (uiObjectScene === null) {
                return null;
            }
            return this._findTriggerUIObjectList(e, uiObjectScene).sort(function (a, b) {
                return b.transform.zIndex - a.transform.zIndex;
            })
                .getChild(0);
        };
        DomEventManager.prototype._findTriggerGameObjectList = function (e, objectScene) {
            var triggerObjectList = wdCb.Collection.create(), self = this;
            var find = function (entityObject) {
                if (wd.ClassUtils.hasComponent(entityObject, "SpacePartition")) {
                    entityObject.getSpacePartition().getIntersectListWithRay(e)
                        .forEach(function (entityObject) {
                        self._addTriggerObjectByQueryDetector(entityObject, e, triggerObjectList);
                    });
                }
                else {
                    self._addTriggerObjectByQueryDetector(entityObject, e, triggerObjectList);
                    entityObject.forEach(function (child) {
                        find(child);
                    });
                }
            };
            objectScene.forEach(function (child) {
                find(child);
            });
            return triggerObjectList;
        };
        DomEventManager.prototype._findTriggerUIObjectList = function (e, objectScene) {
            var triggerObjectList = wdCb.Collection.create(), self = this;
            var find = function (entityObject) {
                self._addTriggerObjectByQueryDetector(entityObject, e, triggerObjectList);
                entityObject.forEach(function (child) {
                    find(child);
                });
            };
            objectScene.forEach(function (child) {
                find(child);
            });
            return triggerObjectList;
        };
        DomEventManager.prototype._addTriggerObjectByQueryDetector = function (entityObject, e, triggerObjectList) {
            if (entityObject.hasComponent(wd.EventTriggerDetector)) {
                var detector = entityObject.getComponent(wd.EventTriggerDetector);
                if (detector.isTrigger(e)) {
                    triggerObjectList.addChild(entityObject);
                }
            }
        };
        DomEventManager.prototype._isTriggerScene = function (e) {
            var detector = this.scene.getComponent(wd.EventTriggerDetector);
            return detector.isTrigger(e);
        };
        DomEventManager.prototype._getPointEventTriggerListData = function (e, triggerList) {
            return [triggerList, e];
        };
        return DomEventManager;
    }());
    wd.DomEventManager = DomEventManager;
    var EEventTag;
    (function (EEventTag) {
        EEventTag[EEventTag["POINT_OVER"] = "POINT_OVER"] = "POINT_OVER";
        EEventTag[EEventTag["POINT_OUT"] = "POINT_OUT"] = "POINT_OUT";
    })(EEventTag || (EEventTag = {}));
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PointEventBinder = (function () {
        function PointEventBinder() {
            this._pointDownSubscription = null;
            this._pointTapSubscription = null;
            this._pointUpSubscription = null;
            this._pointMoveSubscription = null;
            this._pointScaleSubscription = null;
        }
        PointEventBinder.create = function () {
            var obj = new this();
            return obj;
        };
        PointEventBinder.prototype.initPointEvent = function () {
            var self = this;
            if (this._isSupportTouch()) {
                var touchdown = wd.EventManager.fromEvent(wd.EEventName.TOUCHDOWN), touchup = wd.EventManager.fromEvent(wd.EEventName.TOUCHUP), touchmove = wd.EventManager.fromEvent(wd.EEventName.TOUCHMOVE);
                this._pointDownSubscription = touchdown
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_DOWN, self._convertTouchEventToPointEvent(e, wd.EEngineEvent.POINT_DOWN)));
                });
                this._pointMoveSubscription = touchmove
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_MOVE, self._convertTouchEventToPointEvent(e, wd.EEngineEvent.POINT_MOVE)));
                });
                this._pointUpSubscription = touchup
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_UP, self._convertTouchEventToPointEvent(e, wd.EEngineEvent.POINT_UP)));
                });
                this._pointTapSubscription = touchup.skipUntil(touchdown)
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_TAP, self._convertTouchEventToPointEvent(e, wd.EEngineEvent.POINT_TAP)));
                });
            }
            else {
                this._pointDownSubscription = wd.EventManager.fromEvent(wd.EEventName.MOUSEDOWN)
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_DOWN, self._convertMouseEventToPointEvent(e, wd.EEngineEvent.POINT_DOWN)));
                });
                this._pointMoveSubscription = wd.EventManager.fromEvent(wd.EEventName.MOUSEMOVE)
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_MOVE, self._convertMouseEventToPointEvent(e, wd.EEngineEvent.POINT_MOVE)));
                });
                this._pointUpSubscription = wd.EventManager.fromEvent(wd.EEventName.MOUSEUP)
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_UP, self._convertMouseEventToPointEvent(e, wd.EEngineEvent.POINT_UP)));
                });
                this._pointScaleSubscription = wd.EventManager.fromEvent(wd.EEventName.MOUSEWHEEL)
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_SCALE, self._convertMouseEventToPointEvent(e, wd.EEngineEvent.POINT_SCALE)));
                });
                this._pointTapSubscription = wd.EventManager.fromEvent(wd.EEventName.CLICK)
                    .subscribe(function (e) {
                    wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.POINT_TAP, self._convertMouseEventToPointEvent(e, wd.EEngineEvent.POINT_TAP)));
                });
            }
        };
        PointEventBinder.prototype.dispose = function () {
            if (!!this._pointTapSubscription) {
                this._pointTapSubscription.dispose();
            }
            if (!!this._pointDownSubscription) {
                this._pointDownSubscription.dispose();
            }
            if (!!this._pointUpSubscription) {
                this._pointUpSubscription.dispose();
            }
            if (!!this._pointMoveSubscription) {
                this._pointMoveSubscription.dispose();
            }
            if (!!this._pointScaleSubscription) {
                this._pointScaleSubscription.dispose();
            }
        };
        PointEventBinder.prototype._isSupportTouch = function () {
            return "ontouchstart" in wd.root;
        };
        PointEventBinder.prototype._convertTouchEventToPointEvent = function (e, eventName) {
            var event = wd.TouchPointEvent.create(eventName);
            event.getDataFromEventObj(e);
            return event;
        };
        PointEventBinder.prototype._convertMouseEventToPointEvent = function (e, eventName) {
            var event = wd.MousePointEvent.create(eventName);
            event.getDataFromEventObj(e);
            return event;
        };
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("should support touch or point event", function () {
                    wd.expect(_this._isSupportTouch() || "onmousedown" in wd.root).true;
                }, this);
            })
        ], PointEventBinder.prototype, "initPointEvent", null);
        return PointEventBinder;
    }());
    wd.PointEventBinder = PointEventBinder;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EntityObject = (function (_super) {
        __extends(EntityObject, _super);
        function EntityObject() {
            _super.apply(this, arguments);
            this._bubbleParent = null;
            this.name = null;
            this.parent = null;
            this.customEventMap = wdCb.Hash.create();
            this.scriptManager = wd.ScriptManager.create(this);
            this.componentManager = wd.ComponentManager.create(this);
            this._hasComponentCache = wdCb.Hash.create();
            this._getComponentCache = wdCb.Hash.create();
            this._componentChangeSubscription = null;
            this._entityObjectManager = wd.EntityObjectManager.create(this);
        }
        Object.defineProperty(EntityObject.prototype, "bubbleParent", {
            get: function () {
                return this._bubbleParent ? this._bubbleParent : this.parent;
            },
            set: function (bubbleParent) {
                this._bubbleParent = bubbleParent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityObject.prototype, "componentDirty", {
            set: function (componentDirty) {
                if (componentDirty === true) {
                    this.clearCache();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EntityObject.prototype, "transform", {
            get: function () {
                return this.componentManager.transform;
            },
            enumerable: true,
            configurable: true
        });
        EntityObject.prototype.initWhenCreate = function () {
            this.addComponent(this.createTransform());
        };
        EntityObject.prototype.clone = function (config) {
            if (config === void 0) { config = {}; }
            var result = null;
            if (wd.CloneUtils.isNotClone((this))) {
                return null;
            }
            config = wdCb.ExtendUtils.extend({
                cloneChildren: true,
                shareGeometry: false,
                cloneGeometry: true
            }, config);
            result = wd.CloneUtils.clone(this);
            this.forEachComponent(function (component) {
                if (!config.cloneGeometry && component instanceof wd.Geometry) {
                    return;
                }
                if (config.shareGeometry && component instanceof wd.Geometry) {
                    result.addComponent(component, true);
                    return;
                }
                result.addComponent(component.clone());
            });
            if (config.cloneChildren) {
                this._cloneChildren(result);
            }
            return result;
        };
        EntityObject.prototype.init = function () {
            var self = this;
            this._componentChangeSubscription = wd.EventManager.fromEvent(this, wd.EEngineEvent.COMPONENT_CHANGE)
                .subscribe(function () {
                self._onComponentChange();
            });
            this.componentManager.init();
            this._entityObjectManager.init();
            this.afterInitChildren();
            wd.ScriptComponentContainer.getInstance().execEntityObjectScriptOnlyOnce(this, "init");
            return this;
        };
        EntityObject.prototype.onEnter = function () {
            wd.ScriptComponentContainer.getInstance().execEntityObjectScriptOnlyOnce(this, "onEnter");
            wd.EventManager.trigger(this, wd.CustomEvent.create(wd.EEngineEvent.ENTER));
        };
        EntityObject.prototype.onExit = function () {
            wd.ScriptComponentContainer.getInstance().execEntityObjectScriptOnlyOnce(this, "onExit");
            wd.EventManager.trigger(this, wd.CustomEvent.create(wd.EEngineEvent.EXIT));
        };
        EntityObject.prototype.onDispose = function () {
            wd.ScriptComponentContainer.getInstance().execEntityObjectScriptOnlyOnce(this, "onDispose");
        };
        EntityObject.prototype.dispose = function () {
            this.onDispose();
            if (this.parent) {
                this.parent.removeChild(this);
                this.parent = null;
            }
            wd.EventManager.off(this);
            this._componentChangeSubscription && this._componentChangeSubscription.dispose();
            this.componentManager.dispose();
            this._entityObjectManager.dispose();
            wd.EventManager.off(this);
        };
        EntityObject.prototype.hasChild = function (child) {
            return this._entityObjectManager.hasChild(child);
        };
        EntityObject.prototype.addChild = function (child) {
            this._entityObjectManager.addChild(child);
            return this;
        };
        EntityObject.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._entityObjectManager.addChildren(args[0]);
            return this;
        };
        EntityObject.prototype.forEach = function (func) {
            this._entityObjectManager.forEach(func);
            return this;
        };
        EntityObject.prototype.filter = function (func) {
            return this._entityObjectManager.filter(func);
        };
        EntityObject.prototype.sort = function (func, isSortSelf) {
            if (isSortSelf === void 0) { isSortSelf = false; }
            return this._entityObjectManager.sort(func, isSortSelf);
        };
        EntityObject.prototype.getChildren = function () {
            return this._entityObjectManager.getChildren();
        };
        EntityObject.prototype.getChild = function (index) {
            return this._entityObjectManager.getChild(index);
        };
        EntityObject.prototype.findChildByUid = function (uid) {
            return this._entityObjectManager.findChildByUid(uid);
        };
        EntityObject.prototype.findChildByTag = function (tag) {
            return this._entityObjectManager.findChildByTag(tag);
        };
        EntityObject.prototype.findChildByName = function (name) {
            return this._entityObjectManager.findChildByName(name);
        };
        EntityObject.prototype.findChildrenByName = function (name) {
            return this._entityObjectManager.findChildrenByName(name);
        };
        EntityObject.prototype.removeChild = function (child) {
            this._entityObjectManager.removeChild(child);
            return this;
        };
        EntityObject.prototype.removeAllChildren = function () {
            this._entityObjectManager.removeAllChildren();
        };
        EntityObject.prototype.getComponent = function (_class) {
            return this.componentManager.getComponent(_class);
        };
        EntityObject.prototype.getComponents = function () {
            return this.componentManager.getComponents();
        };
        EntityObject.prototype.findComponentByUid = function (uid) {
            return this.componentManager.findComponentByUid(uid);
        };
        EntityObject.prototype.forEachComponent = function (func) {
            this.componentManager.forEachComponent(func);
            return this;
        };
        EntityObject.prototype.hasComponent = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var key = this._getHasComponentCacheKey(args[0]), result = this._hasComponentCache.getChild(key);
            if (result !== void 0) {
                return result;
            }
            result = this.componentManager.hasComponent(args[0]);
            this._hasComponentCache.addChild(key, result);
            return result;
        };
        EntityObject.prototype.addComponent = function (component, isShareComponent) {
            if (isShareComponent === void 0) { isShareComponent = false; }
            this.componentManager.addComponent(component, isShareComponent);
            this.componentDirty = true;
            return this;
        };
        EntityObject.prototype.removeComponent = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.componentManager.removeComponent(args[0]);
            this.componentDirty = true;
            return this;
        };
        EntityObject.prototype.removeAllComponent = function () {
            this.componentDirty = true;
            return this.componentManager.removeAllComponent();
        };
        EntityObject.prototype.addAllComponentToComponentContainer = function () {
            return this.componentManager.addAllComponentToComponentContainer();
        };
        EntityObject.prototype.removeAllComponentFromComponentContainer = function () {
            return this.componentManager.removeAllComponentFromComponentContainer();
        };
        EntityObject.prototype.render = function (renderer, camera) {
            var rendererComponent = null;
            rendererComponent = this.componentManager.getRendererComponent();
            if (rendererComponent) {
                rendererComponent.render(renderer, this, camera);
            }
            this.getRenderList().forEach(function (child) {
                child.render(renderer, camera);
            });
        };
        EntityObject.prototype.update = function (elapsed) {
            this.forEach(function (child) {
                child.update(elapsed);
            });
        };
        EntityObject.prototype.getComponentCount = function (_class) {
            return this.componentManager.getComponentCount(_class);
        };
        EntityObject.prototype.getAllChildren = function () {
            return this._entityObjectManager.getAllChildren();
        };
        EntityObject.prototype.getGeometry = function () {
            return this.componentManager.getGeometry();
        };
        EntityObject.prototype.afterInitChildren = function () {
        };
        EntityObject.prototype.getRenderList = function () {
            return this.getChildren();
        };
        EntityObject.prototype.clearCache = function () {
            this._hasComponentCache.removeAllChildren();
            this._getComponentCache.removeAllChildren();
        };
        EntityObject.prototype._getHasComponentCacheKey = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (wd.JudgeUtils.isComponenet(args[0])) {
                var component = args[0];
                return String(component.uid);
            }
            else {
                var _class = args[0];
                return _class.name;
            }
        };
        EntityObject.prototype._onComponentChange = function () {
            this.clearCache();
        };
        EntityObject.prototype._cloneChildren = function (result) {
            this.forEach(function (child) {
                var resultChild = child.clone();
                if (resultChild !== null) {
                    result.addChild(resultChild);
                }
            });
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], EntityObject.prototype, "bubbleParent", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], EntityObject.prototype, "name", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], EntityObject.prototype, "parent", void 0);
        __decorate([
            wd.virtual
        ], EntityObject.prototype, "initWhenCreate", null);
        __decorate([
            wd.require(function (config) {
                var _this = this;
                if (config === void 0) { config = {}; }
                wd.it("if has OneToManySourceInstance component, not support share geometry", function () {
                    if (config.shareGeometry) {
                        wd.expect(_this.hasComponent(wd.OneToManySourceInstance)).false;
                    }
                });
            })
        ], EntityObject.prototype, "clone", null);
        __decorate([
            wd.cache(function (_class) {
                return this._getComponentCache.hasChild(_class.name);
            }, function (_class) {
                return this._getComponentCache.getChild(_class.name);
            }, function (result, _class) {
                this._getComponentCache.addChild(_class.name, result);
            })
        ], EntityObject.prototype, "getComponent", null);
        __decorate([
            wd.virtual
        ], EntityObject.prototype, "render", null);
        __decorate([
            wd.virtual
        ], EntityObject.prototype, "getGeometry", null);
        __decorate([
            wd.virtual
        ], EntityObject.prototype, "afterInitChildren", null);
        __decorate([
            wd.virtual
        ], EntityObject.prototype, "getRenderList", null);
        __decorate([
            wd.ensure(function (key) {
                wd.it("key:" + key + " be string", function () {
                    wd.expect(wd.JudgeUtils.isString(key)).true;
                });
            })
        ], EntityObject.prototype, "_getHasComponentCacheKey", null);
        return EntityObject;
    }(wd.Entity));
    wd.EntityObject = EntityObject;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ComponentManager = (function () {
        function ComponentManager(entityObject) {
            this.transform = null;
            this._entityObject = null;
            this._components = wdCb.Collection.create();
            this._rendererComponent = null;
            this._collider = null;
            this._geometry = null;
            this._entityObject = entityObject;
        }
        ComponentManager.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        ComponentManager.prototype.init = function () {
            for (var _i = 0, _a = wd.SortUtils.insertSort(this._components.getChildren(), function (a, b) {
                return wd.ComponentInitOrderTable.getOrder(a) < wd.ComponentInitOrderTable.getOrder(b);
            }); _i < _a.length; _i++) {
                var component = _a[_i];
                component.init();
            }
        };
        ComponentManager.prototype.dispose = function () {
            var components = this.removeAllComponent();
            components.forEach(function (component) {
                component.dispose();
            });
            this._components.removeAllChildren();
        };
        ComponentManager.prototype.removeAllComponent = function () {
            var _this = this;
            var result = wdCb.Collection.create();
            this._components.forEach(function (component) {
                _this._removeComponentHandler(component);
                result.addChild(component);
            }, this);
            return result;
        };
        ComponentManager.prototype.getComponent = function (_class) {
            return this._components.findOne(function (component) {
                return component instanceof _class;
            });
        };
        ComponentManager.prototype.getComponents = function () {
            return this._components;
        };
        ComponentManager.prototype.findComponentByUid = function (uid) {
            return this._components.findOne(function (component) {
                return component.uid === uid;
            });
        };
        ComponentManager.prototype.forEachComponent = function (func) {
            this._components.forEach(func);
            return this;
        };
        ComponentManager.prototype.hasComponent = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = null;
            if (wd.JudgeUtils.isComponenet(args[0])) {
                var component = args[0];
                result = this._components.hasChild(component);
            }
            else {
                var _class_1 = args[0];
                result = this._components.hasChildWithFunc(function (component) {
                    return component instanceof _class_1;
                });
            }
            return result;
        };
        ComponentManager.prototype.addComponent = function (component, isShareComponent) {
            if (isShareComponent === void 0) { isShareComponent = false; }
            if (!component) {
                return;
            }
            if (component instanceof wd.RendererComponent) {
                this._rendererComponent = component;
            }
            else if (component instanceof wd.Collider) {
                this._collider = component;
            }
            else if (component instanceof wd.Geometry) {
                this._geometry = component;
            }
            else if (component instanceof wd.Transform) {
                if (this.transform) {
                    this.removeComponent(this.transform);
                }
                this.transform = component;
            }
            component.addToObject(this._entityObject, isShareComponent);
            this._components.addChild(component);
            return this;
        };
        ComponentManager.prototype.removeComponent = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var component = null;
            if (args[0] instanceof wd.Component) {
                component = args[0];
            }
            else {
                component = this.getComponent(args[0]);
            }
            if (component) {
                this._components.removeChild(component);
                this._removeComponentHandler(component);
            }
            return this;
        };
        ComponentManager.prototype.addAllComponentToComponentContainer = function () {
            this._components.forEach(function (component) { return component.addToComponentContainer(); });
        };
        ComponentManager.prototype.removeAllComponentFromComponentContainer = function () {
            this._components.forEach(function (component) { return component.removeFromComponentContainer(); });
        };
        ComponentManager.prototype.getComponentCount = function (_class) {
            return this._components.filter(function (component) {
                return component instanceof _class;
            }).getCount();
        };
        ComponentManager.prototype.getGeometry = function () {
            return this._geometry;
        };
        ComponentManager.prototype.getRendererComponent = function () {
            return this._rendererComponent;
        };
        ComponentManager.prototype.getCollider = function () {
            return this._collider;
        };
        ComponentManager.prototype._removeComponentHandler = function (component) {
            component.removeFromObject(this._entityObject);
        };
        __decorate([
            wd.require(function (component, isShareComponent) {
                var _this = this;
                if (isShareComponent === void 0) { isShareComponent = false; }
                if (!component) {
                    return;
                }
                wd.it("should not add the component which is already added", function () {
                    wd.expect(_this.hasComponent(component)).false;
                });
            })
        ], ComponentManager.prototype, "addComponent", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("entityObject shouldn't contain more than 1 geometry component", function () {
                    wd.expect(_this.getComponentCount(wd.Geometry)).lessThan(2);
                });
            })
        ], ComponentManager.prototype, "getGeometry", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("entityObject shouldn't contain more than 1 rendererComponent", function () {
                    wd.expect(_this.getComponentCount(wd.RendererComponent)).lessThan(2);
                });
            })
        ], ComponentManager.prototype, "getRendererComponent", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("entityObject shouldn't contain more than 1 collider", function () {
                    wd.expect(_this.getComponentCount(wd.Collider)).lessThan(2);
                });
            })
        ], ComponentManager.prototype, "getCollider", null);
        return ComponentManager;
    }());
    wd.ComponentManager = ComponentManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EntityObjectManager = (function () {
        function EntityObjectManager(entityObject) {
            this._entityObject = null;
            this._children = wdCb.Collection.create();
            this._entityObject = entityObject;
        }
        EntityObjectManager.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        EntityObjectManager.prototype.init = function () {
            this.forEach(function (child) {
                child.init();
            });
        };
        EntityObjectManager.prototype.dispose = function () {
            this.forEach(function (child) {
                child.dispose();
            });
        };
        EntityObjectManager.prototype.hasChild = function (child) {
            return this._children.hasChild(child);
        };
        EntityObjectManager.prototype.addChild = function (child) {
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this._entityObject;
            child.transform.parent = this._entityObject.transform;
            this._children.addChild(child);
            child.onEnter();
            return this;
        };
        EntityObjectManager.prototype.addChildren = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (wd.JudgeUtils.isArray(args[0])) {
                var children = args[0];
                for (var _a = 0, children_1 = children; _a < children_1.length; _a++) {
                    var child = children_1[_a];
                    this.addChild(child);
                }
            }
            else if (wd.JudgeUtils.isCollection(args[0])) {
                var children = args[0];
                children.forEach(function (child) {
                    _this.addChild(child);
                });
            }
            else {
                this.addChild(args[0]);
            }
            return this;
        };
        EntityObjectManager.prototype.forEach = function (func) {
            this._children.forEach(func);
            return this;
        };
        EntityObjectManager.prototype.filter = function (func) {
            return this._children.filter(func);
        };
        EntityObjectManager.prototype.sort = function (func, isSortSelf) {
            if (isSortSelf === void 0) { isSortSelf = false; }
            return this._children.sort(func, isSortSelf);
        };
        EntityObjectManager.prototype.getChildren = function () {
            return this._children;
        };
        EntityObjectManager.prototype.getAllChildren = function () {
            var result = wdCb.Collection.create();
            var getChildren = function (entityObject) {
                result.addChildren(entityObject.getChildren());
                entityObject.forEach(function (child) {
                    getChildren(child);
                });
            };
            getChildren(this._entityObject);
            return result;
        };
        EntityObjectManager.prototype.getChild = function (index) {
            return this._children.getChild(index);
        };
        EntityObjectManager.prototype.findChildByUid = function (uid) {
            return this._children.findOne(function (child) {
                return child.uid === uid;
            });
        };
        EntityObjectManager.prototype.findChildByTag = function (tag) {
            return this._children.findOne(function (child) {
                return child.hasTag(tag);
            });
        };
        EntityObjectManager.prototype.findChildByName = function (name) {
            return this._children.findOne(function (child) {
                return child.name.search(name) > -1;
            });
        };
        EntityObjectManager.prototype.findChildrenByName = function (name) {
            return this._children.filter(function (child) {
                return child.name.search(name) > -1;
            });
        };
        EntityObjectManager.prototype.removeChild = function (child) {
            child.onExit();
            this._children.removeChild(child);
            child.parent = null;
            return this;
        };
        EntityObjectManager.prototype.removeAllChildren = function () {
            var _this = this;
            this._children.forEach(function (child) {
                _this.removeChild(child);
            }, this);
        };
        return EntityObjectManager;
    }());
    wd.EntityObjectManager = EntityObjectManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ScriptManager = (function () {
        function ScriptManager(entityObject) {
            this._scriptList = wdCb.Hash.create();
            this._entityObject = null;
            this._scriptExecuteHistory = wdCb.Hash.create();
            this._entityObject = entityObject;
        }
        ScriptManager.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        ScriptManager.prototype.addChild = function (scriptName, classInstance) {
            this._scriptList.addChild(scriptName, classInstance);
        };
        ScriptManager.prototype.getChild = function (scriptName) {
            return this._scriptList.getChild(scriptName);
        };
        ScriptManager.prototype.removeChild = function (targetClassInstance) {
            return this._scriptList.removeChild(function (classInstance) {
                return classInstance === targetClassInstance;
            });
        };
        ScriptManager.prototype.hasChild = function (targetClassInstance) {
            return this._scriptList.hasChildWithFunc(function (classInstance) {
                return classInstance === targetClassInstance;
            });
        };
        ScriptManager.prototype.execScriptOnlyOnce = function (method) {
            var _this = this;
            this._scriptList.forEach(function (script, scriptName) {
                if (_this._isScriptExecuted(scriptName, method)) {
                    return;
                }
                if (script && script[method]) {
                    script[method]();
                }
                _this._addToScriptExecuteHistory(scriptName, method);
            }, this);
        };
        ScriptManager.prototype.execScriptWithData = function (method, data) {
            this._scriptList.forEach(function (script) {
                if (script[method]) {
                    script[method](data);
                }
            });
        };
        ScriptManager.prototype.execScript = function (method) {
            this._scriptList.forEach(function (script) {
                if (script[method]) {
                    script[method]();
                }
            });
        };
        ScriptManager.prototype.execEventScriptWithData = function (method, data) {
            this._scriptList.forEach(function (script) {
                if (script && script[method]) {
                    script[method](data);
                }
            });
        };
        ScriptManager.prototype._addToScriptExecuteHistory = function (scriptName, method) {
            this._scriptExecuteHistory.addChild(this._buildScriptHistoryKey(scriptName, method), true);
        };
        ScriptManager.prototype._isScriptExecuted = function (scriptName, method) {
            return this._scriptExecuteHistory.getChild(this._buildScriptHistoryKey(scriptName, method));
        };
        ScriptManager.prototype._buildScriptHistoryKey = function (scriptName, method) {
            return scriptName + "_" + method;
        };
        return ScriptManager;
    }());
    wd.ScriptManager = ScriptManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ComponentContainer = (function () {
        function ComponentContainer() {
            this.list = wdCb.Collection.create();
        }
        ComponentContainer.prototype.addChild = function (component) {
            this.list.addChild(component);
        };
        ComponentContainer.prototype.removeChild = function (component) {
            this.list.removeChild(component);
        };
        ComponentContainer.prototype.removeAllChildren = function () {
            this.list.removeAllChildren();
        };
        ComponentContainer.prototype.hasChild = function (component) {
            return this.list.hasChild(component);
        };
        return ComponentContainer;
    }());
    wd.ComponentContainer = ComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ScriptComponentContainer = (function () {
        function ScriptComponentContainer() {
            this._scriptList = wdCb.Collection.create();
        }
        ScriptComponentContainer.getInstance = function () { };
        ScriptComponentContainer.prototype.addChild = function (entityObject, scriptName, classInstance) {
            entityObject.scriptManager.addChild(scriptName, classInstance);
            this._scriptList.addChild(classInstance);
        };
        ScriptComponentContainer.prototype.removeChild = function (entityObject, classInstance) {
            entityObject.scriptManager.removeChild(classInstance);
            this._scriptList.removeChild(classInstance);
        };
        ScriptComponentContainer.prototype.removeAllChildren = function () {
            this._scriptList.removeAllChildren();
        };
        ScriptComponentContainer.prototype.findScript = function (entityObject, scriptName) {
            return entityObject.scriptManager.getChild(scriptName);
        };
        ScriptComponentContainer.prototype.execEntityObjectScript = function (entityObject, method) {
            entityObject.scriptManager.execScript(method);
        };
        ScriptComponentContainer.prototype.execEntityObjectScriptOnlyOnce = function (entityObject, method) {
            entityObject.scriptManager.execScriptOnlyOnce(method);
        };
        ScriptComponentContainer.prototype.execEntityObjectScriptWithData = function (entityObject, method, data) {
            entityObject.scriptManager.execScriptWithData(method, data);
        };
        ScriptComponentContainer.prototype.execScript = function (method) {
            this._scriptList.forEach(function (script) {
                if (script[method]) {
                    script[method]();
                }
            });
        };
        ScriptComponentContainer.prototype.execScriptWithData = function (method, data) {
            this._scriptList.forEach(function (script) {
                if (script[method]) {
                    script[method](data);
                }
            });
        };
        ScriptComponentContainer.prototype.execEntityObjectEventScriptWithData = function (entityObject, method, data) {
            entityObject.scriptManager.execEventScriptWithData(method, data);
        };
        ScriptComponentContainer = __decorate([
            wd.singleton()
        ], ScriptComponentContainer);
        return ScriptComponentContainer;
    }());
    wd.ScriptComponentContainer = ScriptComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CollisionComponentContainer = (function (_super) {
        __extends(CollisionComponentContainer, _super);
        function CollisionComponentContainer() {
            _super.call(this);
            this._collisionDetector = wd.CollisionDetector.create();
        }
        CollisionComponentContainer.getInstance = function () { };
        CollisionComponentContainer.prototype.update = function (elapsed) {
            this.list.forEach(function (child) {
                child.update(elapsed);
            });
        };
        CollisionComponentContainer.prototype.detect = function (elapsed) {
            this._collisionDetector.update(elapsed);
        };
        CollisionComponentContainer = __decorate([
            wd.singleton()
        ], CollisionComponentContainer);
        return CollisionComponentContainer;
    }(wd.ComponentContainer));
    wd.CollisionComponentContainer = CollisionComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ActionComponentContainer = (function (_super) {
        __extends(ActionComponentContainer, _super);
        function ActionComponentContainer() {
            _super.call(this);
        }
        ActionComponentContainer.getInstance = function () { };
        ActionComponentContainer.prototype.update = function (elapsed) {
            var removeQueue = [];
            this.list.forEach(function (child) {
                if (child.isFinish) {
                    removeQueue.push(child);
                    return;
                }
                if (child.isStop || child.isPause) {
                    return;
                }
                child.update(elapsed);
            });
            for (var _i = 0, removeQueue_1 = removeQueue; _i < removeQueue_1.length; _i++) {
                var child = removeQueue_1[_i];
                child.entityObject.removeComponent(child);
            }
        };
        ActionComponentContainer = __decorate([
            wd.singleton()
        ], ActionComponentContainer);
        return ActionComponentContainer;
    }(wd.ComponentContainer));
    wd.ActionComponentContainer = ActionComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LODComponentContainer = (function (_super) {
        __extends(LODComponentContainer, _super);
        function LODComponentContainer() {
            _super.call(this);
        }
        LODComponentContainer.getInstance = function () { };
        LODComponentContainer.prototype.update = function (elapsed) {
            this.list.forEach(function (child) {
                child.update(elapsed);
            });
        };
        LODComponentContainer = __decorate([
            wd.singleton()
        ], LODComponentContainer);
        return LODComponentContainer;
    }(wd.ComponentContainer));
    wd.LODComponentContainer = LODComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SpacePartitionComponentContainer = (function (_super) {
        __extends(SpacePartitionComponentContainer, _super);
        function SpacePartitionComponentContainer() {
            _super.call(this);
        }
        SpacePartitionComponentContainer.getInstance = function () { };
        SpacePartitionComponentContainer.prototype.update = function (elapsed) {
            this.list.forEach(function (child) {
                child.update(elapsed);
            });
        };
        SpacePartitionComponentContainer = __decorate([
            wd.singleton()
        ], SpacePartitionComponentContainer);
        return SpacePartitionComponentContainer;
    }(wd.ComponentContainer));
    wd.SpacePartitionComponentContainer = SpacePartitionComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var AnimationComponentContainer = (function (_super) {
        __extends(AnimationComponentContainer, _super);
        function AnimationComponentContainer() {
            _super.call(this);
        }
        AnimationComponentContainer.getInstance = function () { };
        AnimationComponentContainer.prototype.update = function (elapsed) {
            this.list.forEach(function (child) {
                child.update(elapsed);
            });
        };
        AnimationComponentContainer = __decorate([
            wd.singleton()
        ], AnimationComponentContainer);
        return AnimationComponentContainer;
    }(wd.ComponentContainer));
    wd.AnimationComponentContainer = AnimationComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PhysicsComponentContainer = (function (_super) {
        __extends(PhysicsComponentContainer, _super);
        function PhysicsComponentContainer() {
            _super.call(this);
            this.physicsEngineAdapter = wd.PhysicsEngineFactory.createNullAdapter();
        }
        PhysicsComponentContainer.getInstance = function () { };
        PhysicsComponentContainer.prototype.removeChild = function (body) {
            var physicsEngineAdapter = this.physicsEngineAdapter;
            _super.prototype.removeChild.call(this, body);
            if (physicsEngineAdapter) {
                var entityObject = body.entityObject;
                physicsEngineAdapter.removeGameObject(entityObject);
                physicsEngineAdapter.removeConstraints(entityObject);
            }
        };
        PhysicsComponentContainer.prototype.initPhysicsComponentContainerAdapter = function () {
            var physics = wd.Director.getInstance().scene.physics;
            this.physicsEngineAdapter = wd.PhysicsEngineFactory.create(physics.enable, physics.engine);
            this.physicsEngineAdapter.init();
        };
        PhysicsComponentContainer.prototype.initBody = function () {
            this.list.forEach(function (child) {
                child.initBody();
            });
        };
        PhysicsComponentContainer.prototype.initConstraint = function () {
            this.list.forEach(function (child) {
                child.initConstraint();
            });
        };
        PhysicsComponentContainer.prototype.update = function (elapsed) {
            var physics = wd.Director.getInstance().scene.physics;
            if (physics.enable) {
                this.physicsEngineAdapter.update(elapsed);
            }
        };
        PhysicsComponentContainer = __decorate([
            wd.singleton()
        ], PhysicsComponentContainer);
        return PhysicsComponentContainer;
    }(wd.ComponentContainer));
    wd.PhysicsComponentContainer = PhysicsComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BillboardComponentContainer = (function (_super) {
        __extends(BillboardComponentContainer, _super);
        function BillboardComponentContainer() {
            _super.call(this);
        }
        BillboardComponentContainer.getInstance = function () { };
        BillboardComponentContainer.prototype.update = function (elapsed) {
            this.list.forEach(function (child) {
                child.update(elapsed);
            });
        };
        BillboardComponentContainer = __decorate([
            wd.singleton()
        ], BillboardComponentContainer);
        return BillboardComponentContainer;
    }(wd.ComponentContainer));
    wd.BillboardComponentContainer = BillboardComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var UIComponentContainer = (function (_super) {
        __extends(UIComponentContainer, _super);
        function UIComponentContainer() {
            _super.apply(this, arguments);
        }
        UIComponentContainer.prototype.update = function (elapsed) {
            this.list.forEach(function (child) {
                child.update(elapsed);
            });
        };
        UIComponentContainer = __decorate([
            wd.singleton()
        ], UIComponentContainer);
        return UIComponentContainer;
    }(wd.ComponentContainer));
    wd.UIComponentContainer = UIComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ThreeDUIComponentContainer = (function (_super) {
        __extends(ThreeDUIComponentContainer, _super);
        function ThreeDUIComponentContainer() {
            _super.call(this);
        }
        ThreeDUIComponentContainer.getInstance = function () { };
        ThreeDUIComponentContainer = __decorate([
            wd.singleton()
        ], ThreeDUIComponentContainer);
        return ThreeDUIComponentContainer;
    }(wd.UIComponentContainer));
    wd.ThreeDUIComponentContainer = ThreeDUIComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDUIComponentContainer = (function (_super) {
        __extends(TwoDUIComponentContainer, _super);
        function TwoDUIComponentContainer() {
            _super.call(this);
        }
        TwoDUIComponentContainer.getInstance = function () { };
        TwoDUIComponentContainer.prototype.render = function () {
            var _this = this;
            this.list.forEach(function (ui) {
                var uiObject = ui.entityObject;
                if (uiObject.isVisible && _this._isDirty(ui.entityObject))
                    ui.render();
            }, this);
        };
        TwoDUIComponentContainer.prototype._isDirty = function (uiObject) {
            return uiObject.getComponent(wd.UIRenderer).state === wd.EUIRendererState.DIRTY;
        };
        TwoDUIComponentContainer = __decorate([
            wd.singleton()
        ], TwoDUIComponentContainer);
        return TwoDUIComponentContainer;
    }(wd.UIComponentContainer));
    wd.TwoDUIComponentContainer = TwoDUIComponentContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var UIObject = (function (_super) {
        __extends(UIObject, _super);
        function UIObject() {
            _super.apply(this, arguments);
            this._isVisible = true;
        }
        UIObject.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(UIObject.prototype, "isVisible", {
            get: function () {
                return this._isVisible;
            },
            set: function (isVisible) {
                if (this._isVisible !== isVisible) {
                    this._isVisible = isVisible;
                    wd.UIRendererUtils.getUIRenderer(this).dirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        UIObject.prototype.createTransform = function () {
            return wd.RectTransform.create();
        };
        UIObject.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.name = "uiObject" + String(this.uid);
        };
        UIObject.prototype.addComponent = function (component) {
            _super.prototype.addComponent.call(this, component);
            return this;
        };
        UIObject.prototype.addChild = function (child) {
            _super.prototype.addChild.call(this, child);
            return this;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], UIObject.prototype, "_isVisible", void 0);
        __decorate([
            wd.require(function (component) {
                if (component instanceof wd.TwoDUI) {
                    wd.assert(!!!this.getComponent(wd.TwoDUI), wd.Log.info.FUNC_SHOULD("only has one TwoDUI component"));
                }
            })
        ], UIObject.prototype, "addComponent", null);
        __decorate([
            wd.require(function (child) {
                wd.assert(this.getComponent(wd.UIRenderer) === child.getComponent(wd.UIRenderer), wd.Log.info.FUNC_MUST_BE("the UIRenderer of UIObject and its children", "the same one"));
            })
        ], UIObject.prototype, "addChild", null);
        return UIObject;
    }(wd.EntityObject));
    wd.UIObject = UIObject;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        function GameObject() {
            _super.apply(this, arguments);
            this.renderGroup = 0;
            this.renderPriority = 0;
            this.isVisible = true;
        }
        GameObject.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        GameObject.merge = function (gameObjectArr) {
            var source = gameObjectArr[0], resultObject = source.clone({
                cloneChildren: false,
                cloneGeometry: false
            }), mergedGeometry = wd.ModelGeometry.create();
            resultObject.removeAllChildren();
            for (var _i = 0, gameObjectArr_1 = gameObjectArr; _i < gameObjectArr_1.length; _i++) {
                var gameObject = gameObjectArr_1[_i];
                mergedGeometry.merge(gameObject.getComponent(wd.Geometry), gameObject.transform);
            }
            mergedGeometry.material = source.getComponent(wd.Geometry).material.clone();
            resultObject.addComponent(mergedGeometry);
            return resultObject;
        };
        GameObject.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.name = "gameObject" + String(this.uid);
        };
        GameObject.prototype.getSpacePartition = function () {
            return this.getComponent(wd.ClassUtils.getClass("SpacePartition"));
        };
        GameObject.prototype.getGeometry = function () {
            var GeometryLOD = wd.ClassUtils.getClass("GeometryLOD");
            if (!!GeometryLOD) {
                var lod = this.getComponent(GeometryLOD);
                if (lod && lod.activeGeometry) {
                    return lod.activeGeometry;
                }
            }
            return _super.prototype.getGeometry.call(this);
        };
        GameObject.prototype.createTransform = function () {
            return wd.ThreeDTransform.create();
        };
        GameObject.prototype.getRenderList = function () {
            if (wd.ClassUtils.hasComponent(this, "Octree")) {
                return this.getSpacePartition().getRenderList();
            }
            return wd.RenderUtils.getGameObjectRenderList(this.getChildren());
        };
        GameObject.prototype.afterInitChildren = function () {
            if (wd.ClassUtils.hasComponent(this, "Octree")) {
                return this.getSpacePartition().build();
            }
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GameObject.prototype, "renderGroup", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GameObject.prototype, "renderPriority", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GameObject.prototype, "isVisible", void 0);
        __decorate([
            wd.require(function (gameObjectArr) {
                var checkShouldContainGeometry = function (gameObject) {
                    wd.assert(gameObject.hasComponent(wd.Geometry), wd.Log.info.FUNC_SHOULD("contain geometry component"));
                }, checkShouldHasTheSameMaterialClass = function () {
                    var sourceObject = gameObjectArr[0], materialClassName = null;
                    checkShouldContainGeometry(sourceObject);
                    materialClassName = wd.ClassUtils.getClassName(sourceObject.getComponent(wd.Geometry).material);
                    for (var i = 1, len = gameObjectArr.length; i < len; i++) {
                        var gameObject = gameObjectArr[i];
                        checkShouldContainGeometry(gameObject);
                        wd.assert(wd.ClassUtils.getClassName(gameObject.getComponent(wd.Geometry).material) === materialClassName, wd.Log.info.FUNC_SHOULD("gameObjectArr", "has the same material class"));
                    }
                };
                wd.assert(gameObjectArr.length > 1, wd.Log.info.FUNC_SHOULD("object count", "> 1"));
                checkShouldHasTheSameMaterialClass();
            }),
            wd.ensure(function (mergedObject) {
                wd.assert(mergedObject.getChildren().getCount() === 0, wd.Log.info.FUNC_SHOULD("merged object", "has no children"));
            })
        ], GameObject, "merge", null);
        return GameObject;
    }(wd.EntityObject));
    wd.GameObject = GameObject;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SceneDispatcher = (function (_super) {
        __extends(SceneDispatcher, _super);
        function SceneDispatcher() {
            _super.apply(this, arguments);
            this.name = "scene" + String(this.uid);
            this.uiObjectScene = null;
            this.gameObjectScene = wd.GameObjectScene.create();
        }
        SceneDispatcher.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(SceneDispatcher.prototype, "scriptManager", {
            get: function () {
                return this.gameObjectScene.scriptManager;
            },
            set: function (manager) {
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "ambientLight", {
            get: function () {
                return this.gameObjectScene.ambientLight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "directionLights", {
            get: function () {
                return this.gameObjectScene.directionLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "pointLights", {
            get: function () {
                return this.gameObjectScene.pointLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "side", {
            get: function () {
                return this.gameObjectScene.side;
            },
            set: function (side) {
                this.gameObjectScene.side = side;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "shadowMap", {
            get: function () {
                return this.gameObjectScene.shadowMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "currentCamera", {
            get: function () {
                return this.gameObjectScene.currentCamera;
            },
            set: function (arg) {
                this.gameObjectScene.currentCamera = arg;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "physics", {
            get: function () {
                return this.gameObjectScene.physics;
            },
            set: function (physics) {
                this.gameObjectScene.physics = physics;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "glslData", {
            get: function () {
                return this.gameObjectScene.glslData;
            },
            set: function (glslData) {
                this.gameObjectScene.glslData = glslData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "isUseShader", {
            get: function () {
                return this.gameObjectScene.isUseShader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneDispatcher.prototype, "currentShaderType", {
            get: function () {
                return this.gameObjectScene.currentShaderType;
            },
            enumerable: true,
            configurable: true
        });
        SceneDispatcher.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.addComponent(wd.SceneEventTriggerDetector.create());
            var UIObjectScene = wd.ClassUtils.getClass("UIObjectScene");
            if (!!UIObjectScene) {
                this.uiObjectScene = UIObjectScene.create();
            }
        };
        SceneDispatcher.prototype.useShaderType = function (type) {
            this.gameObjectScene.useShaderType(type);
        };
        SceneDispatcher.prototype.unUseShader = function () {
            this.gameObjectScene.unUseShader();
        };
        SceneDispatcher.prototype.addChild = function (child) {
            if (child instanceof wd.GameObject) {
                this.gameObjectScene.addChild(child);
            }
            else if (wd.JudgeUtils.isClass(child, "UIObject")) {
                this.uiObjectScene.addChild(child);
            }
            child.parent = this;
            return this;
        };
        SceneDispatcher.prototype.addCommonRenderTargetRenderer = function (renderTargetRenderer) {
            return this.gameObjectScene.renderTargetRendererManager.addCommonRenderTargetRenderer(renderTargetRenderer);
        };
        SceneDispatcher.prototype.addProceduralRenderTargetRenderer = function (renderTargetRenderer) {
            return this.gameObjectScene.renderTargetRendererManager.addProceduralRenderTargetRenderer(renderTargetRenderer);
        };
        SceneDispatcher.prototype.dispose = function () {
            this.gameObjectScene.dispose();
            this.uiObjectScene.dispose();
        };
        SceneDispatcher.prototype.hasChild = function (child) {
            if (child instanceof wd.GameObject) {
                return this.gameObjectScene.hasChild(child);
            }
            else if (wd.JudgeUtils.isClass(child, "UIObject")) {
                return this.uiObjectScene.hasChild(child);
            }
        };
        SceneDispatcher.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args[0] instanceof wd.EntityObject) {
                var child = args[0];
                this.addChild(child);
            }
            if (args[0] instanceof wdCb.Collection) {
                var children = args[0], self_5 = this;
                children.forEach(function (child) {
                    self_5.addChild(child);
                });
            }
            else if (wd.JudgeUtils.isArrayExactly(args[0])) {
                var children = args[0];
                for (var _a = 0, children_2 = children; _a < children_2.length; _a++) {
                    var child = children_2[_a];
                    this.addChild(child);
                }
            }
            return this;
        };
        SceneDispatcher.prototype.getChildren = function () {
            return this.gameObjectScene.getChildren().clone().addChildren(this.uiObjectScene.getChildren());
        };
        SceneDispatcher.prototype.findChildByUid = function (uid) {
            var result = this.gameObjectScene.findChildByUid(uid);
            if (!result) {
                result = this.uiObjectScene.findChildByUid(uid);
            }
            return result;
        };
        SceneDispatcher.prototype.findChildByTag = function (tag) {
            var result = this.gameObjectScene.findChildByTag(tag);
            if (!result) {
                result = this.uiObjectScene.findChildByTag(tag);
            }
            return result;
        };
        SceneDispatcher.prototype.findChildByName = function (name) {
            var result = this.gameObjectScene.findChildByName(name);
            if (!result) {
                result = this.uiObjectScene.findChildByName(name);
            }
            return result;
        };
        SceneDispatcher.prototype.findChildrenByName = function (name) {
            return this.gameObjectScene.findChildrenByName(name).addChildren(this.uiObjectScene.findChildrenByName(name));
        };
        SceneDispatcher.prototype.removeChild = function (child) {
            if (child instanceof wd.GameObject) {
                return this.gameObjectScene.removeChild(child);
            }
            else if (wd.JudgeUtils.isClass(child, "UIObject")) {
                return this.uiObjectScene.removeChild(child);
            }
        };
        SceneDispatcher.prototype.onEnter = function () {
            this.gameObjectScene.onEnter();
            this.uiObjectScene.onEnter();
        };
        SceneDispatcher.prototype.onExit = function () {
            this.gameObjectScene.onExit();
            this.uiObjectScene.onExit();
        };
        SceneDispatcher.prototype.onDispose = function () {
            this.gameObjectScene.onDispose();
            this.uiObjectScene.onDispose();
        };
        SceneDispatcher.prototype.createTransform = function () {
            return null;
        };
        __decorate([
            wd.ensureGetter(function (directionLights) {
                if (!directionLights) {
                    return;
                }
                wd.assert(directionLights.getCount() <= 4, wd.Log.info.FUNC_SHOULD("direction lights' count", "<= 4"));
            })
        ], SceneDispatcher.prototype, "directionLights", null);
        __decorate([
            wd.ensureGetter(function (pointLights) {
                if (!pointLights) {
                    return;
                }
                wd.assert(pointLights.getCount() <= 4, wd.Log.info.FUNC_SHOULD("point lights' count", "<= 4"));
            })
        ], SceneDispatcher.prototype, "pointLights", null);
        return SceneDispatcher;
    }(wd.EntityObject));
    wd.SceneDispatcher = SceneDispatcher;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene() {
            _super.apply(this, arguments);
        }
        return Scene;
    }(wd.EntityObject));
    wd.Scene = Scene;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var UIObjectScene = (function (_super) {
        __extends(UIObjectScene, _super);
        function UIObjectScene() {
            _super.apply(this, arguments);
            this._startLoopSubscription = null;
            this._endLoopSubscription = null;
        }
        UIObjectScene.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        UIObjectScene.prototype.init = function () {
            var self = this;
            _super.prototype.init.call(this);
            this._startLoopSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.STARTLOOP)
                .subscribe(function () {
                self._sortSiblingChildren();
            });
            this._endLoopSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.ENDLOOP)
                .subscribe(function () {
                self._resetAllRendererClearCanvasFlag();
            });
            return this;
        };
        UIObjectScene.prototype.update = function (elapsed) {
            _super.prototype.update.call(this, elapsed);
            wd.TwoDUIComponentContainer.getInstance().update(elapsed);
        };
        UIObjectScene.prototype.onDispose = function () {
            _super.prototype.onDispose.call(this);
            this._startLoopSubscription.dispose();
            this._endLoopSubscription.dispose();
        };
        UIObjectScene.prototype.render = function () {
            var self = this;
            this._resetAllRendererState();
            this.forEach(function (child) {
                var renderer = self._getUIRenderer(child);
                if (renderer.dirty) {
                    if (!renderer.isClearCanvas) {
                        renderer.clearCanvas();
                    }
                    renderer.state = wd.EUIRendererState.DIRTY;
                    renderer.resetDirty();
                }
                else {
                    if (renderer.state !== wd.EUIRendererState.DIRTY) {
                        renderer.state = wd.EUIRendererState.NOT_DIRTY;
                    }
                }
            });
            wd.TwoDUIComponentContainer.getInstance().render();
        };
        UIObjectScene.prototype.createTransform = function () {
            return null;
        };
        UIObjectScene.prototype._getUIRenderer = function (uiObject) {
            return wd.UIRendererUtils.getUIRenderer(uiObject);
        };
        UIObjectScene.prototype._resetAllRendererClearCanvasFlag = function () {
            var self = this;
            this.forEach(function (child) {
                var renderer = self._getUIRenderer(child);
                renderer.isClearCanvas = false;
            });
        };
        UIObjectScene.prototype._resetAllRendererState = function () {
            var self = this;
            this.forEach(function (child) {
                var renderer = self._getUIRenderer(child);
                renderer.state = wd.EUIRendererState.NORMAL;
            });
        };
        UIObjectScene.prototype._sortSiblingChildren = function () {
            var sort = function (uiObject) {
                uiObject.sort(function (a, b) {
                    return a.transform.zIndex - b.transform.zIndex;
                }, true);
                uiObject.forEach(function (child) {
                    sort(child);
                });
            };
            sort(this);
        };
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("child must be UIObject", function () {
                    _this.forEach(function (child) {
                        wd.expect(child).instanceof(wd.UIObject);
                    });
                });
            })
        ], UIObjectScene.prototype, "render", null);
        __decorate([
            wd.require(function (uiObject) {
                wd.it("uiObject shouldn't contain more than 1 uiRenderer component", function () {
                    wd.expect(uiObject.getComponentCount(wd.UIRenderer)).lte(1);
                });
            })
        ], UIObjectScene.prototype, "_getUIRenderer", null);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("should reset all UIRenderers->isClearCanvas", function () {
                    _this.getAllChildren().forEach(function (child) {
                        var renderer = _this._getUIRenderer(child);
                        wd.expect(renderer.isClearCanvas).false;
                    });
                }, this);
            })
        ], UIObjectScene.prototype, "_resetAllRendererClearCanvasFlag", null);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("should reset all UIRenderers->isClearCanvas", function () {
                    _this.getAllChildren().forEach(function (child) {
                        var renderer = _this._getUIRenderer(child);
                        wd.expect(renderer.state).equals(wd.EUIRendererState.NORMAL);
                    });
                }, this);
            })
        ], UIObjectScene.prototype, "_resetAllRendererState", null);
        return UIObjectScene;
    }(wd.Scene));
    wd.UIObjectScene = UIObjectScene;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BufferTable = (function () {
        function BufferTable() {
        }
        BufferTable.bindIndexBuffer = function (indexBuffer) {
            var gl = null;
            if (this.lastBindedElementBuffer === indexBuffer) {
                return;
            }
            this.lastBindedElementBuffer = indexBuffer;
            gl = wd.DeviceManager.getInstance().gl;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
        };
        BufferTable.hasBuffer = function (key) {
            return this._table.hasChild(key);
        };
        BufferTable.addBuffer = function (key, buffer) {
            this._table.addChild(key, buffer);
        };
        BufferTable.getBuffer = function (key) {
            return this._table.getChild(key);
        };
        BufferTable.dispose = function () {
            this._table.forEach(function (buffer) {
                buffer.dispose();
            });
            this.lastBindedArrayBufferListUidStr = null;
            this.lastBindedElementBuffer = null;
        };
        BufferTable.clearAll = function () {
            this._table.removeAllChildren();
            this.lastBindedArrayBufferListUidStr = null;
            this.lastBindedElementBuffer = null;
        };
        BufferTable.resetBindedArrayBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            this.lastBindedArrayBufferListUidStr = null;
        };
        BufferTable.resetBindedElementBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            this.lastBindedElementBuffer = null;
        };
        BufferTable.lastBindedArrayBufferListUidStr = null;
        BufferTable.lastBindedElementBuffer = null;
        BufferTable._table = wdCb.Hash.create();
        return BufferTable;
    }());
    wd.BufferTable = BufferTable;
    (function (BufferTableKey) {
        BufferTableKey[BufferTableKey["PROCEDURAL_VERTEX"] = "PROCEDURAL_VERTEX"] = "PROCEDURAL_VERTEX";
        BufferTableKey[BufferTableKey["PROCEDURAL_INDEX"] = "PROCEDURAL_INDEX"] = "PROCEDURAL_INDEX";
    })(wd.BufferTableKey || (wd.BufferTableKey = {}));
    var BufferTableKey = wd.BufferTableKey;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ProgramTable = (function () {
        function ProgramTable() {
        }
        ProgramTable.hasProgram = function (key) {
            return this._table.hasChild(key);
        };
        ProgramTable.addProgram = function (key, program) {
            this._table.addChild(key, program);
        };
        ProgramTable.getProgram = function (key) {
            return this._table.getChild(key);
        };
        ProgramTable.dispose = function () {
            this._table.forEach(function (program) {
                program.dispose();
            });
            this.lastUsedProgram = null;
        };
        ProgramTable.clearAll = function () {
            this._table.removeAllChildren();
            this.lastUsedProgram = null;
        };
        ProgramTable.lastUsedProgram = null;
        ProgramTable._table = wdCb.Hash.create();
        return ProgramTable;
    }());
    wd.ProgramTable = ProgramTable;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TextureCache = (function () {
        function TextureCache() {
        }
        TextureCache.isCached = function (unit, texture) {
            return wd.JudgeUtils.isEqual(this.getActiveTexture(unit), texture);
        };
        TextureCache.addActiveTexture = function (unit, texture) {
            this._bindTextureUnitCache[unit] = texture;
        };
        TextureCache.getActiveTexture = function (unit) {
            return this._bindTextureUnitCache[unit];
        };
        TextureCache.clearAll = function () {
            this._bindTextureUnitCache = [];
        };
        TextureCache.clearAllBindTextureUnitCache = function () {
            this._bindTextureUnitCache = [];
        };
        TextureCache.clearBindTextureUnitCache = function (unit) {
            this._bindTextureUnitCache[unit] = null;
        };
        TextureCache._checkUnit = function (unit) {
            var maxTextureUnit = wd.GPUDetector.getInstance().maxTextureUnit;
            wd.assert(unit >= 0, wd.Log.info.FUNC_SHOULD("texture unit", ">= 0, but actual is " + unit));
            wd.assert(unit < maxTextureUnit, "trying to cache " + unit + " texture units, but GPU only supports " + maxTextureUnit + " units");
        };
        TextureCache._bindTextureUnitCache = [];
        __decorate([
            wd.require(function (unit, texture) {
                this._checkUnit(unit);
            })
        ], TextureCache, "addActiveTexture", null);
        __decorate([
            wd.require(function (unit, texture) {
                this._checkUnit(unit);
            })
        ], TextureCache, "getActiveTexture", null);
        return TextureCache;
    }());
    wd.TextureCache = TextureCache;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GameObjectScene = (function (_super) {
        __extends(GameObjectScene, _super);
        function GameObjectScene() {
            _super.apply(this, arguments);
            this._currentCamera = null;
            this.side = null;
            this.shadowMap = ShadowMapModel.create(this);
            this.physics = wd.ClassUtils.createClassInstance("PhysicsConfig");
            this.glslData = wdCb.Hash.create();
            this.currentShaderType = null;
            this.renderTargetRendererManager = wd.RenderTargetRendererManager.create();
            this.shadowManager = wd.ClassUtils.createClassInstanceOrEmpty("ShadowManager", "EmptyShadowManager", this);
            this._lightManager = wd.LightManager.create();
            this._cameraList = wdCb.Collection.create();
        }
        GameObjectScene.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(GameObjectScene.prototype, "ambientLight", {
            get: function () {
                return this._lightManager.ambientLight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObjectScene.prototype, "directionLights", {
            get: function () {
                return this._lightManager.directionLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObjectScene.prototype, "pointLights", {
            get: function () {
                return this._lightManager.pointLights;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObjectScene.prototype, "currentCamera", {
            get: function () {
                return this._currentCamera || this._cameraList.getChild(0);
            },
            set: function (arg) {
                if (wd.JudgeUtils.isNumber(arg)) {
                    var index = arg;
                    this._currentCamera = this._cameraList.getChild(index);
                }
                else if (arg instanceof wd.GameObject) {
                    var currentCamera = arg;
                    this._currentCamera = currentCamera;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObjectScene.prototype, "isUseShader", {
            get: function () {
                return this.currentShaderType !== null;
            },
            enumerable: true,
            configurable: true
        });
        GameObjectScene.prototype.init = function () {
            wd.ClassUtils.execSingletonMethod("PhysicsComponentContainer", "initPhysicsComponentContainerAdapter");
            if (this.shadowManager) {
                this.shadowManager.init();
            }
            _super.prototype.init.call(this);
            this.renderTargetRendererManager.init();
            wd.ClassUtils.execSingletonMethod("PhysicsComponentContainer", "initBody");
            wd.ClassUtils.execSingletonMethod("PhysicsComponentContainer", "initConstraint");
            return this;
        };
        GameObjectScene.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.shadowManager.dispose();
            this.renderTargetRendererManager.dispose();
        };
        GameObjectScene.prototype.addChild = function (child) {
            var cameraList = this._getCameras(child), lightList = this._getLights(child);
            if (cameraList.getCount() > 0) {
                this._cameraList.addChildren(cameraList);
            }
            if (lightList.getCount() > 0) {
                this._lightManager.addChildren(lightList);
            }
            return _super.prototype.addChild.call(this, child);
        };
        GameObjectScene.prototype.update = function (elapsed) {
            var currentCamera = this._getCurrentCameraComponent(), shadowManager = this.shadowManager;
            wd.ClassUtils.execSingletonMethod("PhysicsComponentContainer", "update", elapsed);
            if (currentCamera) {
                currentCamera.update(elapsed);
            }
            shadowManager.update(elapsed);
            wd.ClassUtils.execSingletonMethod("LODComponentContainer", "update", elapsed);
            wd.ClassUtils.execSingletonMethod("SpacePartitionComponentContainer", "update", elapsed);
            wd.ClassUtils.execSingletonMethod("AnimationComponentContainer", "update", elapsed);
            wd.CollisionComponentContainer.getInstance().update(elapsed);
            wd.ClassUtils.execSingletonMethod("ThreeDUIComponentContainer", "update", elapsed);
            _super.prototype.update.call(this, elapsed);
            wd.CollisionComponentContainer.getInstance().detect(elapsed);
            wd.ClassUtils.execSingletonMethod("BillboardComponentContainer", "update", elapsed);
        };
        GameObjectScene.prototype.render = function (renderer) {
            this.shadowManager.setShadowRenderListForCurrentLoop();
            this.renderTargetRendererManager.render(renderer, this.currentCamera);
            _super.prototype.render.call(this, renderer, this.currentCamera);
        };
        GameObjectScene.prototype.useShaderType = function (type) {
            this.currentShaderType = type;
        };
        GameObjectScene.prototype.unUseShader = function () {
            this.currentShaderType = null;
        };
        GameObjectScene.prototype.getRenderList = function () {
            return wd.RenderUtils.getGameObjectRenderList(this.getChildren());
        };
        GameObjectScene.prototype.createTransform = function () {
            return null;
        };
        GameObjectScene.prototype._getCameras = function (gameObject) {
            return this._find(gameObject, this._isCamera);
        };
        GameObjectScene.prototype._getLights = function (gameObject) {
            return this._find(gameObject, this._isLight);
        };
        GameObjectScene.prototype._find = function (gameObject, judgeFunc) {
            var self = this, resultArr = wdCb.Collection.create();
            var find = function (gameObject) {
                if (judgeFunc.call(self, gameObject)) {
                    resultArr.addChild(gameObject);
                }
                gameObject.forEach(function (child) {
                    find(child);
                });
            };
            find(gameObject);
            return resultArr;
        };
        GameObjectScene.prototype._isCamera = function (child) {
            return child.hasComponent(wd.CameraController);
        };
        GameObjectScene.prototype._isLight = function (child) {
            return child.hasComponent(wd.Light);
        };
        GameObjectScene.prototype._getCurrentCameraComponent = function () {
            if (!this.currentCamera) {
                return null;
            }
            return this.currentCamera.getComponent(wd.CameraController);
        };
        __decorate([
            wd.requireSetter(function (arg) {
                if (wd.JudgeUtils.isNumber(arg)) {
                    var index = arg;
                    wd.assert(!!this._cameraList.getChild(index), wd.Log.info.FUNC_NOT_EXIST("current camera in cameraList"));
                }
            })
        ], GameObjectScene.prototype, "currentCamera", null);
        return GameObjectScene;
    }(wd.Scene));
    wd.GameObjectScene = GameObjectScene;
    var ShadowMapModel = (function () {
        function ShadowMapModel(scene) {
            this._scene = null;
            this._enable = true;
            this._softType = wd.EShadowMapSoftType.NONE;
            this.shadowLayerList = wd.ClassUtils.createClassInstance("ShadowLayerList", this);
            this._scene = scene;
        }
        ShadowMapModel.create = function (scene) {
            var obj = new this(scene);
            return obj;
        };
        Object.defineProperty(ShadowMapModel.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                this._enable = enable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapModel.prototype, "softType", {
            get: function () {
                return this._softType;
            },
            set: function (softType) {
                if (softType !== this._softType) {
                    wd.EventManager.broadcast(this._scene, wd.CustomEvent.create(wd.EEngineEvent.SHADOWMAP_SOFTTYPE_CHANGE));
                    this._softType = softType;
                }
            },
            enumerable: true,
            configurable: true
        });
        ShadowMapModel.prototype.getTwoDShadowMapDataMap = function (layer) {
            return this._scene.shadowManager.getTwoDShadowMapDataMap(layer);
        };
        ShadowMapModel.prototype.getCubemapShadowMapDataMap = function (layer) {
            return this._scene.shadowManager.getCubemapShadowMapDataMap(layer);
        };
        return ShadowMapModel;
    }());
    wd.ShadowMapModel = ShadowMapModel;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CollisionDetector = (function () {
        function CollisionDetector() {
            this._collisionTable = wdCb.Hash.create();
            this._lastCollisionTable = wdCb.Hash.create();
        }
        CollisionDetector.create = function () {
            var obj = new this();
            return obj;
        };
        CollisionDetector.prototype.update = function (elapsed) {
            var scene = wd.Director.getInstance().scene.gameObjectScene, checkTargetList = scene.filter(function (gameObjectScene) {
                return gameObjectScene.hasComponent(wd.Collider)
                    || (wd.JudgeUtils.isSpacePartitionObject(gameObjectScene) && gameObjectScene.getSpacePartition().isCollideEnable);
            }), self = this;
            if (checkTargetList.getCount() === 0) {
                return;
            }
            this._clearCollisionTable();
            checkTargetList.forEach(function (gameObjectScene) {
                if (wd.ClassUtils.hasComponent(gameObjectScene, "RigidBody")) {
                    return;
                }
                self._recordCollideObjects(gameObjectScene, checkTargetList);
            });
            this._triggerCollisionEvent();
        };
        CollisionDetector.prototype._recordCollideObjects = function (sourceObject, checkTargetList) {
            var self = this;
            if (wd.JudgeUtils.isSpacePartitionObject(sourceObject)) {
                var sourceSpacePartition_1 = sourceObject.getSpacePartition();
                checkTargetList.forEach(function (targetObject) {
                    if (wd.JudgeUtils.isSelf(sourceObject, targetObject)) {
                        return;
                    }
                    if (wd.JudgeUtils.isSpacePartitionObject(targetObject)) {
                        self._handleCollisionBetweenSpacePartitionAndSpacePartition(targetObject.getSpacePartition(), sourceSpacePartition_1);
                    }
                    else {
                        self._handleCollisionBetweenGameObjectAndSpacePartition(targetObject.getComponent(wd.Collider), sourceSpacePartition_1);
                    }
                });
                return;
            }
            var sourceObjectCollider = sourceObject.getComponent(wd.Collider);
            if (!sourceObjectCollider.enable) {
                return;
            }
            checkTargetList.forEach(function (targetObject) {
                if (wd.JudgeUtils.isSelf(sourceObject, targetObject)) {
                    return;
                }
                if (wd.JudgeUtils.isSpacePartitionObject(targetObject)) {
                    self._handleCollisionBetweenGameObjectAndSpacePartition(sourceObjectCollider, targetObject.getSpacePartition());
                }
                else {
                    self._handleCollisionBetweenGameObjectAndGameObject(sourceObjectCollider, targetObject);
                }
            });
        };
        CollisionDetector.prototype._isGameObjectCollideWithGameObject = function (sourceObject, sourceCollider, targetObject) {
            return !(this._isNotTransform(sourceObject) && this._isNotTransform(targetObject) && !sourceObject.hasTag(ECollisionTag.COLLIDED))
                && sourceCollider.isCollide(targetObject);
        };
        CollisionDetector.prototype._clearCollisionTable = function () {
            this._collisionTable.removeAllChildren();
        };
        CollisionDetector.prototype._isCollidedInTable = function (sourceObject, targetObject) {
            var table = this._collisionTable, sourceKey = String(sourceObject.uid), targetKey = String(targetObject.uid);
            return table.hasChild(sourceKey) && table.getChild(sourceKey).targetObjectMap.hasChild(targetKey);
        };
        CollisionDetector.prototype._recordToTable = function (sourceObject, targetObject) {
            var table = this._collisionTable, sourceKey = String(sourceObject.uid), targetKey = String(targetObject.uid);
            if (!table.hasChild(sourceKey)) {
                var targetObjectMap = wdCb.Hash.create();
                targetObjectMap.addChild(targetKey, targetObject);
                table.addChild(sourceKey, {
                    sourceObject: sourceObject,
                    targetObjectMap: targetObjectMap
                });
                return;
            }
            table.getChild(sourceKey).targetObjectMap.addChild(targetKey, targetObject);
        };
        CollisionDetector.prototype._handleCollisionBetweenGameObjectAndSpacePartition = function (targetObjectCollider, spacePartition) {
            var targetObject = targetObjectCollider.entityObject, self = this;
            if (!targetObjectCollider.enable) {
                return;
            }
            spacePartition.getCollideObjects(targetObjectCollider.shape).forEach(function (sourceObject) {
                var sourceCollider = sourceObject.getComponent(wd.Collider);
                if (!sourceCollider.enable || self._isCollidedInTable(sourceObject, targetObject)) {
                    return;
                }
                if (self._isGameObjectCollideWithGameObject(sourceObject, sourceCollider, targetObject)) {
                    self._recordToTable(sourceObject, targetObject);
                    self._recordToTable(targetObject, sourceObject);
                }
            });
        };
        CollisionDetector.prototype._handleCollisionBetweenSpacePartitionAndSpacePartition = function (sourceSpacePartition, targetSpacePartition) {
            var _this = this;
            sourceSpacePartition.getChildren()
                .forEach(function (sourceObject) {
                var sourceCollider = sourceObject.getComponent(wd.Collider);
                if (!sourceCollider.enable) {
                    return;
                }
                _this._handleCollisionBetweenGameObjectAndSpacePartition(sourceCollider, targetSpacePartition);
            }, this);
        };
        CollisionDetector.prototype._handleCollisionBetweenGameObjectAndGameObject = function (sourceObjectCollider, targetObject) {
            var sourceObject = sourceObjectCollider.entityObject;
            if (!targetObject.getComponent(wd.Collider).enable || this._isCollidedInTable(sourceObject, targetObject)) {
                return;
            }
            if (this._isGameObjectCollideWithGameObject(sourceObject, sourceObjectCollider, targetObject)) {
                this._recordToTable(sourceObject, targetObject);
                this._recordToTable(targetObject, sourceObject);
            }
        };
        CollisionDetector.prototype._isCollisionStart = function (gameObjectScene) {
            return !gameObjectScene.hasTag(ECollisionTag.COLLIDED);
        };
        CollisionDetector.prototype._triggerCollisionEventOfCollideObjectWhichHasRigidBody = function (collideObjects, currentGameObject, eventList) {
            if (!wd.ClassUtils.hasComponent(currentGameObject, "RigidBody")) {
                return;
            }
            collideObjects.filter(function (gameObjectScene) {
                return wd.ClassUtils.hasComponent(gameObjectScene, "RigidBody");
            })
                .forEach(function (collideObject) {
                for (var _i = 0, eventList_1 = eventList; _i < eventList_1.length; _i++) {
                    var eventName = eventList_1[_i];
                    wd.ScriptComponentContainer.getInstance().execEntityObjectScriptWithData(collideObject, eventName, wdCb.Collection.create([currentGameObject]));
                }
            });
        };
        CollisionDetector.prototype._triggerCollisionEvent = function () {
            var _this = this;
            this._collisionTable.forEach(function (_a) {
                var sourceObject = _a.sourceObject, targetObjectMap = _a.targetObjectMap;
                var targetObjects = targetObjectMap.toCollection();
                if (_this._isCollisionStart(sourceObject)) {
                    wd.ScriptComponentContainer.getInstance().execEntityObjectScriptWithData(sourceObject, "onCollisionStart", targetObjects);
                    wd.ScriptComponentContainer.getInstance().execEntityObjectScriptWithData(sourceObject, "onContact", targetObjects);
                    _this._triggerCollisionEventOfCollideObjectWhichHasRigidBody(targetObjects, sourceObject, ["onCollisionStart", "onContact"]);
                }
                else {
                    wd.ScriptComponentContainer.getInstance().execEntityObjectScriptWithData(sourceObject, "onContact", targetObjects);
                    _this._triggerCollisionEventOfCollideObjectWhichHasRigidBody(targetObjects, sourceObject, ["onContact"]);
                }
                if (!sourceObject.hasTag(ECollisionTag.COLLIDED)) {
                    sourceObject.addTag(ECollisionTag.COLLIDED);
                }
            }, this);
            this._triggerCollisionEndEvent();
            this._lastCollisionTable = this._collisionTable.clone();
        };
        CollisionDetector.prototype._triggerCollisionEndEvent = function () {
            var _this = this;
            var table = this._collisionTable;
            this._lastCollisionTable.forEach(function (_a) {
                var sourceObject = _a.sourceObject, targetObjectMap = _a.targetObjectMap;
                if (!table.hasChild(String(sourceObject.uid))) {
                    wd.ScriptComponentContainer.getInstance().execEntityObjectScript(sourceObject, "onCollisionEnd");
                    _this._triggerCollisionEventOfCollideObjectWhichHasRigidBody(targetObjectMap.toCollection(), sourceObject, ["onCollisionEnd"]);
                    sourceObject.removeTag(ECollisionTag.COLLIDED);
                }
            });
        };
        CollisionDetector.prototype._isNotTransform = function (gameObjectScene) {
            return !gameObjectScene.transform.isTransform;
        };
        __decorate([
            wd.require(function (sourceObject, checkTargetList) {
                checkTargetList.forEach(function (targetObject) {
                    wd.assert(targetObject instanceof wd.GameObject, wd.Log.info.FUNC_SHOULD("targetObject", "be GameObject"));
                });
            })
        ], CollisionDetector.prototype, "_recordCollideObjects", null);
        __decorate([
            wd.require(function (sourceObject, sourceCollider, targetObject) {
                wd.assert(sourceObject instanceof wd.GameObject && targetObject instanceof wd.GameObject, wd.Log.info.FUNC_SHOULD("sourceObject and targetObject", "be GameObject"));
            })
        ], CollisionDetector.prototype, "_isGameObjectCollideWithGameObject", null);
        return CollisionDetector;
    }());
    wd.CollisionDetector = CollisionDetector;
    var ECollisionTag;
    (function (ECollisionTag) {
        ECollisionTag[ECollisionTag["COLLIDED"] = "COLLIDED"] = "COLLIDED";
    })(ECollisionTag || (ECollisionTag = {}));
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowManager = (function () {
        function ShadowManager(gameObjectScene) {
            this.gameObjectScene = null;
            this._shadowRenderList = null;
            this._endLoopSubscription = null;
            this._shadowMapManager = wd.ShadowMapManager.create(this);
            this._shadowMapLayerChangeSubscription = null;
            this.gameObjectScene = gameObjectScene;
        }
        ShadowManager.create = function (gameObjectScene) {
            var obj = new this(gameObjectScene);
            return obj;
        };
        Object.defineProperty(ShadowManager.prototype, "twoDShadowMapDataMap", {
            get: function () {
                return this._shadowMapManager.twoDShadowMapDataMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowManager.prototype, "twoDShadowMapCountForGLSL", {
            get: function () {
                return this._shadowMapManager.twoDShadowMapCountForGLSL;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowManager.prototype, "cubemapShadowMapDataMap", {
            get: function () {
                return this._shadowMapManager.cubemapShadowMapDataMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowManager.prototype, "cubemapShadowMapCountForGLSL", {
            get: function () {
                return this._shadowMapManager.cubemapShadowMapCountForGLSL;
            },
            enumerable: true,
            configurable: true
        });
        ShadowManager.prototype.update = function (elapsed) {
            if (!this._isShadowMapEnable()) {
                return;
            }
            this.gameObjectScene.shadowMap.shadowLayerList.update();
        };
        ShadowManager.prototype.dispose = function () {
            this._endLoopSubscription && this._endLoopSubscription.dispose();
            this._shadowMapLayerChangeSubscription && this._shadowMapLayerChangeSubscription.dispose();
            this._shadowMapManager.dispose();
        };
        ShadowManager.prototype.getTwoDShadowMapDataMap = function (layer) {
            return this._shadowMapManager.twoDShadowMapDataMap.getChild(layer);
        };
        ShadowManager.prototype.getCubemapShadowMapDataMap = function (layer) {
            return this._shadowMapManager.cubemapShadowMapDataMap.getChild(layer);
        };
        ShadowManager.prototype.setShadowRenderListForCurrentLoop = function () {
            if (!this._isShadowMapEnable()) {
                return;
            }
            this._shadowRenderList = this._getShadowRenderList();
        };
        ShadowManager.prototype.getShadowRenderListByLayer = function (layer) {
            return this._shadowRenderList.filter(function (gameObject) {
                return gameObject.getComponent(wd.Shadow).layer === layer;
            });
        };
        ShadowManager.prototype.getShadowLayerList = function () {
            var shadowLayerList = null, sceneShadowLayerList = this.gameObjectScene.shadowMap.shadowLayerList, self = this;
            if (sceneShadowLayerList.dirty) {
                return sceneShadowLayerList.removeRepeatItems();
            }
            shadowLayerList = wd.ShadowLayerList.create();
            wd.RenderUtils.getGameObjectRenderList(this.gameObjectScene.getChildren())
                .forEach(function (child) {
                if (wd.JudgeUtils.isSpacePartitionObject(child)) {
                    child.forEach(function (c) {
                        if (self._isCastShadow(c)) {
                            shadowLayerList.addChild(c.getComponent(wd.Shadow).layer);
                        }
                    });
                    return;
                }
                if (self._isCastShadow(child)) {
                    shadowLayerList.addChild(child.getComponent(wd.Shadow).layer);
                }
            });
            shadowLayerList.dirty = false;
            return shadowLayerList.removeRepeatItems();
        };
        ShadowManager.prototype.init = function () {
            var self = this, scene = this.gameObjectScene, sceneShadowLayerList = null;
            if (!this._isShadowMapEnable() || !this._hasShadow()) {
                return;
            }
            this.gameObjectScene.shadowMap.shadowLayerList = this.getShadowLayerList();
            sceneShadowLayerList = this.gameObjectScene.shadowMap.shadowLayerList;
            sceneShadowLayerList.init();
            this._shadowMapManager.initShadowMapData(sceneShadowLayerList);
            this._shadowMapManager.twoDShadowMapDataMap.forEach(function (twoDShadowMapDataList, layer) {
                twoDShadowMapDataList.forEach(function (_a) {
                    var shadowMap = _a.shadowMap, light = _a.light;
                    var renderer = wd.TwoDShadowMapRenderTargetRenderer.create(shadowMap, light, layer);
                    scene.renderTargetRendererManager.addCommonRenderTargetRenderer(renderer);
                });
            });
            this._shadowMapManager.cubemapShadowMapDataMap.forEach(function (cubemapShadowMapDataList, layer) {
                cubemapShadowMapDataList.forEach(function (_a) {
                    var shadowMap = _a.shadowMap, light = _a.light;
                    var renderer = wd.CubemapShadowMapRenderTargetRenderer.create(shadowMap, light, layer);
                    scene.renderTargetRendererManager.addCommonRenderTargetRenderer(renderer);
                });
            });
            this._initShadowList();
            this._shadowMapLayerChangeSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.SHADOWMAP_LAYER_CHANGE)
                .subscribe(function () {
                self._updateWhenShadowLayerChange();
            });
        };
        ShadowManager.prototype._getShadowRenderList = function () {
            var list = wdCb.Collection.create(), self = this;
            wd.RenderUtils.getGameObjectRenderList(this.gameObjectScene.getChildren())
                .forEach(function (child) {
                if (wd.JudgeUtils.isSpacePartitionObject(child)) {
                    list.addChildren(child.getSpacePartition().getRenderList().filter(function (c) {
                        return self._isCastShadow(c);
                    }));
                    return;
                }
                if (self._isCastShadow(child)) {
                    list.addChild(child);
                }
            });
            return list;
        };
        ShadowManager.prototype._updateWhenShadowLayerChange = function () {
            var scene = this.gameObjectScene;
            if (!this._hasShadow()) {
                return;
            }
            this._shadowMapManager.updateWhenShadowLayerChange(scene.shadowMap.shadowLayerList.getDiffData());
            var _a = this._shadowMapManager.getAllDiffShadowMapDataWhenShadowLayerChange(), addTwoDShadowMapData = _a.addTwoDShadowMapData, removeTwoDShadowMapData = _a.removeTwoDShadowMapData, addCubemapShadowMapData = _a.addCubemapShadowMapData, removeCubemapShadowMapData = _a.removeCubemapShadowMapData;
            this._refreshRenderTargerRendererList(addTwoDShadowMapData, removeTwoDShadowMapData, addCubemapShadowMapData, removeCubemapShadowMapData);
        };
        ShadowManager.prototype._refreshRenderTargerRendererList = function (addTwoDShadowMapData, removeTwoDShadowMapData, addCubemapShadowMapData, removeCubemapShadowMapData) {
            var scene = this.gameObjectScene;
            scene.renderTargetRendererManager.removeCommonRenderTargetRenderer(function (renderTargetRenderer) {
                var texture = renderTargetRenderer.texture;
                return removeTwoDShadowMapData.hasChildWithFunc(function (data) {
                    return wd.JudgeUtils.isEqual(data.shadowMap, texture);
                })
                    || removeCubemapShadowMapData.hasChildWithFunc(function (data) {
                        return wd.JudgeUtils.isEqual(data.shadowMap, texture);
                    });
            })
                .forEach(function (renderTargetRenderer) {
                renderTargetRenderer.dispose();
            });
            addTwoDShadowMapData.forEach(function (twoDShadowMapDataList, layer) {
                twoDShadowMapDataList.forEach(function (_a) {
                    var shadowMap = _a.shadowMap, light = _a.light;
                    var renderer = wd.TwoDShadowMapRenderTargetRenderer.create(shadowMap, light, layer);
                    renderer.init();
                    scene.renderTargetRendererManager.addCommonRenderTargetRenderer(renderer);
                });
            });
            addCubemapShadowMapData.forEach(function (cubemapShadowMapDataList, layer) {
                cubemapShadowMapDataList.forEach(function (_a) {
                    var shadowMap = _a.shadowMap, light = _a.light;
                    var renderer = wd.CubemapShadowMapRenderTargetRenderer.create(shadowMap, light, layer);
                    renderer.init();
                    scene.renderTargetRendererManager.addCommonRenderTargetRenderer(renderer);
                });
            });
        };
        ShadowManager.prototype._initShadowList = function () {
            var self = this;
            this._endLoopSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.ENDLOOP)
                .subscribe(function () {
                self._removeShadowMapGLSLData();
            });
        };
        ShadowManager.prototype._isCastShadow = function (gameObject) {
            var shadow = gameObject.getComponent(wd.Shadow);
            return !!shadow && shadow.cast;
        };
        ShadowManager.prototype._removeShadowMapGLSLData = function () {
            wd.Director.getInstance().scene.glslData.removeChild(wd.EShaderGLSLData.TWOD_SHADOWMAP);
            wd.Director.getInstance().scene.glslData.removeChild(wd.EShaderGLSLData.CUBEMAP_SHADOWMAP);
            wd.Director.getInstance().scene.glslData.removeChild(wd.EShaderGLSLData.BUILD_CUBEMAP_SHADOWMAP);
        };
        ShadowManager.prototype._hasShadow = function () {
            var scene = this.gameObjectScene;
            return !!scene.directionLights || !!scene.pointLights;
        };
        ShadowManager.prototype._isShadowMapEnable = function () {
            return this.gameObjectScene.shadowMap.enable;
        };
        __decorate([
            wd.require(function () {
                var self = this;
                var checkFirstLevelOfGameObjectScene = function () {
                    self.gameObjectScene.getChildren()
                        .filter(function (firstLevelChild) {
                        return !wd.JudgeUtils.isSpacePartitionObject(firstLevelChild);
                    })
                        .forEach(function (firstLevelChild) {
                        var checkChild = function (child) {
                            wd.assert(!child.hasComponent(wd.Shadow), wd.Log.info.FUNC_CAN_NOT("if the first level object of gameObjectScene don't contain Shadow component, its children", "contain Shadow component"));
                            child.forEach(function (c) {
                                checkChild(c);
                            });
                        };
                        if (!firstLevelChild.hasComponent(wd.Shadow)) {
                            firstLevelChild.forEach(function (child) {
                                checkChild(child);
                            });
                        }
                    });
                }, checkFirstLevelOfSpacePartitionObject = function () {
                    self.gameObjectScene.getChildren()
                        .filter(function (firstLevelChild) {
                        return wd.JudgeUtils.isSpacePartitionObject(firstLevelChild);
                    })
                        .forEach(function (spacePartitionObject) {
                        spacePartitionObject.forEach(function (firstLevelChildOfSpacePartitionObject) {
                            var checkChild = function (child) {
                                wd.assert(!child.hasComponent(wd.Shadow), wd.Log.info.FUNC_CAN_NOT("if the first level object of space partition objject don't contain Shadow component, its children", "contain Shadow component"));
                                child.forEach(function (c) {
                                    checkChild(c);
                                });
                            };
                            if (!firstLevelChildOfSpacePartitionObject.hasComponent(wd.Shadow)) {
                                firstLevelChildOfSpacePartitionObject.forEach(function (child) {
                                    checkChild(child);
                                });
                            }
                        });
                    });
                };
                checkFirstLevelOfGameObjectScene();
                checkFirstLevelOfSpacePartitionObject();
            })
        ], ShadowManager.prototype, "_getShadowRenderList", null);
        __decorate([
            wd.require(function () {
                var shadowLayerList = this.gameObjectScene.shadowMap.shadowLayerList;
                wd.assert(shadowLayerList.dirty, wd.Log.info.FUNC_SHOULD("shadowLayerList", "dirty"));
                this._getShadowRenderList()
                    .forEach(function (gameObject) {
                    wd.assert(shadowLayerList.hasChild(gameObject.getComponent(wd.Shadow).layer), wd.Log.info.FUNC_SHOULD("the shadow layer of shadow gameObject", "exist in scene->shadowLayerList"));
                });
            })
        ], ShadowManager.prototype, "_updateWhenShadowLayerChange", null);
        __decorate([
            wd.ensure(function () {
                wd.assert(!this.gameObjectScene.renderTargetRendererManager.getCommonRenderTargetRendererList().hasRepeatItems(), wd.Log.info.FUNC_SHOULD_NOT("scene->commonRenderTargetRendererList", "has repeat items"));
            })
        ], ShadowManager.prototype, "_refreshRenderTargerRendererList", null);
        return ShadowManager;
    }());
    wd.ShadowManager = ShadowManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EmptyShadowManager = (function () {
        function EmptyShadowManager() {
        }
        EmptyShadowManager.create = function () {
            var obj = new this();
            return obj;
        };
        EmptyShadowManager.prototype.update = function (elapsed) {
        };
        EmptyShadowManager.prototype.dispose = function () {
        };
        EmptyShadowManager.prototype.getTwoDShadowMapDataMap = function (layer) {
            return null;
        };
        EmptyShadowManager.prototype.getCubemapShadowMapDataMap = function (layer) {
            return null;
        };
        EmptyShadowManager.prototype.setShadowRenderListForCurrentLoop = function () {
        };
        EmptyShadowManager.prototype.getShadowRenderListByLayer = function (layer) {
            return null;
        };
        EmptyShadowManager.prototype.getShadowLayerList = function () {
            return null;
        };
        EmptyShadowManager.prototype.init = function () {
        };
        return EmptyShadowManager;
    }());
    wd.EmptyShadowManager = EmptyShadowManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowMapManager = (function () {
        function ShadowMapManager(shadowManager) {
            this.twoDShadowMapDataMap = wdCb.Hash.create();
            this.cubemapShadowMapDataMap = wdCb.Hash.create();
            this._shadowManager = null;
            this._lastTwoDShadowMapDataMap = wdCb.Hash.create();
            this._lastCubemapShadowMapDataMap = wdCb.Hash.create();
            this._shadowManager = shadowManager;
        }
        ShadowMapManager.create = function (shadowManager) {
            var obj = new this(shadowManager);
            return obj;
        };
        Object.defineProperty(ShadowMapManager.prototype, "twoDShadowMapCountForGLSL", {
            get: function () {
                var count = 0;
                this.twoDShadowMapDataMap
                    .forEach(function (dataList) {
                    count += dataList.getCount();
                });
                return count;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShadowMapManager.prototype, "cubemapShadowMapCountForGLSL", {
            get: function () {
                var count = 0;
                this.cubemapShadowMapDataMap.forEach(function (dataList) {
                    count += dataList.getCount();
                });
                return count;
            },
            enumerable: true,
            configurable: true
        });
        ShadowMapManager.prototype.initShadowMapData = function (shadowLayerList) {
            var _this = this;
            var scene = this._shadowManager.gameObjectScene;
            if (scene.directionLights && scene.directionLights.getCount() > 0) {
                scene.directionLights.forEach(function (lightObject) {
                    var light = lightObject.getComponent(wd.DirectionLight);
                    if (light.castShadow) {
                        _this._addTwoDShadowMapDataWithLayer(shadowLayerList, light);
                    }
                }, this);
            }
            if (scene.pointLights && scene.pointLights.getCount() > 0) {
                scene.pointLights.forEach(function (lightObject) {
                    var light = lightObject.getComponent(wd.PointLight);
                    if (light.castShadow) {
                        _this._addCubemapShadowMapDataWithLayer(shadowLayerList, light);
                    }
                }, this);
            }
        };
        ShadowMapManager.prototype.updateWhenShadowLayerChange = function (_a) {
            var _this = this;
            var addLayerList = _a.addLayerList, removeLayerList = _a.removeLayerList;
            var scene = null;
            scene = this._shadowManager.gameObjectScene;
            if (scene.directionLights && scene.directionLights.getCount() > 0) {
                var twoDShadowMapDataMap_1 = this.twoDShadowMapDataMap;
                this._lastTwoDShadowMapDataMap = twoDShadowMapDataMap_1.clone();
                removeLayerList.forEach(function (layer) {
                    twoDShadowMapDataMap_1.removeChild(layer);
                });
                scene.directionLights.forEach(function (lightObject) {
                    var light = lightObject.getComponent(wd.DirectionLight);
                    if (light.castShadow) {
                        _this._addTwoDShadowMapDataWithLayer(addLayerList, light);
                    }
                }, this);
            }
            if (scene.pointLights && scene.pointLights.getCount() > 0) {
                var cubemapShadowMapDataMap_1 = this.cubemapShadowMapDataMap;
                this._lastCubemapShadowMapDataMap = cubemapShadowMapDataMap_1.clone();
                removeLayerList.forEach(function (layer) {
                    cubemapShadowMapDataMap_1.removeChild(layer);
                });
                scene.pointLights.forEach(function (lightObject) {
                    var light = lightObject.getComponent(wd.PointLight);
                    if (light.castShadow) {
                        _this._addCubemapShadowMapDataWithLayer(addLayerList, light);
                    }
                }, this);
            }
        };
        ShadowMapManager.prototype.getAllDiffShadowMapDataWhenShadowLayerChange = function () {
            var twoDDiff = this._getDiffShadowMapDataWhenShadowLayerChange(this._lastTwoDShadowMapDataMap, this.twoDShadowMapDataMap), cubemapDiff = this._getDiffShadowMapDataWhenShadowLayerChange(this._lastCubemapShadowMapDataMap, this.cubemapShadowMapDataMap);
            return {
                addTwoDShadowMapData: twoDDiff.addShadowMapData,
                removeTwoDShadowMapData: twoDDiff.removeShadowMapData,
                addCubemapShadowMapData: cubemapDiff.addShadowMapData,
                removeCubemapShadowMapData: cubemapDiff.removeShadowMapData
            };
        };
        ShadowMapManager.prototype._getDiffShadowMapDataWhenShadowLayerChange = function (lastShadowMapDataMap, currentShadowMapDataMap) {
            var addShadowMapData = wdCb.Hash.create(), removeShadowMapData = wdCb.Collection.create();
            removeShadowMapData = lastShadowMapDataMap
                .filter(function (shadowMapDataList, layer) {
                return !currentShadowMapDataMap.hasChild(layer);
            })
                .toCollection();
            addShadowMapData = currentShadowMapDataMap
                .filter(function (shadowMapDataList, layer) {
                return !lastShadowMapDataMap.hasChild(layer);
            });
            return {
                addShadowMapData: addShadowMapData,
                removeShadowMapData: removeShadowMapData
            };
        };
        ShadowMapManager.prototype._addTwoDShadowMapDataWithLayer = function (layerList, light) {
            var twoDShadowMapDataMap = this.twoDShadowMapDataMap;
            layerList.forEach(function (layer) {
                twoDShadowMapDataMap.appendChild(layer, {
                    shadowMap: wd.TwoDShadowMapTexture.create(),
                    light: light
                });
            });
        };
        ShadowMapManager.prototype._addCubemapShadowMapDataWithLayer = function (layerList, light) {
            var cubemapShadowMapDataMap = this.cubemapShadowMapDataMap;
            layerList.forEach(function (layer) {
                cubemapShadowMapDataMap.appendChild(layer, {
                    shadowMap: wd.CubemapShadowMapTexture.create(),
                    light: light
                });
            });
        };
        ShadowMapManager.prototype.dispose = function () {
        };
        __decorate([
            wd.require(function (layerList, light) {
                wd.assert(!layerList.hasRepeatItems(), wd.Log.info.FUNC_SHOULD_NOT("has repeat shadow layer"));
            })
        ], ShadowMapManager.prototype, "_addTwoDShadowMapDataWithLayer", null);
        __decorate([
            wd.require(function (layerList, light) {
                wd.assert(!layerList.hasRepeatItems(), wd.Log.info.FUNC_SHOULD_NOT("has repeat shadow layer"));
            })
        ], ShadowMapManager.prototype, "_addCubemapShadowMapDataWithLayer", null);
        return ShadowMapManager;
    }());
    wd.ShadowMapManager = ShadowMapManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightManager = (function () {
        function LightManager() {
            this._lights = wdCb.Hash.create();
        }
        LightManager.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(LightManager.prototype, "ambientLight", {
            get: function () {
                return this._lights.getChild(wd.AmbientLight.type);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightManager.prototype, "directionLights", {
            get: function () {
                return this._getLights(wd.DirectionLight.type);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LightManager.prototype, "pointLights", {
            get: function () {
                return this._getLights(wd.PointLight.type);
            },
            enumerable: true,
            configurable: true
        });
        LightManager.prototype.addChild = function (light) {
            if (light.hasComponent(wd.AmbientLight)) {
                this._lights.addChild(wd.AmbientLight.type, light);
            }
            else if (light.hasComponent(wd.DirectionLight)) {
                this._lights.appendChild(wd.DirectionLight.type, light);
            }
            else if (light.hasComponent(wd.PointLight)) {
                this._lights.appendChild(wd.PointLight.type, light);
            }
            else {
                wd.Log.error(true, wd.Log.info.FUNC_INVALID("light"));
            }
        };
        LightManager.prototype.addChildren = function (lightList) {
            var self = this;
            lightList.forEach(function (light) {
                self.addChild(light);
            });
        };
        LightManager.prototype._getLights = function (type) {
            return this._lights.getChild(type);
        };
        return LightManager;
    }());
    wd.LightManager = LightManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RenderTargetRendererManager = (function () {
        function RenderTargetRendererManager() {
            this._commonRenderTargetRendererList = wdCb.Collection.create();
            this._proceduralRendererList = wdCb.Collection.create();
        }
        RenderTargetRendererManager.create = function () {
            var obj = new this();
            return obj;
        };
        RenderTargetRendererManager.prototype.init = function () {
            this._commonRenderTargetRendererList.forEach(function (renderTargetRenderer) { return renderTargetRenderer.init(); });
            this._proceduralRendererList.forEach(function (renderTargetRenderer) { return renderTargetRenderer.init(); });
        };
        RenderTargetRendererManager.prototype.dispose = function () {
            this._commonRenderTargetRendererList.forEach(function (renderTargetRenderer) { return renderTargetRenderer.dispose(); });
            this._proceduralRendererList.forEach(function (renderTargetRenderer) { return renderTargetRenderer.dispose(); });
        };
        RenderTargetRendererManager.prototype.addCommonRenderTargetRenderer = function (renderTargetRenderer) {
            this._commonRenderTargetRendererList.addChild(renderTargetRenderer);
        };
        RenderTargetRendererManager.prototype.getCommonRenderTargetRendererList = function () {
            return this._commonRenderTargetRendererList;
        };
        RenderTargetRendererManager.prototype.removeCommonRenderTargetRenderer = function (func) {
            return this._commonRenderTargetRendererList.removeChild(func);
        };
        RenderTargetRendererManager.prototype.addProceduralRenderTargetRenderer = function (renderTargetRenderer) {
            this._proceduralRendererList.addChild(renderTargetRenderer);
        };
        RenderTargetRendererManager.prototype.render = function (renderer, camera) {
            this._proceduralRendererList.filter(function (target) {
                return target.needRender();
            })
                .forEach(function (target) {
                target.render(renderer);
            });
            this._commonRenderTargetRendererList.filter(function (target) {
                return target.needRender();
            })
                .forEach(function (target) {
                target.render(renderer, camera);
            });
        };
        return RenderTargetRendererManager;
    }());
    wd.RenderTargetRendererManager = RenderTargetRendererManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowLayerList = (function () {
        function ShadowLayerList() {
            this.dirty = false;
            this._list = wdCb.Collection.create();
            this._lastList = null;
        }
        ShadowLayerList.create = function () {
            var obj = new this();
            return obj;
        };
        ShadowLayerList.prototype.init = function () {
            this._lastList = this._list.clone();
        };
        ShadowLayerList.prototype.update = function () {
            if (this.dirty) {
                wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.SHADOWMAP_LAYER_CHANGE));
                this.dirty = false;
            }
            this._lastList = this._list.clone();
        };
        ShadowLayerList.prototype.getDiffData = function () {
            var lastList = this._lastList, currentList = this._list, addLayerList = null, removeLayerList = null;
            if (lastList === null) {
                return {
                    addLayerList: this._list.clone(),
                    removeLayerList: wdCb.Collection.create()
                };
            }
            addLayerList = wdCb.Collection.create();
            removeLayerList = wdCb.Collection.create();
            removeLayerList = lastList
                .filter(function (layer) {
                return !currentList.hasChild(layer);
            });
            addLayerList = currentList
                .filter(function (layer) {
                return !lastList.hasChild(layer);
            });
            return {
                addLayerList: addLayerList,
                removeLayerList: removeLayerList
            };
        };
        ShadowLayerList.prototype.getCount = function () {
            return this._list.getCount();
        };
        ShadowLayerList.prototype.addChild = function (layer) {
            this._list.addChild(layer);
            this.dirty = true;
        };
        ShadowLayerList.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._list.addChildren.apply(this._list, args);
            this.dirty = true;
        };
        ShadowLayerList.prototype.removeChild = function (layer) {
            this.dirty = true;
            return this._convertCollectionToThis(this._list.removeChild(layer));
        };
        ShadowLayerList.prototype.removeAllChildren = function () {
            this.dirty = true;
            this._list.removeAllChildren();
        };
        ShadowLayerList.prototype.removeRepeatItems = function () {
            var result = this._convertCollectionToThis(this._list.removeRepeatItems());
            result.dirty = this.dirty;
            return result;
        };
        ShadowLayerList.prototype.hasRepeatItems = function () {
            return this._list.hasRepeatItems();
        };
        ShadowLayerList.prototype.forEach = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._list.forEach.apply(this._list, args);
        };
        ShadowLayerList.prototype.getChildren = function () {
            return this._list.getChildren();
        };
        ShadowLayerList.prototype.hasChild = function (layer) {
            return this._list.hasChild(layer);
        };
        ShadowLayerList.prototype._convertCollectionToThis = function (list) {
            var result = ShadowLayerList.create();
            result.addChildren(list.getChildren());
            return result;
        };
        return ShadowLayerList;
    }());
    wd.ShadowLayerList = ShadowLayerList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventManager = (function () {
        function EventManager() {
        }
        EventManager.on = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 2 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1], priority = 1, eventBinder = wd.EventBinderFactory.createEventBinder(eventName);
                eventBinder.on(eventName, handler, priority);
            }
            else if (args.length === 3 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1], priority = args[2], eventBinder = wd.EventBinderFactory.createEventBinder(eventName);
                eventBinder.on(eventName, handler, priority);
            }
            else if (args.length === 3 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], handler = args[2], priority = 1, eventBinder = wd.CustomEventBinder.getInstance();
                eventBinder.on(target, eventName, handler, priority);
            }
            else if (args.length === 3 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1], handler = args[2], priority = 1, eventBinder = wd.DomEventBinder.getInstance();
                eventBinder.on(dom, eventName, handler, priority);
            }
            else if (args.length === 4 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], handler = args[2], priority = args[3], eventBinder = wd.CustomEventBinder.getInstance();
                eventBinder.on(target, eventName, handler, priority);
            }
            else if (args.length === 4 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1], handler = args[2], priority = args[3], eventBinder = wd.DomEventBinder.getInstance();
                eventBinder.on(dom, eventName, handler, priority);
            }
        };
        EventManager.off = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 0) {
                var customEventBinder = wd.CustomEventBinder.getInstance(), domEventBinder = wd.DomEventBinder.getInstance();
                customEventBinder.off();
                domEventBinder.off();
            }
            else if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], eventBinder = wd.EventBinderFactory.createEventBinder(eventName);
                eventBinder.off(eventName);
            }
            else if (args.length === 1 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventBinder = wd.CustomEventBinder.getInstance();
                eventBinder.off(target);
            }
            else if (args.length === 1 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventBinder = wd.DomEventBinder.getInstance();
                eventBinder.off(dom);
            }
            else if (args.length === 2 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1], eventBinder = wd.EventBinderFactory.createEventBinder(eventName);
                eventBinder.off(eventName, handler);
            }
            else if (args.length === 2 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], eventBinder = wd.CustomEventBinder.getInstance();
                eventBinder.off(target, eventName);
            }
            else if (args.length === 2 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1], eventBinder = wd.DomEventBinder.getInstance();
                eventBinder.off(dom, eventName);
            }
            else if (args.length === 3 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], handler = args[2], eventBinder = wd.CustomEventBinder.getInstance();
                eventBinder.off(target, eventName, handler);
            }
            else if (args.length === 3 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1], handler = args[2], eventBinder = wd.DomEventBinder.getInstance();
                eventBinder.off(dom, eventName, handler);
            }
        };
        EventManager.trigger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var length = args.length;
            if (length === 1) {
                var event_1 = args[0], eventDispatcher = wd.EventDispatcherFactory.createEventDispatcher(event_1);
                eventDispatcher.trigger(event_1);
            }
            else if (length === 2 && wd.EventUtils.isEvent(args[0])) {
                var event_2 = args[0], userData = args[1], eventDispatcher = wd.CustomEventDispatcher.getInstance();
                eventDispatcher.trigger(event_2, userData);
            }
            else if (length === 2 && wd.EventUtils.isEntityObject(args[0])) {
                var target = args[0], event_3 = args[1], eventDispatcher = wd.CustomEventDispatcher.getInstance();
                if (!target) {
                    return;
                }
                eventDispatcher.trigger(target, event_3);
            }
            else if (length === 2) {
                var dom = args[0], event_4 = args[1], eventDispatcher = wd.DomEventDispatcher.getInstance();
                if (!dom) {
                    return;
                }
                eventDispatcher.trigger(dom, event_4);
            }
            else if (length === 3) {
                var target = args[0], event_5 = args[1], userData = args[2], eventDispatcher = wd.CustomEventDispatcher.getInstance();
                if (!target) {
                    return;
                }
                eventDispatcher.trigger(target, event_5, userData);
            }
            else if (length === 4) {
                var target = args[0], event_6 = args[1], userData = args[2], notSetTarget = args[3], eventDispatcher = wd.CustomEventDispatcher.getInstance();
                if (!target) {
                    return;
                }
                eventDispatcher.trigger(target, event_6, userData, notSetTarget);
            }
        };
        EventManager.broadcast = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eventDispatcher = wd.CustomEventDispatcher.getInstance();
            eventDispatcher.broadcast.apply(eventDispatcher, args);
        };
        EventManager.emit = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eventDispatcher = wd.CustomEventDispatcher.getInstance();
            eventDispatcher.emit.apply(eventDispatcher, args);
        };
        EventManager.fromEvent = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var addHandler = null, removeHandler = null;
            if (args.length === 1) {
                var eventName_1 = args[0];
                addHandler = function (handler) {
                    EventManager.on(eventName_1, handler);
                };
                removeHandler = function (handler) {
                    EventManager.off(eventName_1, handler);
                };
            }
            else if (args.length === 2 && wd.JudgeUtils.isNumber(args[1])) {
                var eventName_2 = args[0], priority_1 = args[1];
                addHandler = function (handler) {
                    EventManager.on(eventName_2, handler, priority_1);
                };
                removeHandler = function (handler) {
                    EventManager.off(eventName_2, handler);
                };
            }
            else if (args.length === 2) {
                var eventName_3 = args[1];
                addHandler = function (handler) {
                    EventManager.on(args[0], eventName_3, handler);
                };
                removeHandler = function (handler) {
                    EventManager.off(args[0], eventName_3, handler);
                };
            }
            else if (args.length === 3) {
                var eventName_4 = args[1], priority_2 = args[2];
                addHandler = function (handler) {
                    EventManager.on(args[0], eventName_4, handler, priority_2);
                };
                removeHandler = function (handler) {
                    EventManager.off(args[0], eventName_4, handler);
                };
            }
            return wdFrp.fromEventPattern(addHandler, removeHandler);
        };
        EventManager.setBubbleParent = function (target, parent) {
            wd.CustomEventRegister.getInstance().setBubbleParent(target, parent);
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (args[0] instanceof wd.EntityObject) {
                    var eventName_5 = args[1];
                    wd.it("event must be custom event", function () {
                        var eventType = wd.EventTable.getEventType(eventName_5);
                        wd.expect(eventType === wd.EEventType.CUSTOM || eventType === wd.EEventType.POINT).true;
                    });
                }
                else if (wd.JudgeUtils.isDom(args[0])) {
                    var eventName = args[1], eventType_1 = wd.EventTable.getEventType(eventName);
                    wd.it("event must be dom event", function () {
                        wd.expect(eventType_1 === wd.EEventType.TOUCH || eventType_1 === wd.EEventType.MOUSE || eventType_1 === wd.EEventType.KEYBOARD).true;
                    });
                }
            })
        ], EventManager, "on", null);
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (args.length > 2 && args[0] instanceof wd.EntityObject) {
                    var eventName = args[1], eventType_2 = wd.EventTable.getEventType(eventName);
                    wd.it("event must be custom or point event", function () {
                        wd.expect(eventType_2 === wd.EEventType.CUSTOM || eventType_2 === wd.EEventType.POINT).true;
                    });
                }
                else if (args.length > 2 && wd.JudgeUtils.isDom(args[0])) {
                    var eventName = args[1], eventType_3 = wd.EventTable.getEventType(eventName);
                    wd.it("event must be keyboard event", function () {
                        wd.expect(eventType_3 === wd.EEventType.KEYBOARD).true;
                    });
                }
            })
        ], EventManager, "off", null);
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (args.length === 2 && args[0] instanceof wd.Event) {
                    var event_7 = args[0];
                    wd.assert(event_7 instanceof wd.CustomEvent, wd.Log.info.FUNC_MUST_BE("event type", "CUSTOM"));
                }
                else if (args.length === 2 && args[0] instanceof wd.EntityObject) {
                }
                else if (args.length === 2) {
                    if (args[0]) {
                        wd.assert(wd.JudgeUtils.isDom(args[0]), wd.Log.info.FUNC_MUST_BE("the first param", "dom"));
                    }
                }
                else if (args[0] instanceof wd.EntityObject) {
                    var event_8 = args[1];
                    wd.assert(event_8 instanceof wd.CustomEvent, wd.Log.info.FUNC_MUST_BE("event type", "CUSTOM"));
                }
            })
        ], EventManager, "trigger", null);
        __decorate([
            wd.require(function (target, eventObject, userData) {
                wd.assert(eventObject instanceof wd.CustomEvent, wd.Log.info.FUNC_MUST_BE("eventObject", "CustomEvent"));
            })
        ], EventManager, "broadcast", null);
        __decorate([
            wd.require(function (target, eventObject, userData) {
                wd.assert(eventObject instanceof wd.CustomEvent, wd.Log.info.FUNC_MUST_BE("eventObject", "CustomEvent"));
            })
        ], EventManager, "emit", null);
        __decorate([
            wd.require(function (target, parent) {
                wd.assert(target instanceof wd.EntityObject, "only EntityObject can setBubleParent");
            })
        ], EventManager, "setBubbleParent", null);
        return EventManager;
    }());
    wd.EventManager = EventManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EEngineEvent) {
        EEngineEvent[EEngineEvent["STARTLOOP"] = "wd_startLoop"] = "STARTLOOP";
        EEngineEvent[EEngineEvent["ENDLOOP"] = "wd_endLoop"] = "ENDLOOP";
        EEngineEvent[EEngineEvent["POINT_TAP"] = "wd_pointtap"] = "POINT_TAP";
        EEngineEvent[EEngineEvent["POINT_DOWN"] = "wd_pointdown"] = "POINT_DOWN";
        EEngineEvent[EEngineEvent["POINT_UP"] = "wd_pointup"] = "POINT_UP";
        EEngineEvent[EEngineEvent["POINT_MOVE"] = "wd_pointmove"] = "POINT_MOVE";
        EEngineEvent[EEngineEvent["POINT_OVER"] = "wd_pointover"] = "POINT_OVER";
        EEngineEvent[EEngineEvent["POINT_OUT"] = "wd_pointout"] = "POINT_OUT";
        EEngineEvent[EEngineEvent["POINT_SCALE"] = "wd_pointscale"] = "POINT_SCALE";
        EEngineEvent[EEngineEvent["POINT_DRAG"] = "wd_pointdrag"] = "POINT_DRAG";
        EEngineEvent[EEngineEvent["MATERIAL_CHANGE"] = "wd_material_change"] = "MATERIAL_CHANGE";
        EEngineEvent[EEngineEvent["UI_WIDTH_CHANGE"] = "wd_ui_width_change"] = "UI_WIDTH_CHANGE";
        EEngineEvent[EEngineEvent["UI_HEIGHT_CHANGE"] = "wd_ui_height_change"] = "UI_HEIGHT_CHANGE";
        EEngineEvent[EEngineEvent["TRANSFORM_TRANSLATE"] = "wd_transform_translate"] = "TRANSFORM_TRANSLATE";
        EEngineEvent[EEngineEvent["TRANSFORM_ROTATE"] = "wd_transform_rotate"] = "TRANSFORM_ROTATE";
        EEngineEvent[EEngineEvent["TRANSFORM_SCALE"] = "wd_transform_scale"] = "TRANSFORM_SCALE";
        EEngineEvent[EEngineEvent["SHADOWMAP_SOFTTYPE_CHANGE"] = "wd_shadowMap_softType_change"] = "SHADOWMAP_SOFTTYPE_CHANGE";
        EEngineEvent[EEngineEvent["SHADOWMAP_LAYER_CHANGE"] = "wd_shadowMap_layer_change"] = "SHADOWMAP_LAYER_CHANGE";
        EEngineEvent[EEngineEvent["COMPONENT_CHANGE"] = "wd_component_change"] = "COMPONENT_CHANGE";
        EEngineEvent[EEngineEvent["AFTER_SCENEGRAPH_BUILD"] = "wd_after_sceneGraph_build"] = "AFTER_SCENEGRAPH_BUILD";
        EEngineEvent[EEngineEvent["ANIMATION_STOP"] = "wd_animation_stop"] = "ANIMATION_STOP";
        EEngineEvent[EEngineEvent["EXIT"] = "wd_exit"] = "EXIT";
        EEngineEvent[EEngineEvent["ENTER"] = "wd_enter"] = "ENTER";
    })(wd.EEngineEvent || (wd.EEngineEvent = {}));
    var EEngineEvent = wd.EEngineEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventListenerMap = (function () {
        function EventListenerMap() {
        }
        EventListenerMap.prototype.buildSecondLevelKey = function (eventName) {
            return eventName;
        };
        return EventListenerMap;
    }());
    wd.EventListenerMap = EventListenerMap;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomEventListenerMap = (function (_super) {
        __extends(CustomEventListenerMap, _super);
        function CustomEventListenerMap() {
            _super.apply(this, arguments);
            this._globalListenerMap = wdCb.Hash.create();
            this._targetRecordMap = wdCb.Hash.create();
        }
        CustomEventListenerMap.create = function () {
            var obj = new this();
            return obj;
        };
        CustomEventListenerMap.prototype.hasChild = function (target) {
            return target.customEventMap.getCount() > 0;
        };
        CustomEventListenerMap.prototype.appendChild = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 2) {
                var eventName = args[0], data = args[1];
                this._globalListenerMap.appendChild(eventName, data);
            }
            else {
                var target = args[0], eventName = args[1], data = args[2];
                this._targetRecordMap.addChild(this.buildFirstLevelKey(target), target);
                target.customEventMap.appendChild(this.buildSecondLevelKey(eventName), data);
            }
        };
        CustomEventListenerMap.prototype.forEachAll = function (func) {
            this._globalListenerMap.forEach(func);
            this._targetRecordMap.forEach(function (target) {
                target.customEventMap.forEach(func);
            });
        };
        CustomEventListenerMap.prototype.forEachEventName = function (func) {
            this._globalListenerMap.forEach(func);
        };
        CustomEventListenerMap.prototype.clear = function () {
            this._globalListenerMap.removeAllChildren();
            this._targetRecordMap.forEach(function (target) {
                target.customEventMap.removeAllChildren();
            });
            this._targetRecordMap.removeAllChildren();
        };
        CustomEventListenerMap.prototype.getChild = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0];
                return this._globalListenerMap.getChild(eventName);
            }
            else if (args.length === 1 && args[0] instanceof wd.EntityObject) {
                var target = args[0];
                return target.customEventMap;
            }
            else if (args.length === 2) {
                var target = args[0], eventName = args[1], secondMap = null;
                secondMap = target.customEventMap;
                if (!secondMap) {
                    return null;
                }
                return secondMap.getChild(this.buildSecondLevelKey(eventName));
            }
        };
        CustomEventListenerMap.prototype.removeChild = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0];
                this._globalListenerMap.removeChild(eventName);
            }
            else if (args.length === 1 && args[0] instanceof wd.EntityObject) {
                var target = args[0];
                target.customEventMap.removeAllChildren();
                this._targetRecordMap.removeChild(this.buildFirstLevelKey(target));
            }
            else if (args.length === 2 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler_1 = args[1], list = null;
                list = this._globalListenerMap.getChild(eventName);
                if (!!list) {
                    list.removeChild(function (val) {
                        return val.originHandler === handler_1;
                    });
                    if (list.getCount() === 0) {
                        this._globalListenerMap.removeChild(eventName);
                    }
                }
            }
            else if (args.length === 2 && wd.JudgeUtils.isNumber(args[0])) {
                var uid = args[0], eventName = args[1], secondMap = null;
                secondMap = (this._targetRecordMap.getChild(this.buildFirstLevelKey(uid)));
                if (!!secondMap) {
                    secondMap.removeChild(this.buildSecondLevelKey(eventName));
                }
            }
            else if (args.length === 2 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], secondMap = null;
                secondMap = target.customEventMap;
                if (!!secondMap) {
                    secondMap.removeChild(this.buildSecondLevelKey(eventName));
                }
            }
            else if (args.length === 3 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], handler_2 = args[2], secondMap = null;
                secondMap = target.customEventMap;
                if (!!secondMap) {
                    var secondList = secondMap.getChild(eventName);
                    if (!!secondList) {
                        secondList.removeChild(function (val) {
                            return val.originHandler === handler_2;
                        });
                        if (secondList.getCount() === 0) {
                            secondMap.removeChild(eventName);
                        }
                    }
                }
            }
        };
        CustomEventListenerMap.prototype.buildFirstLevelKey = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var v = args[0], uid = v.uid;
            if (uid) {
                return String(uid);
            }
            return v;
        };
        return CustomEventListenerMap;
    }(wd.EventListenerMap));
    wd.CustomEventListenerMap = CustomEventListenerMap;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DomEventListenerMap = (function (_super) {
        __extends(DomEventListenerMap, _super);
        function DomEventListenerMap() {
            _super.apply(this, arguments);
            this._targetListenerMap = wdCb.Hash.create();
        }
        DomEventListenerMap.create = function () {
            var obj = new this();
            return obj;
        };
        DomEventListenerMap.prototype.hasChild = function (dom, eventName) {
            var list = this._targetListenerMap.getChild(this.buildFirstLevelKey(dom));
            if (!list) {
                return false;
            }
            list = list.getChild(eventName);
            return list && list.getCount() > 0;
        };
        DomEventListenerMap.prototype.appendChild = function (dom, eventName, data) {
            var firstLevelKey = this.buildFirstLevelKey(dom);
            if (!this._targetListenerMap.hasChild(firstLevelKey)) {
                var secondMap = wdCb.Hash.create();
                secondMap.addChild(this.buildSecondLevelKey(eventName), wdCb.Collection.create([data]));
                this._targetListenerMap.addChild(firstLevelKey, secondMap);
                return;
            }
            this._targetListenerMap.getChild(firstLevelKey).appendChild(this.buildSecondLevelKey(eventName), data);
        };
        DomEventListenerMap.prototype.forEachAll = function (func) {
            this._targetListenerMap.forEach(function (secondMap) {
                secondMap.forEach(func);
            });
        };
        DomEventListenerMap.prototype.forEachEventName = function (func) {
            this.forEachAll(func);
        };
        DomEventListenerMap.prototype.clear = function () {
            this._targetListenerMap.removeAllChildren();
        };
        DomEventListenerMap.prototype.getChild = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1) {
                var dom = args[0];
                return this._targetListenerMap.getChild(this.buildFirstLevelKey(dom));
            }
            else if (args.length === 2) {
                var dom = args[0], eventName = args[1], secondMap = null;
                secondMap = this._targetListenerMap.getChild(this.buildFirstLevelKey(dom));
                if (!secondMap) {
                    return null;
                }
                return secondMap.getChild(this.buildSecondLevelKey(eventName));
            }
        };
        DomEventListenerMap.prototype.removeChild = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = null;
            if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName_6 = args[0], arr_2 = [];
                this._targetListenerMap.forEach(function (secondMap, firstLevelKey) {
                    var secondLevelKey = _this.buildSecondLevelKey(eventName_6);
                    if (secondMap.hasChild(secondLevelKey)) {
                        arr_2.push(secondMap.removeChild(secondLevelKey).getChild(0));
                    }
                });
                var l = wdCb.Collection.create();
                for (var _a = 0, arr_3 = arr_2; _a < arr_3.length; _a++) {
                    var list = arr_3[_a];
                    l.addChildren(list);
                }
                result = this._getEventDataOffDataList(eventName_6, l);
            }
            else if (args.length === 2 && wd.JudgeUtils.isString(args[0])) {
                var eventName_7 = args[0], handler_3 = args[1], arr_4 = [];
                this._targetListenerMap.forEach(function (secondMap, firstLevelKey) {
                    var list = secondMap.getChild(_this.buildSecondLevelKey(eventName_7));
                    if (list) {
                        arr_4.push(list.removeChild(function (data) {
                            return data.originHandler === handler_3;
                        }));
                    }
                });
                var l = wdCb.Collection.create();
                for (var _b = 0, arr_5 = arr_4; _b < arr_5.length; _b++) {
                    var list = arr_5[_b];
                    l.addChildren(list);
                }
                result = this._getEventDataOffDataList(eventName_7, l);
            }
            else if (args.length === 2 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1], secondMap = null;
                secondMap = this._targetListenerMap.getChild(this.buildFirstLevelKey(dom));
                if (!secondMap) {
                    result = wdCb.Collection.create();
                }
                else {
                    result = this._getEventDataOffDataList(eventName, secondMap.removeChild(this.buildSecondLevelKey(eventName)).getChild(0));
                }
            }
            else if (args.length === 3 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1], handler_4 = args[2], secondMap = null;
                secondMap = this._targetListenerMap.getChild(this.buildFirstLevelKey(dom));
                if (!secondMap) {
                    result = wdCb.Collection.create();
                }
                else {
                    var list = secondMap.getChild(this.buildSecondLevelKey(eventName));
                    if (!list) {
                        result = wdCb.Collection.create();
                    }
                    else {
                        result = this._getEventDataOffDataList(eventName, list.removeChild(function (val) {
                            return val.originHandler === handler_4;
                        }));
                    }
                }
            }
            return result;
        };
        DomEventListenerMap.prototype.buildFirstLevelKey = function (dom) {
            if (dom.id) {
                return "" + dom.tagName + dom.id;
            }
            if (dom.nodeName) {
                return "" + dom.nodeName;
            }
            return "" + dom.tagName;
        };
        DomEventListenerMap.prototype._getEventDataOffDataList = function (eventName, result) {
            if (!result) {
                return wdCb.Collection.create();
            }
            return result.map(function (data) {
                return {
                    dom: data.dom,
                    eventName: eventName,
                    domHandler: data.domHandler
                };
            });
        };
        return DomEventListenerMap;
    }(wd.EventListenerMap));
    wd.DomEventListenerMap = DomEventListenerMap;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EEventType) {
        EEventType[EEventType["MOUSE"] = 0] = "MOUSE";
        EEventType[EEventType["TOUCH"] = 1] = "TOUCH";
        EEventType[EEventType["POINT"] = 2] = "POINT";
        EEventType[EEventType["KEYBOARD"] = 3] = "KEYBOARD";
        EEventType[EEventType["CUSTOM"] = 4] = "CUSTOM";
    })(wd.EEventType || (wd.EEventType = {}));
    var EEventType = wd.EEventType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EBrowserIdentifier;
    (function (EBrowserIdentifier) {
        EBrowserIdentifier[EBrowserIdentifier["FALLBACK"] = "fallback"] = "FALLBACK";
        EBrowserIdentifier[EBrowserIdentifier["FIREFOX"] = "firefox"] = "FIREFOX";
        EBrowserIdentifier[EBrowserIdentifier["CHROME"] = "chrome"] = "CHROME";
    })(EBrowserIdentifier || (EBrowserIdentifier = {}));
    (function (EEventName) {
        EEventName[EEventName["CLICK"] = "click"] = "CLICK";
        EEventName[EEventName["MOUSEOVER"] = "mouseover"] = "MOUSEOVER";
        EEventName[EEventName["MOUSEUP"] = "mouseup"] = "MOUSEUP";
        EEventName[EEventName["MOUSEOUT"] = "mouseout"] = "MOUSEOUT";
        EEventName[EEventName["MOUSEMOVE"] = "mousemove"] = "MOUSEMOVE";
        EEventName[EEventName["MOUSEDOWN"] = "mousedown"] = "MOUSEDOWN";
        EEventName[EEventName["MOUSEWHEEL"] = ("mousewheel|DOMMouseScroll*" + EBrowserIdentifier.FIREFOX)] = "MOUSEWHEEL";
        EEventName[EEventName["MOUSEDRAG"] = "mousedrag"] = "MOUSEDRAG";
        EEventName[EEventName["TOUCHUP"] = "touchend"] = "TOUCHUP";
        EEventName[EEventName["TOUCHMOVE"] = "touchmove"] = "TOUCHMOVE";
        EEventName[EEventName["TOUCHDOWN"] = "touchstart"] = "TOUCHDOWN";
        EEventName[EEventName["KEYDOWN"] = "keydown"] = "KEYDOWN";
        EEventName[EEventName["KEYUP"] = "keyup"] = "KEYUP";
        EEventName[EEventName["KEYPRESS"] = "keypress"] = "KEYPRESS";
    })(wd.EEventName || (wd.EEventName = {}));
    var EEventName = wd.EEventName;
    var EVENTNAME_SPLITTER = '|', BROWSER_IDENTIFIER = '*';
    var EventNameHandler = (function () {
        function EventNameHandler() {
        }
        EventNameHandler.handleEventName = function (domEventName) {
            var eventName = domEventName, fallbackEventName = null, specifyBrowserEventNameArr = [], result = null;
            for (var _i = 0, _a = eventName.split(EVENTNAME_SPLITTER); _i < _a.length; _i++) {
                var name_1 = _a[_i];
                if (this._isFallbackEventName(name_1)) {
                    fallbackEventName = name_1;
                }
                else {
                    specifyBrowserEventNameArr.push(name_1);
                }
            }
            result = this._getSpecifyBrowserEventName(specifyBrowserEventNameArr);
            return result !== null ? result : fallbackEventName;
        };
        EventNameHandler._isFallbackEventName = function (eventName) {
            return eventName.split(BROWSER_IDENTIFIER).length === 1;
        };
        EventNameHandler._getSpecifyBrowserEventName = function (specifyBrowserEventNameArr) {
            var result = null;
            for (var _i = 0, specifyBrowserEventNameArr_1 = specifyBrowserEventNameArr; _i < specifyBrowserEventNameArr_1.length; _i++) {
                var eventName = specifyBrowserEventNameArr_1[_i];
                var _a = eventName.split(BROWSER_IDENTIFIER), domEventName = _a[0], browserIdentifier = _a[1];
                switch (browserIdentifier) {
                    case EBrowserIdentifier.CHROME:
                        if (bowser.chrome) {
                            result = domEventName;
                        }
                        break;
                    case EBrowserIdentifier.FIREFOX:
                        if (bowser.firefox) {
                            result = domEventName;
                        }
                        break;
                    default:
                        break;
                }
                if (result) {
                    break;
                }
            }
            return result;
        };
        return EventNameHandler;
    }());
    wd.EventNameHandler = EventNameHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EEventPhase) {
        EEventPhase[EEventPhase["BROADCAST"] = 0] = "BROADCAST";
        EEventPhase[EEventPhase["EMIT"] = 1] = "EMIT";
    })(wd.EEventPhase || (wd.EEventPhase = {}));
    var EEventPhase = wd.EEventPhase;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var _table = wdCb.Hash.create();
    _table.addChild(wd.EEventName.CLICK, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.MOUSEMOVE, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.MOUSEDOWN, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.MOUSEDRAG, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.MOUSEOUT, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.MOUSEOVER, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.MOUSEUP, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.MOUSEWHEEL, wd.EEventType.MOUSE);
    _table.addChild(wd.EEventName.TOUCHMOVE, wd.EEventType.TOUCH);
    _table.addChild(wd.EEventName.TOUCHDOWN, wd.EEventType.TOUCH);
    _table.addChild(wd.EEventName.TOUCHUP, wd.EEventType.TOUCH);
    _table.addChild(wd.EEngineEvent.POINT_TAP, wd.EEventType.POINT);
    _table.addChild(wd.EEngineEvent.POINT_OVER, wd.EEventType.POINT);
    _table.addChild(wd.EEngineEvent.POINT_OUT, wd.EEventType.POINT);
    _table.addChild(wd.EEngineEvent.POINT_MOVE, wd.EEventType.POINT);
    _table.addChild(wd.EEngineEvent.POINT_DOWN, wd.EEventType.POINT);
    _table.addChild(wd.EEngineEvent.POINT_UP, wd.EEventType.POINT);
    _table.addChild(wd.EEngineEvent.POINT_SCALE, wd.EEventType.POINT);
    _table.addChild(wd.EEngineEvent.POINT_DRAG, wd.EEventType.POINT);
    _table.addChild(wd.EEventName.KEYDOWN, wd.EEventType.KEYBOARD);
    _table.addChild(wd.EEventName.KEYPRESS, wd.EEventType.KEYBOARD);
    _table.addChild(wd.EEventName.KEYUP, wd.EEventType.KEYBOARD);
    var EventTable = (function () {
        function EventTable() {
        }
        EventTable.getEventType = function (eventName) {
            var result = _table.getChild(eventName);
            if (result === void 0) {
                result = wd.EEventType.CUSTOM;
            }
            return result;
        };
        return EventTable;
    }());
    wd.EventTable = EventTable;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Event = (function () {
        function Event(eventName) {
            this.name = null;
            this.currentTarget = null;
            this.isStopPropagation = false;
            this.phase = null;
            this.name = eventName;
        }
        Event.prototype.stopPropagation = function () {
            this.isStopPropagation = true;
        };
        Event.prototype.copyMember = function (destination, source, memberArr) {
            memberArr.forEach(function (member) {
                destination[member] = source[member];
            });
            return destination;
        };
        return Event;
    }());
    wd.Event = Event;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DomEvent = (function (_super) {
        __extends(DomEvent, _super);
        function DomEvent(event, eventName) {
            _super.call(this, eventName);
            this._event = null;
            this.event = event;
        }
        Object.defineProperty(DomEvent.prototype, "event", {
            get: function () {
                return this._event;
            },
            set: function (event) {
                this._event = event || wd.root.event;
            },
            enumerable: true,
            configurable: true
        });
        DomEvent.prototype.preventDefault = function () {
            var e = this._event;
            if (bowser.msie && Number(bowser.version) <= 8) {
                e.returnValue = false;
            }
            else {
                e.preventDefault();
            }
        };
        DomEvent.prototype.getDataFromCustomEvent = function (event) {
            this.target = event.target;
            this.currentTarget = event.currentTarget;
            this.isStopPropagation = event.isStopPropagation;
        };
        return DomEvent;
    }(wd.Event));
    wd.DomEvent = DomEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SPECIAL_KEY_MAP = {
        8: "backspace",
        9: "tab",
        10: "return",
        13: "return",
        16: "shift",
        17: "ctrl",
        18: "alt",
        19: "pause",
        20: "capslock",
        27: "esc",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down",
        45: "insert",
        46: "del",
        59: ";",
        61: "=",
        65: "a",
        66: "b",
        67: "c",
        68: "d",
        69: "e",
        70: "f",
        71: "g",
        72: "h",
        73: "i",
        74: "j",
        75: "k",
        76: "l",
        77: "m",
        78: "n",
        79: "o",
        80: "p",
        81: "q",
        82: "r",
        83: "s",
        84: "t",
        85: "u",
        86: "v",
        87: "w",
        88: "x",
        89: "y",
        90: "z",
        96: "0",
        97: "1",
        98: "2",
        99: "3",
        100: "4",
        101: "5",
        102: "6",
        103: "7",
        104: "8",
        105: "9",
        106: "*",
        107: "+",
        109: "-",
        110: ".",
        111: "/",
        112: "f1",
        113: "f2",
        114: "f3",
        115: "f4",
        116: "f5",
        117: "f6",
        118: "f7",
        119: "f8",
        120: "f9",
        121: "f10",
        122: "f11",
        123: "f12",
        144: "numlock",
        145: "scroll",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'"
    }, SHIFT_KEY_MAP = {
        "`": "~",
        "1": "!",
        "2": "@",
        "3": "#",
        "4": "$",
        "5": "%",
        "6": "^",
        "7": "&",
        "8": "*",
        "9": "(",
        "0": ")",
        "-": "_",
        "=": "+",
        ";": ": ",
        "'": "\"",
        ",": "<",
        ".": ">",
        "/": "?",
        "\\": "|"
    };
    var KeyboardEvent = (function (_super) {
        __extends(KeyboardEvent, _super);
        function KeyboardEvent() {
            _super.apply(this, arguments);
            this.type = wd.EEventType.KEYBOARD;
            this.keyState = null;
        }
        KeyboardEvent.create = function (event, eventName) {
            var obj = new this(event, eventName);
            return obj;
        };
        Object.defineProperty(KeyboardEvent.prototype, "ctrlKey", {
            get: function () {
                return this.event.ctrlKey;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyboardEvent.prototype, "altKey", {
            get: function () {
                return this.event.altKey;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyboardEvent.prototype, "shiftKey", {
            get: function () {
                return this.event.shiftKey;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyboardEvent.prototype, "metaKey", {
            get: function () {
                return this.event.metaKey;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyboardEvent.prototype, "keyCode", {
            get: function () {
                return this.event.keyCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KeyboardEvent.prototype, "key", {
            get: function () {
                var key = SPECIAL_KEY_MAP[this.keyCode], char = null;
                if (!key) {
                    char = String.fromCharCode(this.keyCode).toLowerCase();
                    if (this.shiftKey) {
                        return SHIFT_KEY_MAP[char];
                    }
                    return char;
                }
                return key;
            },
            enumerable: true,
            configurable: true
        });
        KeyboardEvent.prototype.clone = function () {
            var eventObj = KeyboardEvent.create(this.event, this.name);
            return this.copyMember(eventObj, this, ["target", "currentTarget", "isStopPropagation", "phase"]);
        };
        return KeyboardEvent;
    }(wd.DomEvent));
    wd.KeyboardEvent = KeyboardEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PointEvent = (function (_super) {
        __extends(PointEvent, _super);
        function PointEvent() {
            _super.apply(this, arguments);
            this.type = wd.EEventType.POINT;
            this.eventObj = null;
        }
        Object.defineProperty(PointEvent.prototype, "lastX", {
            get: function () {
                return this.eventObj.lastX;
            },
            set: function (x) {
                this.eventObj.lastX = x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointEvent.prototype, "lastY", {
            get: function () {
                return this.eventObj.lastY;
            },
            set: function (y) {
                this.eventObj.lastY = y;
            },
            enumerable: true,
            configurable: true
        });
        PointEvent.prototype.cloneHelper = function (eventObj) {
            eventObj.event = this.event;
            return this.copyMember(eventObj, this, ["eventObj", "target", "currentTarget", "isStopPropagation", "phase", "lastX", "lastY"]);
        };
        return PointEvent;
    }(wd.DomEvent));
    wd.PointEvent = PointEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TouchPointEvent = (function (_super) {
        __extends(TouchPointEvent, _super);
        function TouchPointEvent() {
            _super.apply(this, arguments);
            this.button = null;
        }
        TouchPointEvent.create = function (eventName) {
            var obj = new this(null, eventName);
            return obj;
        };
        Object.defineProperty(TouchPointEvent.prototype, "location", {
            get: function () {
                return this.eventObj.location;
            },
            set: function (point) {
                this.eventObj.location = point;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TouchPointEvent.prototype, "locationInView", {
            get: function () {
                return this.eventObj.locationInView;
            },
            set: function (locationInView) {
                this.eventObj.locationInView = locationInView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TouchPointEvent.prototype, "wheel", {
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TouchPointEvent.prototype, "movementDelta", {
            get: function () {
                return this.eventObj.movementDelta;
            },
            enumerable: true,
            configurable: true
        });
        TouchPointEvent.prototype.getDataFromEventObj = function (e) {
            var touchData = e.touchData;
            this.eventObj = e;
            this.event = {
                clientX: touchData.clientX,
                clientY: touchData.clientY,
                pageX: touchData.pageX,
                pageY: touchData.pageY,
                target: touchData.target,
                currentTarget: e.currentTarget
            };
        };
        TouchPointEvent.prototype.clone = function () {
            return this.cloneHelper(TouchPointEvent.create(this.name));
        };
        return TouchPointEvent;
    }(wd.PointEvent));
    wd.TouchPointEvent = TouchPointEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MousePointEvent = (function (_super) {
        __extends(MousePointEvent, _super);
        function MousePointEvent() {
            _super.apply(this, arguments);
        }
        MousePointEvent.create = function (eventName) {
            var obj = new this(null, eventName);
            return obj;
        };
        Object.defineProperty(MousePointEvent.prototype, "location", {
            get: function () {
                return this.eventObj.location;
            },
            set: function (point) {
                this.eventObj.location = point;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MousePointEvent.prototype, "locationInView", {
            get: function () {
                return this.eventObj.locationInView;
            },
            set: function (locationInView) {
                this.eventObj.locationInView = locationInView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MousePointEvent.prototype, "button", {
            get: function () {
                return this.eventObj.button;
            },
            set: function (button) {
                this.eventObj.button = button;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MousePointEvent.prototype, "wheel", {
            get: function () {
                return this.eventObj.wheel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MousePointEvent.prototype, "movementDelta", {
            get: function () {
                return this.eventObj.movementDelta;
            },
            enumerable: true,
            configurable: true
        });
        MousePointEvent.prototype.getDataFromEventObj = function (e) {
            this.eventObj = e;
            this.event = e.event;
        };
        MousePointEvent.prototype.clone = function () {
            return this.cloneHelper(MousePointEvent.create(this.name));
        };
        return MousePointEvent;
    }(wd.PointEvent));
    wd.MousePointEvent = MousePointEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MouseEvent = (function (_super) {
        __extends(MouseEvent, _super);
        function MouseEvent() {
            _super.apply(this, arguments);
            this._location = null;
            this._locationInView = null;
            this._button = null;
            this.type = wd.EEventType.MOUSE;
            this.lastX = null;
            this.lastY = null;
        }
        MouseEvent.create = function (event, eventName) {
            var obj = new this(event, eventName);
            return obj;
        };
        Object.defineProperty(MouseEvent.prototype, "location", {
            get: function () {
                var point = null, e = this.event;
                if (this._location) {
                    return this._location;
                }
                point = wd.Point.create();
                if (bowser.msie) {
                    point.x = e.clientX + document.body.scrollLeft || document.documentElement.scrollLeft;
                    point.y = e.clientY + document.body.scrollTop || document.documentElement.scrollTop;
                }
                else {
                    point.x = e.pageX;
                    point.y = e.pageY;
                }
                return point;
            },
            set: function (point) {
                this._location = point;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseEvent.prototype, "locationInView", {
            get: function () {
                var point = null, viewOffset = null;
                if (this._locationInView) {
                    return this._locationInView;
                }
                point = this.location;
                viewOffset = wd.DeviceManager.getInstance().view.offset;
                return wd.Point.create(point.x - viewOffset.x, point.y - viewOffset.y);
            },
            set: function (locationInView) {
                this._locationInView = locationInView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseEvent.prototype, "button", {
            get: function () {
                var e = this.event, mouseButton = null;
                if (bowser.mobile) {
                    return null;
                }
                if (this._button !== null) {
                    return this._button;
                }
                if (bowser.msie) {
                    switch (e.button) {
                        case 1:
                            mouseButton = wd.EMouseButton.LEFT;
                            break;
                        case 4:
                            mouseButton = wd.EMouseButton.RIGHT;
                            break;
                        case 2:
                            mouseButton = wd.EMouseButton.CENTER;
                            break;
                        default:
                            wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("multi mouse button"));
                            break;
                    }
                }
                else {
                    switch (e.button) {
                        case 0:
                            mouseButton = wd.EMouseButton.LEFT;
                            break;
                        case 1:
                            mouseButton = wd.EMouseButton.RIGHT;
                            break;
                        case 2:
                            mouseButton = wd.EMouseButton.CENTER;
                            break;
                        default:
                            wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("multi mouse button"));
                            break;
                    }
                }
                return mouseButton;
            },
            set: function (button) {
                this._button = button;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseEvent.prototype, "wheel", {
            get: function () {
                var e = this.event;
                if (bowser.mobile) {
                    return null;
                }
                if (e.detail) {
                    return -1 * e.detail;
                }
                if (e.wheelDelta) {
                    return e.wheelDelta / 120;
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseEvent.prototype, "movementDelta", {
            get: function () {
                var e = this.event, dx = null, dy = null;
                if (this._isPointerLocked()) {
                    dx = e.movementX || e.webkitMovementX || e.mozMovementX || 0;
                    dy = e.movementY || e.webkitMovementY || e.mozMovementY || 0;
                }
                else {
                    var location_1 = this.location, lastX = this.lastX, lastY = this.lastY;
                    if (lastX === null && lastY === null) {
                        dx = 0;
                        dy = 0;
                    }
                    else {
                        dx = location_1.x - lastX;
                        dy = location_1.y - lastY;
                    }
                }
                return {
                    x: dx,
                    y: dy
                };
            },
            enumerable: true,
            configurable: true
        });
        MouseEvent.prototype.clone = function () {
            var eventObj = MouseEvent.create(this.event, this.name);
            return this.copyMember(eventObj, this, ["target", "currentTarget", "isStopPropagation", "phase", "lastX", "lastY"]);
        };
        MouseEvent.prototype._isPointerLocked = function () {
            return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
        };
        return MouseEvent;
    }(wd.DomEvent));
    wd.MouseEvent = MouseEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TouchEvent = (function (_super) {
        __extends(TouchEvent, _super);
        function TouchEvent() {
            _super.apply(this, arguments);
            this._location = null;
            this._locationInView = null;
            this.type = wd.EEventType.TOUCH;
            this.lastX = null;
            this.lastY = null;
        }
        TouchEvent.create = function (event, eventName) {
            var obj = new this(event, eventName);
            return obj;
        };
        Object.defineProperty(TouchEvent.prototype, "location", {
            get: function () {
                var point = null;
                if (this._location) {
                    return this._location;
                }
                var touchData = this.touchData;
                point = wd.Point.create();
                point.x = touchData.pageX;
                point.y = touchData.pageY;
                return point;
            },
            set: function (point) {
                this._location = point;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TouchEvent.prototype, "touchData", {
            get: function () {
                var touches = this.event.changedTouches;
                return touches[0];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TouchEvent.prototype, "locationInView", {
            get: function () {
                var point = null, viewOffset = null;
                if (this._locationInView) {
                    return this._locationInView;
                }
                point = this.location;
                viewOffset = wd.DeviceManager.getInstance().view.offset;
                return wd.Point.create(point.x - viewOffset.x, point.y - viewOffset.y);
            },
            set: function (locationInView) {
                this._locationInView = locationInView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TouchEvent.prototype, "movementDelta", {
            get: function () {
                var dx = null, dy = null, location = this.location, lastX = this.lastX, lastY = this.lastY;
                if (lastX === null && lastY === null) {
                    dx = 0;
                    dy = 0;
                }
                else {
                    dx = location.x - lastX;
                    dy = location.y - lastY;
                }
                return {
                    x: dx,
                    y: dy
                };
            },
            enumerable: true,
            configurable: true
        });
        TouchEvent.prototype.clone = function () {
            var eventObj = TouchEvent.create(this.event, this.name);
            return this.copyMember(eventObj, this, ["target", "currentTarget", "isStopPropagation", "phase", "lastX", "lastY"]);
        };
        __decorate([
            wd.ensureGetter(function (touchData) {
                wd.it("should exist touch data", function () {
                    wd.expect(touchData).exist;
                }, this);
            })
        ], TouchEvent.prototype, "touchData", null);
        return TouchEvent;
    }(wd.DomEvent));
    wd.TouchEvent = TouchEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomEvent = (function (_super) {
        __extends(CustomEvent, _super);
        function CustomEvent() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            _super.call(this, args[0]);
            this.type = wd.EEventType.CUSTOM;
            this.userData = null;
            if (args.length === 2) {
                var userData = args[1];
                this.userData = userData;
            }
        }
        CustomEvent.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var obj = null;
            if (args.length === 1) {
                obj = new this(args[0]);
            }
            else {
                obj = new this(args[0], args[1]);
            }
            return obj;
        };
        CustomEvent.prototype.copyPublicAttri = function (destination, source) {
            var property = null;
            wdCb.ExtendUtils.extend(destination, function (item, property) {
                return property.slice(0, 1) !== "_"
                    && !wd.JudgeUtils.isFunction(item);
            });
            return destination;
        };
        CustomEvent.prototype.clone = function () {
            var eventObj = CustomEvent.create(this.name);
            return this.copyMember(eventObj, this, ["target", "currentTarget", "isStopPropagation", "phase"]);
        };
        CustomEvent.prototype.getDataFromDomEvent = function (event) {
            this.target = event.target;
            this.currentTarget = event.currentTarget;
            this.isStopPropagation = event.isStopPropagation;
        };
        return CustomEvent;
    }(wd.Event));
    wd.CustomEvent = CustomEvent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EMouseButton) {
        EMouseButton[EMouseButton["LEFT"] = 0] = "LEFT";
        EMouseButton[EMouseButton["RIGHT"] = 1] = "RIGHT";
        EMouseButton[EMouseButton["CENTER"] = 2] = "CENTER";
    })(wd.EMouseButton || (wd.EMouseButton = {}));
    var EMouseButton = wd.EMouseButton;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventHandler = (function () {
        function EventHandler() {
        }
        return EventHandler;
    }());
    wd.EventHandler = EventHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DomEventHandler = (function (_super) {
        __extends(DomEventHandler, _super);
        function DomEventHandler() {
            _super.apply(this, arguments);
        }
        DomEventHandler.prototype.off = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var self = this, eventName = null, dom = null, eventRegister = wd.DomEventRegister.getInstance(), eventOffDataList = null;
            if (args.length === 1) {
                eventName = args[0];
                dom = this.getDefaultDom();
                eventOffDataList = eventRegister.remove(eventName);
            }
            else if (args.length === 2 && wd.JudgeUtils.isDom(args[0])) {
                dom = args[0];
                eventName = args[1];
                eventOffDataList = eventRegister.remove(dom, eventName);
            }
            else if (args.length === 2) {
                var handler = args[1];
                eventName = args[0];
                dom = this.getDefaultDom();
                eventOffDataList = eventRegister.remove(eventName, handler);
            }
            else {
                var handler = args[2];
                dom = args[0];
                eventName = args[1];
                eventOffDataList = eventRegister.remove(dom, eventName, handler);
            }
            if (eventOffDataList && !eventRegister.isBinded(dom, eventName)) {
                eventOffDataList.forEach(function (eventOffData) {
                    self._unBind(eventOffData.dom, eventOffData.eventName, eventOffData.domHandler);
                });
            }
        };
        DomEventHandler.prototype.trigger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var dom = null, event = null, eventName = null, registerDataList = null;
            if (args.length === 1) {
                event = args[0];
                dom = this.getDefaultDom();
            }
            else {
                dom = args[0];
                event = args[1];
            }
            eventName = event.name;
            registerDataList = wd.DomEventRegister.getInstance().getEventRegisterDataList(dom, eventName);
            if (registerDataList === null || registerDataList.getCount() === 0) {
                return;
            }
            registerDataList.forEach(function (registerData) {
                var eventCopy = event.clone();
                registerData.handler(eventCopy, registerData.eventData);
            });
        };
        DomEventHandler.prototype.clearHandler = function () {
        };
        DomEventHandler.prototype.buildDomHandler = function (dom, eventName) {
            var self = this, context = wd.root;
            return wdCb.EventUtils.bindEvent(context, function (event) {
                self.triggerDomEvent(dom, event, eventName);
            });
        };
        DomEventHandler.prototype.handler = function (dom, eventName, handler, priority) {
            var domHandler = null, originHandler = handler;
            handler = this.addEngineHandler(eventName, handler);
            if (!wd.DomEventRegister.getInstance().isBinded(dom, eventName)) {
                domHandler = this._bind(dom, eventName);
            }
            else {
                domHandler = wd.DomEventRegister.getInstance().getDomHandler(dom, eventName);
            }
            wd.DomEventRegister.getInstance().register(dom, eventName, this.createEventData(), handler, originHandler, domHandler, priority);
        };
        DomEventHandler.prototype._bind = function (dom, eventName) {
            var domHandler = null;
            domHandler = this.buildDomHandler(dom, eventName);
            wdCb.EventUtils.addEvent(dom, wd.EventNameHandler.handleEventName(eventName), domHandler);
            return domHandler;
        };
        DomEventHandler.prototype._unBind = function (dom, eventName, handler) {
            wdCb.EventUtils.removeEvent(dom, wd.EventNameHandler.handleEventName(eventName), handler);
        };
        __decorate([
            wd.virtual
        ], DomEventHandler.prototype, "clearHandler", null);
        return DomEventHandler;
    }(wd.EventHandler));
    wd.DomEventHandler = DomEventHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PointEventHandler = (function (_super) {
        __extends(PointEventHandler, _super);
        function PointEventHandler() {
            _super.apply(this, arguments);
        }
        PointEventHandler.prototype.on = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var dom = null, eventName = null, handler = null, priority = null;
            if (args.length === 3) {
                dom = this.getDefaultDom();
                eventName = args[0];
                handler = args[1];
                priority = args[2];
            }
            else {
                dom = args[0];
                eventName = args[1];
                handler = args[2];
                priority = args[3];
            }
            this.handler(dom, eventName, handler, priority);
        };
        PointEventHandler.prototype.getDefaultDom = function () {
            return document.body;
        };
        PointEventHandler.prototype.triggerDomEvent = function (dom, event, eventName) {
            var eventObj = this.createEventObject(dom, event, eventName);
            wd.EventManager.trigger(dom, eventObj);
        };
        PointEventHandler.prototype.createEventData = function () {
            var eventData = wdCb.Hash.create();
            eventData.addChild("lastX", null);
            eventData.addChild("lastY", null);
            return eventData;
        };
        PointEventHandler.prototype.handleMove = function (handler) {
            var self = this;
            return function (event, eventData) {
                self._copyEventDataToEventObject(event, eventData);
                handler(event);
                self._saveLocation(event, eventData);
            };
        };
        PointEventHandler.prototype._copyEventDataToEventObject = function (event, eventData) {
            event.lastX = eventData.getChild("lastX");
            event.lastY = eventData.getChild("lastY");
        };
        PointEventHandler.prototype._saveLocation = function (event, eventData) {
            var location = event.location;
            eventData.setValue("lastX", location.x);
            eventData.setValue("lastY", location.y);
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (args.length === 4) {
                    var dom_1 = args[0];
                    wd.it("first param should be HTMLElement", function () {
                        wd.expect(wd.JudgeUtils.isDom(dom_1)).true;
                    });
                }
            })
        ], PointEventHandler.prototype, "on", null);
        return PointEventHandler;
    }(wd.DomEventHandler));
    wd.PointEventHandler = PointEventHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MouseEventHandler = (function (_super) {
        __extends(MouseEventHandler, _super);
        function MouseEventHandler() {
            _super.call(this);
        }
        MouseEventHandler.getInstance = function () { };
        MouseEventHandler.prototype.addEngineHandler = function (eventName, handler) {
            var resultHandler = null;
            switch (eventName) {
                case wd.EEventName.MOUSEMOVE:
                    resultHandler = this.handleMove(handler);
                    break;
                default:
                    resultHandler = handler;
                    break;
            }
            return resultHandler;
        };
        MouseEventHandler.prototype.createEventObject = function (dom, event, eventName) {
            var obj = wd.MouseEvent.create(event ? event : wd.root.event, eventName);
            obj.target = dom;
            return obj;
        };
        MouseEventHandler = __decorate([
            wd.singleton()
        ], MouseEventHandler);
        return MouseEventHandler;
    }(wd.PointEventHandler));
    wd.MouseEventHandler = MouseEventHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TouchEventHandler = (function (_super) {
        __extends(TouchEventHandler, _super);
        function TouchEventHandler() {
            _super.call(this);
        }
        TouchEventHandler.getInstance = function () { };
        TouchEventHandler.prototype.addEngineHandler = function (eventName, handler) {
            var resultHandler = null;
            switch (eventName) {
                case wd.EEventName.TOUCHMOVE:
                    resultHandler = this.handleMove(handler);
                    break;
                default:
                    resultHandler = handler;
                    break;
            }
            return resultHandler;
        };
        TouchEventHandler.prototype.createEventObject = function (dom, event, eventName) {
            var obj = wd.TouchEvent.create(event ? event : wd.root.event, eventName);
            obj.target = dom;
            return obj;
        };
        TouchEventHandler = __decorate([
            wd.singleton()
        ], TouchEventHandler);
        return TouchEventHandler;
    }(wd.PointEventHandler));
    wd.TouchEventHandler = TouchEventHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var KeyboardEventHandler = (function (_super) {
        __extends(KeyboardEventHandler, _super);
        function KeyboardEventHandler() {
            _super.call(this);
        }
        KeyboardEventHandler.getInstance = function () { };
        KeyboardEventHandler.prototype.on = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eventName = null, handler = null, priority = null;
            if (args.length === 3) {
                eventName = args[0];
                handler = args[1];
                priority = args[2];
            }
            else {
                wd.Log.warn("keyboard event can only bind on document.body");
                eventName = args[1];
                handler = args[2];
                priority = args[3];
            }
            this.handler(this.getDefaultDom(), eventName, handler, priority);
        };
        KeyboardEventHandler.prototype.triggerDomEvent = function (dom, event, eventName) {
            var eventObj = this._createEventObject(dom, event, eventName);
            wd.EventManager.trigger(dom, eventObj);
        };
        KeyboardEventHandler.prototype.getDefaultDom = function () {
            return document.body;
        };
        KeyboardEventHandler.prototype.addEngineHandler = function (eventName, handler) {
            var resultHandler = null;
            switch (eventName) {
                case wd.EEventName.KEYDOWN:
                    resultHandler = this._handleKeyDown(handler);
                    break;
                case wd.EEventName.KEYUP:
                    resultHandler = this._handleKeyUp(handler);
                    break;
                default:
                    resultHandler = handler;
                    break;
            }
            return resultHandler;
        };
        KeyboardEventHandler.prototype.createEventData = function () {
            var eventData = wdCb.Hash.create();
            eventData.addChild("keyState", {});
            return eventData;
        };
        KeyboardEventHandler.prototype._handleKeyDown = function (handler) {
            var self = this;
            return function (event, eventData) {
                var keyState = eventData.getChild("keyState");
                self._setKeyStateAllFalse(keyState);
                keyState[event.key] = true;
                self._copyEventDataToEventObject(event, eventData);
                handler(event);
            };
        };
        KeyboardEventHandler.prototype._handleKeyUp = function (handler) {
            var self = this;
            return function (event, eventData) {
                self._setKeyStateAllFalse(eventData.getChild("keyState"));
                self._copyEventDataToEventObject(event, eventData);
                handler(event);
            };
        };
        KeyboardEventHandler.prototype._copyEventDataToEventObject = function (event, eventData) {
            event.keyState = eventData.getChild("keyState");
        };
        KeyboardEventHandler.prototype._setKeyStateAllFalse = function (keyState) {
            for (var i in keyState) {
                if (keyState.hasOwnProperty(i)) {
                    keyState[i] = false;
                }
            }
        };
        KeyboardEventHandler.prototype._createEventObject = function (dom, event, eventName) {
            var obj = wd.KeyboardEvent.create(event ? event : wd.root.event, eventName);
            obj.target = dom;
            return obj;
        };
        KeyboardEventHandler = __decorate([
            wd.singleton()
        ], KeyboardEventHandler);
        return KeyboardEventHandler;
    }(wd.DomEventHandler));
    wd.KeyboardEventHandler = KeyboardEventHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomEventHandler = (function (_super) {
        __extends(CustomEventHandler, _super);
        function CustomEventHandler() {
            _super.call(this);
        }
        CustomEventHandler.getInstance = function () { };
        CustomEventHandler.prototype.on = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 3) {
                var eventName = args[0], handler = args[1], originHandler = handler, priority = args[2];
                wd.CustomEventRegister.getInstance().register(eventName, handler, originHandler, null, priority);
            }
            else if (args.length === 4) {
                var target = args[0], eventName = args[1], handler = args[2], originHandler = handler, priority = args[3];
                wd.CustomEventRegister.getInstance().register(target, eventName, handler, originHandler, null, priority);
            }
        };
        CustomEventHandler.prototype.off = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eventRegister = wd.CustomEventRegister.getInstance();
            eventRegister.remove.apply(eventRegister, args);
        };
        CustomEventHandler.prototype.trigger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var event = null;
            if (args.length === 1 || args.length === 2) {
                var userData = null;
                if (args.length === 1) {
                    event = args[0];
                }
                else {
                    event = args[0];
                    userData = args[1];
                }
                return this._triggerEventHandler(event, userData);
            }
            else if (args.length === 3 || args.length === 4) {
                var target = null, userData = null, notSetTarget = null;
                if (args.length === 3) {
                    target = args[0];
                    event = args[1];
                    notSetTarget = args[2];
                }
                else {
                    target = args[0];
                    event = args[1];
                    userData = args[2];
                    notSetTarget = args[3];
                }
                return this._triggerTargetAndEventHandler(target, event, userData, notSetTarget);
            }
        };
        CustomEventHandler.prototype._triggerEventHandler = function (event, userData) {
            var registerDataList = null, self = this;
            registerDataList = wd.CustomEventRegister.getInstance().getEventRegisterDataList(event.name);
            if (registerDataList === null || registerDataList.getCount() === 0) {
                return false;
            }
            registerDataList.forEach(function (registerData) {
                event.currentTarget = registerData.target;
                event.target = registerData.target;
                self._setUserData(event, userData);
                registerData.handler(event);
            });
            return true;
        };
        CustomEventHandler.prototype._triggerTargetAndEventHandler = function (target, event, userData, notSetTarget) {
            var registerDataList = null, isStopPropagation = false, self = this;
            if (!notSetTarget) {
                event.target = target;
            }
            registerDataList = wd.CustomEventRegister.getInstance().getEventRegisterDataList(target, event.name);
            if (registerDataList === null || registerDataList.getCount() === 0) {
                return false;
            }
            registerDataList.forEach(function (registerData) {
                event.currentTarget = registerData.target;
                self._setUserData(event, userData);
                registerData.handler(event);
                if (event.isStopPropagation) {
                    isStopPropagation = true;
                }
            });
            return isStopPropagation;
        };
        CustomEventHandler.prototype._setUserData = function (event, userData) {
            if (userData) {
                event.userData = userData;
            }
        };
        CustomEventHandler = __decorate([
            wd.singleton()
        ], CustomEventHandler);
        return CustomEventHandler;
    }(wd.EventHandler));
    wd.CustomEventHandler = CustomEventHandler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventDispatcher = (function () {
        function EventDispatcher() {
        }
        return EventDispatcher;
    }());
    wd.EventDispatcher = EventDispatcher;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomEventDispatcher = (function (_super) {
        __extends(CustomEventDispatcher, _super);
        function CustomEventDispatcher() {
            _super.call(this);
        }
        CustomEventDispatcher.getInstance = function () { };
        CustomEventDispatcher.prototype.trigger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var length = args.length;
            if (length === 1) {
                var event_9 = args[0], eventType = event_9.type;
                return wd.EventHandlerFactory.createEventHandler(eventType)
                    .trigger(event_9);
            }
            else if (length === 2 && wd.EventUtils.isEvent(args[0])) {
                var event_10 = args[0], userData = args[1], eventType = event_10.type;
                return wd.EventHandlerFactory.createEventHandler(eventType)
                    .trigger(event_10, userData);
            }
            else if ((length === 2 && wd.EventUtils.isEntityObject(args[0])) || (length === 3 && wd.JudgeUtils.isBoolean(args[2]))) {
                var target = args[0], event_11 = args[1], notSetTarget = args[2] === void 0 ? false : args[2], eventType = event_11.type;
                return wd.EventHandlerFactory.createEventHandler(eventType)
                    .trigger(target, event_11, notSetTarget);
            }
            else if (length === 3 || length === 4) {
                var target = args[0], event_12 = args[1], userData = args[2], notSetTarget = args[3] === void 0 ? false : args[3], eventType = event_12.type;
                return wd.EventHandlerFactory.createEventHandler(eventType)
                    .trigger(target, event_12, userData, notSetTarget);
            }
        };
        CustomEventDispatcher.prototype.emit = function (target, eventObject, userData) {
            var isStopPropagation = false;
            if (!target) {
                return;
            }
            eventObject.phase = wd.EEventPhase.EMIT;
            eventObject.target = target;
            do {
                isStopPropagation = this._triggerWithUserData(target, eventObject, userData, true);
                if (isStopPropagation) {
                    break;
                }
                target = target.bubbleParent;
            } while (target);
        };
        CustomEventDispatcher.prototype.broadcast = function (target, eventObject, userData) {
            var self = this;
            var iterator = function (obj) {
                var children = obj.getChildren();
                if (children.getCount() === 0) {
                    return;
                }
                children.forEach(function (child) {
                    self._triggerWithUserData(child, eventObject, userData, true);
                    iterator(child);
                });
            };
            if (!target) {
                return;
            }
            eventObject.phase = wd.EEventPhase.BROADCAST;
            eventObject.target = target;
            this._triggerWithUserData(target, eventObject, userData, true);
            iterator(target);
        };
        CustomEventDispatcher.prototype._triggerWithUserData = function (target, event, userData, notSetTarget) {
            return userData ? this.trigger(target, event, userData, notSetTarget)
                : this.trigger(target, event, notSetTarget);
        };
        CustomEventDispatcher = __decorate([
            wd.singleton()
        ], CustomEventDispatcher);
        return CustomEventDispatcher;
    }(wd.EventDispatcher));
    wd.CustomEventDispatcher = CustomEventDispatcher;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DomEventDispatcher = (function (_super) {
        __extends(DomEventDispatcher, _super);
        function DomEventDispatcher() {
            _super.call(this);
        }
        DomEventDispatcher.getInstance = function () { };
        DomEventDispatcher.prototype.trigger = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1) {
                var event_13 = args[0], eventType = event_13.type;
                wd.EventHandlerFactory.createEventHandler(eventType)
                    .trigger(event_13);
            }
            else if (args.length === 2) {
                var dom = args[0], event_14 = args[1], eventType = event_14.type;
                wd.EventHandlerFactory.createEventHandler(eventType)
                    .trigger(dom, event_14);
            }
        };
        DomEventDispatcher = __decorate([
            wd.singleton()
        ], DomEventDispatcher);
        return DomEventDispatcher;
    }(wd.EventDispatcher));
    wd.DomEventDispatcher = DomEventDispatcher;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventRegister = (function () {
        function EventRegister() {
        }
        EventRegister.prototype.getEventRegisterDataList = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = this.listenerMap.getChild.apply(this.listenerMap, args);
            if (!result) {
                return null;
            }
            return result.sort(function (dataA, dataB) {
                return dataB.priority - dataA.priority;
            }, true);
        };
        EventRegister.prototype.forEachAll = function (func) {
            return this.listenerMap.forEachAll(func);
        };
        EventRegister.prototype.forEachEventName = function (func) {
            this.listenerMap.forEachEventName(func);
        };
        EventRegister.prototype.clear = function () {
            return this.listenerMap.clear();
        };
        EventRegister.prototype.getChild = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return this.listenerMap.getChild.apply(this.listenerMap, Array.prototype.slice.call(arguments, 0));
        };
        return EventRegister;
    }());
    wd.EventRegister = EventRegister;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomEventRegister = (function (_super) {
        __extends(CustomEventRegister, _super);
        function CustomEventRegister() {
            _super.call(this);
            this.listenerMap = wd.CustomEventListenerMap.create();
        }
        CustomEventRegister.getInstance = function () { };
        CustomEventRegister.prototype.register = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 5) {
                var eventName = args[0], handler = args[1], originHandler = args[2], domHandler = args[3], priority = args[4];
                this.listenerMap.appendChild(eventName, {
                    target: null,
                    eventName: eventName,
                    handler: handler,
                    originHandler: originHandler,
                    domHandler: domHandler,
                    priority: priority
                });
            }
            else {
                var target = args[0], eventName = args[1], handler = args[2], originHandler = args[3], domHandler = args[4], priority = args[5];
                this.listenerMap.appendChild(target, eventName, {
                    target: target,
                    eventName: eventName,
                    handler: handler,
                    originHandler: originHandler,
                    domHandler: domHandler,
                    priority: priority
                });
            }
        };
        CustomEventRegister.prototype.remove = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var target = args[0];
            if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0];
                this.listenerMap.removeChild(eventName);
            }
            else if (args.length === 1 && args[0] instanceof wd.EntityObject) {
                this.listenerMap.removeChild(target);
                this._handleAfterAllEventHandlerRemoved(target);
            }
            else if (args.length === 2 && wd.JudgeUtils.isFunction(args[1])) {
                var eventName = args[0], handler = args[1];
                this.listenerMap.removeChild(eventName, handler);
            }
            else if (args.length === 2 && wd.JudgeUtils.isNumber(args[0])) {
                var uid = args[0], eventName = args[1];
                this.listenerMap.removeChild(uid, eventName);
            }
            else if ((args.length === 2 && args[0] instanceof wd.EntityObject) || args.length === 3) {
                this.listenerMap.removeChild.apply(this.listenerMap, args);
                if (this._isAllEventHandlerRemoved(target)) {
                    this._handleAfterAllEventHandlerRemoved(target);
                }
            }
        };
        CustomEventRegister.prototype.setBubbleParent = function (target, parent) {
            target.bubbleParent = parent;
        };
        CustomEventRegister.prototype._isAllEventHandlerRemoved = function (target) {
            return !this.listenerMap.hasChild(target);
        };
        CustomEventRegister.prototype._handleAfterAllEventHandlerRemoved = function (target) {
            this.setBubbleParent(target, null);
        };
        CustomEventRegister = __decorate([
            wd.singleton()
        ], CustomEventRegister);
        return CustomEventRegister;
    }(wd.EventRegister));
    wd.CustomEventRegister = CustomEventRegister;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DomEventRegister = (function (_super) {
        __extends(DomEventRegister, _super);
        function DomEventRegister() {
            _super.call(this);
            this.listenerMap = wd.DomEventListenerMap.create();
        }
        DomEventRegister.getInstance = function () { };
        DomEventRegister.prototype.register = function (dom, eventName, eventData, handler, originHandler, domHandler, priority) {
            this.listenerMap.appendChild(dom, eventName, {
                dom: dom,
                eventName: eventName,
                eventData: eventData,
                handler: handler,
                originHandler: originHandler,
                domHandler: domHandler,
                priority: priority
            });
        };
        DomEventRegister.prototype.remove = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = null;
            if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0];
                result = this.listenerMap.removeChild(eventName);
            }
            else if (args.length === 2 && wd.JudgeUtils.isFunction(args[1])) {
                var eventName = args[0], handler = args[1];
                result = this.listenerMap.removeChild(eventName, handler);
            }
            else if ((args.length === 2 && wd.JudgeUtils.isDom(args[0])) || args.length === 3) {
                result = this.listenerMap.removeChild.apply(this.listenerMap, args);
            }
            return result;
        };
        DomEventRegister.prototype.isBinded = function (dom, eventName) {
            return this.listenerMap.hasChild(dom, eventName);
        };
        DomEventRegister.prototype.getDomHandler = function (dom, eventName) {
            var list = this.getChild(dom, eventName);
            if (list && list.getCount() > 0) {
                return list.getChild(0).domHandler;
            }
        };
        DomEventRegister = __decorate([
            wd.singleton()
        ], DomEventRegister);
        return DomEventRegister;
    }(wd.EventRegister));
    wd.DomEventRegister = DomEventRegister;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventBinder = (function () {
        function EventBinder() {
        }
        return EventBinder;
    }());
    wd.EventBinder = EventBinder;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomEventBinder = (function (_super) {
        __extends(CustomEventBinder, _super);
        function CustomEventBinder() {
            _super.call(this);
        }
        CustomEventBinder.getInstance = function () { };
        CustomEventBinder.prototype.on = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 2) {
                var eventName = args[0], handler = args[1];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(eventName, handler);
            }
            else if (args.length === 3 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1], priority = args[2];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(eventName, handler, priority);
            }
            else if (args.length === 3 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], handler = args[2];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(target, eventName, handler);
            }
            else if (args.length === 4) {
                var target = args[0], eventName = args[1], handler = args[2], priority = args[3];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(target, eventName, handler, priority);
            }
        };
        CustomEventBinder.prototype.off = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eventRegister = wd.CustomEventRegister.getInstance();
            if (args.length === 0) {
                eventRegister.forEachAll(function (list, eventName) {
                    wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                        .off(eventName);
                });
                eventRegister.clear();
            }
            else if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName_8 = args[0];
                eventRegister.forEachEventName(function (list, registeredEventName) {
                    if (registeredEventName === eventName_8) {
                        wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName_8))
                            .off(eventName_8);
                    }
                });
            }
            else if (args.length === 1 && args[0] instanceof wd.EntityObject) {
                var target_1 = args[0], secondMap = null;
                secondMap = eventRegister.getChild(target_1);
                if (!!secondMap) {
                    secondMap.forEach(function (list, eventName) {
                        wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                            .off(target_1, eventName);
                    });
                }
            }
            else if (args.length === 2 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .off(eventName, handler);
            }
            else if (args.length === 2 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .off(target, eventName);
            }
            else if (args.length === 3 && args[0] instanceof wd.EntityObject) {
                var target = args[0], eventName = args[1], handler = args[2];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .off(target, eventName, handler);
            }
        };
        CustomEventBinder = __decorate([
            wd.singleton()
        ], CustomEventBinder);
        return CustomEventBinder;
    }(wd.EventBinder));
    wd.CustomEventBinder = CustomEventBinder;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DomEventBinder = (function (_super) {
        __extends(DomEventBinder, _super);
        function DomEventBinder() {
            _super.call(this);
        }
        DomEventBinder.getInstance = function () { };
        DomEventBinder.prototype.on = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 2 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(eventName, handler);
            }
            else if (args.length === 3 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1], priority = args[2];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(eventName, handler, priority);
            }
            else if (args.length === 3 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1], handler = args[2];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(dom, eventName, handler);
            }
            else if (args.length === 4) {
                var dom = args[0], eventName = args[1], handler = args[2], priority = args[3];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .on(dom, eventName, handler, priority);
            }
        };
        DomEventBinder.prototype.off = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eventRegister = wd.DomEventRegister.getInstance();
            if (args.length === 0) {
                eventRegister.forEachAll(function (list, eventName) {
                    wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                        .off(eventName);
                });
                eventRegister.clear();
            }
            else if (args.length === 1 && wd.JudgeUtils.isString(args[0])) {
                var eventName_9 = args[0];
                eventRegister.forEachEventName(function (list, registeredEventName) {
                    if (registeredEventName === eventName_9) {
                        wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName_9))
                            .off(eventName_9);
                    }
                });
            }
            else if (args.length === 1 && wd.JudgeUtils.isDom(args[0])) {
                var dom_2 = args[0], secondMap = null;
                secondMap = eventRegister.getChild(dom_2);
                if (!!secondMap) {
                    secondMap.forEach(function (list, eventName) {
                        wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                            .off(dom_2, eventName);
                    });
                }
            }
            else if (args.length === 2 && wd.JudgeUtils.isString(args[0])) {
                var eventName = args[0], handler = args[1];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .off(eventName, handler);
            }
            else if (args.length === 2 && wd.JudgeUtils.isDom(args[0])) {
                var dom = args[0], eventName = args[1];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .off(dom, eventName);
            }
            else if (args.length === 3) {
                var dom = args[0], eventName = args[1], handler = args[2];
                wd.EventHandlerFactory.createEventHandler(wd.EventTable.getEventType(eventName))
                    .off(dom, eventName, handler);
            }
        };
        DomEventBinder = __decorate([
            wd.singleton()
        ], DomEventBinder);
        return DomEventBinder;
    }(wd.EventBinder));
    wd.DomEventBinder = DomEventBinder;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventHandlerFactory = (function () {
        function EventHandlerFactory() {
        }
        EventHandlerFactory.createEventHandler = function (eventType) {
            var handler = null;
            switch (eventType) {
                case wd.EEventType.MOUSE:
                    handler = wd.MouseEventHandler.getInstance();
                    break;
                case wd.EEventType.TOUCH:
                    handler = wd.TouchEventHandler.getInstance();
                    break;
                case wd.EEventType.KEYBOARD:
                    handler = wd.KeyboardEventHandler.getInstance();
                    break;
                case wd.EEventType.CUSTOM:
                case wd.EEventType.POINT:
                    handler = wd.CustomEventHandler.getInstance();
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("eventType"));
                    break;
            }
            return handler;
        };
        return EventHandlerFactory;
    }());
    wd.EventHandlerFactory = EventHandlerFactory;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventBinderFactory = (function () {
        function EventBinderFactory() {
        }
        EventBinderFactory.createEventBinder = function (eventName) {
            var binder = null, eventType = wd.EventTable.getEventType(eventName);
            switch (eventType) {
                case wd.EEventType.MOUSE:
                case wd.EEventType.TOUCH:
                case wd.EEventType.KEYBOARD:
                    binder = wd.DomEventBinder.getInstance();
                    break;
                case wd.EEventType.CUSTOM:
                case wd.EEventType.POINT:
                    binder = wd.CustomEventBinder.getInstance();
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("eventName:" + eventName));
                    break;
            }
            return binder;
        };
        return EventBinderFactory;
    }());
    wd.EventBinderFactory = EventBinderFactory;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventDispatcherFactory = (function () {
        function EventDispatcherFactory() {
        }
        EventDispatcherFactory.createEventDispatcher = function (event) {
            var dispatcher = null, eventType = event.type;
            switch (eventType) {
                case wd.EEventType.MOUSE:
                case wd.EEventType.TOUCH:
                case wd.EEventType.KEYBOARD:
                    dispatcher = wd.DomEventDispatcher.getInstance();
                    break;
                case wd.EEventType.CUSTOM:
                case wd.EEventType.POINT:
                    dispatcher = wd.CustomEventDispatcher.getInstance();
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("event:" + event));
                    break;
            }
            return dispatcher;
        };
        return EventDispatcherFactory;
    }());
    wd.EventDispatcherFactory = EventDispatcherFactory;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventUtils = (function () {
        function EventUtils() {
        }
        EventUtils.isEvent = function (arg) {
            return arg && arg.currentTarget !== void 0;
        };
        EventUtils.isEntityObject = function (arg) {
            return arg && arg.bubbleParent !== void 0;
        };
        __decorate([
            wd.ensure(function (isEntityObject, arg) {
                if (isEntityObject) {
                    wd.assert(arg instanceof wd.EntityObject, wd.Log.info.FUNC_MUST_BE("EntityObject, but actual is " + arg));
                }
            })
        ], EventUtils, "isEntityObject", null);
        return EventUtils;
    }());
    wd.EventUtils = EventUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Action = (function (_super) {
        __extends(Action, _super);
        function Action() {
            _super.apply(this, arguments);
            this.p_target = null;
            this.isFinish = false;
        }
        Object.defineProperty(Action.prototype, "isStop", {
            get: function () { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "isPause", {
            get: function () { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "isStart", {
            get: function () {
                return !this.isStop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "target", {
            get: function () {
                return this.p_target;
            },
            set: function (target) {
                this.p_target = target;
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Action.prototype.reset = function () {
            this.isFinish = false;
        };
        Action.prototype.addToObject = function (entityObject, isShareComponent) {
            if (isShareComponent === void 0) { isShareComponent = false; }
            _super.prototype.addToObject.call(this, entityObject, isShareComponent);
            this.target = entityObject;
        };
        Action.prototype.addToComponentContainer = function () {
            var container = wd.ActionComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        Action.prototype.removeFromComponentContainer = function () {
            wd.ActionComponentContainer.getInstance().removeChild(this);
        };
        Action.prototype.init = function () {
            this.start();
        };
        Action.prototype.finish = function () {
            this.isFinish = true;
            this.stop();
        };
        return Action;
    }(wd.Component));
    wd.Action = Action;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ActionInstant = (function (_super) {
        __extends(ActionInstant, _super);
        function ActionInstant() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(ActionInstant.prototype, "isStop", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActionInstant.prototype, "isPause", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        ActionInstant.prototype.start = function () {
        };
        ActionInstant.prototype.stop = function () {
        };
        ActionInstant.prototype.pause = function () {
        };
        ActionInstant.prototype.resume = function () {
        };
        return ActionInstant;
    }(wd.Action));
    wd.ActionInstant = ActionInstant;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CallFunc = (function (_super) {
        __extends(CallFunc, _super);
        function CallFunc(func, context, dataArr) {
            _super.call(this);
            this._context = null;
            this._callFunc = null;
            this._dataArr = null;
            this._context = context || wd.root;
            this._callFunc = func;
            this._dataArr = wdCb.Collection.create(dataArr);
        }
        CallFunc.create = function (func, context) {
            var data = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                data[_i - 2] = arguments[_i];
            }
            var dataArr = Array.prototype.slice.call(arguments, 2), action = new this(func, context, dataArr);
            return action;
        };
        CallFunc.prototype.clone = function () {
            return wd.CloneUtils.clone(this, null, [this._callFunc, this._context, this._dataArr.clone(true).toArray()]);
        };
        CallFunc.prototype.reverse = function () {
            return this;
        };
        CallFunc.prototype.update = function (elapsed) {
            if (this._callFunc) {
                this._callFunc.call(this._context, this.p_target, this._dataArr);
            }
            this.finish();
        };
        return CallFunc;
    }(wd.ActionInstant));
    wd.CallFunc = CallFunc;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ActionInterval = (function (_super) {
        __extends(ActionInterval, _super);
        function ActionInterval() {
            _super.apply(this, arguments);
            this.elapsed = null;
            this.duration = null;
            this._isStop = true;
            this._isPause = false;
            this._timeController = wd.CommonTimeController.create();
        }
        Object.defineProperty(ActionInterval.prototype, "isStop", {
            get: function () {
                return this._isStop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActionInterval.prototype, "isPause", {
            get: function () {
                return this._isPause;
            },
            enumerable: true,
            configurable: true
        });
        ActionInterval.prototype.update = function (elapsed) {
            if (elapsed < this._timeController.startTime) {
                return;
            }
            this.elapsed = this._convertToRatio(this._timeController.computeElapseTime(elapsed));
            this.updateBody(elapsed);
            if (this.elapsed === 1) {
                this.finish();
            }
        };
        ActionInterval.prototype.start = function () {
            this._isStop = false;
            this._timeController.start();
        };
        ActionInterval.prototype.stop = function () {
            this._isStop = true;
            this._timeController.stop();
        };
        ActionInterval.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this._isStop = true;
        };
        ActionInterval.prototype.pause = function () {
            this._isPause = true;
            this._timeController.pause();
        };
        ActionInterval.prototype.resume = function () {
            this._isPause = false;
            this._timeController.resume();
        };
        ActionInterval.prototype.updateBody = function (time) {
        };
        ActionInterval.prototype._convertToRatio = function (elapsed) {
            var ratio = elapsed / this.duration;
            return ratio > 1 ? 1 : ratio;
        };
        __decorate([
            wd.virtual
        ], ActionInterval.prototype, "updateBody", null);
        return ActionInterval;
    }(wd.Action));
    wd.ActionInterval = ActionInterval;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Control = (function (_super) {
        __extends(Control, _super);
        function Control() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(Control.prototype, "target", {
            set: function (target) {
                this.p_target = target;
                this.getInnerActions().forEach(function (action) {
                    action.target = target;
                });
            },
            enumerable: true,
            configurable: true
        });
        Control.prototype.init = function () {
            _super.prototype.init.call(this);
            this.iterate("init");
        };
        Control.prototype.reverse = function () {
            this.iterate("reverse");
            return this;
        };
        Control.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this.iterate("reset");
            return this;
        };
        Control.prototype.iterate = function (method, argArr) {
            this.getInnerActions().forEach(function (action) {
                action[method].apply(action, argArr);
            });
        };
        return Control;
    }(wd.ActionInterval));
    wd.Control = Control;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Sequence = (function (_super) {
        __extends(Sequence, _super);
        function Sequence(actionArr) {
            _super.call(this);
            this._actions = wdCb.Collection.create();
            this._currentAction = null;
            this._actionIndex = 0;
            this._actions.addChildren(actionArr);
        }
        Sequence.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var sequence = new this(args);
            sequence.initWhenCreate();
            return sequence;
        };
        Sequence.prototype.initWhenCreate = function () {
            this._currentAction = this._actions.getChild(0);
        };
        Sequence.prototype.clone = function () {
            return wd.CloneUtils.clone(this, null, this._actions.clone(true).toArray());
        };
        Sequence.prototype.update = function (elapsed) {
            if (this._actionIndex === this._actions.getCount()) {
                this.finish();
                return;
            }
            this._currentAction = this._actions.getChild(this._actionIndex);
            if (this._currentAction.isFinish) {
                this._startNextActionAndJudgeFinish();
                return;
            }
            this._currentAction.update(elapsed);
            if (this._currentAction.isFinish) {
                this._startNextActionAndJudgeFinish();
            }
            return null;
        };
        Sequence.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this._actionIndex = 0;
            this._currentAction = this._actions.getChild(this._actionIndex);
            return this;
        };
        Sequence.prototype.start = function () {
            _super.prototype.start.call(this);
            this._currentAction.start();
            return this;
        };
        Sequence.prototype.stop = function () {
            _super.prototype.stop.call(this);
            this._currentAction.stop();
            return this;
        };
        Sequence.prototype.pause = function () {
            _super.prototype.pause.call(this);
            this._currentAction.pause();
            return this;
        };
        Sequence.prototype.resume = function () {
            _super.prototype.resume.call(this);
            this._currentAction.resume();
            return this;
        };
        Sequence.prototype.reverse = function () {
            this._actions = this._actions.reverse();
            _super.prototype.reverse.call(this);
            return this;
        };
        Sequence.prototype.getInnerActions = function () {
            return this._actions;
        };
        Sequence.prototype._startNextActionAndJudgeFinish = function () {
            this._actionIndex++;
            if (this._actionIndex === this._actions.getCount()) {
                this.finish();
                return;
            }
            this._actions.getChild(this._actionIndex).start();
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.it("action's count should > 1", function () {
                    wd.expect(args.length).to.greaterThan(1);
                });
            })
        ], Sequence, "create", null);
        return Sequence;
    }(wd.Control));
    wd.Sequence = Sequence;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Spawn = (function (_super) {
        __extends(Spawn, _super);
        function Spawn(actionArr) {
            _super.call(this);
            this._actions = wdCb.Collection.create();
            this._actions.addChildren(actionArr);
        }
        Spawn.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var spawn = null;
            spawn = new this(args);
            return spawn;
        };
        Spawn.prototype.clone = function () {
            return wd.CloneUtils.clone(this, null, this._actions.clone(true).toArray());
        };
        Spawn.prototype.update = function (elapsed) {
            if (this._isFinish()) {
                this.finish();
                return;
            }
            this.iterate("update", [elapsed]);
            if (this._isFinish()) {
                this.finish();
            }
        };
        Spawn.prototype.start = function () {
            _super.prototype.start.call(this);
            this.iterate("start");
            return this;
        };
        Spawn.prototype.stop = function () {
            _super.prototype.stop.call(this);
            this.iterate("stop");
            return this;
        };
        Spawn.prototype.pause = function () {
            _super.prototype.pause.call(this);
            this.iterate("pause");
            return this;
        };
        Spawn.prototype.resume = function () {
            _super.prototype.resume.call(this);
            this.iterate("resume");
            return this;
        };
        Spawn.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this.iterate("reset");
            return this;
        };
        Spawn.prototype.reverse = function () {
            this._actions = this._actions.reverse();
            _super.prototype.reverse.call(this);
            return this;
        };
        Spawn.prototype.getInnerActions = function () {
            return this._actions;
        };
        Spawn.prototype.iterate = function (method, argArr) {
            this._actions.forEach(function (action) {
                action[method].apply(action, argArr);
            });
        };
        Spawn.prototype._isFinish = function () {
            var isFinish = true;
            this._actions.forEach(function (action) {
                if (!action.isFinish) {
                    isFinish = false;
                    return wdCb.$BREAK;
                }
            });
            return isFinish;
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.it("action's count should > 1", function () {
                    wd.expect(args.length).to.greaterThan(1);
                });
            })
        ], Spawn, "create", null);
        return Spawn;
    }(wd.Control));
    wd.Spawn = Spawn;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DelayTime = (function (_super) {
        __extends(DelayTime, _super);
        function DelayTime(delayTime) {
            _super.call(this);
            this.duration = delayTime;
        }
        DelayTime.create = function (delayTime) {
            var action = new this(delayTime);
            return action;
        };
        DelayTime.prototype.clone = function () {
            return wd.CloneUtils.clone(this, null, [this.duration]);
        };
        DelayTime.prototype.reverse = function () {
            return this;
        };
        return DelayTime;
    }(wd.ActionInterval));
    wd.DelayTime = DelayTime;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Repeat = (function (_super) {
        __extends(Repeat, _super);
        function Repeat(action, times) {
            _super.call(this);
            this._innerAction = null;
            this._originTimes = null;
            this._times = null;
            this._innerAction = action;
            this._times = times;
        }
        Repeat.create = function (action, times) {
            var repeat = new this(action, times);
            repeat.initWhenCreate();
            return repeat;
        };
        Repeat.prototype.clone = function () {
            return wd.CloneUtils.clone(this, null, [this._innerAction.clone(), this._times]);
        };
        Repeat.prototype.initWhenCreate = function () {
            this._originTimes = this._times;
        };
        Repeat.prototype.update = function (elapsed) {
            if (this._times === 0) {
                this.finish();
                return;
            }
            this._innerAction.update(elapsed);
            if (this._innerAction.isFinish) {
                this._times -= 1;
                if (this._times !== 0) {
                    this._innerAction.reset();
                    this._innerAction.start();
                    return;
                }
                this.finish();
            }
        };
        Repeat.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this._times = this._originTimes;
            return this;
        };
        Repeat.prototype.start = function () {
            _super.prototype.start.call(this);
            this._innerAction.start();
        };
        Repeat.prototype.stop = function () {
            _super.prototype.stop.call(this);
            this._innerAction.stop();
        };
        Repeat.prototype.pause = function () {
            _super.prototype.pause.call(this);
            this._innerAction.pause();
        };
        Repeat.prototype.resume = function () {
            _super.prototype.resume.call(this);
            this._innerAction.resume();
        };
        Repeat.prototype.getInnerActions = function () {
            return wdCb.Collection.create([this._innerAction]);
        };
        return Repeat;
    }(wd.Control));
    wd.Repeat = Repeat;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RepeatForever = (function (_super) {
        __extends(RepeatForever, _super);
        function RepeatForever(action) {
            _super.call(this);
            this._innerAction = null;
            this._innerAction = action;
        }
        RepeatForever.create = function (action) {
            var repeat = new this(action);
            return repeat;
        };
        RepeatForever.prototype.clone = function () {
            return wd.CloneUtils.clone(this, null, [this._innerAction.clone()]);
        };
        RepeatForever.prototype.update = function (elapsed) {
            this._innerAction.update(elapsed);
            if (this._innerAction.isFinish) {
                this._innerAction.reset();
                this._innerAction.start();
            }
        };
        RepeatForever.prototype.start = function () {
            _super.prototype.start.call(this);
            this._innerAction.start();
        };
        RepeatForever.prototype.stop = function () {
            _super.prototype.stop.call(this);
            this._innerAction.stop();
        };
        RepeatForever.prototype.pause = function () {
            _super.prototype.pause.call(this);
            this._innerAction.pause();
        };
        RepeatForever.prototype.resume = function () {
            _super.prototype.resume.call(this);
            this._innerAction.resume();
        };
        RepeatForever.prototype.getInnerActions = function () {
            return wdCb.Collection.create([this._innerAction]);
        };
        return RepeatForever;
    }(wd.Control));
    wd.RepeatForever = RepeatForever;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Tween = (function (_super) {
        __extends(Tween, _super);
        function Tween() {
            _super.apply(this, arguments);
            this._object = null;
            this._valuesStart = wdCb.Hash.create();
            this._valuesEnd = wdCb.Hash.create();
            this._easingFunction = Tween.Easing.Linear.None;
            this._interpolationFunction = Tween.Interpolation.Linear;
            this._onStartCallback = null;
            this._onStartCallbackFired = false;
            this._onUpdateCallback = null;
            this._onFinishCallback = null;
            this._onStopCallback = null;
        }
        Tween.create = function () {
            var obj = new this();
            return obj;
        };
        Tween.prototype.updateBody = function (time) {
            var self = this, easeValue = null;
            if (this._onStartCallbackFired === false) {
                if (this._onStartCallback !== null) {
                    this._onStartCallback.call(this._object.getChildren());
                }
                this._onStartCallbackFired = true;
            }
            easeValue = this._easingFunction(this.elapsed);
            this._valuesEnd.forEach(function (value, key) {
                var start = self._valuesStart.getChild(key), end = value;
                if (end instanceof Array) {
                    self._object.setValue(key, self._interpolationFunction(end, easeValue));
                }
                else {
                    if (wd.JudgeUtils.isString(end)) {
                        end = start + wd.root.parseFloat(end, 10);
                    }
                    if (wd.JudgeUtils.isNumber(end)) {
                        self._object.setValue(key, start + (end - start) * easeValue);
                    }
                }
            });
            if (this._onUpdateCallback !== null) {
                this._onUpdateCallback.call(this._object.getChildren(), easeValue);
            }
            return true;
        };
        Tween.prototype.from = function (object) {
            var self = this;
            this._object = wdCb.Hash.create(object);
            this._object.forEach(function (value, key) {
                self._valuesStart.addChild(key, wd.root.parseFloat(value, 10));
            });
            return this;
        };
        Tween.prototype.to = function (properties, duration) {
            if (duration === void 0) { duration = 1000; }
            this.duration = duration;
            this._valuesEnd = wdCb.Hash.create(properties);
            return this;
        };
        Tween.prototype.init = function () {
            var self = this;
            _super.prototype.init.call(this);
            this._valuesEnd.forEach(function (value, key) {
                if (value instanceof Array) {
                    if (value.length === 0) {
                        return;
                    }
                    self._valuesEnd.setValue(key, [self._object.getChild(key)].concat(self._valuesEnd.getChild(key)));
                }
                self._valuesStart.setValue(key, self._object.getChild(key));
                if ((self._valuesStart.getChild(key) instanceof Array) === false) {
                    self._valuesStart.setValue(key, self._valuesStart.getChild(key) * 1.0);
                }
            });
        };
        Tween.prototype.start = function () {
            _super.prototype.start.call(this);
            this._onStartCallbackFired = false;
            return this;
        };
        Tween.prototype.stop = function () {
            _super.prototype.stop.call(this);
            if (this._onStopCallback !== null) {
                this._onStopCallback.call(this._object.getChildren());
            }
            return this;
        };
        Tween.prototype.reverse = function () {
            var tmp = this._valuesStart;
            this._valuesStart = this._valuesEnd;
            this._valuesEnd = tmp;
        };
        Tween.prototype.easing = function (easing) {
            this._easingFunction = easing;
            return this;
        };
        Tween.prototype.interpolation = function (interpolation) {
            this._interpolationFunction = interpolation;
            return this;
        };
        Tween.prototype.onUpdate = function (callback) {
            this._onUpdateCallback = callback;
            return this;
        };
        Tween.prototype.onFinish = function (callback) {
            this._onFinishCallback = callback;
            return this;
        };
        Tween.prototype.onStart = function (callback) {
            this._onStartCallback = callback;
            return this;
        };
        Tween.prototype.onStop = function (callback) {
            this._onStopCallback = callback;
            return this;
        };
        Tween.prototype.finish = function () {
            _super.prototype.finish.call(this);
            if (this._onFinishCallback !== null) {
                this._onFinishCallback.call(this._object.getChildren());
            }
        };
        Tween.Easing = {
            Linear: {
                None: function (k) {
                    return k;
                }
            },
            Quadratic: {
                In: function (k) {
                    return k * k;
                },
                Out: function (k) {
                    return k * (2 - k);
                },
                InOut: function (k) {
                    if ((k *= 2) < 1)
                        return 0.5 * k * k;
                    return -0.5 * (--k * (k - 2) - 1);
                }
            },
            Cubic: {
                In: function (k) {
                    return k * k * k;
                },
                Out: function (k) {
                    return --k * k * k + 1;
                },
                InOut: function (k) {
                    if ((k *= 2) < 1)
                        return 0.5 * k * k * k;
                    return 0.5 * ((k -= 2) * k * k + 2);
                }
            },
            Quartic: {
                In: function (k) {
                    return k * k * k * k;
                },
                Out: function (k) {
                    return 1 - (--k * k * k * k);
                },
                InOut: function (k) {
                    if ((k *= 2) < 1)
                        return 0.5 * k * k * k * k;
                    return -0.5 * ((k -= 2) * k * k * k - 2);
                }
            },
            Quintic: {
                In: function (k) {
                    return k * k * k * k * k;
                },
                Out: function (k) {
                    return --k * k * k * k * k + 1;
                },
                InOut: function (k) {
                    if ((k *= 2) < 1)
                        return 0.5 * k * k * k * k * k;
                    return 0.5 * ((k -= 2) * k * k * k * k + 2);
                }
            },
            Sinusoidal: {
                In: function (k) {
                    return 1 - Math.cos(k * Math.PI / 2);
                },
                Out: function (k) {
                    return Math.sin(k * Math.PI / 2);
                },
                InOut: function (k) {
                    return 0.5 * (1 - Math.cos(Math.PI * k));
                }
            },
            Exponential: {
                In: function (k) {
                    return k === 0 ? 0 : Math.pow(1024, (k - 1));
                },
                Out: function (k) {
                    return k === 1 ? 1 : 1 - Math.pow(2, (-10 * k));
                },
                InOut: function (k) {
                    if (k === 0)
                        return 0;
                    if (k === 1)
                        return 1;
                    if ((k *= 2) < 1)
                        return 0.5 * Math.pow(1024, (k - 1));
                    return 0.5 * (-(Math.pow(2, (-10 * (k - 1)))) + 2);
                }
            },
            Circular: {
                In: function (k) {
                    return 1 - Math.sqrt(1 - k * k);
                },
                Out: function (k) {
                    return Math.sqrt(1 - (--k * k));
                },
                InOut: function (k) {
                    if ((k *= 2) < 1)
                        return -0.5 * (Math.sqrt(1 - k * k) - 1);
                    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                }
            },
            Elastic: {
                In: function (k) {
                    var s, a = 0.1, p = 0.4;
                    if (k === 0)
                        return 0;
                    if (k === 1)
                        return 1;
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    }
                    else
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    return -(a * Math.pow(2, (10 * (k -= 1))) * Math.sin((k - s) * (2 * Math.PI) / p));
                },
                Out: function (k) {
                    var s, a = 0.1, p = 0.4;
                    if (k === 0)
                        return 0;
                    if (k === 1)
                        return 1;
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    }
                    else
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    return (a * Math.pow(2, (-10 * k)) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
                },
                InOut: function (k) {
                    var s, a = 0.1, p = 0.4;
                    if (k === 0)
                        return 0;
                    if (k === 1)
                        return 1;
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    }
                    else
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    if ((k *= 2) < 1)
                        return -0.5 * (a * Math.pow(2, (10 * (k -= 1))) * Math.sin((k - s) * (2 * Math.PI) / p));
                    return a * Math.pow(2, (-10 * (k -= 1))) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
                }
            },
            Back: {
                In: function (k) {
                    var s = 1.70158;
                    return k * k * ((s + 1) * k - s);
                },
                Out: function (k) {
                    var s = 1.70158;
                    return --k * k * ((s + 1) * k + s) + 1;
                },
                InOut: function (k) {
                    var s = 1.70158 * 1.525;
                    if ((k *= 2) < 1)
                        return 0.5 * (k * k * ((s + 1) * k - s));
                    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                }
            },
            Bounce: {
                In: function (k) {
                    return 1 - Tween.Easing.Bounce.Out(1 - k);
                },
                Out: function (k) {
                    if (k < (1 / 2.75)) {
                        return 7.5625 * k * k;
                    }
                    else if (k < (2 / 2.75)) {
                        return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
                    }
                    else if (k < (2.5 / 2.75)) {
                        return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
                    }
                    else {
                        return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
                    }
                },
                InOut: function (k) {
                    if (k < 0.5)
                        return Tween.Easing.Bounce.In(k * 2) * 0.5;
                    return Tween.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
                }
            }
        };
        Tween.Interpolation = {
            Linear: function (v, k) {
                var m = v.length - 1, f = m * k, i = Math.floor(f), fn = Tween.Interpolation.Utils.Linear;
                if (k < 0)
                    return fn(v[0], v[1], f);
                if (k > 1)
                    return fn(v[m], v[m - 1], m - f);
                return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
            },
            Bezier: function (v, k) {
                var b = 0, n = v.length - 1, bn = Tween.Interpolation.Utils.Bernstein, i;
                for (i = 0; i <= n; i++) {
                    b += Math.pow((1 - k), (n - i)) * Math.pow(k, i) * v[i] * bn(n, i);
                }
                return b;
            },
            CatmullRom: function (v, k) {
                var m = v.length - 1, f = m * k, i = Math.floor(f), fn = Tween.Interpolation.Utils.CatmullRom;
                if (v[0] === v[m]) {
                    if (k < 0)
                        i = Math.floor(f = m * (1 + k));
                    return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
                }
                else {
                    if (k < 0)
                        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
                    if (k > 1)
                        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                    return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
                }
            },
            Utils: {
                Linear: function (p0, p1, t) {
                    return (p1 - p0) * t + p0;
                },
                Bernstein: function (n, i) {
                    var fc = Tween.Interpolation.Utils.Factorial;
                    return fc(n) / fc(i) / fc(n - i);
                },
                Factorial: (function () {
                    var a = [1];
                    return function (n) {
                        var s = 1, i;
                        if (a[n])
                            return a[n];
                        for (i = n; i > 1; i--)
                            s *= i;
                        return a[n] = s;
                    };
                })(),
                CatmullRom: function (p0, p1, p2, p3, t) {
                    var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;
                    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
                }
            }
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "duration", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Tween.prototype, "_valuesStart", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Tween.prototype, "_valuesEnd", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "_easingFunction", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "_interpolationFunction", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "_onStartCallback", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "_onStartCallbackFired", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "_onUpdateCallback", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "_onFinishCallback", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Tween.prototype, "_onStopCallback", void 0);
        return Tween;
    }(wd.ActionInterval));
    wd.Tween = Tween;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            _super.apply(this, arguments);
            this.state = EAnimationState.DEFAULT;
            this.pauseTime = null;
            this.resumeTime = null;
            this.pauseDuration = null;
            this.frameCount = null;
            this._isResume = false;
        }
        Object.defineProperty(Animation.prototype, "isStart", {
            get: function () {
                return this.state === EAnimationState.RUN;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "isStop", {
            get: function () {
                return this.state === EAnimationState.STOP;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "isPause", {
            get: function () {
                return this.state === EAnimationState.PAUSE;
            },
            enumerable: true,
            configurable: true
        });
        Animation.prototype.addToComponentContainer = function () {
            var container = wd.AnimationComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        Animation.prototype.removeFromComponentContainer = function () {
            wd.AnimationComponentContainer.getInstance().removeChild(this);
        };
        Animation.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Animation.prototype.pause = function () {
            this.state = EAnimationState.PAUSE;
            this.pauseTime = this.getPauseTime();
        };
        Animation.prototype.resume = function () {
            this.state = EAnimationState.RUN;
            this._isResume = true;
            this.resumeTime = this.getResumeTime();
        };
        Animation.prototype.stop = function () {
            this.state = EAnimationState.STOP;
            wd.EventManager.emit(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.ANIMATION_STOP));
        };
        Animation.prototype.update = function (elapsed) {
            if (this.state === EAnimationState.DEFAULT || this.isStop) {
                return;
            }
            if (this.isPause) {
                this.handleWhenPause(elapsed);
                return;
            }
            if (this._isResume) {
                this._isResume = false;
                this.continueFromPausePoint(elapsed);
            }
            this.handleUpdate(elapsed);
        };
        Animation.prototype.getPauseTime = function () {
            return this.getCurrentTime();
        };
        Animation.prototype.getResumeTime = function () {
            return this.getCurrentTime();
        };
        Animation.prototype.getCurrentTime = function () {
            return wd.Director.getInstance().elapsed;
        };
        Animation.prototype.continueFromPausePoint = function (elapsed) {
            this.pauseDuration += this.resumeTime - this.pauseTime;
        };
        return Animation;
    }(wd.Component));
    wd.Animation = Animation;
    (function (EAnimationState) {
        EAnimationState[EAnimationState["DEFAULT"] = 0] = "DEFAULT";
        EAnimationState[EAnimationState["RUN"] = 1] = "RUN";
        EAnimationState[EAnimationState["STOP"] = 2] = "STOP";
        EAnimationState[EAnimationState["PAUSE"] = 3] = "PAUSE";
    })(wd.EAnimationState || (wd.EAnimationState = {}));
    var EAnimationState = wd.EAnimationState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SingleLayerKeyFrameAnimation = (function (_super) {
        __extends(SingleLayerKeyFrameAnimation, _super);
        function SingleLayerKeyFrameAnimation() {
            _super.apply(this, arguments);
            this.isFrameChange = false;
        }
        SingleLayerKeyFrameAnimation.prototype.handleUpdate = function (elapsed) {
            this.handleBeforeJudgeWhetherCurrentFrameFinish(elapsed);
            if (this.isCurrentFrameFinish(elapsed)) {
                this.handleWhenCurrentFrameFinish(elapsed);
            }
            else {
                this.isFrameChange = false;
            }
            this.handleAfterJudgeWhetherCurrentFrameFinish(elapsed);
        };
        return SingleLayerKeyFrameAnimation;
    }(wd.Animation));
    wd.SingleLayerKeyFrameAnimation = SingleLayerKeyFrameAnimation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MultiLayerKeyFrameAnimation = (function (_super) {
        __extends(MultiLayerKeyFrameAnimation, _super);
        function MultiLayerKeyFrameAnimation() {
            _super.apply(this, arguments);
            this.controllerList = wdCb.Collection.create();
            this._isPlayOneTime = false;
        }
        MultiLayerKeyFrameAnimation.prototype.init = function () {
            this.createControllerMap();
        };
        MultiLayerKeyFrameAnimation.prototype.playOneTime = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._isPlayOneTime = true;
            this.play.apply(this, args);
        };
        MultiLayerKeyFrameAnimation.prototype.handleUpdate = function (elapsed) {
            var _this = this;
            var self = this;
            this.controllerList.forEach(function (controller) {
                if (!controller.hasCurrentAnimData()) {
                    return;
                }
                _this.handleBeforeJudgeWhetherCurrentFrameFinish(controller, elapsed);
                if (_this.isCurrentFrameFinish(controller, elapsed)) {
                    _this.handleWhenCurrentFrameFinish(controller, elapsed);
                }
                _this.handleAfterJudgeWhetherCurrentFrameFinish(controller, elapsed);
            });
            if (this._isPlayOneTime && this._isAllControllerFinishAnimation()) {
                this.stop();
                return;
            }
            this.handleAfterJudgeWhetherAllCurrentFrameFinish(elapsed);
        };
        MultiLayerKeyFrameAnimation.prototype._isAllControllerFinishAnimation = function () {
            var isFinishAnimation = true;
            this.controllerList.forEach(function (controller) {
                if (!controller.isFinishAnimation) {
                    isFinishAnimation = false;
                    return wdCb.$BREAK;
                }
            });
            return isFinishAnimation;
        };
        return MultiLayerKeyFrameAnimation;
    }(wd.Animation));
    wd.MultiLayerKeyFrameAnimation = MultiLayerKeyFrameAnimation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MorphAnimation = (function (_super) {
        __extends(MorphAnimation, _super);
        function MorphAnimation() {
            _super.apply(this, arguments);
            this.interpolation = 0;
            this.currentFrame = 0;
            this.duration = null;
            this.fps = null;
            this.currentAnimName = null;
            this._prevFrameEndTime = null;
        }
        MorphAnimation.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(MorphAnimation.prototype, "nextFrame", {
            get: function () {
                var nextFrame = this.currentFrame + 1;
                if (nextFrame >= this.frameCount) {
                    nextFrame = 0;
                }
                return nextFrame;
            },
            enumerable: true,
            configurable: true
        });
        MorphAnimation.prototype.init = function () {
        };
        MorphAnimation.prototype.dispose = function () {
        };
        MorphAnimation.prototype.play = function (animName, fps) {
            var geometry = this.entityObject.getComponent(wd.ModelGeometry);
            this.currentAnimName = animName;
            this.fps = fps;
            this.duration = 1.0 / fps * 1000;
            this.frameCount = geometry.morphVertices.getChild(animName).getCount();
            this._resetAnim();
            this.state = wd.EAnimationState.RUN;
        };
        MorphAnimation.prototype.handleWhenPause = function (elapsed) {
        };
        MorphAnimation.prototype.handleWhenCurrentFrameFinish = function (elapsed) {
            this.isFrameChange = true;
            this._prevFrameEndTime = wd.MathUtils.maxFloorIntegralMultiple((elapsed - this.pauseDuration), this.duration);
            this.currentFrame++;
            if (this._isFinishAllFrames()) {
                this.currentFrame = 0;
            }
        };
        MorphAnimation.prototype.handleBeforeJudgeWhetherCurrentFrameFinish = function (elapsed) {
            if (this._prevFrameEndTime === null) {
                this._prevFrameEndTime = this.getCurrentTime();
            }
        };
        MorphAnimation.prototype.isCurrentFrameFinish = function (elapsed) {
            return elapsed - this._prevFrameEndTime - this.pauseDuration > this.duration;
        };
        MorphAnimation.prototype.handleAfterJudgeWhetherCurrentFrameFinish = function (elapsed) {
            this._computeInterpolation(elapsed);
        };
        MorphAnimation.prototype._resetAnim = function () {
            this._prevFrameEndTime = null;
            this.currentFrame = 0;
            this.pauseDuration = 0;
        };
        MorphAnimation.prototype._computeInterpolation = function (elapsed) {
            this.interpolation = this.fps * (elapsed - this._prevFrameEndTime - this.pauseDuration) / 1000;
        };
        MorphAnimation.prototype._isFinishAllFrames = function () {
            return this.currentFrame >= this.frameCount;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MorphAnimation.prototype, "interpolation", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MorphAnimation.prototype, "currentFrame", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MorphAnimation.prototype, "duration", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MorphAnimation.prototype, "fps", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MorphAnimation.prototype, "currentAnimName", void 0);
        __decorate([
            wd.require(function (animName, fps) {
                var geometry = this.entityObject.getComponent(wd.ModelGeometry);
                wd.assert(geometry, wd.Log.info.FUNC_SHOULD("this entityObject", "add ModelGeometry component"));
                wd.assert(geometry.morphVertices.getChild(animName) && geometry.morphVertices.getChild(animName).getCount() > 0, wd.Log.info.FUNC_NOT_EXIST("\"" + animName + "\" animation"));
            }),
            wd.ensure(function () {
                wd.assert(this.frameCount > 1, wd.Log.info.FUNC_SHOULD("frames.count", "> 1"));
            })
        ], MorphAnimation.prototype, "play", null);
        __decorate([
            wd.require(function (elapsed) {
                wd.assert(elapsed - this._prevFrameEndTime - this.pauseDuration >= 0, wd.Log.info.FUNC_SHOULD("elapsed of current frame:" + (elapsed - this._prevFrameEndTime - this.pauseDuration), ">= 0"));
            })
        ], MorphAnimation.prototype, "isCurrentFrameFinish", null);
        __decorate([
            wd.ensure(function () {
                var interpolation = this.interpolation;
                wd.assert(interpolation >= 0 && interpolation <= 1, wd.Log.info.FUNC_SHOULD("interpolation(" + interpolation, ">= 0 && <= 1"));
            })
        ], MorphAnimation.prototype, "_computeInterpolation", null);
        return MorphAnimation;
    }(wd.SingleLayerKeyFrameAnimation));
    wd.MorphAnimation = MorphAnimation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SkinSkeletonAnimation = (function (_super) {
        __extends(SkinSkeletonAnimation, _super);
        function SkinSkeletonAnimation() {
            _super.apply(this, arguments);
            this._jointMatrices = null;
            this.bindShapeMatrix = null;
            this.boneMatrixMap = null;
            this.jointNames = null;
            this.inverseBindMatrices = null;
            this.jointTransformData = null;
            this._jointOrderMap = wdCb.Hash.create();
            this._afterSceneGraphBuildSubcription = null;
            this._inverseNodeToRootMatrix = null;
        }
        SkinSkeletonAnimation.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(SkinSkeletonAnimation.prototype, "jointMatrices", {
            get: function () {
                return this._jointMatrices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinSkeletonAnimation.prototype, "maxJoints", {
            get: function () {
                return this.jointNames.length;
            },
            enumerable: true,
            configurable: true
        });
        SkinSkeletonAnimation.prototype.initWhenCreate = function () {
            this._bindPreComputeEvent();
        };
        SkinSkeletonAnimation.prototype.init = function () {
            _super.prototype.init.call(this);
            this._initJointMatrices();
        };
        SkinSkeletonAnimation.prototype.dispose = function () {
            this._afterSceneGraphBuildSubcription && this._afterSceneGraphBuildSubcription.dispose();
        };
        SkinSkeletonAnimation.prototype.play = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var self = this;
            this.controllerList.forEach(function (controller) {
                controller.resetAnim();
            });
            if (wd.JudgeUtils.isNumber(args[0])) {
                var animIndex_1 = args[0], i_1 = 0;
                this.jointTransformData.forEach(function (jointMap, animName) {
                    if (animIndex_1 === i_1) {
                        jointMap.forEach(function (jointData, jointName) {
                            var controller = self.controllerList.getChild(self._jointOrderMap.getChild(jointName));
                            controller.setCurrentAnimData(animName, jointData);
                        });
                        return wdCb.$BREAK;
                    }
                    i_1++;
                });
            }
            else if (wd.JudgeUtils.isString(args[0])) {
                var animName_1 = args[0];
                this.jointTransformData.getChild(animName_1).forEach(function (jointData, jointName) {
                    var controller = self.controllerList.getChild(self._jointOrderMap.getChild(jointName));
                    controller.setCurrentAnimData(animName_1, jointData);
                });
            }
            this.pauseDuration = 0;
            this.controllerList.forEach(function (controller) {
                if (!controller.hasCurrentAnimData()) {
                    return;
                }
                controller.isPlayed = true;
                controller.updateCurrentFrameData();
                if (controller.getFirstFrameTime() > 0) {
                    controller.addBoneMatrixAsTheFirstFrameWhoseTimeIsZero(self.boneMatrixMap.getChild(controller.jointName));
                }
                controller.saveZeroTimeFrameData();
                controller.setFrameCount();
            });
            this.state = wd.EAnimationState.RUN;
        };
        SkinSkeletonAnimation.prototype.createControllerMap = function () {
            var jointNames = this.jointNames;
            for (var i = 0, len = jointNames.length; i < len; i++) {
                var jointName = jointNames[i], controller = wd.JointKeyFrameController.create();
                controller.jointName = jointName;
                this.controllerList.addChild(controller);
                this._jointOrderMap.addChild(jointName, i);
            }
        };
        SkinSkeletonAnimation.prototype.handleWhenPause = function (elapsed) {
        };
        SkinSkeletonAnimation.prototype.handleWhenCurrentFrameFinish = function (controller, elapsed) {
            controller.updateFrame(elapsed, this.pauseDuration);
            controller.savePrevFrameData();
        };
        SkinSkeletonAnimation.prototype.handleBeforeJudgeWhetherCurrentFrameFinish = function (controller, elapsed) {
            controller.setBeginElapsedTimeOfFirstFrame(this.getCurrentTime());
        };
        SkinSkeletonAnimation.prototype.isCurrentFrameFinish = function (controller, elapsed) {
            return controller.isCurrentFrameFinish(elapsed, this.pauseDuration);
        };
        SkinSkeletonAnimation.prototype.handleAfterJudgeWhetherCurrentFrameFinish = function (controller, elapsed) {
            controller.updateTargets(elapsed, this.pauseDuration);
            this.boneMatrixMap.getChild(controller.jointName).updateLocalMatrix(controller.currentUpdatedTransformMatrix);
        };
        SkinSkeletonAnimation.prototype.handleAfterJudgeWhetherAllCurrentFrameFinish = function (elapsed) {
            var len = 0, inverseNodeToRootMatrix = this._inverseNodeToRootMatrix, bindShapeMatrix = this.bindShapeMatrix, inverseBindMatrices = this.inverseBindMatrices, boneMatrixMap = this.boneMatrixMap, jointMatrices = this.jointMatrices;
            for (var _i = 0, _a = this.jointNames; _i < _a.length; _i++) {
                var jointName = _a[_i];
                var index = this._jointOrderMap.getChild(jointName), mat = null;
                if (bindShapeMatrix !== null) {
                    mat = bindShapeMatrix.applyMatrix(inverseBindMatrices[index], true);
                }
                else {
                    mat = inverseBindMatrices[index].clone();
                }
                mat.applyMatrix(boneMatrixMap.getChild(jointName).globalMatrix)
                    .applyMatrix(inverseNodeToRootMatrix)
                    .cloneToArray(jointMatrices, len);
                len += 16;
            }
        };
        SkinSkeletonAnimation.prototype._initJointMatrices = function () {
            var identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], jointMatrices = [];
            for (var i = 0; i < this.maxJoints; i++) {
                jointMatrices = jointMatrices.concat(identity);
            }
            this._jointMatrices = new Float32Array(jointMatrices);
        };
        SkinSkeletonAnimation.prototype._bindPreComputeEvent = function () {
            var self = this;
            this._afterSceneGraphBuildSubcription = wd.EventManager.fromEvent(wd.EEngineEvent.AFTER_SCENEGRAPH_BUILD)
                .subscribe(function () {
                self._inverseNodeToRootMatrix = self.entityObject.transform.localToWorldMatrix.clone().invert();
            });
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SkinSkeletonAnimation.prototype, "bindShapeMatrix", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                if (source[memberName] === null) {
                    return;
                }
                target[memberName] = source[memberName].clone(true);
            })
        ], SkinSkeletonAnimation.prototype, "boneMatrixMap", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                if (source[memberName] === null) {
                    return;
                }
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], SkinSkeletonAnimation.prototype, "jointNames", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                if (source[memberName] === null) {
                    return;
                }
                var arr = [];
                for (var _i = 0, _a = source[memberName]; _i < _a.length; _i++) {
                    var mat = _a[_i];
                    arr.push(mat.clone());
                }
                target[memberName] = arr;
            })
        ], SkinSkeletonAnimation.prototype, "inverseBindMatrices", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SkinSkeletonAnimation.prototype, "jointTransformData", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SkinSkeletonAnimation.prototype, "_inverseNodeToRootMatrix", void 0);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("all joint of jointNames should be used in jointTransformData", function () {
                    var jointNamesUsedInJointTransformData = wdCb.Collection.create(), isFailed = false;
                    _this.jointTransformData.forEach(function (animationData) {
                        animationData.forEach(function (data, jointName) {
                            jointNamesUsedInJointTransformData.addChild(jointName);
                        });
                    });
                    jointNamesUsedInJointTransformData = jointNamesUsedInJointTransformData.removeRepeatItems();
                    for (var _i = 0, _a = _this.jointNames; _i < _a.length; _i++) {
                        var name_2 = _a[_i];
                        if (!jointNamesUsedInJointTransformData.hasChild(name_2)) {
                            wd.Log.warn("joint:" + name_2 + " is not used in jointTransformData");
                        }
                    }
                }, this);
            })
        ], SkinSkeletonAnimation.prototype, "createControllerMap", null);
        return SkinSkeletonAnimation;
    }(wd.MultiLayerKeyFrameAnimation));
    wd.SkinSkeletonAnimation = SkinSkeletonAnimation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ArticulatedAnimation = (function (_super) {
        __extends(ArticulatedAnimation, _super);
        function ArticulatedAnimation() {
            _super.apply(this, arguments);
            this.data = null;
            this._controller = this.createController();
        }
        ArticulatedAnimation.prototype.init = function () {
            this._controller.entityObject = this.entityObject;
        };
        ArticulatedAnimation.prototype.dispose = function () {
        };
        ArticulatedAnimation.prototype.play = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._controller.resetAnim();
            this.pauseDuration = 0;
            if (wd.JudgeUtils.isNumber(args[0])) {
                var animIndex_2 = args[0], i_2 = 0, self_6 = this;
                this.data.forEach(function (data, animName) {
                    if (animIndex_2 === i_2) {
                        self_6._controller.setCurrentAnimData(animName, data);
                        return wdCb.$BREAK;
                    }
                    i_2++;
                });
            }
            else if (wd.JudgeUtils.isString(args[0])) {
                var animName = args[0];
                this._controller.setCurrentAnimData(animName, this.data.getChild(animName));
            }
            this._controller.updateCurrentFrameData();
            this._controller.saveZeroTimeFrameData();
            this._controller.setFrameCount();
            this.state = wd.EAnimationState.RUN;
        };
        ArticulatedAnimation.prototype.handleWhenPause = function (elapsed) {
        };
        ArticulatedAnimation.prototype.handleWhenCurrentFrameFinish = function (elapsed) {
            this.isFrameChange = true;
            this._controller.updateFrame(elapsed, this.pauseDuration);
            this._controller.savePrevFrameData();
        };
        ArticulatedAnimation.prototype.handleBeforeJudgeWhetherCurrentFrameFinish = function (elapsed) {
            this._controller.setBeginElapsedTimeOfFirstFrame(this.getCurrentTime());
        };
        ArticulatedAnimation.prototype.isCurrentFrameFinish = function (elapsed) {
            return this._controller.isCurrentFrameFinish(elapsed, this.pauseDuration);
        };
        ArticulatedAnimation.prototype.handleAfterJudgeWhetherCurrentFrameFinish = function (elapsed) {
            this._controller.updateTargets(elapsed, this.pauseDuration);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ArticulatedAnimation.prototype, "data", void 0);
        __decorate([
            wd.require(function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (wd.JudgeUtils.isNumber(args[0])) {
                    var animIndex_3 = args[0];
                    wd.it("should exist animation index:" + animIndex_3, function () {
                        wd.expect(_this.data.getCount()).greaterThan(animIndex_3);
                    });
                }
                else if (wd.JudgeUtils.isString(args[0])) {
                    var animName_2 = args[0];
                    wd.it("should exist animation name:" + animName_2, function () {
                        wd.expect(_this.data.hasChild(animName_2)).true;
                    });
                }
            })
        ], ArticulatedAnimation.prototype, "play", null);
        return ArticulatedAnimation;
    }(wd.SingleLayerKeyFrameAnimation));
    wd.ArticulatedAnimation = ArticulatedAnimation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TransformArticulatedAnimation = (function (_super) {
        __extends(TransformArticulatedAnimation, _super);
        function TransformArticulatedAnimation() {
            _super.apply(this, arguments);
        }
        TransformArticulatedAnimation.create = function () {
            var obj = new this();
            return obj;
        };
        TransformArticulatedAnimation.prototype.createController = function () {
            return wd.TransformArticulatedKeyFrameController.create();
        };
        return TransformArticulatedAnimation;
    }(wd.ArticulatedAnimation));
    wd.TransformArticulatedAnimation = TransformArticulatedAnimation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TextureArticulatedAnimation = (function (_super) {
        __extends(TextureArticulatedAnimation, _super);
        function TextureArticulatedAnimation() {
            _super.apply(this, arguments);
        }
        TextureArticulatedAnimation.create = function () {
            var obj = new this();
            return obj;
        };
        TextureArticulatedAnimation.prototype.createController = function () {
            return wd.TextureArticulatedKeyFrameController.create();
        };
        return TextureArticulatedAnimation;
    }(wd.ArticulatedAnimation));
    wd.TextureArticulatedAnimation = TextureArticulatedAnimation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BoneMatrix = (function () {
        function BoneMatrix(localMatrix) {
            this._localMatrix = null;
            this._globalMatrix = null;
            this._parent = null;
            this.dirtyLocal = true;
            this.dirtyGlobal = null;
            this._children = wdCb.Collection.create();
            this._localMatrix = localMatrix;
        }
        BoneMatrix.create = function (localMatrix) {
            var obj = new this(localMatrix);
            return obj;
        };
        Object.defineProperty(BoneMatrix.prototype, "localMatrix", {
            get: function () {
                return this._localMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoneMatrix.prototype, "globalMatrix", {
            get: function () {
                if (this.dirtyLocal) {
                    this.dirtyLocal = false;
                    this.dirtyGlobal = true;
                }
                if (this.dirtyGlobal) {
                    if (this.parent === null) {
                        this._globalMatrix = this._localMatrix;
                    }
                    else {
                        this._globalMatrix = this._localMatrix.applyMatrix(this.parent.globalMatrix, true);
                    }
                    this.dirtyGlobal = false;
                    this._children.forEach(function (child) {
                        child.dirtyGlobal = true;
                    });
                }
                return this._globalMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BoneMatrix.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== null) {
                    this._parent.removeChild(this);
                }
                if (!parent) {
                    this._parent = null;
                    return;
                }
                this._parent = parent;
                this._parent.addChild(this);
            },
            enumerable: true,
            configurable: true
        });
        BoneMatrix.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        BoneMatrix.prototype.updateLocalMatrix = function (localMatrix) {
            this._localMatrix = localMatrix;
            this.dirtyLocal = true;
        };
        BoneMatrix.prototype.removeChild = function (boneMat) {
            this._children.removeChild(boneMat);
        };
        BoneMatrix.prototype.addChild = function (boneMat) {
            this._children.addChild(boneMat);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BoneMatrix.prototype, "_localMatrix", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BoneMatrix.prototype, "parent", null);
        return BoneMatrix;
    }());
    wd.BoneMatrix = BoneMatrix;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LayerKeyFrameController = (function () {
        function LayerKeyFrameController() {
            this._isFinishAnimation = false;
            this.isPlayed = false;
            this.startFrameDataMap = wdCb.Hash.create();
            this.currentAnimData = null;
            this.currentFrameData = null;
            this._frameCount = null;
            this._currentAnimName = null;
            this._currentFrame = null;
            this._beginElapsedTimeOfFirstFrame = null;
            this._prevFrameTime = null;
            this._prevFrameData = null;
        }
        Object.defineProperty(LayerKeyFrameController.prototype, "isFinishAnimation", {
            get: function () {
                if (!this.isPlayed) {
                    return true;
                }
                return this._isFinishAnimation;
            },
            set: function (isFinishAnimation) {
                this._isFinishAnimation = isFinishAnimation;
            },
            enumerable: true,
            configurable: true
        });
        LayerKeyFrameController.prototype.setCurrentAnimData = function (animName, data) {
            this._currentAnimName = animName;
            this.currentAnimData = data;
        };
        LayerKeyFrameController.prototype.updateCurrentFrameData = function () {
            this.currentFrameData = this.currentAnimData.getChild(this._currentFrame);
        };
        LayerKeyFrameController.prototype.hasCurrentAnimData = function () {
            return this.currentAnimData !== null;
        };
        LayerKeyFrameController.prototype.setBeginElapsedTimeOfFirstFrame = function (currentTime) {
            if (this._beginElapsedTimeOfFirstFrame === null) {
                this._beginElapsedTimeOfFirstFrame = currentTime;
            }
        };
        LayerKeyFrameController.prototype.savePrevFrameData = function () {
            this.saveStartFrameData(this._prevFrameData);
        };
        LayerKeyFrameController.prototype.resetAnim = function () {
            this._beginElapsedTimeOfFirstFrame = null;
            this._prevFrameTime = 0;
            this._currentFrame = 0;
            this.currentAnimData = null;
            this.currentFrameData = null;
            this.isFinishAnimation = false;
            this._prevFrameData = null;
            this.startFrameDataMap.removeAllChildren();
        };
        LayerKeyFrameController.prototype.setFrameCount = function () {
            this._frameCount = this.currentAnimData.getCount();
        };
        LayerKeyFrameController.prototype.updateFrame = function (elapsed, pauseDuration) {
            this._updateCurrentFrameIndex(elapsed, pauseDuration);
            if (this._isFinishAllFrames()) {
                this._currentFrame = 0;
                this._beginElapsedTimeOfFirstFrame = this._getBeginElapsedTimeOfFirstFrameWhenFinishAllFrames(elapsed);
                this._prevFrameTime = 0;
                this._prevFrameData = this.currentAnimData.getChild(this._frameCount - 1);
                this.updateCurrentFrameData();
                this.isFinishAnimation = true;
            }
            else {
                this._prevFrameTime = this.currentAnimData.getChild(this._currentFrame - 1).time;
            }
        };
        LayerKeyFrameController.prototype.isCurrentFrameFinish = function (elapsed, pauseDuration) {
            return elapsed - this._beginElapsedTimeOfFirstFrame - pauseDuration > this.currentFrameData.time;
        };
        LayerKeyFrameController.prototype.saveStartFrameData = function (frameData) {
            var startFrameDataMap = this.startFrameDataMap;
            frameData.targets.forEach(function (target) {
                startFrameDataMap.addChild(target.target, target.data);
            });
        };
        LayerKeyFrameController.prototype.computeInterpolation = function (elapsed, pauseDuration, interpolationMethod) {
            var interpolation = null;
            switch (interpolationMethod) {
                case wd.EKeyFrameInterpolation.LINEAR:
                    if (this.currentFrameData.time - this._prevFrameTime === 0) {
                        interpolation = 1;
                    }
                    else {
                        interpolation = (elapsed - this._beginElapsedTimeOfFirstFrame - pauseDuration - this._prevFrameTime) / (this.currentFrameData.time - this._prevFrameTime);
                    }
                    break;
                case wd.EKeyFrameInterpolation.SWITCH:
                    if (this.currentFrameData.time - this._prevFrameTime === 0) {
                        interpolation = 1;
                    }
                    else {
                        interpolation = 0;
                    }
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("interpolationMethod:" + interpolationMethod));
                    break;
            }
            return interpolation;
        };
        LayerKeyFrameController.prototype._getBeginElapsedTimeOfFirstFrameWhenFinishAllFrames = function (elapsed) {
            return elapsed;
        };
        LayerKeyFrameController.prototype._isFinishAllFrames = function () {
            return this._currentFrame >= this._frameCount;
        };
        LayerKeyFrameController.prototype._updateCurrentFrameIndex = function (elapsed, pauseDuration) {
            do {
                this._currentFrame++;
                this._prevFrameData = this.currentFrameData;
                this.updateCurrentFrameData();
            } while (!this._isFinishAllFrames() && this.isCurrentFrameFinish(elapsed, pauseDuration));
        };
        LayerKeyFrameController.prototype._judgeBeginElapsedTime = function (elapsed, isFirstUpdateAttributeName) {
            var _this = this;
            wd.it("the _beginElapsedTime should === elapsed at the first time of the update", function () {
                if (_this[isFirstUpdateAttributeName]) {
                    wd.expect(elapsed).equals(_this._beginElapsedTimeOfFirstFrame);
                    _this[isFirstUpdateAttributeName] = false;
                }
            }, this);
        };
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("should exist animation name:" + this.currentAnimName, function () {
                    wd.expect(_this.currentAnimData).exist;
                });
                this.currentAnimData.forEach(function (data) {
                    wd.it("time should >= 0", function () {
                        wd.expect(data.time).gte(0);
                    });
                    wd.it("KeyFrameAnimationFrameData->targets.getCount() should > 0", function () {
                        wd.expect(data.targets.getCount()).greaterThan(0);
                    });
                    data.targets.forEach(function (target) {
                        var data = target.data;
                        switch (target.target) {
                            case wd.EKeyFrameAnimationTarget.TRANSLATION:
                                wd.it("if target:EKeyFrameAnimationTarget === TRANSLATION, its data must be Vector3", function () {
                                    wd.expect(data).instanceof(wd.Vector3);
                                });
                                break;
                            case wd.EKeyFrameAnimationTarget.ROTATION:
                                wd.it("if target:EKeyFrameAnimationTarget === ROTATION, its data must be Vector3", function () {
                                    wd.expect(data).instanceof(wd.Quaternion);
                                });
                                break;
                            case wd.EKeyFrameAnimationTarget.SCALE:
                                wd.it("if target:EKeyFrameAnimationTarget === SCALE, its data must be Vector3", function () {
                                    wd.expect(data).instanceof(wd.Vector3);
                                });
                                break;
                            case wd.EKeyFrameAnimationTarget.TEXTURE_OFFSET:
                                wd.it("if target:EKeyFrameAnimationTarget === TEXTURE_OFFSET, its data must be Array", function () {
                                    wd.expect(data).be.a("array");
                                });
                                break;
                            default:
                                wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("EKeyFrameAnimationTarget:" + target.target));
                                break;
                        }
                    });
                });
            })
        ], LayerKeyFrameController.prototype, "setCurrentAnimData", null);
        __decorate([
            wd.require(function (elapsed, pauseDuration) {
                var _this = this;
                this._judgeBeginElapsedTime(elapsed, "_contract_isFirstUpdate1");
                wd.it("elapsed of current frame:" + (elapsed - this._beginElapsedTimeOfFirstFrame - pauseDuration) + " should >= 0", function () {
                    wd.expect(elapsed - _this._beginElapsedTimeOfFirstFrame - pauseDuration).gte(0);
                });
            })
        ], LayerKeyFrameController.prototype, "isCurrentFrameFinish", null);
        __decorate([
            wd.require(function (frameData) {
                var _this = this;
                wd.it("should set currentFrameData", function () {
                    wd.expect(_this.currentFrameData).not.null;
                });
                this.currentFrameData.targets.forEach(function (currentTarget, index) {
                    wd.it("the current frame and the start frame should modify the same targets", function () {
                        wd.expect(frameData.targets.getChild(index).target === currentTarget.target).true;
                    });
                });
            })
        ], LayerKeyFrameController.prototype, "saveStartFrameData", null);
        __decorate([
            wd.require(function (elapsed, pauseDuration, interpolationMethod) {
                this._judgeBeginElapsedTime(elapsed, "_contract_isFirstUpdate2");
            }),
            wd.ensure(function (interpolation, elapsed, interpolationMethod) {
                wd.it("interpolation:" + interpolation + " >= 0 && <= 1", function () {
                    wd.expect(interpolation >= 0 && interpolation <= 1).true;
                });
            })
        ], LayerKeyFrameController.prototype, "computeInterpolation", null);
        __decorate([
            wd.require(function (elapsed) {
                var lastEndFrameTime = this.currentAnimData.getChild(this._frameCount - 1).time;
                wd.it("elapsed:" + elapsed + " should >= lastEndFrameTime:" + lastEndFrameTime, function () {
                    wd.expect(elapsed).gte(lastEndFrameTime);
                });
            })
        ], LayerKeyFrameController.prototype, "_getBeginElapsedTimeOfFirstFrameWhenFinishAllFrames", null);
        return LayerKeyFrameController;
    }());
    wd.LayerKeyFrameController = LayerKeyFrameController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var JointKeyFrameController = (function (_super) {
        __extends(JointKeyFrameController, _super);
        function JointKeyFrameController() {
            _super.apply(this, arguments);
            this.currentUpdatedTransformMatrix = wd.Matrix4.create();
            this.jointName = null;
        }
        JointKeyFrameController.create = function () {
            var obj = new this();
            return obj;
        };
        JointKeyFrameController.prototype.saveZeroTimeFrameData = function () {
            this.saveStartFrameData(this.currentAnimData.getChild(0));
        };
        JointKeyFrameController.prototype.getFirstFrameTime = function () {
            return this.currentAnimData.getChild(0).time;
        };
        JointKeyFrameController.prototype.addBoneMatrixAsTheFirstFrameWhoseTimeIsZero = function (boneMatrix) {
            var localMatrix = boneMatrix.localMatrix, currentFirstFrame = this.currentAnimData.getChild(0), targets = wdCb.Collection.create(), newFirstFrame = {
                time: 0,
                targets: targets
            };
            currentFirstFrame.targets.forEach(function (data) {
                switch (data.target) {
                    case wd.EKeyFrameAnimationTarget.TRANSLATION:
                        targets.addChild({
                            interpolationMethod: wd.EKeyFrameInterpolation.LINEAR,
                            target: wd.EKeyFrameAnimationTarget.TRANSLATION,
                            data: localMatrix.getTranslation()
                        });
                        break;
                    case wd.EKeyFrameAnimationTarget.ROTATION:
                        targets.addChild({
                            interpolationMethod: wd.EKeyFrameInterpolation.LINEAR,
                            target: wd.EKeyFrameAnimationTarget.ROTATION,
                            data: localMatrix.getRotation()
                        });
                        break;
                    case wd.EKeyFrameAnimationTarget.SCALE:
                        targets.addChild({
                            interpolationMethod: wd.EKeyFrameInterpolation.LINEAR,
                            target: wd.EKeyFrameAnimationTarget.SCALE,
                            data: localMatrix.getScale()
                        });
                        break;
                    default:
                        break;
                }
            });
            this.currentAnimData.unShiftChild(newFirstFrame);
        };
        JointKeyFrameController.prototype.updateTargets = function (elapsed, pauseDuration) {
            var self = this, startFrameDataMap = this.startFrameDataMap, position = wd.GlobalTempMathClass.Vector3_1, rotation = wd.GlobalTempMathClass.Quaternion_1, scale = wd.GlobalTempMathClass.Vector3_Scale_1;
            this.currentFrameData.targets.forEach(function (target) {
                var endFrameData = target.data, startFrameData = startFrameDataMap.getChild(target.target), interpolation = self.computeInterpolation(elapsed, pauseDuration, target.interpolationMethod);
                switch (target.target) {
                    case wd.EKeyFrameAnimationTarget.TRANSLATION:
                        position = position.clone().lerp(startFrameData, endFrameData, interpolation);
                        break;
                    case wd.EKeyFrameAnimationTarget.ROTATION:
                        rotation = rotation.clone().slerp(startFrameData, endFrameData, interpolation);
                        break;
                    case wd.EKeyFrameAnimationTarget.SCALE:
                        scale = scale.clone().lerp(startFrameData, endFrameData, interpolation);
                        break;
                    default:
                        break;
                }
            });
            this.currentUpdatedTransformMatrix.setTRS(position, rotation, scale);
        };
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("first animation data->time should === 0", function () {
                    wd.expect(_this.currentAnimData.getChild(0).time).equals(0);
                }, this);
            })
        ], JointKeyFrameController.prototype, "saveZeroTimeFrameData", null);
        return JointKeyFrameController;
    }(wd.LayerKeyFrameController));
    wd.JointKeyFrameController = JointKeyFrameController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ArticulatedKeyFrameController = (function (_super) {
        __extends(ArticulatedKeyFrameController, _super);
        function ArticulatedKeyFrameController() {
            _super.apply(this, arguments);
            this.entityObject = null;
        }
        ArticulatedKeyFrameController.prototype.saveZeroTimeFrameData = function () {
            var firstAnimData = this.currentAnimData.getChild(0);
            if (firstAnimData.time === 0) {
                this.saveStartFrameData(firstAnimData);
            }
        };
        ArticulatedKeyFrameController.prototype.updateTargets = function (elapsed, pauseDuration) {
            var self = this, startFrameDataMap = this.startFrameDataMap;
            this.currentFrameData.targets.forEach(function (target) {
                var endFrameData = target.data, startFrameData = startFrameDataMap.getChild(target.target), interpolation = self.computeInterpolation(elapsed, pauseDuration, target.interpolationMethod);
                self.updateTarget(target, startFrameData, endFrameData, interpolation);
            });
        };
        return ArticulatedKeyFrameController;
    }(wd.LayerKeyFrameController));
    wd.ArticulatedKeyFrameController = ArticulatedKeyFrameController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TransformArticulatedKeyFrameController = (function (_super) {
        __extends(TransformArticulatedKeyFrameController, _super);
        function TransformArticulatedKeyFrameController() {
            _super.apply(this, arguments);
        }
        TransformArticulatedKeyFrameController.create = function () {
            var obj = new this();
            return obj;
        };
        TransformArticulatedKeyFrameController.prototype.updateTarget = function (target, startFrameData, endFrameData, interpolation) {
            var transform = this.entityObject.transform;
            switch (target.target) {
                case wd.EKeyFrameAnimationTarget.TRANSLATION:
                    if (!startFrameData) {
                        startFrameData = transform.localPosition;
                    }
                    transform.localPosition = wd.Vector3.create().lerp(startFrameData, endFrameData, interpolation);
                    break;
                case wd.EKeyFrameAnimationTarget.ROTATION:
                    if (!startFrameData) {
                        startFrameData = transform.localRotation;
                    }
                    transform.localRotation = wd.Quaternion.create().slerp(startFrameData, endFrameData, interpolation);
                    break;
                case wd.EKeyFrameAnimationTarget.SCALE:
                    if (!startFrameData) {
                        startFrameData = transform.localScale;
                    }
                    transform.localScale = wd.Vector3.create().lerp(startFrameData, endFrameData, interpolation);
                    break;
                default:
                    break;
            }
        };
        __decorate([
            wd.require(function (target, startFrameData, endFrameData, interpolation) {
                wd.it("transform animation->interpolationMethod shouldn't be SWITCH", function () {
                    switch (target.target) {
                        case wd.EKeyFrameAnimationTarget.TRANSLATION:
                        case wd.EKeyFrameAnimationTarget.ROTATION:
                        case wd.EKeyFrameAnimationTarget.SCALE:
                            wd.expect(target.interpolationMethod).not.equals(wd.EKeyFrameInterpolation.SWITCH);
                            break;
                    }
                });
            })
        ], TransformArticulatedKeyFrameController.prototype, "updateTarget", null);
        return TransformArticulatedKeyFrameController;
    }(wd.ArticulatedKeyFrameController));
    wd.TransformArticulatedKeyFrameController = TransformArticulatedKeyFrameController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TextureArticulatedKeyFrameController = (function (_super) {
        __extends(TextureArticulatedKeyFrameController, _super);
        function TextureArticulatedKeyFrameController() {
            _super.apply(this, arguments);
        }
        TextureArticulatedKeyFrameController.create = function () {
            var obj = new this();
            return obj;
        };
        TextureArticulatedKeyFrameController.prototype.updateTarget = function (target, startFrameData, endFrameData, interpolation) {
            switch (target.target) {
                case wd.EKeyFrameAnimationTarget.TEXTURE_OFFSET:
                    this._updateTextureData(target, startFrameData, endFrameData, interpolation);
                    break;
                default:
                    break;
            }
        };
        TextureArticulatedKeyFrameController.prototype._updateTextureData = function (target, startFrameData, endFrameData, interpolation) {
            var material = this.entityObject.getComponent(wd.Geometry).material, mapName = target.extra.target, map = material[mapName];
            if (!!map) {
                var frameData = null;
                if (interpolation === 0) {
                    frameData = startFrameData;
                }
                else {
                    frameData = endFrameData;
                }
                if (!!frameData) {
                    map.sourceRegion = wd.RectRegion.create(frameData[0], frameData[1], frameData[2], frameData[3]);
                }
            }
        };
        __decorate([
            wd.require(function (target, startFrameData, endFrameData, interpolation) {
                wd.it("texture animation->interpolationMethod should be SWITCH", function () {
                    wd.expect(target.interpolationMethod).equals(wd.EKeyFrameInterpolation.SWITCH);
                });
            })
        ], TextureArticulatedKeyFrameController.prototype, "updateTarget", null);
        __decorate([
            wd.require(function (target, startFrameData, endFrameData, interpolation) {
                var _this = this;
                wd.it("material should has the corresponding animated texture", function () {
                    wd.expect(_this.entityObject.getGeometry().material[target.extra.target]).exist;
                }, this);
                wd.it("this animated texture should has 'sourceRegion' attribute", function () {
                    wd.expect(_this.entityObject.getGeometry().material[target.extra.target].sourceRegion).not.be.a("undefined");
                }, this);
                wd.it("intergration should be 0 or 1", function () {
                    wd.expect(interpolation === 0 || interpolation === 1).true;
                });
            })
        ], TextureArticulatedKeyFrameController.prototype, "_updateTextureData", null);
        return TextureArticulatedKeyFrameController;
    }(wd.ArticulatedKeyFrameController));
    wd.TextureArticulatedKeyFrameController = TextureArticulatedKeyFrameController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Billboard = (function (_super) {
        __extends(Billboard, _super);
        function Billboard() {
            _super.apply(this, arguments);
            this.mode = wd.EBillboardMode.ALL;
        }
        Billboard.create = function () {
            var obj = new this();
            return obj;
        };
        Billboard.prototype.addToComponentContainer = function () {
            var container = wd.BillboardComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        Billboard.prototype.removeFromComponentContainer = function () {
            wd.BillboardComponentContainer.getInstance().removeChild(this);
        };
        Billboard.prototype.update = function (elapsed) {
            var camera = wd.Director.getInstance().scene.currentCamera;
            if (this.mode !== wd.EBillboardMode.NONE && camera) {
                var objToCamProj = wd.Vector3.create(), objTransform = this.entityObject.transform, objPos = objTransform.position, cameraPos = camera.transform.position, isRotateAroundYAxis = null;
                isRotateAroundYAxis = this._rotateByYAxis(camera, objToCamProj, cameraPos, objPos, objTransform);
                if (this.mode === wd.EBillboardMode.ALL && isRotateAroundYAxis) {
                    this._rotateLocalByXAxis(camera, objToCamProj, cameraPos, objPos, objTransform);
                }
            }
        };
        Billboard.prototype._rotateByYAxis = function (camera, objToCamProj, cameraPos, objPos, objTransform) {
            var lookAt = wd.Vector3.create(), upAux = wd.Vector3.create(), angleCosine = null, isRotateAroundYAxis = false;
            objToCamProj.x = cameraPos.x - objPos.x;
            objToCamProj.y = 0;
            objToCamProj.z = cameraPos.z - objPos.z;
            lookAt.x = 0;
            lookAt.y = 0;
            lookAt.z = 1;
            objToCamProj.normalize();
            upAux.cross(lookAt, objToCamProj);
            angleCosine = lookAt.dot(objToCamProj);
            if ((angleCosine < 0.9999) && (angleCosine > -0.9999)) {
                isRotateAroundYAxis = true;
                objTransform.rotation = wd.Quaternion.create().setFromAxisAngle(Math.acos(angleCosine) * 180 / Math.PI, upAux);
            }
            return isRotateAroundYAxis;
        };
        Billboard.prototype._rotateLocalByXAxis = function (camera, objToCamProj, cameraPos, objPos, objTransform) {
            var objToCam = wd.Vector3.create(), angleCosine = null;
            objToCam.x = cameraPos.x - objPos.x;
            objToCam.y = cameraPos.y - objPos.y;
            objToCam.z = cameraPos.z - objPos.z;
            objToCam.normalize();
            angleCosine = objToCamProj.dot(objToCam);
            if ((angleCosine < 0.9999) && (angleCosine > -0.9999))
                if (objToCam.y < 0) {
                    objTransform.rotateLocal(Math.acos(angleCosine) * 180 / Math.PI, 0, 0);
                }
                else {
                    objTransform.rotateLocal(-Math.acos(angleCosine) * 180 / Math.PI, 0, 0);
                }
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Billboard.prototype, "mode", void 0);
        return Billboard;
    }(wd.Component));
    wd.Billboard = Billboard;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EBillboardMode) {
        EBillboardMode[EBillboardMode["NONE"] = 0] = "NONE";
        EBillboardMode[EBillboardMode["Y"] = 1] = "Y";
        EBillboardMode[EBillboardMode["ALL"] = 2] = "ALL";
    })(wd.EBillboardMode || (wd.EBillboardMode = {}));
    var EBillboardMode = wd.EBillboardMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LOD = (function (_super) {
        __extends(LOD, _super);
        function LOD() {
            _super.apply(this, arguments);
        }
        LOD.prototype.addToComponentContainer = function () {
            var container = wd.LODComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        LOD.prototype.removeFromComponentContainer = function () {
            wd.LODComponentContainer.getInstance().removeChild(this);
        };
        return LOD;
    }(wd.Component));
    wd.LOD = LOD;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GeometryLOD = (function (_super) {
        __extends(GeometryLOD, _super);
        function GeometryLOD() {
            _super.apply(this, arguments);
            this.activeGeometry = null;
            this._levelList = wdCb.Collection.create();
            this._originGeometry = null;
        }
        GeometryLOD.create = function () {
            var obj = new this();
            return obj;
        };
        GeometryLOD.prototype.init = function () {
            var entityObject = this.entityObject;
            this.activeGeometry = entityObject.getComponent(wd.Geometry);
            this._originGeometry = this.activeGeometry;
            this._levelList
                .filter(function (_a) {
                var geometry = _a.geometry, distanceBetweenCameraAndObject = _a.distanceBetweenCameraAndObject;
                return geometry !== wd.ELODState.INVISIBLE;
            })
                .forEach(function (_a) {
                var geometry = _a.geometry, distanceBetweenCameraAndObject = _a.distanceBetweenCameraAndObject;
                geometry.entityObject = entityObject;
                geometry.init();
                geometry.createBuffersFromGeometryData();
            });
            _super.prototype.init.call(this);
        };
        GeometryLOD.prototype.addLevel = function (distanceBetweenCameraAndObject, geometryLevel) {
            this._levelList.addChild({
                distanceBetweenCameraAndObject: distanceBetweenCameraAndObject,
                geometry: geometryLevel
            });
            this._levelList.sort(function (levelData1, levelData2) {
                return levelData2.distanceBetweenCameraAndObject - levelData1.distanceBetweenCameraAndObject;
            }, true);
        };
        GeometryLOD.prototype.update = function (elapsed) {
            var currentDistanceBetweenCameraAndObject = wd.Vector3.create().sub2(wd.Director.getInstance().scene.currentCamera.transform.position, this.entityObject.transform.position).length(), useOriginGeometry = true, activeGeometry = null;
            this._levelList.forEach(function (_a) {
                var geometry = _a.geometry, distanceBetweenCameraAndObject = _a.distanceBetweenCameraAndObject;
                if (currentDistanceBetweenCameraAndObject >= distanceBetweenCameraAndObject) {
                    activeGeometry = geometry;
                    useOriginGeometry = false;
                    return wdCb.$BREAK;
                }
            });
            if (activeGeometry === wd.ELODState.INVISIBLE) {
                this.activeGeometry = null;
                this.entityObject.isVisible = false;
                return;
            }
            this.entityObject.isVisible = true;
            if (activeGeometry && !wd.JudgeUtils.isEqual(activeGeometry, this.activeGeometry)) {
                this.activeGeometry = activeGeometry;
                wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.COMPONENT_CHANGE));
            }
            else if (useOriginGeometry) {
                this.activeGeometry = this._originGeometry;
            }
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName, isShareGeometry) {
                source._levelList.forEach(function (levelData) {
                    var levelDataGeometry = null;
                    if (levelData.geometry === wd.ELODState.INVISIBLE) {
                        levelDataGeometry = wd.ELODState.INVISIBLE;
                    }
                    else if (isShareGeometry) {
                        levelDataGeometry = levelData.geometry;
                    }
                    else {
                        levelDataGeometry = levelData.geometry.clone();
                    }
                    target.addLevel(levelData.distanceBetweenCameraAndObject, levelDataGeometry);
                });
            })
        ], GeometryLOD.prototype, "_levelList", void 0);
        __decorate([
            wd.require(function () {
                if (wd.InstanceUtils.isHardwareSupport()) {
                    wd.assert(!wd.InstanceUtils.isObjectInstance(this.entityObject), wd.Log.info.FUNC_SHOULD_NOT("if hardware support instance, object instance", "add lod component"));
                }
            })
        ], GeometryLOD.prototype, "update", null);
        return GeometryLOD;
    }(wd.LOD));
    wd.GeometryLOD = GeometryLOD;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GameObjectLOD = (function (_super) {
        __extends(GameObjectLOD, _super);
        function GameObjectLOD() {
            _super.apply(this, arguments);
            this.activeGameObject = null;
            this.defaultGameObjectSwitchHandler = function (gameObject) { };
            this._levelList = wdCb.Collection.create();
            this._lastActiveGameObject = null;
            this._lastNotNullActiveGameObject = null;
        }
        GameObjectLOD.create = function () {
            var obj = new this();
            return obj;
        };
        GameObjectLOD.prototype.init = function () {
            var entityObject = this.entityObject;
            this.activeGameObject = entityObject;
            this._lastNotNullActiveGameObject = this.activeGameObject;
            this._levelList
                .filter(function (_a) {
                var gameObject = _a.gameObject, distanceBetweenCameraAndObject = _a.distanceBetweenCameraAndObject;
                return gameObject !== wd.ELODState.INVISIBLE;
            })
                .forEach(function (_a) {
                var gameObject = _a.gameObject, distanceBetweenCameraAndObject = _a.distanceBetweenCameraAndObject;
                gameObject.isVisible = false;
                entityObject.addChild(gameObject);
            });
            _super.prototype.init.call(this);
        };
        GameObjectLOD.prototype.addLevel = function (distanceBetweenCameraAndObject, gameObjectLevel, switchHandler) {
            if (switchHandler === void 0) { switchHandler = function (gameObject) { }; }
            this._levelList.addChild({
                distanceBetweenCameraAndObject: distanceBetweenCameraAndObject,
                gameObject: gameObjectLevel,
                switchHandler: switchHandler
            });
            this._levelList.sort(function (levelData1, levelData2) {
                return levelData2.distanceBetweenCameraAndObject - levelData1.distanceBetweenCameraAndObject;
            }, true);
        };
        GameObjectLOD.prototype.update = function (elapsed) {
            var _this = this;
            var currentCameraPos = wd.Director.getInstance().scene.currentCamera.transform.position, activeGameObject = null, switchHandler = null;
            if (this.activeGameObject !== null) {
                this.activeGameObject.isVisible = false;
            }
            this._levelList
                .forEach(function (levelData) {
                if (_this._computeCurrentDistanceBetweenCameraAndObject(currentCameraPos, levelData.gameObject) >= levelData.distanceBetweenCameraAndObject) {
                    activeGameObject = levelData.gameObject;
                    switchHandler = levelData.switchHandler;
                    return wdCb.$BREAK;
                }
            }, this);
            if (activeGameObject === wd.ELODState.INVISIBLE) {
                if (this.activeGameObject !== null) {
                    this._lastNotNullActiveGameObject = this.activeGameObject;
                }
                this.activeGameObject = null;
                return;
            }
            if (activeGameObject === null) {
                this.activeGameObject = this.entityObject;
                this.activeGameObject.isVisible = true;
                if (this._isSwitch()) {
                    this.defaultGameObjectSwitchHandler(this.entityObject);
                }
            }
            else {
                this.activeGameObject = activeGameObject;
                this.activeGameObject.isVisible = true;
                if (this._isSwitch()) {
                    switchHandler(this.activeGameObject);
                }
            }
            this._lastActiveGameObject = this.activeGameObject;
        };
        GameObjectLOD.prototype._computeCurrentDistanceBetweenCameraAndObject = function (currentCameraPos, gameObject) {
            var targetGameObject = null;
            if (gameObject === wd.ELODState.INVISIBLE) {
                targetGameObject = this._lastNotNullActiveGameObject;
            }
            else {
                targetGameObject = gameObject;
            }
            return wd.Vector3.create().sub2(currentCameraPos, targetGameObject.transform.position).length();
        };
        GameObjectLOD.prototype._isSwitch = function () {
            return !wd.JudgeUtils.isEqual(this.activeGameObject, this._lastActiveGameObject);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GameObjectLOD.prototype, "activeGameObject", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GameObjectLOD.prototype, "defaultGameObjectSwitchHandler", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                source._levelList.forEach(function (levelData) {
                    var gameObjectLevel = null;
                    if (levelData.gameObject === wd.ELODState.INVISIBLE) {
                        gameObjectLevel = wd.ELODState.INVISIBLE;
                    }
                    else {
                        gameObjectLevel = levelData.gameObject.clone();
                    }
                    target.addLevel(levelData.distanceBetweenCameraAndObject, gameObjectLevel, levelData.switchHandler);
                });
            })
        ], GameObjectLOD.prototype, "_levelList", void 0);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("should only activeGameObject is visible while others is not", function () {
                    var activeGameObject = _this.activeGameObject;
                    if (activeGameObject !== null) {
                        wd.expect(activeGameObject.isVisible).true;
                    }
                    _this._levelList.map(function (levelData) {
                        return levelData.gameObject;
                    })
                        .addChild(_this.entityObject)
                        .filter(function (gameObject) {
                        return gameObject !== wd.ELODState.INVISIBLE && !wd.JudgeUtils.isEqual(gameObject, activeGameObject);
                    })
                        .forEach(function (gameObject) {
                        wd.expect(gameObject.isVisible).false;
                    });
                });
            })
        ], GameObjectLOD.prototype, "update", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("_lastNotNullActiveGameObject shouldn't be null", function () {
                    wd.expect(_this._lastNotNullActiveGameObject).not.null;
                }, this);
            })
        ], GameObjectLOD.prototype, "_computeCurrentDistanceBetweenCameraAndObject", null);
        return GameObjectLOD;
    }(wd.LOD));
    wd.GameObjectLOD = GameObjectLOD;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ELODState) {
        ELODState[ELODState["INVISIBLE"] = 0] = "INVISIBLE";
    })(wd.ELODState || (wd.ELODState = {}));
    var ELODState = wd.ELODState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SpacePartition = (function (_super) {
        __extends(SpacePartition, _super);
        function SpacePartition() {
            _super.apply(this, arguments);
            this.isCollideEnable = true;
        }
        SpacePartition.prototype.addToComponentContainer = function () {
            var container = wd.SpacePartitionComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        SpacePartition.prototype.removeFromComponentContainer = function () {
            wd.SpacePartitionComponentContainer.getInstance().removeChild(this);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], SpacePartition.prototype, "isCollideEnable", void 0);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("SpacePartition component should add to GameObject", function () {
                    wd.expect(_this.entityObject).instanceOf(wd.GameObject);
                }, this);
            })
        ], SpacePartition.prototype, "addToComponentContainer", null);
        return SpacePartition;
    }(wd.Component));
    wd.SpacePartition = SpacePartition;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Octree = (function (_super) {
        __extends(Octree, _super);
        function Octree() {
            _super.apply(this, arguments);
            this.maxDepth = 2;
            this.maxNodeCapacity = 64;
            this._root = null;
            this._selectionList = wdCb.Collection.create();
            this._renderListCache = null;
        }
        Octree.create = function () {
            var obj = new this();
            return obj;
        };
        Octree.prototype.init = function () {
            _super.prototype.init.call(this);
        };
        Octree.prototype.update = function (elapsed) {
            this._renderListCache = this._getRenderListForCurrentLoop();
        };
        Octree.prototype.getRenderList = function () {
            return this._renderListCache;
        };
        Octree.prototype.build = function () {
            var gameObjectList = this.getChildren(), currentDepth = 0, maxNodeCapacity = this.maxNodeCapacity, maxDepth = this.maxDepth;
            var buildTree = function (worldMin, worldMax, currentDepth, gameObjectList, parentNode) {
                var halfExtends = new wd.Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
                for (var x = 0; x < 2; x++) {
                    for (var y = 0; y < 2; y++) {
                        for (var z = 0; z < 2; z++) {
                            var localMin = worldMin.clone().add(halfExtends.clone().scale(x, y, z)), localMax = worldMin.clone().add(halfExtends.clone().scale(x + 1, y + 1, z + 1)), node = wd.OctreeNode.create(localMin, localMax, maxNodeCapacity, currentDepth + 1, maxDepth);
                            node.addGameObjects(gameObjectList);
                            if (node.gameObjectCount > maxNodeCapacity && currentDepth < maxDepth) {
                                buildTree(localMin, localMax, currentDepth + 1, gameObjectList, node);
                            }
                            parentNode.addNode(node);
                        }
                    }
                }
            };
            this._updateColliderForFirstCheck(gameObjectList);
            var _a = this._getWorldExtends(gameObjectList), worldMin = _a.worldMin, worldMax = _a.worldMax;
            this._root = wd.OctreeNode.create(worldMin, worldMax, maxNodeCapacity, currentDepth + 1, maxDepth);
            buildTree(worldMin, worldMax, currentDepth, gameObjectList, this._root);
        };
        Octree.prototype.getRenderListByFrustumCull = function () {
            var currentCamera = wd.Director.getInstance().scene.currentCamera;
            if (!currentCamera) {
                return wdCb.Collection.create();
            }
            return this._visitRoot("findAndAddToRenderList", [currentCamera.getComponent(wd.CameraController).getPlanes(), this._selectionList]);
        };
        Octree.prototype.getIntersectListWithRay = function (e) {
            var locationInView = e.locationInView;
            return this._visitRoot("findAndAddToIntersectList", [wd.Director.getInstance().scene.currentCamera.getComponent(wd.CameraController).createRay(locationInView.x, locationInView.y), this._selectionList]);
        };
        Octree.prototype.getCollideObjects = function (shape) {
            return this._visitRoot("findAndAddToCollideList", [shape, this._selectionList]);
        };
        Octree.prototype.getChildren = function () {
            return this.entityObject.getChildren();
        };
        Octree.prototype._visitRoot = function (method, args) {
            this._selectionList.removeAllChildren();
            this._root.nodeList.forEach(function (topNode) {
                topNode[method].apply(topNode, args);
            });
            this._selectionList = this._selectionList.removeRepeatItems();
            return this._selectionList;
        };
        Octree.prototype._updateColliderForFirstCheck = function (gameObjectList) {
            var collider = null, self = this;
            gameObjectList.forEach(function (gameObject) {
                if (!gameObject.hasComponent(wd.ColliderForFirstCheck)) {
                    collider = self._createCollider();
                    gameObject.addComponent(collider);
                    collider.init();
                }
                else {
                    collider = gameObject.getComponent(wd.BoxColliderForFirstCheck);
                }
                collider.update(null);
            });
        };
        Octree.prototype._getWorldExtends = function (gameObjectList) {
            var worldMin = wd.Vector3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), worldMax = wd.Vector3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), self = this;
            gameObjectList.forEach(function (gameObject) {
                var min = null, max = null, collider = null, shape = null;
                collider = gameObject.getComponent(wd.BoxColliderForFirstCheck);
                shape = collider.shape;
                min = shape.getMin();
                max = shape.getMax();
                self._checkExtends(min, worldMin, worldMax);
                self._checkExtends(max, worldMin, worldMax);
            });
            return {
                worldMin: worldMin,
                worldMax: worldMax
            };
        };
        Octree.prototype._createCollider = function () {
            return wd.BoxColliderForFirstCheck.create();
        };
        Octree.prototype._checkExtends = function (v, min, max) {
            if (v.x < min.x) {
                min.x = v.x;
            }
            if (v.y < min.y) {
                min.y = v.y;
            }
            if (v.z < min.z) {
                min.z = v.z;
            }
            if (v.x > max.x) {
                max.x = v.x;
            }
            if (v.y > max.y) {
                max.y = v.y;
            }
            if (v.z > max.z) {
                max.z = v.z;
            }
        };
        Octree.prototype._setToRenderInstanceListOfChildren = function (sourceObject, sourceInstanceComponent) {
            var set = function (sourceObject, sourceInstanceComponent) {
                sourceObject.forEach(function (childSource, index) {
                    var childSourceInstance = childSource.getComponent(wd.OneToOneSourceInstance);
                    sourceInstanceComponent.forEachToRenderInstanceList(function (toRenderInstance) {
                        childSourceInstance.addToRenderIntance(toRenderInstance.getChild(index));
                    });
                    set(childSource, childSourceInstance);
                });
            };
            set(sourceObject, sourceInstanceComponent);
        };
        Octree.prototype._addSelfToToRenderInstanceList = function (self, instanceComponent) {
            instanceComponent.addToRenderIntance(self);
        };
        Octree.prototype._getRenderListForCurrentLoop = function () {
            var _this = this;
            var renderListByFrustumCull = this.getRenderListByFrustumCull(), resultRenderList = wdCb.Collection.create(), instanceSourceMap = wdCb.Hash.create();
            renderListByFrustumCull.forEach(function (gameObject) {
                if (!wd.InstanceUtils.isInstance(gameObject)
                    || wd.InstanceUtils.isOneToManySourceInstance(gameObject)) {
                    resultRenderList.addChild(gameObject);
                    return;
                }
                if (wd.InstanceUtils.isOneToOneSourceInstance(gameObject)) {
                    var instanceComponent = gameObject.getComponent(wd.OneToOneSourceInstance);
                    _this._addSelfToToRenderInstanceList(gameObject, instanceComponent);
                    instanceSourceMap.addChild(String(gameObject.uid), gameObject);
                    return;
                }
                var sourceObject = (gameObject.getComponent(wd.ObjectInstance)).sourceObject, sourceInstanceComponent = sourceObject.getComponent(wd.OneToOneSourceInstance);
                _this._addSelfToToRenderInstanceList(gameObject, sourceInstanceComponent);
                instanceSourceMap.addChild(String(sourceObject.uid), sourceObject);
            }, this);
            instanceSourceMap.forEach(function (sourceObject, uid) {
                var sourceInstanceComponent = sourceObject.getComponent(wd.OneToOneSourceInstance);
                _this._setToRenderInstanceListOfChildren(sourceObject, sourceInstanceComponent);
                resultRenderList.addChild(sourceObject);
            }, this);
            return resultRenderList;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Octree.prototype, "maxDepth", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Octree.prototype, "maxNodeCapacity", void 0);
        __decorate([
            wd.require(function () {
                wd.assert(wd.JudgeUtils.isEqual(this.entityObject.parent, wd.Director.getInstance().scene) && wd.Director.getInstance().scene.gameObjectScene.hasChild(this.entityObject), wd.Log.info.FUNC_SHOULD("be added to the one which is the firstLevel child of gameObjectScene"));
            })
        ], Octree.prototype, "init", null);
        __decorate([
            wd.ensure(function (renderList) {
                wd.assert(!!renderList && renderList instanceof wdCb.Collection, wd.Log.info.FUNC_NOT_EXIST("renderList"));
            })
        ], Octree.prototype, "getRenderList", null);
        __decorate([
            wd.require(function () {
                wd.assert(!!wd.Director.getInstance().scene.currentCamera.getComponent(wd.CameraController), wd.Log.info.FUNC_SHOULD("contain CameraController component"));
            })
        ], Octree.prototype, "getRenderListByFrustumCull", null);
        __decorate([
            wd.require(function (e) {
                wd.assert(!!wd.Director.getInstance().scene.currentCamera.getComponent(wd.CameraController), wd.Log.info.FUNC_SHOULD("contain CameraController component"));
            })
        ], Octree.prototype, "getIntersectListWithRay", null);
        __decorate([
            wd.require(function (sourceObject, sourceInstanceComponent) {
                wd.assert(sourceInstanceComponent.hasToRenderInstance(), wd.Log.info.FUNC_SHOULD("top OneToOneSourceInstance", "has to render instance"));
            })
        ], Octree.prototype, "_setToRenderInstanceListOfChildren", null);
        __decorate([
            wd.require(function (self, instanceComponent) {
                wd.assert(instanceComponent instanceof wd.OneToOneSourceInstance, wd.Log.info.FUNC_ONLY("OneToOneSourceInstance has toRenderList"));
                instanceComponent.forEachToRenderInstanceList(function (instance) {
                    wd.assert(!wd.JudgeUtils.isEqual(instance, self), wd.Log.info.FUNC_SHOULD_NOT("toRenderInstanceList", "contain self"));
                });
            })
        ], Octree.prototype, "_addSelfToToRenderInstanceList", null);
        return Octree;
    }(wd.SpacePartition));
    wd.Octree = Octree;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OctreeNode = (function () {
        function OctreeNode(minPoint, maxPoint, capacity, depth, maxDepth) {
            this.gameObjectList = wdCb.Collection.create();
            this.nodeList = wdCb.Collection.create();
            this._depth = null;
            this._maxDepth = null;
            this._capacity = null;
            this._minPoint = null;
            this._maxPoint = null;
            this._boundingVectors = null;
            this._capacity = capacity;
            this._depth = depth;
            this._maxDepth = maxDepth;
            this._minPoint = minPoint;
            this._maxPoint = maxPoint;
        }
        OctreeNode.create = function (minPoint, maxPoint, capacity, depth, maxDepth) {
            var obj = new this(minPoint, maxPoint, capacity, depth, maxDepth);
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(OctreeNode.prototype, "gameObjectCount", {
            get: function () {
                return this.gameObjectList.getCount();
            },
            enumerable: true,
            configurable: true
        });
        OctreeNode.prototype.initWhenCreate = function () {
            this._boundingVectors = wd.BoundingRegionUtils.buildBoundingVectors(this._minPoint, this._maxPoint);
        };
        OctreeNode.prototype.addGameObjects = function (gameObjectList) {
            var self = this, localMin = this._minPoint, localMax = this._maxPoint;
            gameObjectList.forEach(function (gameObject) {
                if (gameObject.getComponent(wd.BoxColliderForFirstCheck).shape.isIntersectWithBox(localMin, localMax)) {
                    self.gameObjectList.addChild(gameObject);
                }
            });
        };
        OctreeNode.prototype.addNode = function (node) {
            this.nodeList.addChild(node);
        };
        OctreeNode.prototype.findAndAddToRenderList = function (frustumPlanes, selectionList) {
            if (wd.BoundingRegionUtils.isAABBIntersectFrustum(this._boundingVectors, frustumPlanes)) {
                if (this._hasNode()) {
                    this.nodeList.forEach(function (node) {
                        node.findAndAddToRenderList(frustumPlanes, selectionList);
                    });
                    return;
                }
                selectionList.addChildren(wd.RenderUtils.getGameObjectRenderListForOctree(this.gameObjectList));
            }
        };
        OctreeNode.prototype.findAndAddToIntersectList = function (ray, selectionList) {
            if (ray.isIntersectWithAABB(this._minPoint, this._maxPoint)) {
                if (this._hasNode()) {
                    this.nodeList.forEach(function (node) {
                        node.findAndAddToIntersectList(ray, selectionList);
                    });
                    return;
                }
                selectionList.addChildren(this.gameObjectList);
            }
        };
        OctreeNode.prototype.findAndAddToCollideList = function (shape, selectionList) {
            if (shape.isIntersectWithBox(this._minPoint, this._maxPoint)) {
                if (this._hasNode()) {
                    this.nodeList.forEach(function (node) {
                        node.findAndAddToCollideList(shape, selectionList);
                    });
                    return;
                }
                selectionList.addChildren(this.gameObjectList);
            }
        };
        OctreeNode.prototype._hasNode = function () {
            return this.nodeList.getCount() > 0;
        };
        __decorate([
            wd.require(function (gameObjectList) {
                gameObjectList.forEach(function (gameObject) {
                    wd.assert(gameObject instanceof wd.GameObject, wd.Log.info.FUNC_SHOULD("add gameObjects"));
                });
            })
        ], OctreeNode.prototype, "addGameObjects", null);
        return OctreeNode;
    }());
    wd.OctreeNode = OctreeNode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RigidBody = (function (_super) {
        __extends(RigidBody, _super);
        function RigidBody() {
            _super.apply(this, arguments);
            this._friction = 0;
            this._restitution = 0;
            this._children = wdCb.Collection.create();
            this.lockConstraint = wd.LockConstraint.create(this);
            this.distanceConstraint = wd.DistanceConstraint.create(this);
            this.hingeConstraint = wd.HingeConstraint.create(this);
            this.pointToPointConstraintList = wd.PointToPointConstraintList.create(this);
        }
        Object.defineProperty(RigidBody.prototype, "friction", {
            get: function () {
                return this._friction;
            },
            set: function (friction) {
                this._friction = friction;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RigidBody.prototype, "restitution", {
            get: function () {
                return this._restitution;
            },
            set: function (restitution) {
                this._restitution = restitution;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RigidBody.prototype, "children", {
            get: function () {
                return this._children;
            },
            set: function (children) {
                if (wd.JudgeUtils.isArrayExactly(children)) {
                    var arr = children;
                    this._children = wdCb.Collection.create(arr);
                }
                else {
                    var list = children;
                    this._children = list;
                }
                this._children.forEach(function (child) {
                    child.addTag("isRigidbodyChild");
                });
            },
            enumerable: true,
            configurable: true
        });
        RigidBody.prototype.addConstraint = function () {
            var _this = this;
            var engineAdapter = this.getPhysicsComponentContainerAdapter();
            if (this.lockConstraint && this.lockConstraint.connectedBody) {
                engineAdapter.addLockConstraint(this.entityObject, this.lockConstraint);
            }
            if (this.distanceConstraint && this.distanceConstraint.connectedBody) {
                engineAdapter.addDistanceConstraint(this.entityObject, this.distanceConstraint);
            }
            if (this.hingeConstraint && this.hingeConstraint.connectedBody) {
                engineAdapter.addHingeConstraint(this.entityObject, this.hingeConstraint);
            }
            if (this.pointToPointConstraintList && this.pointToPointConstraintList.getCount() > 0) {
                this.pointToPointConstraintList.forEach(function (constraint) {
                    engineAdapter.addPointToPointConstraint(_this.entityObject, constraint);
                }, this);
            }
        };
        RigidBody.prototype.addToComponentContainer = function () {
            var container = wd.PhysicsComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        RigidBody.prototype.removeFromComponentContainer = function () {
            wd.PhysicsComponentContainer.getInstance().removeChild(this);
        };
        RigidBody.prototype.dispose = function () {
            this._children.forEach(function (child) {
                child.removeTag("isRigidbodyChild");
            }, this);
        };
        RigidBody.prototype.getPhysicsComponentContainerAdapter = function () {
            return wd.PhysicsComponentContainer.getInstance().physicsEngineAdapter;
        };
        RigidBody.prototype.initBody = function () {
            this.addBody();
        };
        RigidBody.prototype.initConstraint = function () {
            this.addConstraint();
        };
        RigidBody.prototype.addBodyToPhysicsComponentContainer = function (method, data) {
            if (data === void 0) { data = {}; }
            var engineAdapter = this.getPhysicsComponentContainerAdapter(), position = this.entityObject.transform.position, rotation = this.entityObject.transform.rotation;
            engineAdapter[method](this.entityObject, wdCb.ExtendUtils.extend({
                position: position,
                rotation: rotation,
                children: this._children,
                lockConstraint: this.lockConstraint,
                onContact: wdCb.FunctionUtils.bind(this, this._onContact),
                onCollisionStart: wdCb.FunctionUtils.bind(this, this._onCollisionStart),
                onCollisionEnd: wdCb.FunctionUtils.bind(this, this._onCollisionEnd),
                friction: this.friction,
                restitution: this.restitution
            }, data));
        };
        RigidBody.prototype._onContact = function (collideObject) {
            wd.ScriptComponentContainer.getInstance().execEntityObjectScriptWithData(this.entityObject, "onContact", wdCb.Collection.create([collideObject]));
        };
        RigidBody.prototype._onCollisionStart = function (collideObject) {
            wd.ScriptComponentContainer.getInstance().execEntityObjectScriptWithData(this.entityObject, "onCollisionStart", wdCb.Collection.create([collideObject]));
        };
        RigidBody.prototype._onCollisionEnd = function () {
            wd.ScriptComponentContainer.getInstance().execEntityObjectScript(this.entityObject, "onCollisionEnd");
        };
        RigidBody.prototype._isContainer = function (entityObject) {
            var rigidBody = entityObject.getComponent(RigidBody);
            return rigidBody.children.getCount() > 0;
        };
        __decorate([
            wd.operateBodyDataGetterAndSetter("Friction"),
            wd.cloneAttributeAsBasicType()
        ], RigidBody.prototype, "friction", null);
        __decorate([
            wd.operateBodyDataGetterAndSetter("Restitution"),
            wd.cloneAttributeAsBasicType()
        ], RigidBody.prototype, "restitution", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RigidBody.prototype, "children", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RigidBody.prototype, "lockConstraint", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RigidBody.prototype, "distanceConstraint", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RigidBody.prototype, "hingeConstraint", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RigidBody.prototype, "pointToPointConstraintList", void 0);
        __decorate([
            wd.execOnlyOnce("_initBody")
        ], RigidBody.prototype, "initBody", null);
        __decorate([
            wd.execOnlyOnce("_initConstraint")
        ], RigidBody.prototype, "initConstraint", null);
        __decorate([
            wd.require(function () {
                if (this._isContainer(this.entityObject)) {
                    wd.assert(!this.entityObject.getComponent(wd.Collider), wd.Log.info.FUNC_SHOULD_NOT("container", "add collider component in the case of compound"));
                }
                else {
                    wd.assert(!!this.entityObject.getComponent(wd.Collider), wd.Log.info.FUNC_MUST_DEFINE("collider component when add rigid body component"));
                    wd.assert(!!this.entityObject.getComponent(wd.Collider).shape, wd.Log.info.FUNC_SHOULD("create collider.shape before adding rigid body component"));
                }
            })
        ], RigidBody.prototype, "addBodyToPhysicsComponentContainer", null);
        return RigidBody;
    }(wd.Component));
    wd.RigidBody = RigidBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DynamicRigidBody = (function (_super) {
        __extends(DynamicRigidBody, _super);
        function DynamicRigidBody() {
            _super.apply(this, arguments);
            this._linearDamping = 0;
            this._angularDamping = 0;
            this._velocity = wd.Vector3.create(0, 0, 0);
            this._angularVelocity = wd.Vector3.create(0, 0, 0);
            this._mass = 1;
            this.impulse = null;
            this.force = null;
            this.hitPoint = null;
        }
        DynamicRigidBody.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(DynamicRigidBody.prototype, "linearDamping", {
            get: function () {
                return this._linearDamping;
            },
            set: function (linearDamping) {
                this._linearDamping = linearDamping;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicRigidBody.prototype, "angularDamping", {
            get: function () {
                return this._angularDamping;
            },
            set: function (angularDamping) {
                this._angularDamping = angularDamping;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicRigidBody.prototype, "velocity", {
            get: function () {
                return this._velocity;
            },
            set: function (velocity) {
                this._velocity = velocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicRigidBody.prototype, "angularVelocity", {
            get: function () {
                return this._angularVelocity;
            },
            set: function (angularVelocity) {
                this._angularVelocity = angularVelocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicRigidBody.prototype, "mass", {
            get: function () {
                return this._mass;
            },
            set: function (mass) {
                this._mass = mass;
            },
            enumerable: true,
            configurable: true
        });
        DynamicRigidBody.prototype.addBody = function () {
            this.addBodyToPhysicsComponentContainer("addDynamicBody", {
                mass: this.mass,
                linearDamping: this.linearDamping,
                angularDamping: this.angularDamping,
                velocity: this.velocity,
                angularVelocity: this.angularVelocity,
                impulse: this.impulse,
                force: this.force,
                hitPoint: this.hitPoint
            });
        };
        __decorate([
            wd.operateBodyDataGetterAndSetter("LinearDamping"),
            wd.cloneAttributeAsBasicType()
        ], DynamicRigidBody.prototype, "linearDamping", null);
        __decorate([
            wd.operateBodyDataGetterAndSetter("AngularDamping"),
            wd.cloneAttributeAsBasicType()
        ], DynamicRigidBody.prototype, "angularDamping", null);
        __decorate([
            wd.operateBodyDataGetterAndSetter("Velocity"),
            wd.cloneAttributeAsCloneable()
        ], DynamicRigidBody.prototype, "velocity", null);
        __decorate([
            wd.operateBodyDataGetterAndSetter("AngularVelocity"),
            wd.cloneAttributeAsCloneable()
        ], DynamicRigidBody.prototype, "angularVelocity", null);
        __decorate([
            wd.operateBodyDataGetterAndSetter("Mass"),
            wd.cloneAttributeAsBasicType()
        ], DynamicRigidBody.prototype, "mass", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], DynamicRigidBody.prototype, "impulse", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], DynamicRigidBody.prototype, "force", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], DynamicRigidBody.prototype, "hitPoint", void 0);
        return DynamicRigidBody;
    }(wd.RigidBody));
    wd.DynamicRigidBody = DynamicRigidBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var KinematicRigidBody = (function (_super) {
        __extends(KinematicRigidBody, _super);
        function KinematicRigidBody() {
            _super.apply(this, arguments);
            this._velocity = wd.Vector3.create(0, 0, 0);
            this._angularVelocity = wd.Vector3.create(0, 0, 0);
            this._mass = 1;
        }
        KinematicRigidBody.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(KinematicRigidBody.prototype, "velocity", {
            get: function () {
                return this._velocity;
            },
            set: function (velocity) {
                this._velocity = velocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KinematicRigidBody.prototype, "angularVelocity", {
            get: function () {
                return this._angularVelocity;
            },
            set: function (angularVelocity) {
                this._angularVelocity = angularVelocity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(KinematicRigidBody.prototype, "mass", {
            get: function () {
                return this._mass;
            },
            set: function (mass) {
                this._mass = mass;
            },
            enumerable: true,
            configurable: true
        });
        KinematicRigidBody.prototype.addBody = function () {
            this.addBodyToPhysicsComponentContainer("addKinematicBody", {
                mass: this.mass,
                velocity: this.velocity,
                angularVelocity: this.angularVelocity
            });
        };
        __decorate([
            wd.operateBodyDataGetterAndSetter("Velocity"),
            wd.cloneAttributeAsCloneable()
        ], KinematicRigidBody.prototype, "velocity", null);
        __decorate([
            wd.operateBodyDataGetterAndSetter("AngularVelocity"),
            wd.cloneAttributeAsCloneable()
        ], KinematicRigidBody.prototype, "angularVelocity", null);
        __decorate([
            wd.operateBodyDataGetterAndSetter("Mass"),
            wd.cloneAttributeAsBasicType()
        ], KinematicRigidBody.prototype, "mass", null);
        return KinematicRigidBody;
    }(wd.RigidBody));
    wd.KinematicRigidBody = KinematicRigidBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var StaticRigidBody = (function (_super) {
        __extends(StaticRigidBody, _super);
        function StaticRigidBody() {
            _super.apply(this, arguments);
        }
        StaticRigidBody.create = function () {
            var obj = new this();
            return obj;
        };
        StaticRigidBody.prototype.addBody = function () {
            this.addBodyToPhysicsComponentContainer("addStaticBody");
        };
        return StaticRigidBody;
    }(wd.RigidBody));
    wd.StaticRigidBody = StaticRigidBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PhysicsConstraint = (function () {
        function PhysicsConstraint(rigidBody) {
            this.maxForce = null;
            this.rigidBody = null;
            this.rigidBody = rigidBody;
        }
        PhysicsConstraint.prototype.clone = function (constraint) {
            return wd.CloneUtils.clone(this, null, null, constraint);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PhysicsConstraint.prototype, "maxForce", void 0);
        return PhysicsConstraint;
    }());
    wd.PhysicsConstraint = PhysicsConstraint;
    var LockConstraint = (function (_super) {
        __extends(LockConstraint, _super);
        function LockConstraint() {
            _super.apply(this, arguments);
            this._connectedBody = null;
        }
        LockConstraint.create = function (rigidBody) {
            var obj = new this(rigidBody);
            return obj;
        };
        Object.defineProperty(LockConstraint.prototype, "connectedBody", {
            get: function () {
                return this._connectedBody;
            },
            set: function (connectedBody) {
                var engineAdapter = null;
                this._connectedBody = connectedBody;
                engineAdapter = this.rigidBody.getPhysicsComponentContainerAdapter();
                engineAdapter.removeLockConstraint(this.rigidBody.entityObject);
                this.rigidBody.addConstraint();
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], LockConstraint.prototype, "connectedBody", null);
        return LockConstraint;
    }(PhysicsConstraint));
    wd.LockConstraint = LockConstraint;
    var DistanceConstraint = (function (_super) {
        __extends(DistanceConstraint, _super);
        function DistanceConstraint() {
            _super.apply(this, arguments);
            this._connectedBody = null;
            this.distance = null;
        }
        DistanceConstraint.create = function (rigidBody) {
            var obj = new this(rigidBody);
            return obj;
        };
        Object.defineProperty(DistanceConstraint.prototype, "connectedBody", {
            get: function () {
                return this._connectedBody;
            },
            set: function (connectedBody) {
                var engineAdapter = null;
                this._connectedBody = connectedBody;
                engineAdapter = this.rigidBody.getPhysicsComponentContainerAdapter();
                engineAdapter.removeDistanceConstraint(this.rigidBody.entityObject);
                this.rigidBody.addConstraint();
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DistanceConstraint.prototype, "connectedBody", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DistanceConstraint.prototype, "distance", void 0);
        return DistanceConstraint;
    }(PhysicsConstraint));
    wd.DistanceConstraint = DistanceConstraint;
    var HingeConstraint = (function (_super) {
        __extends(HingeConstraint, _super);
        function HingeConstraint() {
            _super.apply(this, arguments);
            this._connectedBody = null;
            this.pivotA = null;
            this.pivotB = null;
            this.axisA = null;
            this.axisB = null;
        }
        HingeConstraint.create = function (rigidBody) {
            var obj = new this(rigidBody);
            return obj;
        };
        Object.defineProperty(HingeConstraint.prototype, "connectedBody", {
            get: function () {
                return this._connectedBody;
            },
            set: function (connectedBody) {
                var engineAdapter = null;
                this._connectedBody = connectedBody;
                engineAdapter = this.rigidBody.getPhysicsComponentContainerAdapter();
                engineAdapter.removeHingeConstraint(this.rigidBody.entityObject);
                this.rigidBody.addConstraint();
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], HingeConstraint.prototype, "connectedBody", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], HingeConstraint.prototype, "pivotA", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], HingeConstraint.prototype, "pivotB", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], HingeConstraint.prototype, "axisA", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], HingeConstraint.prototype, "axisB", void 0);
        return HingeConstraint;
    }(PhysicsConstraint));
    wd.HingeConstraint = HingeConstraint;
    var PointToPointConstraint = (function (_super) {
        __extends(PointToPointConstraint, _super);
        function PointToPointConstraint() {
            _super.apply(this, arguments);
            this.connectedBody = null;
            this.pivotA = null;
            this.pivotB = null;
        }
        PointToPointConstraint.create = function () {
            var obj = new this(null);
            return obj;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PointToPointConstraint.prototype, "connectedBody", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], PointToPointConstraint.prototype, "pivotA", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], PointToPointConstraint.prototype, "pivotB", void 0);
        return PointToPointConstraint;
    }(PhysicsConstraint));
    wd.PointToPointConstraint = PointToPointConstraint;
    var PointToPointConstraintList = (function () {
        function PointToPointConstraintList(rigidBody) {
            this._rigidBody = null;
            this._list = wdCb.Collection.create();
            this._rigidBody = rigidBody;
        }
        PointToPointConstraintList.create = function (rigidBody) {
            var obj = new this(rigidBody);
            return obj;
        };
        PointToPointConstraintList.prototype.clone = function (rigidBody) {
            return wd.CloneUtils.clone(this, null, [rigidBody]);
        };
        PointToPointConstraintList.prototype.forEach = function (func, context) {
            if (context === void 0) { context = wd.root; }
            this._list.forEach(func, context);
        };
        PointToPointConstraintList.prototype.getCount = function () {
            return this._list.getCount();
        };
        PointToPointConstraintList.prototype.getChildren = function () {
            return this._list;
        };
        PointToPointConstraintList.prototype.getChild = function (index) {
            return this._list.getChild(index);
        };
        PointToPointConstraintList.prototype.addChild = function (constraint) {
            var engineAdapter = null;
            this._list.addChild(constraint);
            engineAdapter = this._rigidBody.getPhysicsComponentContainerAdapter();
            engineAdapter.addPointToPointConstraint(this._rigidBody.entityObject, constraint);
        };
        PointToPointConstraintList.prototype.addChildren = function (arg) {
            var _this = this;
            if (wd.JudgeUtils.isArrayExactly(arg)) {
                for (var _i = 0, _a = arg; _i < _a.length; _i++) {
                    var constraint = _a[_i];
                    this.addChild(constraint);
                }
            }
            else {
                var constraintList = arg;
                constraintList.forEach(function (constraint) {
                    _this.addChild(constraint);
                }, this);
            }
        };
        PointToPointConstraintList.prototype.removeChild = function (constraint) {
            var engineAdapter = null;
            this._list.removeChild(constraint);
            engineAdapter = this._rigidBody.getPhysicsComponentContainerAdapter();
            engineAdapter.removePointToPointConstraint(constraint);
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = source[memberName].clone(true);
            })
        ], PointToPointConstraintList.prototype, "_list", void 0);
        return PointToPointConstraintList;
    }());
    wd.PointToPointConstraintList = PointToPointConstraintList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PhysicsConfig = (function () {
        function PhysicsConfig() {
            this._gravity = wd.Vector3.create(0, -9.8, 0);
            this.enable = false;
            this.engine = wd.EPhysicsEngineType.CANNON;
            this.iterations = 10;
        }
        PhysicsConfig.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(PhysicsConfig.prototype, "gravity", {
            get: function () {
                return this._gravity;
            },
            set: function (gravity) {
                this._gravity = gravity;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            wd.operateWorldDataGetterAndSetter("Gravity")
        ], PhysicsConfig.prototype, "gravity", null);
        return PhysicsConfig;
    }());
    wd.PhysicsConfig = PhysicsConfig;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PhysicsEngineFactory = (function () {
        function PhysicsEngineFactory() {
        }
        PhysicsEngineFactory.createNullAdapter = function () {
            return wd.NullPhysicsEngineAdapter.create();
        };
        PhysicsEngineFactory.create = function (enable, type) {
            var result = null;
            if (!enable) {
                return wd.NullPhysicsEngineAdapter.create();
            }
            switch (type) {
                case wd.EPhysicsEngineType.CANNON:
                    result = wd.CannonAdapter.create();
                    break;
                default:
                    wdCb.Log.error(true, wdCb.Log.info.FUNC_UNEXPECT("physics engine type"));
                    break;
            }
            return result;
        };
        return PhysicsEngineFactory;
    }());
    wd.PhysicsEngineFactory = PhysicsEngineFactory;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EPhysicsEngineType) {
        EPhysicsEngineType[EPhysicsEngineType["CANNON"] = 0] = "CANNON";
    })(wd.EPhysicsEngineType || (wd.EPhysicsEngineType = {}));
    var EPhysicsEngineType = wd.EPhysicsEngineType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NullPhysicsEngineAdapter = (function () {
        function NullPhysicsEngineAdapter() {
            this.world = null;
        }
        NullPhysicsEngineAdapter.create = function () {
            var obj = new this();
            return obj;
        };
        NullPhysicsEngineAdapter.prototype.getGravity = function (gravity) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setGravity = function (gravity) {
        };
        NullPhysicsEngineAdapter.prototype.getFriction = function (obj, friction) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setFriction = function (obj, friction) {
        };
        NullPhysicsEngineAdapter.prototype.getRestitution = function (obj, restitution) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setRestitution = function (obj, restitution) {
        };
        NullPhysicsEngineAdapter.prototype.getLinearDamping = function (obj) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setLinearDamping = function (obj, linearDamping) {
        };
        NullPhysicsEngineAdapter.prototype.getAngularDamping = function (obj) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setAngularDamping = function (obj, angularDamping) {
        };
        NullPhysicsEngineAdapter.prototype.getMass = function (obj) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setMass = function (obj, mass) {
        };
        NullPhysicsEngineAdapter.prototype.getVelocity = function (obj) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setVelocity = function (obj, velocity) {
        };
        NullPhysicsEngineAdapter.prototype.getAngularVelocity = function (obj) {
            return null;
        };
        NullPhysicsEngineAdapter.prototype.setAngularVelocity = function (obj, angularVelocity) {
        };
        NullPhysicsEngineAdapter.prototype.init = function () {
        };
        NullPhysicsEngineAdapter.prototype.addDynamicBody = function (entityObject, data) {
        };
        NullPhysicsEngineAdapter.prototype.addKinematicBody = function (entityObject, data) {
        };
        NullPhysicsEngineAdapter.prototype.addStaticBody = function (entityObject, data) {
        };
        NullPhysicsEngineAdapter.prototype.addLockConstraint = function (entityObject, lockConstraint) {
        };
        NullPhysicsEngineAdapter.prototype.removeLockConstraint = function (entityObject) {
        };
        NullPhysicsEngineAdapter.prototype.addDistanceConstraint = function (entityObject, distanceConstraint) {
        };
        NullPhysicsEngineAdapter.prototype.removeDistanceConstraint = function (entityObject) {
        };
        NullPhysicsEngineAdapter.prototype.addHingeConstraint = function (entityObject, hingeConstraint) {
        };
        NullPhysicsEngineAdapter.prototype.removeHingeConstraint = function (entityObject) {
        };
        NullPhysicsEngineAdapter.prototype.addPointToPointConstraint = function (entityObject, pointToPointConstraint) {
        };
        NullPhysicsEngineAdapter.prototype.removePointToPointConstraint = function (pointToPointConstraint) {
        };
        NullPhysicsEngineAdapter.prototype.removeGameObject = function (obj) {
        };
        NullPhysicsEngineAdapter.prototype.removeConstraints = function (obj) {
        };
        NullPhysicsEngineAdapter.prototype.update = function (elapsed) {
        };
        return NullPhysicsEngineAdapter;
    }());
    wd.NullPhysicsEngineAdapter = NullPhysicsEngineAdapter;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonDataList = (function () {
        function CannonDataList() {
            this.dataList = wdCb.Collection.create();
        }
        CannonDataList.prototype.getCount = function () {
            return this.dataList.getCount();
        };
        CannonDataList.prototype.removeByGameObject = function (obj) {
            this.dataList.removeChild(function (_a) {
                var entityObject = _a.entityObject, body = _a.body;
                return wd.JudgeUtils.isEqual(entityObject, obj);
            });
        };
        return CannonDataList;
    }());
    wd.CannonDataList = CannonDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonGameObjectDataList = (function (_super) {
        __extends(CannonGameObjectDataList, _super);
        function CannonGameObjectDataList() {
            _super.apply(this, arguments);
        }
        CannonGameObjectDataList.create = function () {
            var obj = new this();
            return obj;
        };
        CannonGameObjectDataList.prototype.remove = function (obj) {
            this.removeByGameObject(obj);
        };
        CannonGameObjectDataList.prototype.updateBodyTransformData = function () {
            this.dataList.forEach(function (_a) {
                var entityObject = _a.entityObject, body = _a.body;
                var transform = entityObject.transform;
                if (transform.isTranslate || transform.isRotate) {
                    body.position = wd.CannonUtils.convertToCannonVector3(entityObject.transform.position);
                    body.quaternion = wd.CannonUtils.convertToCannonQuaternion(entityObject.transform.rotation);
                }
            });
        };
        CannonGameObjectDataList.prototype.updateGameObjectTransformData = function () {
            this.dataList.forEach(function (_a) {
                var entityObject = _a.entityObject, body = _a.body;
                if (entityObject.hasTag("isRigidbodyChild")) {
                    return;
                }
                entityObject.transform.position = wd.CannonUtils.convertToWDVector3(body.position);
                entityObject.transform.rotation = wd.CannonUtils.convertToWDQuaternion(body.quaternion);
            });
        };
        CannonGameObjectDataList.prototype.add = function (obj, body) {
            this.dataList.addChild({
                entityObject: obj,
                body: body
            });
        };
        CannonGameObjectDataList.prototype.findGameObjectByBody = function (b) {
            var result = this.dataList.findOne(function (_a) {
                var entityObject = _a.entityObject, body = _a.body;
                return body === b;
            });
            return result !== null ? result.entityObject : null;
        };
        CannonGameObjectDataList.prototype.findBodyByGameObject = function (obj) {
            var result = this.dataList.findOne(function (_a) {
                var entityObject = _a.entityObject, body = _a.body;
                return wd.JudgeUtils.isEqual(entityObject, obj);
            });
            return result !== null ? result.body : null;
        };
        return CannonGameObjectDataList;
    }(wd.CannonDataList));
    wd.CannonGameObjectDataList = CannonGameObjectDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonMaterialList = (function (_super) {
        __extends(CannonMaterialList, _super);
        function CannonMaterialList() {
            _super.apply(this, arguments);
        }
        CannonMaterialList.create = function () {
            var obj = new this();
            return obj;
        };
        CannonMaterialList.prototype.remove = function (obj) {
            this.removeByGameObject(obj);
        };
        CannonMaterialList.prototype.findMaterialByGameObject = function (obj) {
            var result = this.dataList.findOne(function (_a) {
                var entityObject = _a.entityObject, material = _a.material;
                return wd.JudgeUtils.isEqual(entityObject, obj);
            });
            return result !== null ? result.material : null;
        };
        CannonMaterialList.prototype.add = function (obj, material) {
            this.dataList.addChild({
                entityObject: obj,
                material: material
            });
        };
        CannonMaterialList.prototype.addContactMaterial = function (world, currentMaterial, friction, restitution) {
            this.dataList.forEach(function (_a) {
                var entityObject = _a.entityObject, material = _a.material;
                world.addContactMaterial(new CANNON.ContactMaterial(material, currentMaterial, {
                    friction: friction,
                    restitution: restitution
                }));
            });
        };
        CannonMaterialList.prototype.getContactMaterialData = function (world, currentMaterial, dataName) {
            var result = null;
            this.dataList.forEach(function (_a) {
                var entityObject = _a.entityObject, material = _a.material;
                var contactMaterial = world.getContactMaterial(material, currentMaterial);
                if (!contactMaterial) {
                    return;
                }
                result = contactMaterial[dataName];
                return wdCb.$BREAK;
            });
            return result;
        };
        CannonMaterialList.prototype.getContactMaterials = function (world, currentMaterial) {
            var resultArr = [];
            this.dataList.forEach(function (_a) {
                var entityObject = _a.entityObject, material = _a.material;
                var contactMaterial = world.getContactMaterial(material, currentMaterial);
                if (!contactMaterial) {
                    return;
                }
                resultArr.push(contactMaterial);
            });
            return resultArr;
        };
        CannonMaterialList.prototype.setContactMaterialData = function (world, currentMaterial, dataName, data) {
            this.dataList.forEach(function (_a) {
                var entityObject = _a.entityObject, material = _a.material;
                var contactMaterial = world.getContactMaterial(material, currentMaterial);
                if (!contactMaterial) {
                    return;
                }
                contactMaterial[dataName] = data;
            });
        };
        return CannonMaterialList;
    }(wd.CannonDataList));
    wd.CannonMaterialList = CannonMaterialList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonConstraintDataList = (function (_super) {
        __extends(CannonConstraintDataList, _super);
        function CannonConstraintDataList() {
            _super.apply(this, arguments);
        }
        return CannonConstraintDataList;
    }(wd.CannonDataList));
    wd.CannonConstraintDataList = CannonConstraintDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonSingleConstraintDataList = (function (_super) {
        __extends(CannonSingleConstraintDataList, _super);
        function CannonSingleConstraintDataList() {
            _super.apply(this, arguments);
        }
        CannonSingleConstraintDataList.prototype.add = function (obj, constraint) {
            this.dataList.addChild({
                entityObject: obj,
                constraint: constraint
            });
        };
        CannonSingleConstraintDataList.prototype.remove = function (obj) {
            this.removeByGameObject(obj);
        };
        CannonSingleConstraintDataList.prototype.findConstraintByGameObject = function (obj) {
            var result = this.dataList.findOne(function (_a) {
                var entityObject = _a.entityObject;
                return wd.JudgeUtils.isEqual(entityObject, obj);
            });
            return result !== null ? result.constraint : null;
        };
        return CannonSingleConstraintDataList;
    }(wd.CannonConstraintDataList));
    wd.CannonSingleConstraintDataList = CannonSingleConstraintDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonLockConstraintDataList = (function (_super) {
        __extends(CannonLockConstraintDataList, _super);
        function CannonLockConstraintDataList() {
            _super.apply(this, arguments);
        }
        CannonLockConstraintDataList.create = function () {
            var obj = new this();
            return obj;
        };
        return CannonLockConstraintDataList;
    }(wd.CannonSingleConstraintDataList));
    wd.CannonLockConstraintDataList = CannonLockConstraintDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonPointToPointConstraintDataList = (function (_super) {
        __extends(CannonPointToPointConstraintDataList, _super);
        function CannonPointToPointConstraintDataList() {
            _super.apply(this, arguments);
        }
        CannonPointToPointConstraintDataList.create = function () {
            var obj = new this();
            return obj;
        };
        CannonPointToPointConstraintDataList.prototype.filter = function (func) {
            return this.dataList.filter(func);
        };
        CannonPointToPointConstraintDataList.prototype.forEach = function (func) {
            this.dataList.forEach(func);
        };
        CannonPointToPointConstraintDataList.prototype.add = function (entityObject, pointToPointConstraint, constraint) {
            this.dataList.addChild({
                entityObject: entityObject,
                pointToPointConstraint: pointToPointConstraint,
                cannonConstraint: constraint
            });
        };
        CannonPointToPointConstraintDataList.prototype.remove = function (constraint) {
            this.dataList.removeChild(function (_a) {
                var pointToPointConstraint = _a.pointToPointConstraint;
                return wd.JudgeUtils.isEqual(pointToPointConstraint, constraint);
            });
        };
        CannonPointToPointConstraintDataList.prototype.findCannonConstraintByPointToPointConstraint = function (constraint) {
            var result = this.dataList.findOne(function (_a) {
                var pointToPointConstraint = _a.pointToPointConstraint;
                return wd.JudgeUtils.isEqual(pointToPointConstraint, constraint);
            });
            return result !== null ? result.cannonConstraint : null;
        };
        return CannonPointToPointConstraintDataList;
    }(wd.CannonConstraintDataList));
    wd.CannonPointToPointConstraintDataList = CannonPointToPointConstraintDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonDistanceConstraintDataList = (function (_super) {
        __extends(CannonDistanceConstraintDataList, _super);
        function CannonDistanceConstraintDataList() {
            _super.apply(this, arguments);
        }
        CannonDistanceConstraintDataList.create = function () {
            var obj = new this();
            return obj;
        };
        return CannonDistanceConstraintDataList;
    }(wd.CannonSingleConstraintDataList));
    wd.CannonDistanceConstraintDataList = CannonDistanceConstraintDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonHingeConstraintDataList = (function (_super) {
        __extends(CannonHingeConstraintDataList, _super);
        function CannonHingeConstraintDataList() {
            _super.apply(this, arguments);
        }
        CannonHingeConstraintDataList.create = function () {
            var obj = new this();
            return obj;
        };
        return CannonHingeConstraintDataList;
    }(wd.CannonSingleConstraintDataList));
    wd.CannonHingeConstraintDataList = CannonHingeConstraintDataList;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonUtils = (function () {
        function CannonUtils() {
        }
        CannonUtils.convertToCannonVector3 = function (v) {
            return new CANNON.Vec3(v.x, v.y, v.z);
        };
        CannonUtils.convertToCannonQuaternion = function (rotation) {
            return new CANNON.Quaternion(rotation.x, rotation.y, rotation.z, rotation.w);
        };
        CannonUtils.convertToWDVector3 = function (v) {
            return wd.Vector3.create(v.x, v.y, v.z);
        };
        CannonUtils.convertToWDQuaternion = function (r) {
            return wd.Quaternion.create(r.x, r.y, r.z, r.w);
        };
        return CannonUtils;
    }());
    wd.CannonUtils = CannonUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonAdapter = (function () {
        function CannonAdapter() {
            this.world = null;
            this._materialList = wd.CannonMaterialList.create();
            this._gameObjectDataList = wd.CannonGameObjectDataList.create();
            this._lockConstraintDataList = wd.CannonLockConstraintDataList.create();
            this._distanceConstraintDataList = wd.CannonDistanceConstraintDataList.create();
            this._hingeConstraintDataList = wd.CannonHingeConstraintDataList.create();
            this._pointToPointConstraintDataList = wd.CannonPointToPointConstraintDataList.create();
            this._dynamicBody = null;
            this._kinematicBody = null;
            this._staticBody = null;
            this._lockConstraint = null;
            this._distanceConstraint = null;
            this._hingeConstraint = null;
            this._pointToPointConstraint = null;
        }
        CannonAdapter.create = function () {
            var obj = new this();
            return obj;
        };
        CannonAdapter.prototype.getGravity = function (gravity) {
            return wd.CannonUtils.convertToWDVector3(this.world.gravity);
        };
        CannonAdapter.prototype.setGravity = function (gravity) {
            this.world.gravity = wd.CannonUtils.convertToCannonVector3(gravity);
        };
        CannonAdapter.prototype.getFriction = function (obj, friction) {
            return this._getMaterialData(obj, "friction");
        };
        CannonAdapter.prototype.setFriction = function (obj, friction) {
            this._setMaterialData(obj, "friction", friction);
        };
        CannonAdapter.prototype.getRestitution = function (obj, restitution) {
            return this._getMaterialData(obj, "restitution");
        };
        CannonAdapter.prototype.setRestitution = function (obj, restitution) {
            this._setMaterialData(obj, "restitution", restitution);
        };
        CannonAdapter.prototype.getLinearDamping = function (obj) {
            return this._getNumberData(obj, "linearDamping");
        };
        CannonAdapter.prototype.setLinearDamping = function (obj, linearDamping) {
            return this._setNumberData(obj, "linearDamping", linearDamping);
        };
        CannonAdapter.prototype.getAngularDamping = function (obj) {
            return this._getNumberData(obj, "angularDamping");
        };
        CannonAdapter.prototype.setAngularDamping = function (obj, angularDamping) {
            return this._setNumberData(obj, "angularDamping", angularDamping);
        };
        CannonAdapter.prototype.getMass = function (obj) {
            return this._getNumberData(obj, "mass");
        };
        CannonAdapter.prototype.setMass = function (obj, mass) {
            return this._setNumberData(obj, "mass", mass);
        };
        CannonAdapter.prototype.getVelocity = function (obj) {
            return this._getVec3Data(obj, "velocity");
        };
        CannonAdapter.prototype.setVelocity = function (obj, velocity) {
            this._setVec3Data(obj, "velocity", velocity);
        };
        CannonAdapter.prototype.getAngularVelocity = function (obj) {
            return this._getVec3Data(obj, "angularVelocity");
        };
        CannonAdapter.prototype.setAngularVelocity = function (obj, angularVelocity) {
            this._setVec3Data(obj, "angularVelocity", angularVelocity);
        };
        CannonAdapter.prototype.init = function () {
            var _a = wd.Director.getInstance().scene.physics, gravity = _a.gravity, iterations = _a.iterations;
            this.world = new CANNON.World();
            this.world.broadphase = new CANNON.NaiveBroadphase();
            this.world.solver.iterations = iterations;
            this.world.gravity.set(gravity.x, gravity.y, gravity.z);
            this._dynamicBody = wd.CannonDynamicBody.create(this.world, this._gameObjectDataList, this._materialList);
            this._kinematicBody = wd.CannonKinematicBody.create(this.world, this._gameObjectDataList, this._materialList);
            this._staticBody = wd.CannonStaticBody.create(this.world, this._gameObjectDataList, this._materialList);
            this._lockConstraint = wd.CannonLockConstraint.create(this.world, this._gameObjectDataList, this._lockConstraintDataList);
            this._distanceConstraint = wd.CannonDistanceConstraint.create(this.world, this._gameObjectDataList, this._distanceConstraintDataList);
            this._hingeConstraint = wd.CannonHingeConstraint.create(this.world, this._gameObjectDataList, this._hingeConstraintDataList);
            this._pointToPointConstraint = wd.CannonPointToPointConstraint.create(this.world, this._gameObjectDataList, this._pointToPointConstraintDataList);
        };
        CannonAdapter.prototype.addDynamicBody = function (entityObject, data) {
            this._dynamicBody.addBody(entityObject, data);
        };
        CannonAdapter.prototype.addKinematicBody = function (entityObject, data) {
            this._kinematicBody.addBody(entityObject, data);
        };
        CannonAdapter.prototype.addStaticBody = function (entityObject, data) {
            this._staticBody.addBody(entityObject, data);
        };
        CannonAdapter.prototype.addLockConstraint = function (entityObject, lockConstraint) {
            this._lockConstraint.addConstraint(entityObject, lockConstraint);
        };
        CannonAdapter.prototype.removeLockConstraint = function (entityObject) {
            this._lockConstraint.removeConstraint(entityObject);
        };
        CannonAdapter.prototype.addDistanceConstraint = function (entityObject, distanceConstraint) {
            this._distanceConstraint.addConstraint(entityObject, distanceConstraint);
        };
        CannonAdapter.prototype.removeDistanceConstraint = function (entityObject) {
            this._distanceConstraint.removeConstraint(entityObject);
        };
        CannonAdapter.prototype.addHingeConstraint = function (entityObject, hingeConstraint) {
            this._hingeConstraint.addConstraint(entityObject, hingeConstraint);
        };
        CannonAdapter.prototype.removeHingeConstraint = function (entityObject) {
            this._hingeConstraint.removeConstraint(entityObject);
        };
        CannonAdapter.prototype.addPointToPointConstraint = function (entityObject, pointToPointConstraint) {
            this._pointToPointConstraint.addConstraint(entityObject, pointToPointConstraint);
        };
        CannonAdapter.prototype.removePointToPointConstraint = function (pointToPointConstraint) {
            this._pointToPointConstraint.removeConstraint(pointToPointConstraint);
        };
        CannonAdapter.prototype.removeGameObject = function (obj) {
            var material = this._getMaterial(obj), body = this._gameObjectDataList.findBodyByGameObject(obj);
            if (body) {
                this.world.remove(body);
            }
            this._gameObjectDataList.remove(obj);
            this._materialList.remove(obj);
        };
        CannonAdapter.prototype.removeConstraints = function (obj) {
            var self = this;
            this._lockConstraint.removeConstraint(obj);
            this._distanceConstraint.removeConstraint(obj);
            this._hingeConstraint.removeConstraint(obj);
            this._pointToPointConstraintDataList
                .filter(function (_a) {
                var entityObject = _a.entityObject;
                return wd.JudgeUtils.isEqual(entityObject, obj);
            })
                .forEach(function (_a) {
                var pointToPointConstraint = _a.pointToPointConstraint;
                self._pointToPointConstraint.removeConstraint(pointToPointConstraint);
            });
        };
        CannonAdapter.prototype.update = function (elapsed) {
            this._gameObjectDataList.updateBodyTransformData();
            this.world.step(wd.Director.getInstance().getDeltaTime() / 1000);
            this._gameObjectDataList.updateGameObjectTransformData();
        };
        CannonAdapter.prototype._getMaterial = function (obj) {
            return this._materialList.findMaterialByGameObject(obj);
        };
        CannonAdapter.prototype._getNumberData = function (obj, dataName) {
            var body = this._gameObjectDataList.findBodyByGameObject(obj);
            if (!body) {
                return null;
            }
            return body[dataName];
        };
        CannonAdapter.prototype._setNumberData = function (obj, dataName, data) {
            var body = this._gameObjectDataList.findBodyByGameObject(obj);
            if (!body) {
                return null;
            }
            body[dataName] = data;
        };
        CannonAdapter.prototype._getVec3Data = function (obj, dataName) {
            var body = this._gameObjectDataList.findBodyByGameObject(obj);
            if (!body) {
                return null;
            }
            return wd.CannonUtils.convertToWDVector3(body[dataName]);
        };
        CannonAdapter.prototype._setVec3Data = function (obj, dataName, data) {
            var body = this._gameObjectDataList.findBodyByGameObject(obj);
            if (!body) {
                return null;
            }
            body[dataName] = wd.CannonUtils.convertToCannonVector3(data);
        };
        CannonAdapter.prototype._getMaterialData = function (obj, dataName) {
            var result = null, currentMaterial = this._getMaterial(obj);
            if (!currentMaterial) {
                return null;
            }
            return this._materialList.getContactMaterialData(this.world, currentMaterial, dataName);
        };
        CannonAdapter.prototype._setMaterialData = function (obj, dataName, data) {
            var world = this.world, currentMaterial = this._getMaterial(obj);
            if (!currentMaterial) {
                wd.Log.warn("no material find, please add material first");
                return;
            }
            this._materialList.setContactMaterialData(this.world, currentMaterial, dataName, data);
        };
        __decorate([
            wd.require(function (obj, dataName) {
                var resultArr = [], firstData = null, currentMaterial = this._getMaterial(obj);
                if (!currentMaterial) {
                    return null;
                }
                resultArr = this._materialList.getContactMaterials(this.world, currentMaterial);
                firstData = resultArr[0];
                for (var _i = 0, resultArr_1 = resultArr; _i < resultArr_1.length; _i++) {
                    var data = resultArr_1[_i];
                    wd.assert(data === firstData, wd.Log.info.FUNC_SHOULD("the data of contact material which contains the same material", "be the same"));
                }
            })
        ], CannonAdapter.prototype, "_getMaterialData", null);
        return CannonAdapter;
    }());
    wd.CannonAdapter = CannonAdapter;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonBody = (function () {
        function CannonBody(world, gameObjectDataList, materialList) {
            this.world = null;
            this.materialList = null;
            this.gameObjectList = null;
            this.world = world;
            this.gameObjectList = gameObjectDataList;
            this.materialList = materialList;
        }
        CannonBody.prototype.addBody = function (entityObject, data) {
            var body = this.createBody(data);
            if (data.children.getCount() > 0) {
                this._addCompounds(entityObject, data.children, body);
            }
            else {
                body.addShape(this._createShape(entityObject.getComponent(wd.Collider).shape));
            }
            this.afterAddShape(body, data);
            body.material = this._createMaterial(entityObject, data.friction, data.restitution);
            body.position = wd.CannonUtils.convertToCannonVector3(data.position);
            body.quaternion = wd.CannonUtils.convertToCannonQuaternion(data.rotation);
            this.world.addBody(body);
            this.gameObjectList.add(entityObject, body);
            this._bindCollideEvent(body, data.onCollisionStart, data.onContact, data.onCollisionEnd);
            return body;
        };
        CannonBody.prototype.afterAddShape = function (body, data) {
        };
        CannonBody.prototype._createShape = function (shape) {
            var cannonShape = null;
            if (shape instanceof wd.AABBShape) {
                cannonShape = new CANNON.Box(wd.CannonUtils.convertToCannonVector3(shape.halfExtents));
            }
            else if (shape instanceof wd.SphereShape) {
                cannonShape = new CANNON.Sphere(shape.radius);
            }
            return cannonShape;
        };
        CannonBody.prototype._bindCollideEvent = function (targetBody, onCollisionStart, onContact, onCollisionEnd) {
            var self = this;
            targetBody.addEventListener("collide", function (e) {
                var entityObject = self.gameObjectList.findGameObjectByBody(e.body), collideObject = null;
                if (!entityObject) {
                    return;
                }
                collideObject = entityObject;
                onCollisionStart(collideObject);
                onContact(collideObject);
                onCollisionEnd(collideObject);
            });
        };
        CannonBody.prototype._createMaterial = function (entityObject, friction, restitution) {
            var material = null, currentMaterial = null;
            material = this._getMaterial(entityObject);
            if (material) {
                return material;
            }
            currentMaterial = new CANNON.Material("material");
            this._addMaterial(entityObject, currentMaterial, friction, restitution);
            return currentMaterial;
        };
        CannonBody.prototype._getMaterial = function (obj) {
            return this.materialList.findMaterialByGameObject(obj);
        };
        CannonBody.prototype._addMaterial = function (entityObject, currentMaterial, friction, restitution) {
            this.materialList.add(entityObject, currentMaterial);
            this.materialList.addContactMaterial(this.world, currentMaterial, friction, restitution);
        };
        CannonBody.prototype._addCompounds = function (entityObject, children, body) {
            var _this = this;
            var position = entityObject.transform.position, rotation = entityObject.transform.rotation;
            children.forEach(function (child) {
                body.addShape(_this._createShape(child.getComponent(wd.Collider).shape), wd.CannonUtils.convertToCannonVector3(child.transform.position.clone().sub(position)), wd.CannonUtils.convertToCannonQuaternion(child.transform.rotation.clone().sub(rotation)));
            }, this);
        };
        __decorate([
            wd.virtual
        ], CannonBody.prototype, "afterAddShape", null);
        __decorate([
            wd.require(function (entityObject, children, body) {
                children.forEach(function (child) {
                    wd.assert(!!child.getComponent(wd.Collider), wd.Log.info.FUNC_MUST_DEFINE("collider component"));
                    wd.assert(!!child.getComponent(wd.Collider).shape, wd.Log.info.FUNC_SHOULD("create collider.shape"));
                });
            })
        ], CannonBody.prototype, "_addCompounds", null);
        return CannonBody;
    }());
    wd.CannonBody = CannonBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonDynamicBody = (function (_super) {
        __extends(CannonDynamicBody, _super);
        function CannonDynamicBody() {
            _super.apply(this, arguments);
        }
        CannonDynamicBody.create = function (world, gameObjectDataList, materialList) {
            var obj = new this(world, gameObjectDataList, materialList);
            return obj;
        };
        CannonDynamicBody.prototype.createBody = function (_a) {
            var mass = _a.mass, linearDamping = _a.linearDamping, angularDamping = _a.angularDamping, velocity = _a.velocity, angularVelocity = _a.angularVelocity;
            return new CANNON.Body({
                mass: mass,
                linearDamping: linearDamping,
                angularDamping: angularDamping,
                velocity: wd.CannonUtils.convertToCannonVector3(velocity),
                angularVelocity: wd.CannonUtils.convertToCannonVector3(angularVelocity)
            });
        };
        CannonDynamicBody.prototype.afterAddShape = function (body, _a) {
            var impulse = _a.impulse, force = _a.force, hitPoint = _a.hitPoint;
            if (impulse && hitPoint) {
                body.applyImpulse(wd.CannonUtils.convertToCannonVector3(impulse), wd.CannonUtils.convertToCannonVector3(hitPoint));
            }
            if (force && hitPoint) {
                body.applyForce(wd.CannonUtils.convertToCannonVector3(force), wd.CannonUtils.convertToCannonVector3(hitPoint));
            }
        };
        return CannonDynamicBody;
    }(wd.CannonBody));
    wd.CannonDynamicBody = CannonDynamicBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonKinematicBody = (function (_super) {
        __extends(CannonKinematicBody, _super);
        function CannonKinematicBody() {
            _super.apply(this, arguments);
        }
        CannonKinematicBody.create = function (world, gameObjectDataList, materialList) {
            var obj = new this(world, gameObjectDataList, materialList);
            return obj;
        };
        CannonKinematicBody.prototype.createBody = function (_a) {
            var mass = _a.mass, velocity = _a.velocity, angularVelocity = _a.angularVelocity;
            return new CANNON.Body({
                type: CANNON.Body.KINEMATIC,
                mass: mass,
                velocity: wd.CannonUtils.convertToCannonVector3(velocity),
                angularVelocity: wd.CannonUtils.convertToCannonVector3(angularVelocity)
            });
        };
        return CannonKinematicBody;
    }(wd.CannonBody));
    wd.CannonKinematicBody = CannonKinematicBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonStaticBody = (function (_super) {
        __extends(CannonStaticBody, _super);
        function CannonStaticBody() {
            _super.apply(this, arguments);
        }
        CannonStaticBody.create = function (world, gameObjectDataList, materialList) {
            var obj = new this(world, gameObjectDataList, materialList);
            return obj;
        };
        CannonStaticBody.prototype.createBody = function (_a) {
            return new CANNON.Body({
                mass: 0
            });
        };
        return CannonStaticBody;
    }(wd.CannonBody));
    wd.CannonStaticBody = CannonStaticBody;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonConstraint = (function () {
        function CannonConstraint(world, gameObjectDataList, constraintDataList) {
            this.world = null;
            this.gameObjectList = null;
            this.constraintDataList = null;
            this.world = world;
            this.gameObjectList = gameObjectDataList;
            this.constraintDataList = constraintDataList;
        }
        CannonConstraint.prototype.addConstraint = function (entityObject, wdConstraint) {
            var constraint = null, body = this.gameObjectList.findBodyByGameObject(entityObject);
            constraint = this.createCannonConstraint(body, wdConstraint);
            this.world.addConstraint(constraint);
            this.addToConstraintDataList(entityObject, wdConstraint, constraint);
        };
        CannonConstraint.prototype.findBody = function (rigidBody) {
            return this.gameObjectList.findBodyByGameObject(rigidBody.entityObject);
        };
        __decorate([
            wd.require(function (entityObject, pointToPointConstraint) {
                wd.assert(this.gameObjectList.findBodyByGameObject(entityObject) !== null, wd.Log.info.FUNC_SHOULD("add rigid body"));
                wd.assert(this.findBody(pointToPointConstraint.connectedBody), wd.Log.info.FUNC_SHOULD("add connectedBody"));
            })
        ], CannonConstraint.prototype, "addConstraint", null);
        return CannonConstraint;
    }());
    wd.CannonConstraint = CannonConstraint;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonSingleConstraint = (function (_super) {
        __extends(CannonSingleConstraint, _super);
        function CannonSingleConstraint() {
            _super.apply(this, arguments);
        }
        CannonSingleConstraint.prototype.removeConstraint = function (entityObject) {
            var constraint = this.constraintDataList.findConstraintByGameObject(entityObject);
            if (constraint) {
                this.world.removeConstraint(constraint);
            }
            this.constraintDataList.remove(entityObject);
        };
        CannonSingleConstraint.prototype.addToConstraintDataList = function (entityObject, wdConstraint, cannonConstraint) {
            this.constraintDataList.add(entityObject, cannonConstraint);
        };
        return CannonSingleConstraint;
    }(wd.CannonConstraint));
    wd.CannonSingleConstraint = CannonSingleConstraint;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonLockConstraint = (function (_super) {
        __extends(CannonLockConstraint, _super);
        function CannonLockConstraint() {
            _super.apply(this, arguments);
        }
        CannonLockConstraint.create = function (world, gameObjectDataList, constraintDataList) {
            var obj = new this(world, gameObjectDataList, constraintDataList);
            return obj;
        };
        CannonLockConstraint.prototype.createCannonConstraint = function (body, lockConstraint) {
            var constraint = null, connectedBody = this.findBody(lockConstraint.connectedBody);
            if (lockConstraint.maxForce) {
                constraint = new CANNON.LockConstraint(body, connectedBody, lockConstraint.maxForce);
            }
            else {
                constraint = new CANNON.LockConstraint(body, connectedBody);
            }
            return constraint;
        };
        return CannonLockConstraint;
    }(wd.CannonSingleConstraint));
    wd.CannonLockConstraint = CannonLockConstraint;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonPointToPointConstraint = (function (_super) {
        __extends(CannonPointToPointConstraint, _super);
        function CannonPointToPointConstraint() {
            _super.apply(this, arguments);
        }
        CannonPointToPointConstraint.create = function (world, gameObjectDataList, constraintDataList) {
            var obj = new this(world, gameObjectDataList, constraintDataList);
            return obj;
        };
        CannonPointToPointConstraint.prototype.removeConstraint = function (pointToPointConstraint) {
            var constraint = this.constraintDataList.findCannonConstraintByPointToPointConstraint(pointToPointConstraint);
            if (constraint) {
                this.world.removeConstraint(constraint);
            }
            this.constraintDataList.remove(pointToPointConstraint);
        };
        CannonPointToPointConstraint.prototype.createCannonConstraint = function (body, pointToPointConstraint) {
            var constraint = null, connectedBody = this.findBody(pointToPointConstraint.connectedBody), pivotA = wd.CannonUtils.convertToCannonVector3(pointToPointConstraint.pivotA), pivotB = wd.CannonUtils.convertToCannonVector3(pointToPointConstraint.pivotB);
            if (pointToPointConstraint.maxForce) {
                constraint = new CANNON.PointToPointConstraint(body, pivotA, connectedBody, pivotB, pointToPointConstraint.maxForce);
            }
            else {
                constraint = new CANNON.PointToPointConstraint(body, pivotA, connectedBody, pivotB);
            }
            return constraint;
        };
        CannonPointToPointConstraint.prototype.addToConstraintDataList = function (entityObject, wdConstraint, cannonConstraint) {
            this.constraintDataList.add(entityObject, wdConstraint, cannonConstraint);
        };
        return CannonPointToPointConstraint;
    }(wd.CannonConstraint));
    wd.CannonPointToPointConstraint = CannonPointToPointConstraint;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonDistanceConstraint = (function (_super) {
        __extends(CannonDistanceConstraint, _super);
        function CannonDistanceConstraint() {
            _super.apply(this, arguments);
        }
        CannonDistanceConstraint.create = function (world, gameObjectDataList, constraintDataList) {
            var obj = new this(world, gameObjectDataList, constraintDataList);
            return obj;
        };
        CannonDistanceConstraint.prototype.createCannonConstraint = function (body, distanceConstraint) {
            var constraint = null, connectedBody = this.findBody(distanceConstraint.connectedBody);
            constraint = new CANNON.DistanceConstraint(body, connectedBody, distanceConstraint.distance !== null ? distanceConstraint.distance : void 0, distanceConstraint.maxForce !== null ? distanceConstraint.maxForce : void 0);
            return constraint;
        };
        return CannonDistanceConstraint;
    }(wd.CannonSingleConstraint));
    wd.CannonDistanceConstraint = CannonDistanceConstraint;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CannonHingeConstraint = (function (_super) {
        __extends(CannonHingeConstraint, _super);
        function CannonHingeConstraint() {
            _super.apply(this, arguments);
        }
        CannonHingeConstraint.create = function (world, gameObjectDataList, constraintDataList) {
            var obj = new this(world, gameObjectDataList, constraintDataList);
            return obj;
        };
        CannonHingeConstraint.prototype.createCannonConstraint = function (body, hingeConstraint) {
            var constraint = null, connectedBody = this.findBody(hingeConstraint.connectedBody), pivotA = wd.CannonUtils.convertToCannonVector3(hingeConstraint.pivotA), axisA = wd.CannonUtils.convertToCannonVector3(hingeConstraint.axisA), pivotB = wd.CannonUtils.convertToCannonVector3(hingeConstraint.pivotB), axisB = wd.CannonUtils.convertToCannonVector3(hingeConstraint.axisB), options = {};
            if (hingeConstraint.pivotA) {
                options.pivotA = pivotA;
            }
            if (hingeConstraint.axisA) {
                options.axisA = axisA;
            }
            if (hingeConstraint.pivotB) {
                options.pivotB = pivotB;
            }
            if (hingeConstraint.axisB) {
                options.axisB = axisB;
            }
            if (hingeConstraint.maxForce) {
                options.maxForce = hingeConstraint.maxForce;
            }
            constraint = new CANNON.HingeConstraint(body, connectedBody, options);
            return constraint;
        };
        return CannonHingeConstraint;
    }(wd.CannonSingleConstraint));
    wd.CannonHingeConstraint = CannonHingeConstraint;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BitmapFontLayout = (function () {
        function BitmapFontLayout() {
            this._layoutList = wdCb.Collection.create();
            this._searchGlyph = wd.BitmapFontSearchGlyph.create();
        }
        BitmapFontLayout.create = function () {
            var obj = new this();
            return obj;
        };
        BitmapFontLayout.prototype.getLayoutData = function (text, fntId, _a) {
            var _b = _a.width, width = _b === void 0 ? 0 : _b, _c = _a.tabSize, tabSize = _c === void 0 ? 4 : _c, _d = _a.letterSpacing, letterSpacing = _d === void 0 ? 0 : _d, _e = _a.align, align = _e === void 0 ? wd.EFontXAlignment.LEFT : _e;
            var fntData = this._getFntObj(fntId);
            if (!fntData) {
                wd.Log.log("impossible to create font: not find fnt file");
                return;
            }
            this._searchGlyph.setupSpaceGlyphs(fntData, tabSize);
            var lines = wd.BitmapFontWordWrapper.getLines(fntData, text, this._searchGlyph, {
                width: width,
                letterSpacing: letterSpacing,
            }), minWidth = width, maxLineWidth = null, x = 0, y = 0, lineHeight = fntData.commonHeight, baseline = fntData.commonBase;
            this._layoutList.removeAllChildren();
            maxLineWidth = lines.reduce(function (prev, line) {
                return Math.max(prev, line.width, minWidth);
            }, 0);
            for (var lineIndex = 0, len = lines.length; lineIndex < len; lineIndex++) {
                var line = lines[lineIndex], start = line.start, end = line.end, lineWidth = line.width, lastGlyph = null;
                for (var i = start; i < end; i++) {
                    var id = text.charCodeAt(i), glyph = this._searchGlyph.getGlyph(fntData, id), tx = null;
                    if (glyph) {
                        if (lastGlyph) {
                            x += wd.BitmapFontParser.getKerning(fntData, lastGlyph.id, glyph.id);
                        }
                        tx = x;
                        if (align === wd.EFontXAlignment.CENTER) {
                            tx += (maxLineWidth - lineWidth) / 2;
                        }
                        else if (align === wd.EFontXAlignment.RIGHT) {
                            tx += (maxLineWidth - lineWidth);
                        }
                        this._layoutList.addChild({
                            position: [tx + glyph.xOffset, y + glyph.yOffset],
                            data: glyph,
                            index: i,
                            line: lineIndex
                        });
                        x += glyph.xAdvance + letterSpacing;
                        lastGlyph = glyph;
                    }
                }
                y += lineHeight;
                x = 0;
            }
            return this._layoutList;
        };
        BitmapFontLayout.prototype._getFntObj = function (fntId) {
            return wd.LoaderManager.getInstance().get(fntId);
        };
        return BitmapFontLayout;
    }());
    wd.BitmapFontLayout = BitmapFontLayout;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BitmapFontParser = (function () {
        function BitmapFontParser() {
        }
        BitmapFontParser.getKerning = function (fntObj, left, right) {
            if (!fntObj.kerningArray || fntObj.kerningArray.length === 0) {
                return 0;
            }
            var table = fntObj.kerningArray;
            for (var i = 0; i < table.length; i++) {
                var kern = table[i];
                if (kern.first === left && kern.second === right) {
                    return kern.amount;
                }
            }
            return 0;
        };
        return BitmapFontParser;
    }());
    wd.BitmapFontParser = BitmapFontParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var M_WIDTHS = ['m', 'w'], TAB_ID = '\t'.charCodeAt(0), SPACE_ID = ' '.charCodeAt(0);
    var BitmapFontSearchGlyph = (function () {
        function BitmapFontSearchGlyph() {
            this._fallbackSpaceGlyph = null;
            this._fallbackTabGlyph = null;
        }
        BitmapFontSearchGlyph.create = function () {
            var obj = new this();
            return obj;
        };
        BitmapFontSearchGlyph.prototype.getGlyph = function (fntObj, id) {
            var glyph = this.getGlyphById(fntObj, id);
            if (glyph) {
                return glyph;
            }
            else if (id === TAB_ID) {
                return this._fallbackTabGlyph;
            }
            else if (id === SPACE_ID) {
                return this._fallbackSpaceGlyph;
            }
            return null;
        };
        BitmapFontSearchGlyph.prototype.getGlyphById = function (fntObj, id) {
            var dict = this._getFontDefDictionary(fntObj);
            if (!dict) {
                return null;
            }
            return dict[String(id)];
        };
        BitmapFontSearchGlyph.prototype.setupSpaceGlyphs = function (fntObj, tabSize) {
            if (!this._getFontDefDictionary(fntObj)) {
                return;
            }
            var space = this.getGlyphById(fntObj, SPACE_ID)
                || this._getMGlyph(fntObj)
                || this._getFirstGlyph(fntObj), tabWidth = tabSize * space.xAdvance;
            this._fallbackSpaceGlyph = space;
            this._fallbackTabGlyph = {
                id: String(TAB_ID),
                page: 0,
                rect: {
                    x: 0, y: 0, width: 0, height: 0
                },
                xOffset: 0,
                yOffset: 0,
                xAdvance: tabWidth
            };
        };
        BitmapFontSearchGlyph.prototype._getMGlyph = function (fntObj) {
            var glyph = null;
            for (var i = 0; i < M_WIDTHS.length; i++) {
                var id = M_WIDTHS[i].charCodeAt(0), glyph_1 = this.getGlyphById(fntObj, id);
                if (glyph_1) {
                    break;
                }
            }
            return glyph;
        };
        BitmapFontSearchGlyph.prototype._getFirstGlyph = function (fntObj) {
            var fontDefDictionary = this._getFontDefDictionary(fntObj), result = null;
            for (var charData in fontDefDictionary) {
                result = fontDefDictionary[charData];
                break;
            }
            return result;
        };
        BitmapFontSearchGlyph.prototype._getFontDefDictionary = function (fntObj) {
            return fntObj.fontDefDictionary;
        };
        return BitmapFontSearchGlyph;
    }());
    wd.BitmapFontSearchGlyph = BitmapFontSearchGlyph;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NEWLINE_CHAR = '\n', WHITESPACE = /\s/;
    var BitmapFontWordWrapper = (function () {
        function BitmapFontWordWrapper() {
        }
        BitmapFontWordWrapper.getLines = function (fntObj, text, searchGlyph, _a) {
            var letterSpacing = _a.letterSpacing, _b = _a.width, width = _b === void 0 ? Number.MAX_VALUE : _b, _c = _a.start, start = _c === void 0 ? 0 : _c, _d = _a.end, end = _d === void 0 ? text.length : _d;
            return this._greedy(fntObj, text, letterSpacing, searchGlyph, start, end, width);
        };
        BitmapFontWordWrapper._greedy = function (fntObj, text, letterSpacing, searchGlyph, start, end, width) {
            var lines = [], testWidth = width;
            while (start < end && start < text.length) {
                var newLine = this._findNewLineIndex(text, NEWLINE_CHAR, start, end);
                while (start < newLine) {
                    if (!this._isWhitespace(text.charAt(start))) {
                        break;
                    }
                    start++;
                }
                var measured = this._computeMetrics(fntObj, text, letterSpacing, searchGlyph, start, newLine, testWidth), lineEnd = start + (measured.end - measured.start), nextStart = lineEnd + NEWLINE_CHAR.length;
                if (lineEnd < newLine) {
                    while (lineEnd > start) {
                        if (this._isWhitespace(text.charAt(lineEnd))) {
                            break;
                        }
                        lineEnd--;
                    }
                    if (lineEnd === start) {
                        if (nextStart > start + NEWLINE_CHAR.length) {
                            nextStart--;
                        }
                        lineEnd = nextStart;
                    }
                    else {
                        nextStart = lineEnd;
                        while (lineEnd > start) {
                            if (!this._isWhitespace(text.charAt(lineEnd - NEWLINE_CHAR.length))) {
                                break;
                            }
                            lineEnd--;
                        }
                    }
                }
                if (lineEnd >= start) {
                    lines.push(this._computeMetrics(fntObj, text, letterSpacing, searchGlyph, start, lineEnd, testWidth));
                }
                start = nextStart;
            }
            return lines;
        };
        BitmapFontWordWrapper._computeMetrics = function (fntObj, text, letterSpacing, searchGlyph, start, end, width) {
            var curPen = 0, curWidth = 0, count = 0, lastGlyph = null;
            if (!fntObj.fontDefDictionary) {
                return {
                    start: start,
                    end: start,
                    width: 0
                };
            }
            end = Math.min(text.length, end);
            for (var i = start; i < end; i++) {
                var id = text.charCodeAt(i), glyph = searchGlyph.getGlyph(fntObj, id);
                if (glyph) {
                    var kern = lastGlyph ? wd.BitmapFontParser.getKerning(fntObj, lastGlyph.id, glyph.id) : 0, nextPen = null, nextWidth = null;
                    curPen += kern;
                    nextPen = curPen + glyph.xAdvance + letterSpacing;
                    nextWidth = curPen + glyph.rect.width;
                    if (nextWidth > width || nextPen > width) {
                        if (count === 0) {
                            count = 1;
                            curWidth = nextWidth;
                        }
                        break;
                    }
                    curPen = nextPen;
                    curWidth = nextWidth;
                    lastGlyph = glyph;
                }
                count++;
            }
            if (lastGlyph) {
                curWidth += lastGlyph.xOffset;
            }
            return {
                start: start,
                end: start + count,
                width: curWidth
            };
        };
        BitmapFontWordWrapper._findNewLineIndex = function (text, chr, start, end) {
            var idx = text.indexOf(chr, start);
            if (idx === -1 || idx > end) {
                return end;
            }
            return idx;
        };
        BitmapFontWordWrapper._isWhitespace = function (chr) {
            return WHITESPACE.test(chr);
        };
        return BitmapFontWordWrapper;
    }());
    wd.BitmapFontWordWrapper = BitmapFontWordWrapper;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ThreeDUI = (function (_super) {
        __extends(ThreeDUI, _super);
        function ThreeDUI() {
            _super.apply(this, arguments);
        }
        ThreeDUI.prototype.update = function (elapsed) {
        };
        ThreeDUI.prototype.addToComponentContainer = function () {
            var container = wd.ThreeDUIComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        ThreeDUI.prototype.removeFromComponentContainer = function () {
            wd.ThreeDUIComponentContainer.getInstance().removeChild(this);
        };
        __decorate([
            wd.virtual
        ], ThreeDUI.prototype, "update", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("ThreeDUI component should add to GameObject", function () {
                    wd.expect(_this.entityObject).instanceOf(wd.GameObject);
                }, this);
            })
        ], ThreeDUI.prototype, "addToComponentContainer", null);
        return ThreeDUI;
    }(wd.Component));
    wd.ThreeDUI = ThreeDUI;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Line = (function (_super) {
        __extends(Line, _super);
        function Line() {
            _super.apply(this, arguments);
        }
        return Line;
    }(wd.ThreeDUI));
    wd.Line = Line;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SolidLine = (function (_super) {
        __extends(SolidLine, _super);
        function SolidLine() {
            _super.apply(this, arguments);
        }
        SolidLine.create = function () {
            var obj = new this();
            return obj;
        };
        return SolidLine;
    }(wd.Line));
    wd.SolidLine = SolidLine;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DashLine = (function (_super) {
        __extends(DashLine, _super);
        function DashLine() {
            _super.apply(this, arguments);
        }
        DashLine.create = function () {
            var obj = new this();
            return obj;
        };
        return DashLine;
    }(wd.Line));
    wd.DashLine = DashLine;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Arrow = (function (_super) {
        __extends(Arrow, _super);
        function Arrow() {
            _super.apply(this, arguments);
        }
        Arrow.create = function () {
            var obj = new this();
            return obj;
        };
        return Arrow;
    }(wd.ThreeDUI));
    wd.Arrow = Arrow;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ThreeDFont = (function (_super) {
        __extends(ThreeDFont, _super);
        function ThreeDFont() {
            _super.apply(this, arguments);
            this.needFormat = false;
            this._isFirstUpdate = true;
        }
        ThreeDFont.prototype.update = function (elapsed) {
            if (!this._isFirstUpdate) {
                if (this.needFormat) {
                    this.reFormat();
                }
            }
            else {
                this._isFirstUpdate = false;
            }
            this.needFormat = false;
        };
        ThreeDFont.prototype.reFormat = function () {
        };
        __decorate([
            wd.virtual
        ], ThreeDFont.prototype, "reFormat", null);
        return ThreeDFont;
    }(wd.ThreeDUI));
    wd.ThreeDFont = ThreeDFont;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDUI = (function (_super) {
        __extends(TwoDUI, _super);
        function TwoDUI() {
            _super.apply(this, arguments);
            this.context = null;
        }
        Object.defineProperty(TwoDUI.prototype, "dirty", {
            get: function () {
                var renderer = this.getUIRenderer();
                if (!renderer) {
                    return true;
                }
                return renderer.dirty;
            },
            set: function (dirty) {
                if (dirty) {
                    var renderer = this.getUIRenderer();
                    if (!renderer) {
                        return;
                    }
                    renderer.dirty = dirty;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TwoDUI.prototype, "width", {
            get: function () {
                return this.entityObject ? this.entityObject.transform.width : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TwoDUI.prototype, "height", {
            get: function () {
                return this.entityObject ? this.entityObject.transform.height : null;
            },
            enumerable: true,
            configurable: true
        });
        TwoDUI.prototype.update = function (elapsed) {
        };
        TwoDUI.prototype.init = function () {
            this.context = this.getContext();
        };
        TwoDUI.prototype.addToComponentContainer = function () {
            var container = wd.TwoDUIComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        TwoDUI.prototype.removeFromComponentContainer = function () {
            wd.TwoDUIComponentContainer.getInstance().removeChild(this);
        };
        TwoDUI.prototype.render = function () {
            var context = this.context;
            if (this.shouldNotRender()) {
                return;
            }
            context.save();
            this._setCanvasTransformForRotation();
            this.draw();
            context.restore();
        };
        TwoDUI.prototype.draw = function () {
        };
        TwoDUI.prototype.shouldNotRender = function () {
            return false;
        };
        TwoDUI.prototype.getContext = function () {
            return this.getUIRenderer().context;
        };
        TwoDUI.prototype.getCanvas = function () {
            return this.getUIRenderer().canvas;
        };
        TwoDUI.prototype.getUIRenderer = function () {
            return wd.UIRendererUtils.getUIRenderer(this.entityObject);
        };
        TwoDUI.prototype.drawInCenterPoint = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var context = args[0], source = args[1];
            if (args.length === 5) {
                var position = args[2], width = args[3], height = args[4];
                context.drawImage(source, position.x - width / 2, position.y - height / 2, width, height);
            }
            else if (args.length === 9) {
                var sx = args[2], sy = args[3], sw = args[4], sh = args[5], position = args[6], width = args[7], height = args[8];
                context.drawImage(source, sx, sy, sw, sh, position.x - width / 2, position.y - height / 2, width, height);
            }
        };
        TwoDUI.prototype._setCanvasTransformForRotation = function () {
            var matrix = this.entityObject.transform.rotationMatrix;
            this.context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
        };
        __decorate([
            wd.virtual
        ], TwoDUI.prototype, "dirty", null);
        __decorate([
            wd.virtual
        ], TwoDUI.prototype, "update", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("ThreeDUI component should add to UIObject", function () {
                    wd.expect(_this.entityObject).instanceOf(wd.UIObject);
                }, this);
            })
        ], TwoDUI.prototype, "addToComponentContainer", null);
        __decorate([
            wd.require(function () {
                wd.assert(this.context !== null, wd.Log.info.FUNC_SHOULD("set context"));
            })
        ], TwoDUI.prototype, "render", null);
        __decorate([
            wd.virtual
        ], TwoDUI.prototype, "draw", null);
        __decorate([
            wd.virtual
        ], TwoDUI.prototype, "shouldNotRender", null);
        return TwoDUI;
    }(wd.Component));
    wd.TwoDUI = TwoDUI;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EFontXAlignment) {
        EFontXAlignment[EFontXAlignment["LEFT"] = 0] = "LEFT";
        EFontXAlignment[EFontXAlignment["CENTER"] = 1] = "CENTER";
        EFontXAlignment[EFontXAlignment["RIGHT"] = 2] = "RIGHT";
    })(wd.EFontXAlignment || (wd.EFontXAlignment = {}));
    var EFontXAlignment = wd.EFontXAlignment;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EFontYAlignment) {
        EFontYAlignment[EFontYAlignment["TOP"] = 0] = "TOP";
        EFontYAlignment[EFontYAlignment["MIDDLE"] = 1] = "MIDDLE";
        EFontYAlignment[EFontYAlignment["BOTTOM"] = 2] = "BOTTOM";
    })(wd.EFontYAlignment || (wd.EFontYAlignment = {}));
    var EFontYAlignment = wd.EFontYAlignment;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDFont = (function (_super) {
        __extends(TwoDFont, _super);
        function TwoDFont() {
            _super.apply(this, arguments);
            this.needFormat = false;
            this._sizeChangeEventSubscription = null;
        }
        TwoDFont.prototype.init = function () {
            var self = this;
            _super.prototype.init.call(this);
            this._sizeChangeEventSubscription = wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.UI_WIDTH_CHANGE)
                .merge(wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.UI_HEIGHT_CHANGE))
                .subscribe(function () {
                self.dirty = true;
                self.needFormat = true;
            });
        };
        TwoDFont.prototype.dispose = function () {
            if (this._sizeChangeEventSubscription) {
                this._sizeChangeEventSubscription.dispose();
            }
        };
        TwoDFont.prototype.update = function (elapsed) {
            if (this.needFormat) {
                this.reFormat();
                this.needFormat = false;
            }
        };
        TwoDFont.prototype.reFormat = function () {
        };
        TwoDFont.prototype.getLeftCornerPosition = function () {
            var transform = this.entityObject.transform, position = transform.position;
            return wd.Vector2.create(position.x - transform.width / 2, position.y - transform.height / 2);
        };
        __decorate([
            wd.virtual
        ], TwoDFont.prototype, "reFormat", null);
        return TwoDFont;
    }(wd.TwoDUI));
    wd.TwoDFont = TwoDFont;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PlainFont = (function (_super) {
        __extends(PlainFont, _super);
        function PlainFont() {
            _super.apply(this, arguments);
            this._text = "";
            this._fontSize = 10;
            this._fontFamily = "sans-serif";
            this._xAlignment = wd.EFontXAlignment.LEFT;
            this._yAlignment = wd.EFontYAlignment.TOP;
            this._lineHeight = null;
            this._strArr = [];
            this._isLineHeightDirty = true;
            this._formater = wd.PlainFontFormater.create();
            this._drawer = wd.PlainFontDrawer.create();
        }
        PlainFont.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(PlainFont.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                if (this._text !== text) {
                    this.dirty = true;
                    this.needFormat = true;
                    this._text = text;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlainFont.prototype, "fontSize", {
            get: function () {
                return this._fontSize;
            },
            set: function (fontSize) {
                if (this._fontSize !== fontSize) {
                    this._fontSize = fontSize;
                    this.dirty = true;
                    this.needFormat = true;
                    this._isLineHeightDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlainFont.prototype, "fontFamily", {
            get: function () {
                return this._fontFamily;
            },
            set: function (fontFamily) {
                if (this._fontFamily !== fontFamily) {
                    this._fontFamily = fontFamily;
                    this.dirty = true;
                    this.needFormat = true;
                    this._isLineHeightDirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlainFont.prototype, "xAlignment", {
            get: function () {
                return this._xAlignment;
            },
            set: function (xAlignment) {
                if (this._xAlignment !== xAlignment) {
                    this._xAlignment = xAlignment;
                    this.dirty = true;
                    this.needFormat = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlainFont.prototype, "yAlignment", {
            get: function () {
                return this._yAlignment;
            },
            set: function (yAlignment) {
                if (this._yAlignment !== yAlignment) {
                    this._yAlignment = yAlignment;
                    this.dirty = true;
                    this.needFormat = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        PlainFont.prototype.init = function () {
            _super.prototype.init.call(this);
            if (this.needFormat) {
                this.reFormat();
                this.needFormat = false;
            }
        };
        PlainFont.prototype.setFillStyle = function (fillStyle) {
            this._drawer.setFillStyle(fillStyle);
        };
        PlainFont.prototype.enableStroke = function (strokeStyle, strokeSize) {
            this._drawer.enableStroke(strokeStyle, strokeSize);
        };
        PlainFont.prototype.enableFill = function (fillStyle) {
            this._drawer.enableFill(fillStyle);
        };
        PlainFont.prototype.setLineHeight = function (lineHeight) {
            this._lineHeight = lineHeight;
        };
        PlainFont.prototype.reFormat = function () {
            this._text = this._formater.trimStr(this._text);
            if (this.width !== 0) {
                this._strArr = this._text.split('\n');
                this._formater.formatText(this.context, this._strArr, this.width, this._fontSize, this._fontFamily);
            }
            if (this._isLineHeightDirty) {
                this._lineHeight = this._getDefaultLineHeight();
                this._isLineHeightDirty = false;
            }
        };
        PlainFont.prototype.draw = function () {
            this._drawer.draw({
                strArr: this._strArr,
                context: this.context,
                width: this.width,
                height: this.height,
                leftCornerPosition: this.getLeftCornerPosition(),
                lineHeight: this._lineHeight,
                xAlignment: this._xAlignment,
                yAlignment: this._yAlignment,
                fontSize: this._fontSize,
                fontFamily: this._fontFamily
            });
        };
        PlainFont.prototype._getDefaultLineHeight = function () {
            return wd.PlainFontUtils.computeLineHeight("normal", this._fontSize, this._fontFamily);
        };
        PlainFont.prototype._measure = function (text) {
            return wd.PlainFontUtils.measure(this.context, text, this._fontSize, this._fontFamily);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFont.prototype, "text", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFont.prototype, "fontSize", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFont.prototype, "fontFamily", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFont.prototype, "xAlignment", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFont.prototype, "yAlignment", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFont.prototype, "_lineHeight", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], PlainFont.prototype, "_drawer", void 0);
        return PlainFont;
    }(wd.TwoDFont));
    wd.PlainFont = PlainFont;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WORD_REX = /([a-zA-Z0-9]+|\S)/, FIRST_ENGLISH_OR_NUM = /^[a-zA-Z0-9]/, LAST_ENGLISH_OR_NUM = /[a-zA-Z0-9]+$/, LAST_INVALID_CHAR = /\s+$/;
    var PlainFontFormater = (function () {
        function PlainFontFormater() {
            this._strArr = null;
            this._context = null;
            this._fontSize = null;
            this._fontFamily = null;
        }
        PlainFontFormater.create = function () {
            var obj = new this();
            return obj;
        };
        PlainFontFormater.prototype.trimStr = function (text) {
            return text.replace(LAST_INVALID_CHAR, "");
        };
        PlainFontFormater.prototype.formatText = function (context, strArr, maxWidth, fontSize, fontFamily) {
            this._strArr = strArr;
            this._context = context;
            this._fontSize = fontSize;
            this._fontFamily = fontFamily;
            for (var i = 0; i < this._strArr.length; i++) {
                var text = this._strArr[i], allWidth = this._measure(text);
                if (allWidth > maxWidth && text.length > 1) {
                    this._formatMultiLine(i, text, allWidth, maxWidth);
                }
            }
        };
        PlainFontFormater.prototype._formatMultiLine = function (i, text, allWidth, maxWidth) {
            var _this = this;
            var LOOP_MAX_NUM = 100;
            var self = this, preText = null, truncationPointIndex = text.length * (maxWidth / allWidth) | 0, nextText = text.substr(truncationPointIndex), loopIndex = 0, width = allWidth - this._measure(nextText), pushNum = 0;
            var truncate = function () {
                while (width > maxWidth && loopIndex < LOOP_MAX_NUM) {
                    truncationPointIndex *= maxWidth / width;
                    truncationPointIndex = Math.floor(truncationPointIndex);
                    nextText = text.substr(truncationPointIndex);
                    width = allWidth - _this._measure(nextText);
                    loopIndex = loopIndex + 1;
                }
                loopIndex = 0;
            };
            var findTruncationPoint = function () {
                while (width < maxWidth && loopIndex < LOOP_MAX_NUM) {
                    if (nextText) {
                        var exec = WORD_REX.exec(nextText);
                        pushNum = exec ? exec[0].length : 1;
                    }
                    truncationPointIndex = truncationPointIndex + pushNum;
                    nextText = text.substr(truncationPointIndex);
                    width = allWidth - _this._measure(nextText);
                    loopIndex = loopIndex + 1;
                }
            };
            var handleTruncationPointIndex = function () {
                if (FIRST_ENGLISH_OR_NUM.test(nextText)) {
                    var preText_1 = text.substr(0, truncationPointIndex), pExec = LAST_ENGLISH_OR_NUM.exec(preText_1);
                    if (pExec) {
                        truncationPointIndex = truncationPointIndex - pExec[0].length;
                    }
                }
                else {
                    truncationPointIndex = truncationPointIndex - pushNum;
                }
                if (truncationPointIndex === 0) {
                    truncationPointIndex = 1;
                }
            };
            var setString = function () {
                nextText = text.substr(truncationPointIndex);
                preText = text.substr(0, truncationPointIndex);
                self._strArr[i] = nextText;
                self._strArr.splice(i, 0, preText);
            };
            truncate();
            findTruncationPoint();
            handleTruncationPointIndex();
            setString();
        };
        PlainFontFormater.prototype._measure = function (text) {
            return wd.PlainFontUtils.measure(this._context, text, this._fontSize, this._fontFamily);
        };
        return PlainFontFormater;
    }());
    wd.PlainFontFormater = PlainFontFormater;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PlainFontDrawer = (function () {
        function PlainFontDrawer() {
            this._context = null;
            this._strArr = null;
            this._leftCornerPosition = null;
            this._fontSize = null;
            this._fontFamily = null;
            this._maxWidth = null;
            this._height = null;
            this._lineHeight = null;
            this._xAlignment = null;
            this._yAlignment = null;
            this._fontClientHeightCache = wdCb.Hash.create();
            this._fillEnabled = true;
            this._fillStyle = "rgba(0, 0, 0, 1)";
            this._strokeEnabled = false;
            this._strokeStyle = null;
            this._strokeSize = null;
        }
        PlainFontDrawer.create = function () {
            var obj = new this();
            return obj;
        };
        PlainFontDrawer.prototype.setFillStyle = function (fillStyle) {
            this._fillStyle = fillStyle;
        };
        PlainFontDrawer.prototype.enableStroke = function (strokeStyle, strokeSize) {
            this._strokeEnabled = true;
            this._fillEnabled = false;
            this._strokeStyle = strokeStyle;
            this._strokeSize = strokeSize;
        };
        PlainFontDrawer.prototype.enableFill = function (fillStyle) {
            this._fillEnabled = true;
            this._strokeEnabled = false;
            this._fillStyle = fillStyle;
        };
        PlainFontDrawer.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        PlainFontDrawer.prototype.draw = function (data) {
            this._context = data.context;
            this._strArr = data.strArr;
            this._leftCornerPosition = data.leftCornerPosition;
            this._fontSize = data.fontSize;
            this._fontFamily = data.fontFamily;
            this._maxWidth = data.width;
            this._height = data.height;
            this._lineHeight = data.lineHeight;
            this._xAlignment = data.xAlignment;
            this._yAlignment = data.yAlignment;
            this._context.font = this._fontSize + "px '" + this._fontFamily + "'";
            this._context.textBaseline = "top";
            this._context.textAlign = "start";
            if (this._strArr.length > 1) {
                this._drawMultiLine();
            }
            else {
                this._drawSingleLine();
            }
        };
        PlainFontDrawer.prototype._getFontClientHeight = function () {
            var fontSize = this._fontSize, fontName = this._fontFamily, key = fontSize + "." + fontName, cacheHeight = this._fontClientHeightCache.getChild(key), height = null;
            if (cacheHeight) {
                return cacheHeight;
            }
            height = wd.PlainFontUtils.computeLineHeight(1, this._fontSize, this._fontFamily);
            this._fontClientHeightCache.addChild(key, height);
            return height;
        };
        PlainFontDrawer.prototype._drawMultiLine = function () {
            var context = this._context, position = this._leftCornerPosition, x = position.x, y = position.y, lineHeight = this._lineHeight, fontClientHeight = this._getFontClientHeight(), lineCount = this._strArr.length, lineTotalHeight = (lineCount - 1) * lineHeight + fontClientHeight;
            if (this._yAlignment === wd.EFontYAlignment.BOTTOM) {
                y = y + this._height - lineTotalHeight;
            }
            else if (this._yAlignment === wd.EFontYAlignment.MIDDLE) {
                y = y + (this._height - lineTotalHeight) / 2;
            }
            for (var _i = 0, _a = this._strArr; _i < _a.length; _i++) {
                var str = _a[_i];
                if (this._xAlignment === wd.EFontXAlignment.RIGHT) {
                    x = x + this._maxWidth - this._measure(str);
                }
                else if (this._xAlignment == wd.EFontXAlignment.CENTER) {
                    x = x + (this._maxWidth - this._measure(str)) / 2;
                }
                if (this._fillEnabled) {
                    context.fillStyle = this._fillStyle;
                    context.fillText(str, x, y);
                }
                else if (this._strokeEnabled) {
                    context.strokeStyle = this._strokeStyle;
                    context.lineWidth = this._strokeSize;
                    context.strokeText(str, x, y);
                }
                x = position.x;
                y = y + lineHeight;
            }
        };
        PlainFontDrawer.prototype._drawSingleLine = function () {
            var context = this._context, position = this._leftCornerPosition, x = position.x, y = position.y, fontClientHeight = this._getFontClientHeight(), lineCount = 1, lineTotalHeight = fontClientHeight, str = this._strArr[0];
            if (this._yAlignment === wd.EFontYAlignment.BOTTOM) {
                y = y + this._height - lineTotalHeight;
            }
            else if (this._yAlignment === wd.EFontYAlignment.MIDDLE) {
                y = y + (this._height - lineTotalHeight) / 2;
            }
            if (this._xAlignment === wd.EFontXAlignment.RIGHT) {
                x = x + this._maxWidth - this._measure(str);
            }
            else if (this._xAlignment == wd.EFontXAlignment.CENTER) {
                x = x + (this._maxWidth - this._measure(str)) / 2;
            }
            if (this._fillEnabled) {
                context.fillStyle = this._fillStyle;
                context.fillText(str, x, y);
            }
            else if (this._strokeEnabled) {
                context.strokeStyle = this._strokeStyle;
                context.lineWidth = this._strokeSize;
                context.strokeText(str, x, y);
            }
        };
        PlainFontDrawer.prototype._measure = function (text) {
            return wd.PlainFontUtils.measure(this._context, text, this._fontSize, this._fontFamily);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFontDrawer.prototype, "_fillEnabled", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFontDrawer.prototype, "_fillStyle", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFontDrawer.prototype, "_strokeEnabled", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFontDrawer.prototype, "_strokeStyle", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlainFontDrawer.prototype, "_strokeSize", void 0);
        return PlainFontDrawer;
    }());
    wd.PlainFontDrawer = PlainFontDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PlainFontUtils = (function () {
        function PlainFontUtils() {
        }
        PlainFontUtils.measure = function (context, text, fontSize, fontFamily) {
            context.font = fontSize + "px '" + fontFamily + "'";
            return context.measureText(text).width;
        };
        PlainFontUtils.computeLineHeight = function (lineHeight, fontSize, fontFamily) {
            var div = wdCb.DomQuery.create("<div></div>"), dom = div.get(0), resultLineHeight = null;
            dom.style.cssText = "\n             font-family: " + fontFamily + ";\n             font-size: " + fontSize + "px;\n             position: absolute;\n             left: -100px;\n             top: -100px;\n             line-height: " + lineHeight + ";\n             ";
            div.prependTo("body");
            dom.innerHTML = "abc!";
            resultLineHeight = dom.clientHeight;
            div.remove();
            return resultLineHeight;
        };
        return PlainFontUtils;
    }());
    wd.PlainFontUtils = PlainFontUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDBitmapFont = (function (_super) {
        __extends(TwoDBitmapFont, _super);
        function TwoDBitmapFont() {
            _super.apply(this, arguments);
            this._text = "";
            this._xAlignment = wd.EFontXAlignment.LEFT;
            this.fntId = null;
            this.bitmapId = null;
            this._charFontList = wdCb.Collection.create();
            this._layout = wd.BitmapFontLayout.create();
        }
        TwoDBitmapFont.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(TwoDBitmapFont.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                if (this._text !== text) {
                    this._text = text;
                    this.dirty = true;
                    this.needFormat = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TwoDBitmapFont.prototype, "xAlignment", {
            get: function () {
                return this._xAlignment;
            },
            set: function (xAlignment) {
                if (this._xAlignment !== xAlignment) {
                    this._xAlignment = xAlignment;
                    this.dirty = true;
                    this.needFormat = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        TwoDBitmapFont.prototype.init = function () {
            var imageAsset = this._getImageAsset();
            if (!imageAsset) {
                wd.Log.log("impossible to create font: not find bitmap file");
                return false;
            }
            _super.prototype.init.call(this);
            var layoutDataList = this._layout.getLayoutData(this.text, this.fntId, {
                width: this.width,
                align: this.xAlignment
            });
            if (layoutDataList) {
                this._createAndAddFontCharUIObjects(layoutDataList, imageAsset);
            }
            this.needFormat = false;
        };
        TwoDBitmapFont.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._removeAllCharFont();
        };
        TwoDBitmapFont.prototype.reFormat = function () {
            var imageAsset = this._getImageAsset();
            this._removeAllCharFont();
            if (!imageAsset) {
                wd.Log.log("impossible to create font: not find bitmap file");
                return false;
            }
            var layoutDataList = this._layout.getLayoutData(this.text, this.fntId, {
                width: this.width,
                align: this.xAlignment
            });
            if (layoutDataList) {
                this._createAndAddFontCharUIObjects(layoutDataList, imageAsset);
            }
        };
        TwoDBitmapFont.prototype._getImageAsset = function () {
            return wd.LoaderManager.getInstance().get(this.bitmapId);
        };
        TwoDBitmapFont.prototype._createAndAddFontCharUIObjects = function (layoutDataList, imageAsset) {
            var _this = this;
            var image = imageAsset.source, uiRenderer = this.getUIRenderer(), text = this.text, position = this.getLeftCornerPosition();
            layoutDataList.forEach(function (layoutData) {
                var glyphData = layoutData.data, rect = wd.RectRegion.create(glyphData.rect.x, glyphData.rect.y, glyphData.rect.width, glyphData.rect.height), _a = _this._createCharFont(layoutData.index, uiRenderer), charFontUIObject = _a.charFontUIObject, charFont = _a.charFont, transform = null;
                transform = charFontUIObject.transform;
                charFont.image = image;
                charFont.rectRegion = rect;
                transform.width = rect.width;
                transform.height = rect.height;
                charFont.char = text[layoutData.index];
                _this._addCharFontUIObject(charFontUIObject);
                _this._setCharFontUIObjectPosition(charFontUIObject, position.x + layoutData.position[0], position.y + layoutData.position[1]);
            });
        };
        TwoDBitmapFont.prototype._createCharFont = function (index, uiRenderer) {
            var charFontUIObject = wd.UIObject.create(), charFont = wd.CharFont.create();
            charFontUIObject.addComponent(charFont);
            charFontUIObject.addComponent(uiRenderer);
            charFontUIObject.addTag(String(index));
            charFontUIObject.init();
            return {
                charFontUIObject: charFontUIObject,
                charFont: charFont
            };
        };
        TwoDBitmapFont.prototype._addCharFontUIObject = function (charFontUIObject) {
            this._charFontList.addChild(charFontUIObject);
            this.entityObject.addChild(charFontUIObject);
        };
        TwoDBitmapFont.prototype._setCharFontUIObjectPosition = function (charFontUIObject, x, y) {
            var transform = charFontUIObject.transform;
            charFontUIObject.transform.position = wd.CoordinateUtils.convertLeftCornerPositionToCenterPositionInCanvas(wd.Vector2.create(x, y), transform.width, transform.height);
        };
        TwoDBitmapFont.prototype._removeAllCharFont = function () {
            this._charFontList.forEach(function (charFont) {
                charFont.dispose();
            });
            this._charFontList.removeAllChildren();
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TwoDBitmapFont.prototype, "text", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TwoDBitmapFont.prototype, "xAlignment", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TwoDBitmapFont.prototype, "fntId", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TwoDBitmapFont.prototype, "bitmapId", void 0);
        return TwoDBitmapFont;
    }(wd.TwoDFont));
    wd.TwoDBitmapFont = TwoDBitmapFont;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CharFont = (function (_super) {
        __extends(CharFont, _super);
        function CharFont() {
            _super.apply(this, arguments);
            this._char = null;
            this.startPosX = null;
            this.xAdvance = null;
            this.image = null;
            this.rectRegion = null;
            this._subscription = null;
        }
        CharFont.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(CharFont.prototype, "x", {
            get: function () {
                return this.entityObject.transform.position.x;
            },
            set: function (x) {
                var position = this.entityObject.transform.position;
                this.entityObject.transform.position = wd.Vector2.create(x, position.y);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CharFont.prototype, "y", {
            get: function () {
                return this.entityObject.transform.position.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CharFont.prototype, "char", {
            get: function () {
                return this._char;
            },
            set: function (char) {
                if (this._char !== null) {
                    wd.Log.log(wd.Log.info.FUNC_NOT_SUPPORT("change char"));
                    return;
                }
                this._char = char;
            },
            enumerable: true,
            configurable: true
        });
        CharFont.prototype.clone = function () {
            wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("clone"));
            return null;
        };
        CharFont.prototype.init = function () {
            var self = this;
            _super.prototype.init.call(this);
            this._subscription = wdFrp.fromArray([wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.TRANSFORM_TRANSLATE), wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.TRANSFORM_ROTATE), wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.TRANSFORM_SCALE)])
                .mergeAll()
                .subscribe(function () {
                self.dirty = true;
            });
        };
        CharFont.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._subscription.dispose();
        };
        CharFont.prototype.shouldNotRender = function () {
            return this.rectRegion === null || (this.width === 0 && this.height === 0);
        };
        CharFont.prototype.draw = function () {
            var transform = null, position = null, dw = null, dh = null;
            transform = this.entityObject.transform;
            position = transform.position;
            dw = this.width;
            dh = this.height;
            this.drawInCenterPoint(this.context, this.image, this.rectRegion.x, this.rectRegion.y, this.rectRegion.width, this.rectRegion.height, position, dw, dh);
        };
        __decorate([
            wd.execOnlyOnce("_isInit")
        ], CharFont.prototype, "init", null);
        return CharFont;
    }(wd.TwoDFont));
    wd.CharFont = CharFont;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ProgressBar = (function (_super) {
        __extends(ProgressBar, _super);
        function ProgressBar() {
            _super.apply(this, arguments);
            this._percent = 0;
            this.borderStyle = "rgba(0, 0, 0, 1)";
            this.fillStyle = "rgba(255, 0, 0, 1)";
            this.radius = 5;
            this._offScreenCanvas = null;
            this._offScreenContext = null;
        }
        ProgressBar.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(ProgressBar.prototype, "percent", {
            get: function () {
                return this._percent;
            },
            set: function (percent) {
                if (this._percent !== percent) {
                    this._percent = percent;
                    this.dirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        ProgressBar.prototype.init = function () {
            _super.prototype.init.call(this);
            this._createOffScreenCanvas();
            this._drawProgressBar();
        };
        ProgressBar.prototype.shouldNotRender = function () {
            return this.percent <= 0;
        };
        ProgressBar.prototype.draw = function () {
            var position = this.entityObject.transform.position;
            this._drawFromLeft(position);
            this._drawBorder(position);
        };
        ProgressBar.prototype._drawFromLeft = function (position) {
            var offscreenCanvas = this._offScreenCanvas, loadedWidth = this.width * this.percent;
            this.drawInCenterPoint(this.context, offscreenCanvas, 0, 0, loadedWidth, this.height, wd.Vector2.create(position.x - this.width / 2 + loadedWidth / 2, position.y), loadedWidth, this.height);
        };
        ProgressBar.prototype._drawBorder = function (position) {
            wd.RoundedRectUtils.drawRoundedRect(this.context, this.borderStyle, null, position.x - this.width / 2, position.y - this.height / 2, this.width, this.height, this.radius);
        };
        ProgressBar.prototype._createOffScreenCanvas = function () {
            var canvas = wdCb.DomQuery.create("<canvas></canvas>");
            canvas.attr("width", this.context.canvas.width);
            canvas.attr("height", this.context.canvas.height);
            this._offScreenCanvas = canvas.get(0);
            this._offScreenContext = this._offScreenCanvas.getContext("2d");
        };
        ProgressBar.prototype._drawProgressBar = function () {
            this._offScreenContext.clearRect(0, 0, this._offScreenCanvas.width, this._offScreenCanvas.height);
            wd.RoundedRectUtils.drawRoundedRect(this._offScreenContext, this.borderStyle, this.fillStyle, 0, 0, this.width, this.height, this.radius);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ProgressBar.prototype, "percent", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ProgressBar.prototype, "borderStyle", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ProgressBar.prototype, "fillStyle", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ProgressBar.prototype, "radius", void 0);
        __decorate([
            wd.require(function () {
                wd.assert(this.percent >= 0 && this.percent <= 1, wd.Log.info.FUNC_SHOULD("percent", " >= 0 and <= 1"));
            })
        ], ProgressBar.prototype, "draw", null);
        return ProgressBar;
    }(wd.TwoDUI));
    wd.ProgressBar = ProgressBar;
})(wd || (wd = {}));
var wd;
(function (wd) {
    function _canUseNewCanvasBlendModes() {
        var canvas = null, context = null;
        if (typeof document === 'undefined') {
            return false;
        }
        canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        context = canvas.getContext('2d');
        context.fillStyle = '#000';
        context.fillRect(0, 0, 1, 1);
        context.globalCompositeOperation = 'multiply';
        context.fillStyle = '#fff';
        context.fillRect(0, 0, 1, 1);
        return context.getImageData(0, 0, 1, 1).data[0] === 0;
    }
    var Image = (function (_super) {
        __extends(Image, _super);
        function Image() {
            _super.apply(this, arguments);
            this._source = null;
            this.color = null;
            this.targetSource = null;
            this.targetColor = null;
        }
        Image.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(Image.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (source) {
                if (source !== this._source) {
                    this._source = source;
                    this.dirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Image.prototype.shouldNotRender = function () {
            return this._getDrawSource() === null && this._getDrawColor() === null;
        };
        Image.prototype.draw = function () {
            var drawColor = this._getDrawColor(), drawSource = this._getDrawSource();
            if (drawColor !== null) {
                var position = this.entityObject.transform.position;
                this._setFillStyle(drawColor.toString());
                if (drawColor.a < 1) {
                    this._setGlobalAlpha(this.context, drawColor.a);
                }
                this.context.fillRect(position.x - this.width / 2, position.y - this.height / 2, this.width, this.height);
                if (drawSource) {
                    this._blendColorWithSource();
                }
            }
            else {
                this.drawInCenterPoint(this.context, drawSource.source, this.entityObject.transform.position, this.width, this.height);
            }
        };
        Image.prototype._setFillStyle = function (style) {
            this.context.fillStyle = style;
        };
        Image.prototype._getDrawSource = function () {
            if (this.targetSource) {
                return this.targetSource;
            }
            return this.source;
        };
        Image.prototype._getDrawColor = function () {
            if (this.targetColor) {
                return this.targetColor;
            }
            return this.color;
        };
        Image.prototype._blendByMultiply = function () {
            this._setGlobalCompositeOperation(this.context, "multiply");
            this.drawInCenterPoint(this.context, this._getDrawSource().source, this.entityObject.transform.position, this.width, this.height);
        };
        Image.prototype._blendByPerPixel = function () {
            var context = this.context, canvas = this.getCanvas(), r = this.color.r, g = this.color.g, b = this.color.b, pixelData = null, pixels = null;
            context.globalCompositeOperation = "clone";
            this.drawInCenterPoint(this.context, this._getDrawSource().source, this.entityObject.transform.position, this.width, this.height);
            pixelData = context.getImageData(0, 0, canvas.width, canvas.height);
            pixels = pixelData.data;
            for (var i = 0, len = pixels.length; i < len; i += 4) {
                pixels[i] *= r;
                pixels[i + 1] *= g;
                pixels[i + 2] *= b;
            }
            context.putImageData(pixelData, 0, 0);
        };
        Image.prototype._setGlobalCompositeOperation = function (context, mode) {
            context.globalCompositeOperation = mode;
        };
        Image.prototype._setGlobalAlpha = function (context, alpha) {
            context.globalAlpha = alpha;
        };
        Image.constructorForBlend = function (obj) {
            obj._blendColorWithSource = _canUseNewCanvasBlendModes() ?
                obj._blendByMultiply : obj._blendByPerPixel;
            return true;
        };
        Image.constructorInitForBlend = Image.constructorForBlend(Image.prototype);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Image.prototype, "source", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Image.prototype, "color", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                if (source[memberName]) {
                    target[memberName] = wd.ImageTextureAsset.create(source[memberName].source);
                }
            })
        ], Image.prototype, "targetSource", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Image.prototype, "targetColor", void 0);
        __decorate([
            wd.require(function () {
                wd.assert(!!this._getDrawSource(), wd.Log.info.FUNC_SHOULD("source", "exist"));
            })
        ], Image.prototype, "_blendByMultiply", null);
        __decorate([
            wd.require(function () {
                wd.assert(!!this._getDrawSource(), wd.Log.info.FUNC_SHOULD("source", "exist"));
            })
        ], Image.prototype, "_blendByPerPixel", null);
        return Image;
    }(wd.TwoDUI));
    wd.Image = Image;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var InteractionUI = (function (_super) {
        __extends(InteractionUI, _super);
        function InteractionUI() {
            _super.apply(this, arguments);
            this.p_transitionMode = null;
            this.transitionManager = wd.TransitionManager.create(this);
        }
        Object.defineProperty(InteractionUI.prototype, "transitionMode", {
            get: function () {
                return this.p_transitionMode;
            },
            set: function (transitionMode) {
                this.p_transitionMode = transitionMode;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], InteractionUI.prototype, "transitionMode", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], InteractionUI.prototype, "transitionManager", void 0);
        return InteractionUI;
    }(wd.TwoDUI));
    wd.InteractionUI = InteractionUI;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Button = (function (_super) {
        __extends(Button, _super);
        function Button() {
            _super.apply(this, arguments);
            this._text = null;
            this._pointdownSubscription = null;
            this._pointupSubscription = null;
            this._pointoverSubscription = null;
            this._pointoutSubscription = null;
            this._stateMachine = wd.UIStateMachine.create(this);
        }
        Button.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(Button.prototype, "text", {
            get: function () {
                var fontObject = null;
                if (this.entityObject === null) {
                    return this._text;
                }
                fontObject = this.getObject(wd.EButtonObjectName.TEXT);
                if (fontObject) {
                    return fontObject.getComponent(wd.PlainFont).text;
                }
                return null;
            },
            set: function (text) {
                var fontObject = null;
                this._text = text;
                if (this.entityObject === null || !this.getUIRenderer()) {
                    return;
                }
                fontObject = this.getObject(wd.EButtonObjectName.TEXT);
                if (fontObject) {
                    fontObject.getComponent(wd.PlainFont).text = text;
                }
                else {
                    this.entityObject.addChild(this._createFontObject());
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Button.prototype, "isDisabled", {
            get: function () {
                return this._stateMachine.currentState === wd.EUIState.DISABLED;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Button.prototype, "currentState", {
            get: function () {
                return this._stateMachine.currentState;
            },
            enumerable: true,
            configurable: true
        });
        Button.prototype.initWhenCreate = function () {
            this.transitionMode = wd.ETransitionMode.SPRITE;
            this.text = "button";
        };
        Button.prototype.init = function () {
            _super.prototype.init.call(this);
            this.entityObject.addChild(this._createBackgroundObject());
            if (!this._hasFontObject()) {
                this.entityObject.addChild(this._createFontObject());
            }
            this._bindEvent();
        };
        Button.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._pointdownSubscription.dispose();
            this._pointupSubscription.dispose();
            this._pointoverSubscription.dispose();
            this._pointoutSubscription.dispose();
        };
        Button.prototype.getObject = function (objectName) {
            return this.entityObject.findChildByName(objectName);
        };
        Button.prototype.getObjectTransition = function (objectName) {
            return this.transitionManager.getObjectTransition(objectName);
        };
        Button.prototype.enable = function () {
            this._stateMachine.changeState(wd.EUIState.NORMAL);
        };
        Button.prototype.disable = function () {
            this._stateMachine.changeState(wd.EUIState.DISABLED);
        };
        Button.prototype.update = function (elapsed) {
            var target = this.transitionManager.getObjectTarget(wd.EButtonObjectName.BACKGROUND);
            if (!target) {
                var image = this.getObject(wd.EButtonObjectName.BACKGROUND).getComponent(wd.Image);
                switch (this.p_transitionMode) {
                    case wd.ETransitionMode.SPRITE:
                        image.targetSource = null;
                        break;
                    case wd.ETransitionMode.COLOR:
                        image.targetColor = null;
                        break;
                    default:
                        wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("transitionMode"));
                        break;
                }
                return;
            }
            switch (this.p_transitionMode) {
                case wd.ETransitionMode.SPRITE:
                    this.getObject(wd.EButtonObjectName.BACKGROUND).getComponent(wd.Image).targetSource = target;
                    break;
                case wd.ETransitionMode.COLOR:
                    this.getObject(wd.EButtonObjectName.BACKGROUND).getComponent(wd.Image).targetColor = target;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("transitionMode"));
                    break;
            }
        };
        Button.prototype.render = function () {
        };
        Button.prototype._createBackgroundObject = function () {
            var object = wd.UIObject.create(), image = wd.Image.create(), transform = this.entityObject.transform;
            object.addComponent(image);
            object.addComponent(this.getUIRenderer());
            object.transform.width = transform.width;
            object.transform.height = transform.height;
            object.transform.zIndex = 1;
            object.name = wd.EButtonObjectName.BACKGROUND;
            wd.CloneUtils.markNotClone(object);
            return object;
        };
        Button.prototype._createFontObject = function () {
            var fontObject = wd.UIObject.create(), font = wd.PlainFont.create(), transform = this.entityObject.transform;
            font.text = this._text;
            font.enableFill("#000000");
            font.xAlignment = wd.EFontXAlignment.CENTER;
            font.yAlignment = wd.EFontYAlignment.MIDDLE;
            fontObject.addComponent(font);
            fontObject.addComponent(this.getUIRenderer());
            fontObject.transform.width = transform.width;
            fontObject.transform.height = transform.height;
            fontObject.transform.zIndex = 2;
            fontObject.name = wd.EButtonObjectName.TEXT;
            wd.CloneUtils.markNotClone(fontObject);
            return fontObject;
        };
        Button.prototype._hasFontObject = function () {
            return !!this.getObject(wd.EButtonObjectName.TEXT);
        };
        Button.prototype._bindEvent = function () {
            var self = this;
            this._pointdownSubscription = wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.POINT_DOWN)
                .filter(function (e) {
                return !self.isDisabled;
            })
                .subscribe(function (e) {
                self._stateMachine.changeState(wd.EUIState.PRESSED);
            });
            this._pointupSubscription = wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.POINT_UP)
                .filter(function (e) {
                return !self.isDisabled;
            })
                .subscribe(function (e) {
                self._stateMachine.backState();
            });
            this._pointoverSubscription = wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.POINT_OVER)
                .filter(function (e) {
                return !self.isDisabled;
            })
                .subscribe(function (e) {
                self._stateMachine.changeState(wd.EUIState.HIGHLIGHT);
            });
            this._pointoutSubscription = wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.POINT_OUT)
                .filter(function (e) {
                return !self.isDisabled;
            })
                .subscribe(function (e) {
                if (self._stateMachine.isState(wd.EUIState.PRESSED)) {
                    self._stateMachine.backState();
                    self._stateMachine.backState();
                }
                else {
                    self._stateMachine.backState();
                }
            });
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Button.prototype, "_text", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Button.prototype, "_stateMachine", void 0);
        __decorate([
            wd.require(function () {
                wd.assert(this.getObject(wd.EButtonObjectName.BACKGROUND).hasComponent(wd.Image), wd.Log.info.FUNC_SHOULD("Button UIObject", "contain Image component"));
            })
        ], Button.prototype, "update", null);
        return Button;
    }(wd.InteractionUI));
    wd.Button = Button;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EButtonObjectName) {
        EButtonObjectName[EButtonObjectName["BACKGROUND"] = "background"] = "BACKGROUND";
        EButtonObjectName[EButtonObjectName["TEXT"] = "text"] = "TEXT";
    })(wd.EButtonObjectName || (wd.EButtonObjectName = {}));
    var EButtonObjectName = wd.EButtonObjectName;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EUIState) {
        EUIState[EUIState["NORMAL"] = 0] = "NORMAL";
        EUIState[EUIState["HIGHLIGHT"] = 1] = "HIGHLIGHT";
        EUIState[EUIState["PRESSED"] = 2] = "PRESSED";
        EUIState[EUIState["DISABLED"] = 3] = "DISABLED";
    })(wd.EUIState || (wd.EUIState = {}));
    var EUIState = wd.EUIState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var UIStateMachine = (function () {
        function UIStateMachine(ui) {
            this._ui = null;
            this._stateHistory = wdCb.Stack.create();
            this._ui = ui;
        }
        UIStateMachine.create = function (ui) {
            var obj = new this(ui);
            return obj;
        };
        Object.defineProperty(UIStateMachine.prototype, "transitionManager", {
            get: function () {
                return this._ui.transitionManager;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIStateMachine.prototype, "currentState", {
            get: function () {
                return this._stateHistory.top || wd.EUIState.NORMAL;
            },
            enumerable: true,
            configurable: true
        });
        UIStateMachine.prototype.clone = function (machine) {
            return wd.CloneUtils.clone(this, null, null, machine);
        };
        UIStateMachine.prototype.changeState = function (state) {
            this._stateHistory.push(state);
            this.transitionManager.changeState(state);
            this._ui.dirty = true;
        };
        UIStateMachine.prototype.backState = function () {
            var lastState = null;
            this._stateHistory.pop();
            lastState = this._stateHistory.top;
            if (!lastState) {
                lastState = wd.EUIState.NORMAL;
            }
            this.transitionManager.changeState(lastState);
            this._ui.dirty = true;
        };
        UIStateMachine.prototype.isState = function (state) {
            return this.currentState === state;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], UIStateMachine.prototype, "_stateHistory", void 0);
        return UIStateMachine;
    }());
    wd.UIStateMachine = UIStateMachine;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Transition = (function () {
        function Transition() {
            this._target = null;
        }
        Object.defineProperty(Transition.prototype, "target", {
            get: function () {
                if (this._target === null) {
                    this.changeState(wd.EUIState.NORMAL);
                }
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: true,
            configurable: true
        });
        Transition.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        return Transition;
    }());
    wd.Transition = Transition;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SpriteTransition = (function (_super) {
        __extends(SpriteTransition, _super);
        function SpriteTransition() {
            _super.apply(this, arguments);
            this.normalSprite = null;
            this.highlightSprite = null;
            this.pressedSprite = null;
            this.disabledSprite = null;
        }
        SpriteTransition.create = function () {
            var obj = new this();
            return obj;
        };
        SpriteTransition.prototype.changeState = function (state) {
            switch (state) {
                case wd.EUIState.NORMAL:
                    this.target = this.normalSprite;
                    break;
                case wd.EUIState.HIGHLIGHT:
                    this.target = this.highlightSprite;
                    break;
                case wd.EUIState.PRESSED:
                    this.target = this.pressedSprite;
                    break;
                case wd.EUIState.DISABLED:
                    this.target = this.disabledSprite;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("state"));
                    break;
            }
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SpriteTransition.prototype, "normalSprite", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SpriteTransition.prototype, "highlightSprite", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SpriteTransition.prototype, "pressedSprite", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SpriteTransition.prototype, "disabledSprite", void 0);
        return SpriteTransition;
    }(wd.Transition));
    wd.SpriteTransition = SpriteTransition;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ColorTransition = (function (_super) {
        __extends(ColorTransition, _super);
        function ColorTransition() {
            _super.apply(this, arguments);
            this.normalColor = null;
            this.highlightColor = null;
            this.pressedColor = null;
            this.disabledColor = null;
        }
        ColorTransition.create = function () {
            var obj = new this();
            return obj;
        };
        ColorTransition.prototype.changeState = function (state) {
            switch (state) {
                case wd.EUIState.NORMAL:
                    this.target = this.normalColor;
                    break;
                case wd.EUIState.HIGHLIGHT:
                    this.target = this.highlightColor;
                    break;
                case wd.EUIState.PRESSED:
                    this.target = this.pressedColor;
                    break;
                case wd.EUIState.DISABLED:
                    this.target = this.disabledColor;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("state"));
                    break;
            }
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ColorTransition.prototype, "normalColor", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ColorTransition.prototype, "highlightColor", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ColorTransition.prototype, "pressedColor", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ColorTransition.prototype, "disabledColor", void 0);
        return ColorTransition;
    }(wd.Transition));
    wd.ColorTransition = ColorTransition;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETransitionMode) {
        ETransitionMode[ETransitionMode["SPRITE"] = 0] = "SPRITE";
        ETransitionMode[ETransitionMode["COLOR"] = 1] = "COLOR";
    })(wd.ETransitionMode || (wd.ETransitionMode = {}));
    var ETransitionMode = wd.ETransitionMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TransitionManager = (function () {
        function TransitionManager(ui) {
            this._ui = null;
            this._spriteTransitionMap = wdCb.Hash.create();
            this._colorTransitionMap = wdCb.Hash.create();
            this._ui = ui;
        }
        TransitionManager.create = function (ui) {
            var obj = new this(ui);
            return obj;
        };
        TransitionManager.prototype.clone = function (manager) {
            return wd.CloneUtils.clone(this, null, null, manager);
        };
        TransitionManager.prototype.getObjectTransition = function (objectName) {
            var result = this._getTransitionMap().getChild(objectName);
            if (!result) {
                result = this._createTransitionInstance();
                this._getTransitionMap().addChild(objectName, result);
            }
            return result;
        };
        TransitionManager.prototype.getObjectTarget = function (objectName) {
            return this.getObjectTransition(objectName).target;
        };
        TransitionManager.prototype.changeState = function (state) {
            wdFrp.fromArray([
                this._spriteTransitionMap,
                this._colorTransitionMap
            ])
                .subscribe(function (map) {
                map.forEach(function (transition) {
                    transition.changeState(state);
                });
            });
        };
        TransitionManager.prototype._getTransitionMap = function () {
            var map = null;
            switch (this._ui.transitionMode) {
                case wd.ETransitionMode.SPRITE:
                    map = this._spriteTransitionMap;
                    break;
                case wd.ETransitionMode.COLOR:
                    map = this._colorTransitionMap;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("transitionMode"));
                    break;
            }
            return map;
        };
        TransitionManager.prototype._createTransitionInstance = function () {
            var transition = null;
            switch (this._ui.transitionMode) {
                case wd.ETransitionMode.SPRITE:
                    transition = wd.SpriteTransition.create();
                    break;
                case wd.ETransitionMode.COLOR:
                    transition = wd.ColorTransition.create();
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("transitionMode"));
                    break;
            }
            return transition;
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = source[memberName].clone(true);
            })
        ], TransitionManager.prototype, "_spriteTransitionMap", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = source[memberName].clone(true);
            })
        ], TransitionManager.prototype, "_colorTransitionMap", void 0);
        return TransitionManager;
    }());
    wd.TransitionManager = TransitionManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RoundedRectUtils = (function () {
        function RoundedRectUtils() {
        }
        RoundedRectUtils.drawRoundedRect = function (context, strokeStyle, fillStyle, cornerX, cornerY, width, height, cornerRadius) {
            context.save();
            context.beginPath();
            if (width > 0) {
                context.moveTo(cornerX + cornerRadius, cornerY);
            }
            else {
                context.moveTo(cornerX - cornerRadius, cornerY);
            }
            context.arcTo(cornerX + width, cornerY, cornerX + width, cornerY + height, cornerRadius);
            context.arcTo(cornerX + width, cornerY + height, cornerX, cornerY + height, cornerRadius);
            context.arcTo(cornerX, cornerY + height, cornerX, cornerY, cornerRadius);
            if (width > 0) {
                context.arcTo(cornerX, cornerY, cornerX + cornerRadius, cornerY, cornerRadius);
            }
            else {
                context.arcTo(cornerX, cornerY, cornerX - cornerRadius, cornerY, cornerRadius);
            }
            context.closePath();
            context.strokeStyle = strokeStyle;
            context.fillStyle = fillStyle;
            if (strokeStyle) {
                context.stroke();
            }
            if (fillStyle) {
                context.fill();
            }
            context.restore();
        };
        return RoundedRectUtils;
    }());
    wd.RoundedRectUtils = RoundedRectUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var UIRendererUtils = (function () {
        function UIRendererUtils() {
        }
        UIRendererUtils.getUIRenderer = function (uiObject) {
            if (!uiObject) {
                return null;
            }
            return uiObject.getComponent(wd.UIRenderer);
        };
        return UIRendererUtils;
    }());
    wd.UIRendererUtils = UIRendererUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ComponentInitOrderTable = (function () {
        function ComponentInitOrderTable() {
        }
        ComponentInitOrderTable.getOrder = function (component) {
            if (component instanceof wd.SourceInstance) {
                return 1;
            }
            if (wd.JudgeUtils.isClass(component, "Shadow")) {
                return 2;
            }
            if (wd.JudgeUtils.isClass(component, "ThreeDBitmapFont")) {
                return 3;
            }
            if (component instanceof wd.Geometry) {
                return 4;
            }
            return 5;
        };
        return ComponentInitOrderTable;
    }());
    wd.ComponentInitOrderTable = ComponentInitOrderTable;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Instance = (function (_super) {
        __extends(Instance, _super);
        function Instance() {
            _super.apply(this, arguments);
        }
        Instance.prototype.addToObject = function (entityObject, isShareComponent) {
            if (isShareComponent === void 0) { isShareComponent = false; }
            _super.prototype.addToObject.call(this, entityObject, isShareComponent);
        };
        Instance.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        __decorate([
            wd.require(function (entityObject) {
                wd.assert(entityObject instanceof wd.GameObject, wd.Log.info.FUNC_SHOULD("Instance component", "add to GameObject"));
            })
        ], Instance.prototype, "addToObject", null);
        return Instance;
    }(wd.Component));
    wd.Instance = Instance;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SourceInstance = (function (_super) {
        __extends(SourceInstance, _super);
        function SourceInstance() {
            _super.apply(this, arguments);
            this._instanceBuffer = null;
        }
        Object.defineProperty(SourceInstance.prototype, "instanceBuffer", {
            get: function () {
                if (this._instanceBuffer === null) {
                    this._instanceBuffer = wd.InstanceBuffer.create();
                }
                return this._instanceBuffer;
            },
            enumerable: true,
            configurable: true
        });
        return SourceInstance;
    }(wd.Instance));
    wd.SourceInstance = SourceInstance;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToOneSourceInstance = (function (_super) {
        __extends(OneToOneSourceInstance, _super);
        function OneToOneSourceInstance() {
            _super.apply(this, arguments);
            this.instanceList = wdCb.Collection.create();
            this._toRenderInstanceList = wdCb.Collection.create();
            this._endLoopSubscription = null;
            this._isAddSourceInstanceToChildren = false;
            this._enterSubscription = null;
            this._exitSubscription = null;
        }
        OneToOneSourceInstance.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(OneToOneSourceInstance.prototype, "toRenderInstanceListForDraw", {
            get: function () {
                if (!this.hasToRenderInstance()) {
                    this._toRenderInstanceList = this.defaultToRenderInstanceList;
                }
                return this._toRenderInstanceList;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneToOneSourceInstance.prototype, "defaultToRenderInstanceList", {
            get: function () {
                return wdCb.Collection.create().addChild(this.entityObject).addChildren(this.instanceList);
            },
            enumerable: true,
            configurable: true
        });
        OneToOneSourceInstance.prototype.init = function () {
            var self = this;
            if (!this._isAddSourceInstanceToChildren) {
                this._addSourceInstanceToChildren();
            }
            this._endLoopSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.ENDLOOP)
                .subscribe(function () {
                self._toRenderInstanceList.removeAllChildren();
            });
            this._enterSubscription = wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.ENTER)
                .subscribe(function () {
                self._addAllInstances();
            });
            this._exitSubscription = wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.EXIT)
                .subscribe(function () {
                self._removeAllInstances();
            });
        };
        OneToOneSourceInstance.prototype.dispose = function () {
            this._endLoopSubscription.dispose();
            this._enterSubscription.dispose();
            this._exitSubscription.dispose();
            this.instanceList.forEach(function (instance) {
                instance.dispose();
            });
        };
        OneToOneSourceInstance.prototype.cloneInstance = function (name) {
            var _this = this;
            var self = this;
            var clone = function (name, entityObject) {
                var instance = wd.GameObject.create(), objectInstanceComponent = wd.ObjectInstance.create(), sourceInstanceList = null;
                sourceInstanceList = entityObject.getComponent(OneToOneSourceInstance).instanceList;
                instance.name = name;
                _this._addComponentsFromSourceToObject(entityObject, instance);
                objectInstanceComponent.sourceObject = entityObject;
                instance.addComponent(objectInstanceComponent);
                instance.bubbleParent = entityObject.bubbleParent;
                instance.parent = entityObject.parent;
                instance.isVisible = entityObject.isVisible;
                entityObject.getTagList().forEach(function (tag) {
                    instance.addTag(tag);
                });
                sourceInstanceList.addChild(instance);
                entityObject.forEach(function (child) {
                    instance.addChild(clone(self._buildInstanceChildName(name, child.name), child));
                });
                return instance;
            };
            this._addSourceInstanceToChildren();
            this._isAddSourceInstanceToChildren = true;
            return clone(name, this.entityObject);
        };
        OneToOneSourceInstance.prototype.hasToRenderInstance = function () {
            return this._toRenderInstanceList && this._toRenderInstanceList.getCount() > 0;
        };
        OneToOneSourceInstance.prototype.addToRenderIntance = function (instanceObj) {
            this._toRenderInstanceList.addChild(instanceObj);
        };
        OneToOneSourceInstance.prototype.forEachToRenderInstanceList = function (func) {
            this._toRenderInstanceList.forEach(func);
        };
        OneToOneSourceInstance.prototype._addComponentsFromSourceToObject = function (source, instance) {
            instance.removeComponent(wd.Transform);
            source.forEachComponent(function (component) {
                if (component instanceof OneToOneSourceInstance
                    || wd.JudgeUtils.isClass(component, "GeometryLOD")) {
                    return;
                }
                if (component instanceof wd.Geometry) {
                    instance.addComponent(component, true);
                }
                else {
                    instance.addComponent(component.clone());
                }
            });
        };
        OneToOneSourceInstance.prototype._addSourceInstanceToChildren = function () {
            var add = function (child) {
                if (!wd.InstanceUtils.isOneToOneSourceInstance(child)) {
                    var sourceInstanceComponent = OneToOneSourceInstance.create();
                    child.addComponent(sourceInstanceComponent);
                    child.forEach(function (c) {
                        add(c);
                    });
                }
            };
            this.entityObject.forEach(function (child) {
                add(child);
            });
        };
        OneToOneSourceInstance.prototype._addAllInstances = function () {
            var parent = this.entityObject.parent, tag = (wd.EInstanceTag.isAddSourceInstance);
            this.instanceList.forEach(function (instance) {
                instance.addTag(tag);
                parent.addChild(instance);
                instance.removeTag(tag);
            });
        };
        OneToOneSourceInstance.prototype._removeAllInstances = function () {
            var tag = (wd.EInstanceTag.isRemoveSourceInstance);
            this.instanceList.forEach(function (instance) {
                instance.addTag(tag);
                instance.parent.removeChild(instance);
                instance.removeTag(tag);
            });
        };
        OneToOneSourceInstance.prototype._buildInstanceChildName = function (parentName, childName) {
            return parentName + "_" + childName;
        };
        __decorate([
            wd.ensureGetter(function (toRenderInstanceListForDraw) {
                var _this = this;
                wd.it("should not be empty", function () {
                    wd.expect(toRenderInstanceListForDraw.getCount()).greaterThan(0);
                });
                wd.it("should render self entityObject or the entityObject in instanceList", function () {
                    toRenderInstanceListForDraw.forEach(function (instance) {
                        wd.expect(wd.JudgeUtils.isEqual(instance, _this.entityObject) || _this.instanceList.hasChild(instance)).true;
                    });
                }, this);
                wd.it("shouldn't has repeat instance which is to render", function () {
                    wd.expect(toRenderInstanceListForDraw.hasRepeatItems()).false;
                });
            })
        ], OneToOneSourceInstance.prototype, "toRenderInstanceListForDraw", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], OneToOneSourceInstance.prototype, "instanceList", void 0);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("children should contain OneToOneSourceInstance component", function () {
                    _this.entityObject.forEach(function (child) {
                        wd.IterateUtils.forEachAll(child, function (child) {
                            wd.expect(wd.InstanceUtils.isOneToOneSourceInstance(child)).true;
                        });
                    });
                }, this);
            })
        ], OneToOneSourceInstance.prototype, "init", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("instance is not only in instanceList but also in loop", function () {
                    var scene = null, children = null, isInLoop = true;
                    if (_this.instanceList.getCount() === 0) {
                        return;
                    }
                    scene = wd.Director.getInstance().scene;
                    children = wdCb.Collection.create();
                    wd.IterateUtils.forEachAll(scene.gameObjectScene, function (gameObject) {
                        children.addChild(gameObject);
                    });
                    _this.instanceList.forEach(function (instance) {
                        if (!children.hasChild(instance)) {
                            isInLoop = false;
                            return wdCb.$BREAK;
                        }
                    });
                    wd.expect(isInLoop).true;
                }, this);
            })
        ], OneToOneSourceInstance.prototype, "dispose", null);
        __decorate([
            wd.require(function () {
                var entityObject = this.entityObject;
                wd.it("space partition not support instance", function () {
                    wd.expect(wd.ClassUtils.hasComponent(entityObject, "SpacePartition")).false;
                });
            }),
            wd.ensure(function (instance) {
                wd.it("should be object instance", function () {
                    wd.expect(wd.InstanceUtils.isObjectInstance(instance)).true;
                });
            })
        ], OneToOneSourceInstance.prototype, "cloneInstance", null);
        __decorate([
            wd.ensure(function (returnValue, source, instance) {
                wd.it("instance should contain ThreeDTransform component", function () {
                    wd.expect(instance.hasComponent(wd.ThreeDTransform)).true;
                });
            })
        ], OneToOneSourceInstance.prototype, "_addComponentsFromSourceToObject", null);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("children should contain only one OneToOneSourceInstance component", function () {
                    wd.IterateUtils.forEachAll(_this.entityObject, function (gameObject) {
                        wd.expect(gameObject.getComponents()
                            .filter(function (component) {
                            return component instanceof OneToOneSourceInstance;
                        })
                            .getCount()).equal(1);
                    });
                });
            })
        ], OneToOneSourceInstance.prototype, "_addSourceInstanceToChildren", null);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("instance shouldn't add EInstanceTag.isAddSourceInstance tag here", function () {
                    _this.instanceList.forEach(function (instance) {
                        wd.expect(instance.hasTag(wd.EInstanceTag.isAddSourceInstance)).false;
                    });
                }, this);
            })
        ], OneToOneSourceInstance.prototype, "_addAllInstances", null);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("instance shouldn't add EInstanceTag.isRemoveSourceInstance tag here", function () {
                    _this.instanceList.forEach(function (instance) {
                        wd.expect(instance.hasTag(wd.EInstanceTag.isRemoveSourceInstance)).false;
                    });
                }, this);
            })
        ], OneToOneSourceInstance.prototype, "_removeAllInstances", null);
        return OneToOneSourceInstance;
    }(wd.SourceInstance));
    wd.OneToOneSourceInstance = OneToOneSourceInstance;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToManySourceInstance = (function (_super) {
        __extends(OneToManySourceInstance, _super);
        function OneToManySourceInstance() {
            _super.apply(this, arguments);
        }
        OneToManySourceInstance.create = function () {
            var obj = new this();
            return obj;
        };
        return OneToManySourceInstance;
    }(wd.SourceInstance));
    wd.OneToManySourceInstance = OneToManySourceInstance;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ObjectInstance = (function (_super) {
        __extends(ObjectInstance, _super);
        function ObjectInstance() {
            _super.apply(this, arguments);
            this.sourceObject = null;
            this._enterSubscription = null;
            this._exitSubscription = null;
        }
        ObjectInstance.create = function () {
            var obj = new this();
            return obj;
        };
        ObjectInstance.prototype.init = function () {
            var self = this, entityObject = this.entityObject;
            this._enterSubscription = wd.EventManager.fromEvent(entityObject, wd.EEngineEvent.ENTER)
                .subscribe(function () {
                if (entityObject.hasTag(wd.EInstanceTag.isAddSourceInstance)) {
                    return;
                }
                self._addToSourceAndItsChildren();
            });
            this._exitSubscription = wd.EventManager.fromEvent(entityObject, wd.EEngineEvent.EXIT)
                .subscribe(function () {
                if (entityObject.hasTag(wd.EInstanceTag.isRemoveSourceInstance)) {
                    return;
                }
                self._removeFromSourceAndItsChildren();
            });
        };
        ObjectInstance.prototype.dispose = function () {
            this._enterSubscription.dispose();
            this._exitSubscription.dispose();
            this._removeFromSourceAndItsChildren();
        };
        ObjectInstance.prototype._addToSourceAndItsChildren = function () {
            var add = function (sourceInstanceObject, objectInstanceObject) {
                sourceInstanceObject.getComponent(wd.OneToOneSourceInstance).instanceList.addChild(objectInstanceObject);
                objectInstanceObject.forEach(function (child, index) {
                    add(sourceInstanceObject.getChild(index), child);
                });
            };
            add(this.sourceObject, this.entityObject);
        };
        ObjectInstance.prototype._removeFromSourceAndItsChildren = function () {
            var remove = function (sourceInstanceObject, objectInstanceObject) {
                sourceInstanceObject.getComponent(wd.OneToOneSourceInstance).instanceList.removeChild(objectInstanceObject);
                objectInstanceObject.forEach(function (child, index) {
                    remove(sourceInstanceObject.getChild(index), child);
                });
            };
            remove(this.sourceObject, this.entityObject);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ObjectInstance.prototype, "sourceObject", void 0);
        return ObjectInstance;
    }(wd.Instance));
    wd.ObjectInstance = ObjectInstance;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EInstanceTag) {
        EInstanceTag[EInstanceTag["isRemoveSourceInstance"] = "isRemoveSourceInstance"] = "isRemoveSourceInstance";
        EInstanceTag[EInstanceTag["isAddSourceInstance"] = "isAddSourceInstance"] = "isAddSourceInstance";
    })(wd.EInstanceTag || (wd.EInstanceTag = {}));
    var EInstanceTag = wd.EInstanceTag;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventTriggerDetector = (function (_super) {
        __extends(EventTriggerDetector, _super);
        function EventTriggerDetector() {
            _super.apply(this, arguments);
        }
        EventTriggerDetector.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        return EventTriggerDetector;
    }(wd.Component));
    wd.EventTriggerDetector = EventTriggerDetector;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var UIEventTriggerDetector = (function (_super) {
        __extends(UIEventTriggerDetector, _super);
        function UIEventTriggerDetector() {
            _super.apply(this, arguments);
        }
        UIEventTriggerDetector.create = function () {
            var obj = new this();
            return obj;
        };
        UIEventTriggerDetector.prototype.isTrigger = function (e) {
            var transform = this.entityObject.transform, width = transform.width, height = transform.height, position = transform.position, locationInView = e.locationInView, leftUpCornerPosition = null;
            leftUpCornerPosition = wd.Vector2.create(position.x - width / 2, position.y - height / 2);
            return wd.EventTriggerDetectorUtils.isInRect(locationInView, leftUpCornerPosition, width, height);
        };
        return UIEventTriggerDetector;
    }(wd.EventTriggerDetector));
    wd.UIEventTriggerDetector = UIEventTriggerDetector;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RayCasterEventTriggerDetector = (function (_super) {
        __extends(RayCasterEventTriggerDetector, _super);
        function RayCasterEventTriggerDetector() {
            _super.apply(this, arguments);
        }
        RayCasterEventTriggerDetector.create = function () {
            var obj = new this();
            return obj;
        };
        RayCasterEventTriggerDetector.prototype.isTrigger = function (e) {
            var scene = wd.Director.getInstance().scene, cameraController = scene.currentCamera.getComponent(wd.CameraController), locationInView = e.locationInView;
            return cameraController.isIntersectWithRay(this.entityObject, locationInView.x, locationInView.y);
        };
        return RayCasterEventTriggerDetector;
    }(wd.EventTriggerDetector));
    wd.RayCasterEventTriggerDetector = RayCasterEventTriggerDetector;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SceneEventTriggerDetector = (function (_super) {
        __extends(SceneEventTriggerDetector, _super);
        function SceneEventTriggerDetector() {
            _super.apply(this, arguments);
        }
        SceneEventTriggerDetector.create = function () {
            var obj = new this();
            return obj;
        };
        SceneEventTriggerDetector.prototype.isTrigger = function (e) {
            var view = wd.DeviceManager.getInstance().view, width = view.width, height = view.height, locationInView = e.locationInView, leftUpCornerPosition = wd.Vector2.create(0, 0);
            return wd.EventTriggerDetectorUtils.isInRect(locationInView, leftUpCornerPosition, width, height);
        };
        return SceneEventTriggerDetector;
    }(wd.EventTriggerDetector));
    wd.SceneEventTriggerDetector = SceneEventTriggerDetector;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EventTriggerDetectorUtils = (function () {
        function EventTriggerDetectorUtils() {
        }
        EventTriggerDetectorUtils.isInRect = function (locationInView, leftUpCornerPosition, width, height) {
            return locationInView.x >= leftUpCornerPosition.x && locationInView.x <= leftUpCornerPosition.x + width && locationInView.y >= leftUpCornerPosition.y && locationInView.y <= leftUpCornerPosition.y + height;
        };
        return EventTriggerDetectorUtils;
    }());
    wd.EventTriggerDetectorUtils = EventTriggerDetectorUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var _scriptHandlerNameTable = wdCb.Hash.create(), _scriptEngineEventTable = wdCb.Hash.create();
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_TAP, "onPointTap");
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_OVER, "onPointOver");
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_OUT, "onPointOut");
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_MOVE, "onPointMove");
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_DOWN, "onPointDown");
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_UP, "onPointUp");
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_SCALE, "onPointScale");
    _scriptHandlerNameTable.addChild(wd.EEngineEvent.POINT_DRAG, "onPointDrag");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_TAP, "POINT_TAP");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_DOWN, "POINT_DOWN");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_UP, "POINT_UP");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_MOVE, "POINT_MOVE");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_OVER, "POINT_OVER");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_OUT, "POINT_OUT");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_SCALE, "POINT_SCALE");
    _scriptEngineEventTable.addChild(wd.EEngineEvent.POINT_DRAG, "POINT_DRAG");
    var EventTriggerTable = (function () {
        function EventTriggerTable() {
        }
        EventTriggerTable.getScriptHandlerName = function (eventName) {
            var result = _scriptHandlerNameTable.getChild(eventName);
            return result;
        };
        EventTriggerTable.getScriptEngineEvent = function (eventName) {
            var result = _scriptEngineEventTable.getChild(eventName);
            return result;
        };
        return EventTriggerTable;
    }());
    wd.EventTriggerTable = EventTriggerTable;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Script = (function (_super) {
        __extends(Script, _super);
        function Script(id) {
            if (id === void 0) { id = null; }
            _super.call(this);
            this.id = null;
            this.id = id;
        }
        Script.create = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 0) {
                return new this();
            }
            else if (args.length === 1) {
                var id = args[0];
                return new this(id);
            }
        };
        Script.addScript = function (scriptName, _class) {
            this.scriptList.push({
                name: scriptName,
                class: _class
            });
        };
        Script.prototype.addToComponentContainer = function () {
            var data = wd.LoaderManager.getInstance().get(this.id);
            wd.GlobalScriptUtils.addScriptToEntityObject(this.entityObject, data);
        };
        Script.scriptList = wdCb.Stack.create();
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Script.prototype, "id", void 0);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("script should be loaded", function () {
                    wd.expect(wd.LoaderManager.getInstance().get(_this.id)).exist;
                }, this);
            })
        ], Script.prototype, "addToComponentContainer", null);
        return Script;
    }(wd.Component));
    wd.Script = Script;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            _super.apply(this, arguments);
            this.p_parent = null;
            this._isTranslate = false;
            this._isRotate = false;
            this._isScale = false;
            this.dirtyLocal = true;
            this.children = wdCb.Collection.create();
            this._endLoopSubscription = null;
        }
        Object.defineProperty(Transform.prototype, "parent", {
            get: function () {
                return this.p_parent;
            },
            set: function (parent) {
                this.setParent(parent);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "isTransform", {
            get: function () {
                return this.isTranslate || this.isRotate || this.isScale;
            },
            set: function (isTransform) {
                if (isTransform) {
                    this._setGlobalTransformState(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "isTranslate", {
            get: function () {
                return this._isTranslate;
            },
            set: function (isTranslate) {
                this._setGlobalTransformState(wd.ETransformState.ISTRANSLATE, isTranslate);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "isRotate", {
            get: function () {
                return this._isRotate;
            },
            set: function (isRotate) {
                this._setGlobalTransformState(wd.ETransformState.ISROTATE, isRotate);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "isScale", {
            get: function () {
                return this._isScale;
            },
            set: function (isScale) {
                this._setGlobalTransformState(wd.ETransformState.ISSCALE, isScale);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "isLocalTranslate", {
            set: function (isTranslate) {
                this._setLocalTransformState(wd.ETransformState.ISLOCALTRANSLATE, isTranslate);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "isLocalRotate", {
            set: function (isRotate) {
                this._setLocalTransformState(wd.ETransformState.ISLOCALROTATE, isRotate);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "isLocalScale", {
            set: function (isScale) {
                this._setLocalTransformState(wd.ETransformState.ISLOCALSCALE, isScale);
            },
            enumerable: true,
            configurable: true
        });
        Transform.prototype.init = function () {
            var self = this;
            this.clearCache();
            this._endLoopSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.ENDLOOP)
                .subscribe(function () {
                self._resetTransformFlag();
            });
        };
        Transform.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._endLoopSubscription && this._endLoopSubscription.dispose();
        };
        Transform.prototype.addChild = function (child) {
            this.children.addChild(child);
        };
        Transform.prototype.removeChild = function (child) {
            this.children.removeChild(child);
        };
        Transform.prototype.setChildrenTransformState = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1) {
                var state = args[0];
                if (state) {
                    this.children.forEach(function (child) {
                        child.isTransform = true;
                    });
                }
            }
            else {
                var transformState_1 = args[0], state = args[1];
                if (state) {
                    this.children.forEach(function (child) {
                        child[transformState_1] = true;
                    });
                }
            }
        };
        Transform.prototype.handleWhenSetTransformState = function (transformState) {
        };
        Transform.prototype.setParent = function (parent) {
            if (this.p_parent) {
                this.p_parent.removeChild(this);
            }
            if (!parent) {
                this.p_parent = null;
                return;
            }
            this.p_parent = parent;
            this.p_parent.addChild(this);
        };
        Transform.prototype.getMatrix = function (syncMethod, matrixAttriName) {
            var syncList = wdCb.Collection.create(), current = this.p_parent;
            syncList.addChild(this);
            while (current !== null) {
                syncList.addChild(current);
                current = current.parent;
            }
            syncList.reverse().forEach(function (transform) {
                transform[syncMethod]();
            });
            return this[matrixAttriName];
        };
        Transform.prototype._setGlobalTransformState = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args.length === 1) {
                var state = args[0];
                if (!state) {
                    return;
                }
                this._isTranslate = true;
                this._isRotate = true;
                this._isScale = true;
                this.dirtyLocal = true;
                this.clearCache();
                this.handleWhenSetTransformState();
                this.setChildrenTransformState(state);
            }
            else {
                var transformState = args[0], state = args[1];
                this[("_" + transformState)] = state;
                if (state) {
                    this.dirtyLocal = true;
                    this.clearCache();
                    this.handleWhenSetTransformState(transformState);
                }
                if (state) {
                    this.setChildrenTransformState(transformState, state);
                }
            }
        };
        Transform.prototype._setLocalTransformState = function (transformState, state) {
            if (state) {
                this.dirtyLocal = true;
                this.clearCache();
            }
            if (state) {
                this.setChildrenTransformState(transformState, state);
            }
        };
        Transform.prototype._resetTransformFlag = function () {
            this.isTranslate = false;
            this.isScale = false;
            this.isRotate = false;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Transform.prototype, "parent", null);
        __decorate([
            wd.virtual
        ], Transform.prototype, "handleWhenSetTransformState", null);
        return Transform;
    }(wd.Component));
    wd.Transform = Transform;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ThreeDTransform = (function (_super) {
        __extends(ThreeDTransform, _super);
        function ThreeDTransform() {
            _super.apply(this, arguments);
            this._localToWorldMatrix = null;
            this._position = wd.Vector3.create();
            this._rotation = wd.Quaternion.create(0, 0, 0, 1);
            this._scale = wd.Vector3.create(1, 1, 1);
            this._eulerAngles = null;
            this._localPosition = wd.Vector3.create(0, 0, 0);
            this._localRotation = wd.Quaternion.create(0, 0, 0, 1);
            this._localEulerAngles = null;
            this._localScale = wd.Vector3.create(1, 1, 1);
            this.dirtyWorld = null;
            this._localToParentMatrix = wd.Matrix4.create();
            this._localToWorldMatrixCache = null;
            this._positionCache = null;
            this._rotationCache = null;
            this._scaleCache = null;
            this._eulerAnglesCache = null;
            this._localEulerAnglesCache = null;
            this._normalMatrixCache = null;
            this._isUserSpecifyTheLocalToWorldMatrix = false;
            this._userLocalToWorldMatrix = null;
        }
        ThreeDTransform.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(ThreeDTransform.prototype, "localToWorldMatrix", {
            get: function () {
                if (this._isUserSpecifyTheLocalToWorldMatrix) {
                    return this._userLocalToWorldMatrix;
                }
                return this.getMatrix("sync", "_localToWorldMatrix");
            },
            set: function (matrix) {
                this._isUserSpecifyTheLocalToWorldMatrix = true;
                this._userLocalToWorldMatrix = matrix;
                this.isTransform = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "normalMatrix", {
            get: function () {
                return this.localToWorldMatrix.invertTo3x3().transpose();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "position", {
            get: function () {
                this._position = this.localToWorldMatrix.getTranslation();
                return this._position;
            },
            set: function (position) {
                if (this.p_parent === null) {
                    this._localPosition = position;
                }
                else {
                    this._localPosition = this.p_parent.localToWorldMatrix.clone().invert().multiplyPoint(position);
                }
                this.isTranslate = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "rotation", {
            get: function () {
                this._rotation.setFromMatrix(this.localToWorldMatrix);
                return this._rotation;
            },
            set: function (rotation) {
                if (this.p_parent === null) {
                    this._localRotation = rotation;
                }
                else {
                    this._localRotation = this.p_parent.rotation.clone().invert().multiply(rotation);
                }
                this.isRotate = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "scale", {
            get: function () {
                this._scale = this.localToWorldMatrix.getScale();
                return this._scale;
            },
            set: function (scale) {
                if (this.p_parent === null) {
                    this._localScale = scale;
                }
                else {
                    this._localScale = this.p_parent.localToWorldMatrix.clone().invert().multiplyVector3(scale);
                }
                this.isScale = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "eulerAngles", {
            get: function () {
                this._eulerAngles = this.localToWorldMatrix.getEulerAngles();
                return this._eulerAngles;
            },
            set: function (eulerAngles) {
                this._localRotation.setFromEulerAngles(eulerAngles);
                if (this.p_parent !== null) {
                    this._localRotation = this.p_parent.rotation.clone().invert().multiply(this._localRotation);
                }
                this.isRotate = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "localPosition", {
            get: function () {
                return this._localPosition;
            },
            set: function (position) {
                this._localPosition = position;
                this.isLocalTranslate = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "localRotation", {
            get: function () {
                return this._localRotation;
            },
            set: function (rotation) {
                this._localRotation = rotation;
                this.isLocalRotate = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "localEulerAngles", {
            get: function () {
                this._localEulerAngles = this._localRotation.getEulerAngles();
                return this._localEulerAngles;
            },
            set: function (localEulerAngles) {
                this._localRotation.setFromEulerAngles(localEulerAngles);
                this.isLocalRotate = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "localScale", {
            get: function () {
                return this._localScale;
            },
            set: function (scale) {
                this._localScale = scale;
                this.isLocalScale = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "up", {
            get: function () {
                return this.localToWorldMatrix.getY().normalize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "right", {
            get: function () {
                return this.localToWorldMatrix.getX().normalize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDTransform.prototype, "forward", {
            get: function () {
                return this.localToWorldMatrix.getZ().normalize().scale(-1);
            },
            enumerable: true,
            configurable: true
        });
        ThreeDTransform.prototype.sync = function () {
            if (this.dirtyLocal) {
                this._localToParentMatrix.setTRS(this._localPosition, this._localRotation, this._localScale);
                this.dirtyLocal = false;
                this.dirtyWorld = true;
            }
            if (this.dirtyWorld) {
                if (this.p_parent === null) {
                    this._localToWorldMatrix = this._localToParentMatrix.clone();
                }
                else {
                    this._localToWorldMatrix = this.p_parent.localToWorldMatrix.clone().multiply(this._localToParentMatrix);
                }
                this.dirtyWorld = false;
                this.children.forEach(function (child) {
                    child.dirtyWorld = true;
                });
            }
        };
        ThreeDTransform.prototype.translateLocal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var translation = null;
            if (args.length === 3) {
                translation = wd.Vector3.create(args[0], args[1], args[2]);
            }
            else {
                translation = args[0];
            }
            this._localPosition = this._localPosition.add(this._localRotation.multiplyVector3(translation));
            this.isTranslate = true;
            return this;
        };
        ThreeDTransform.prototype.translate = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var translation = null;
            if (args.length === 3) {
                translation = wd.Vector3.create(args[0], args[1], args[2]);
            }
            else {
                translation = args[0];
            }
            this.position = translation.add(this.position);
            return this;
        };
        ThreeDTransform.prototype.rotate = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eulerAngles = null, quaternion = wd.Quaternion.create();
            if (args.length === 3) {
                eulerAngles = wd.Vector3.create(args[0], args[1], args[2]);
            }
            else {
                eulerAngles = args[0];
            }
            quaternion.setFromEulerAngles(eulerAngles);
            if (this.p_parent === null) {
                this._localRotation = quaternion.multiply(this._localRotation);
            }
            else {
                quaternion = this.p_parent.rotation.clone().invert().multiply(quaternion);
                this._localRotation = quaternion.multiply(this.rotation);
            }
            this.isRotate = true;
            return this;
        };
        ThreeDTransform.prototype.rotateLocal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var eulerAngles = null, quaternion = wd.Quaternion.create();
            if (args.length === 3) {
                eulerAngles = wd.Vector3.create(args[0], args[1], args[2]);
            }
            else {
                eulerAngles = args[0];
            }
            quaternion.setFromEulerAngles(eulerAngles);
            this._localRotation.multiply(quaternion);
            this.isRotate = true;
            return this;
        };
        ThreeDTransform.prototype.rotateAround = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var angle = null, center = null, axis = null, rot = null, dir = null;
            if (args.length === 3) {
                angle = args[0];
                center = args[1];
                axis = args[2];
            }
            else {
                angle = args[0];
                center = wd.Vector3.create(args[1], args[2], args[3]);
                axis = wd.Vector3.create(args[4], args[5], args[6]);
            }
            rot = wd.Quaternion.create().setFromAxisAngle(angle, axis);
            dir = this.position.clone().sub(center);
            dir = rot.multiplyVector3(dir);
            this.position = center.add(dir);
            this.rotation = rot.multiply(this.rotation);
            return this;
        };
        ThreeDTransform.prototype.lookAt = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var target = null, up = null;
            if (args.length === 1) {
                target = args[0];
                up = wd.Vector3.up;
            }
            else if (args.length === 2) {
                target = args[0];
                up = args[1];
            }
            else if (args.length === 3) {
                target = wd.Vector3.create(args[0], args[1], args[2]);
                up = wd.Vector3.up;
            }
            else {
                target = wd.Vector3.create(args[0], args[1], args[2]);
                up = wd.Vector3.create(args[3], args[4], args[5]);
            }
            this.rotation = wd.Quaternion.create().setFromMatrix(wd.Matrix4.create().setLookAt(this.position, target, up));
            return this;
        };
        ThreeDTransform.prototype.clearCache = function () {
            this._localToWorldMatrixCache = null;
            this._normalMatrixCache = null;
            this._positionCache = null;
            this._rotationCache = null;
            this._scaleCache = null;
            this._eulerAnglesCache = null;
            this._localEulerAnglesCache = null;
        };
        ThreeDTransform.prototype.handleWhenSetTransformState = function (transformState) {
            var eventName = null;
            if (transformState === void 0) {
                wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.TRANSFORM_TRANSLATE));
                wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.TRANSFORM_ROTATE));
                wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.TRANSFORM_SCALE));
                return;
            }
            switch (transformState) {
                case wd.ETransformState.ISTRANSLATE:
                    eventName = wd.EEngineEvent.TRANSFORM_TRANSLATE;
                    break;
                case wd.ETransformState.ISROTATE:
                    eventName = wd.EEngineEvent.TRANSFORM_ROTATE;
                    break;
                case wd.ETransformState.ISSCALE:
                    eventName = wd.EEngineEvent.TRANSFORM_SCALE;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNKNOW("transformState:" + transformState));
                    break;
            }
            wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(eventName));
        };
        __decorate([
            wd.cacheGetter(function () {
                return this._localToWorldMatrixCache !== null;
            }, function () {
                return this._localToWorldMatrixCache;
            }, function (result) {
                this._localToWorldMatrixCache = result;
            })
        ], ThreeDTransform.prototype, "localToWorldMatrix", null);
        __decorate([
            wd.cacheGetter(function () {
                return this._normalMatrixCache !== null;
            }, function () {
                return this._normalMatrixCache;
            }, function (result) {
                this._normalMatrixCache = result;
            })
        ], ThreeDTransform.prototype, "normalMatrix", null);
        __decorate([
            wd.cloneAttributeAsCloneable(),
            wd.cacheGetter(function () {
                return this._positionCache !== null;
            }, function () {
                return this._positionCache;
            }, function (result) {
                this._positionCache = result;
            })
        ], ThreeDTransform.prototype, "position", null);
        __decorate([
            wd.cloneAttributeAsCloneable(),
            wd.cacheGetter(function () {
                return this._rotationCache !== null;
            }, function () {
                return this._rotationCache;
            }, function (result) {
                this._rotationCache = result;
            })
        ], ThreeDTransform.prototype, "rotation", null);
        __decorate([
            wd.cloneAttributeAsCloneable(),
            wd.cacheGetter(function () {
                return this._scaleCache !== null;
            }, function () {
                return this._scaleCache;
            }, function (result) {
                this._scaleCache = result;
            })
        ], ThreeDTransform.prototype, "scale", null);
        __decorate([
            wd.cacheGetter(function () {
                return this._eulerAnglesCache !== null;
            }, function () {
                return this._eulerAnglesCache;
            }, function (result) {
                this._eulerAnglesCache = result;
            })
        ], ThreeDTransform.prototype, "eulerAngles", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ThreeDTransform.prototype, "localPosition", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ThreeDTransform.prototype, "localRotation", null);
        __decorate([
            wd.cacheGetter(function () {
                return this._localEulerAnglesCache !== null;
            }, function () {
                return this._localEulerAnglesCache;
            }, function (result) {
                this._localEulerAnglesCache = result;
            })
        ], ThreeDTransform.prototype, "localEulerAngles", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ThreeDTransform.prototype, "localScale", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ThreeDTransform.prototype, "_isUserSpecifyTheLocalToWorldMatrix", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ThreeDTransform.prototype, "_userLocalToWorldMatrix", void 0);
        return ThreeDTransform;
    }(wd.Transform));
    wd.ThreeDTransform = ThreeDTransform;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RectTransform = (function (_super) {
        __extends(RectTransform, _super);
        function RectTransform() {
            _super.apply(this, arguments);
            this._rotationMatrix = null;
            this._localPositionAndScaleMatrix = wd.Matrix3.create();
            this._position = wd.Vector2.create();
            this._rotation = 0;
            this._scale = wd.Vector2.create(1, 1);
            this._localPosition = wd.Vector2.create(0, 0);
            this._localScale = wd.Vector2.create(1, 1);
            this._anchorX = wd.Vector2.create(0.5, 0.5);
            this._anchorY = wd.Vector2.create(0.5, 0.5);
            this._width = null;
            this._height = null;
            this.dirtyRotation = true;
            this.dirtyPositionAndScale = true;
            this.pivot = wd.Vector2.create(0, 0);
            this.zIndex = 1;
            this._localRotationMatrix = wd.Matrix3.create();
            this._localToParentMatrix = wd.Matrix3.create();
            this._rotationMatrixCache = null;
            this._localPositionAndScaleMatrixCache = null;
        }
        RectTransform.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(RectTransform.prototype, "rotationMatrix", {
            get: function () {
                return this.getMatrix("syncRotation", "_rotationMatrix");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "localPositionAndScaleMatrix", {
            get: function () {
                return this.getMatrix("syncPositionAndScale", "_localPositionAndScaleMatrix");
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "position", {
            get: function () {
                this._position = this.localPositionAndScaleMatrix.getTranslation();
                return this._position;
            },
            set: function (position) {
                if (this.p_parent === null) {
                    this._localPosition = position;
                }
                else {
                    this._localPosition = this.p_parent.localPositionAndScaleMatrix.clone().invert().multiplyPoint(position);
                }
                this.isTranslate = true;
                this._markRendererDirty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "rotation", {
            get: function () {
                this._rotation = this.rotationMatrix.getRotation();
                return this._rotation;
            },
            set: function (angle) {
                this.resetRotation();
                this.rotate(angle);
                this.dirtyRotation = true;
                this.isRotate = true;
                this._markRendererDirty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "scale", {
            get: function () {
                this._scale = this.localPositionAndScaleMatrix.getScale();
                return this._scale;
            },
            set: function (scale) {
                if (this.p_parent === null) {
                    this._localScale = scale;
                }
                else {
                    this._localScale = this.p_parent.localPositionAndScaleMatrix.clone().invert().multiplyVector2(scale);
                }
                this.isScale = true;
                this._markRendererDirty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "localPosition", {
            get: function () {
                return this._localPosition;
            },
            set: function (position) {
                this._localPosition = position;
                this.isLocalTranslate = true;
                this._markRendererDirty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "localScale", {
            get: function () {
                return this._localScale;
            },
            set: function (scale) {
                this._localScale = scale;
                this.isLocalScale = true;
                this._markRendererDirty();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "anchorX", {
            get: function () {
                return this._anchorX;
            },
            set: function (anchorX) {
                var parentWidth = null;
                if (this._anchorX.isEqual(anchorX)) {
                    return;
                }
                this._anchorX = anchorX;
                if (anchorX.x === anchorX.y) {
                    var widthFromAnchorToPosition = (anchorX.x - 0.5) * this._getParentWidth();
                    this.position = wd.Vector2.create(this._getParentPosition().x + widthFromAnchorToPosition, this.position.y);
                    return;
                }
                parentWidth = this._getParentWidth();
                this.position = wd.Vector2.create(this._getParentPosition().x + (anchorX.x + anchorX.y - 1) / 2 * parentWidth, this.position.y);
                this.width = parentWidth / this._getParentScale().x * (anchorX.y - anchorX.x) * this.scale.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "anchorY", {
            get: function () {
                return this._anchorY;
            },
            set: function (anchorY) {
                var parentHeight = null;
                if (this._anchorY.isEqual(anchorY)) {
                    return;
                }
                this._anchorY = anchorY;
                if (anchorY.x === anchorY.y) {
                    var heightFromAnchorToPosition = (anchorY.x - 0.5) * this._getParentHeight();
                    this.position = wd.Vector2.create(this.position.x, this._getParentPosition().y + heightFromAnchorToPosition);
                    return;
                }
                parentHeight = this._getParentHeight();
                this.position = wd.Vector2.create(this.position.x, this._getParentPosition().y + (anchorY.x + anchorY.y - 1) / 2 * parentHeight);
                this.height = parentHeight / this._getParentScale().y * (anchorY.y - anchorY.x) * this.scale.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "width", {
            get: function () {
                return this._width * this.scale.x;
            },
            set: function (width) {
                if (this._width === width) {
                    return;
                }
                this._width = width;
                if (this.entityObject) {
                    wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.UI_WIDTH_CHANGE));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectTransform.prototype, "height", {
            get: function () {
                return this._height * this.scale.y;
            },
            set: function (height) {
                if (this._height === height) {
                    return;
                }
                this._height = height;
                if (this.entityObject) {
                    wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.UI_HEIGHT_CHANGE));
                }
            },
            enumerable: true,
            configurable: true
        });
        RectTransform.prototype.syncRotation = function () {
            if (this.dirtyRotation) {
                if (this.p_parent === null) {
                    this._rotationMatrix = this._localRotationMatrix.clone();
                }
                else {
                    this._rotationMatrix = this.p_parent.rotationMatrix.clone().multiply(this._localRotationMatrix);
                }
                this.children.forEach(function (child) {
                    child.dirtyRotation = true;
                });
            }
        };
        RectTransform.prototype.syncPositionAndScale = function () {
            if (this.dirtyLocal) {
                this._localToParentMatrix.setTS(this._localPosition, this._localScale);
                this.dirtyLocal = false;
                this.dirtyPositionAndScale = true;
            }
            if (this.dirtyPositionAndScale) {
                if (this.p_parent === null) {
                    this._localPositionAndScaleMatrix = this._localToParentMatrix.clone();
                }
                else {
                    this._localPositionAndScaleMatrix = this.p_parent.localPositionAndScaleMatrix.clone().multiply(this._localToParentMatrix);
                }
                this.dirtyLocal = false;
                this.children.forEach(function (child) {
                    child.dirtyPositionAndScale = true;
                });
            }
        };
        RectTransform.prototype.translate = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var translation = null;
            if (args.length === 2) {
                translation = wd.Vector2.create(args[0], args[1]);
            }
            else {
                translation = args[0];
            }
            this.position = translation.add(this.position);
            return this;
        };
        RectTransform.prototype.rotate = function (angle) {
            var position = this.position;
            this.rotateAround(angle, position.x + this.pivot.x, position.y - this.pivot.y);
            this.dirtyRotation = true;
            this.isRotate = true;
            return this;
        };
        RectTransform.prototype.rotateAround = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var angle = null, center = null, position = null, x = null, y = null;
            if (args.length === 2) {
                angle = args[0];
                center = args[1];
            }
            else {
                angle = args[0];
                center = wd.Vector2.create(args[1], args[2]);
            }
            x = center.x;
            y = center.y;
            this._translateInRotationMatrix(x, y);
            this._rotateAroundCanvasOriginPoint(angle);
            this._translateInRotationMatrix(-x, -y);
            return this;
        };
        RectTransform.prototype._translateInRotationMatrix = function (x, y) {
            this._localRotationMatrix.translate(x, y);
            return this;
        };
        RectTransform.prototype.resetPosition = function () {
            this.position = wd.Vector2.create(0, 0);
        };
        RectTransform.prototype.resetScale = function () {
            this.scale = wd.Vector2.create(1, 1);
        };
        RectTransform.prototype.resetRotation = function () {
            this._localRotationMatrix.setIdentity();
        };
        RectTransform.prototype.handleWhenSetTransformState = function (transformState) {
            var eventName = null;
            switch (transformState) {
                case wd.ETransformState.ISTRANSLATE:
                    eventName = wd.EEngineEvent.TRANSFORM_TRANSLATE;
                    break;
                case wd.ETransformState.ISROTATE:
                    eventName = wd.EEngineEvent.TRANSFORM_ROTATE;
                    break;
                case wd.ETransformState.ISSCALE:
                    eventName = wd.EEngineEvent.TRANSFORM_SCALE;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNKNOW("transformState:" + transformState));
                    break;
            }
            wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(eventName));
        };
        RectTransform.prototype.clearCache = function () {
            this._rotationMatrixCache = null;
            this._localPositionAndScaleMatrixCache = null;
        };
        RectTransform.prototype._rotateAroundCanvasOriginPoint = function (angle) {
            this._localRotationMatrix.rotate(angle);
            this.dirtyRotation = true;
            return this;
        };
        RectTransform.prototype._getParentWidth = function () {
            if (this.p_parent === null) {
                return wd.DeviceManager.getInstance().view.width;
            }
            return this.p_parent.width;
        };
        RectTransform.prototype._getParentHeight = function () {
            if (this.p_parent === null) {
                return wd.DeviceManager.getInstance().view.height;
            }
            return this.p_parent.height;
        };
        RectTransform.prototype._getParentPosition = function () {
            if (this.p_parent === null) {
                var view = wd.DeviceManager.getInstance().view;
                return wd.Vector2.create(view.width / 2, view.height / 2);
            }
            return this.p_parent.position;
        };
        RectTransform.prototype._getParentScale = function () {
            if (this.p_parent === null) {
                return wd.Vector2.create(1, 1);
            }
            return this.p_parent.scale;
        };
        RectTransform.prototype._markRendererDirty = function () {
            var renderer = wd.UIRendererUtils.getUIRenderer(this.entityObject);
            if (!renderer) {
                return;
            }
            renderer.dirty = true;
        };
        __decorate([
            wd.cacheGetter(function () {
                return this._rotationMatrixCache !== null;
            }, function () {
                return this._rotationMatrixCache;
            }, function (result) {
                this._rotationMatrixCache = result;
            })
        ], RectTransform.prototype, "rotationMatrix", null);
        __decorate([
            wd.cacheGetter(function () {
                return this._localPositionAndScaleMatrixCache !== null;
            }, function () {
                return this._localPositionAndScaleMatrixCache;
            }, function (result) {
                this._localPositionAndScaleMatrixCache = result;
            })
        ], RectTransform.prototype, "localPositionAndScaleMatrix", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RectTransform.prototype, "position", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], RectTransform.prototype, "rotation", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RectTransform.prototype, "scale", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RectTransform.prototype, "localPosition", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RectTransform.prototype, "localScale", null);
        __decorate([
            wd.requireSetter(function (anchorX) {
                wd.assert(anchorX.x <= anchorX.y, wd.Log.info.FUNC_SHOULD("minX", "<= maxY"));
                wd.assert(anchorX.x >= 0 && anchorX.x <= 1, wd.Log.info.FUNC_SHOULD("minX", ">= 0 && <= 1"));
                wd.assert(anchorX.y >= 0 && anchorX.y <= 1, wd.Log.info.FUNC_SHOULD("maxX", ">= 0 && <= 1"));
            }),
            wd.cloneAttributeAsCloneable()
        ], RectTransform.prototype, "anchorX", null);
        __decorate([
            wd.requireSetter(function (anchorY) {
                wd.assert(anchorY.x <= anchorY.y, wd.Log.info.FUNC_SHOULD("minY", "<= maxY"));
                wd.assert(anchorY.x >= 0 && anchorY.x <= 1, wd.Log.info.FUNC_SHOULD("minY", ">= 0 && <= 1"));
                wd.assert(anchorY.y >= 0 && anchorY.y <= 1, wd.Log.info.FUNC_SHOULD("maxY", ">= 0 && <= 1"));
            }),
            wd.cloneAttributeAsCloneable()
        ], RectTransform.prototype, "anchorY", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], RectTransform.prototype, "width", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], RectTransform.prototype, "height", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RectTransform.prototype, "pivot", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], RectTransform.prototype, "zIndex", void 0);
        return RectTransform;
    }(wd.Transform));
    wd.RectTransform = RectTransform;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETransformState) {
        ETransformState[ETransformState["ISTRANSLATE"] = "isTranslate"] = "ISTRANSLATE";
        ETransformState[ETransformState["ISROTATE"] = "isRotate"] = "ISROTATE";
        ETransformState[ETransformState["ISSCALE"] = "isScale"] = "ISSCALE";
        ETransformState[ETransformState["ISLOCALTRANSLATE"] = "isLocalTranslate"] = "ISLOCALTRANSLATE";
        ETransformState[ETransformState["ISLOCALROTATE"] = "isLocalRotate"] = "ISLOCALROTATE";
        ETransformState[ETransformState["ISLOCALSCALE"] = "isLocalScale"] = "ISLOCALSCALE";
    })(wd.ETransformState || (wd.ETransformState = {}));
    var ETransformState = wd.ETransformState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Shadow = (function (_super) {
        __extends(Shadow, _super);
        function Shadow() {
            _super.apply(this, arguments);
            this._receive = true;
            this._cast = true;
            this._layer = wd.EShadowLayer.DEFAULT;
            this._shadowMapLayerChangeSubscription = null;
            this._isInit = false;
        }
        Shadow.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(Shadow.prototype, "receive", {
            get: function () {
                return this._receive;
            },
            set: function (receive) {
                if (this._isInit && this._receive !== receive) {
                    if (wd.InstanceUtils.isObjectInstance(this.entityObject)) {
                        this._receive = receive;
                        return;
                    }
                    if (receive) {
                        this._addShadowMapsToObjectAndChildren();
                        this._switchToShadowMapShaderLib(this.entityObject);
                    }
                    else {
                        this._removeShadowMapsOfObjectAndChildren();
                        this._switchToNoShadowMapShaderLib(this.entityObject);
                    }
                }
                this._receive = receive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shadow.prototype, "cast", {
            get: function () {
                return this._cast;
            },
            set: function (cast) {
                this._cast = cast;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shadow.prototype, "layer", {
            get: function () {
                if (wd.InstanceUtils.isObjectInstance(this.entityObject) && !wd.InstanceUtils.isHardwareSupport()) {
                    this._layer = this.entityObject.getComponent(wd.ObjectInstance).sourceObject.getComponent(Shadow).layer;
                }
                return this._layer;
            },
            set: function (layer) {
                if (layer && this._layer !== layer) {
                    this._layer = layer;
                }
            },
            enumerable: true,
            configurable: true
        });
        Shadow.prototype.addToObject = function (entityObject, isShareComponent) {
            if (isShareComponent === void 0) { isShareComponent = false; }
            _super.prototype.addToObject.call(this, entityObject, isShareComponent);
        };
        Shadow.prototype.init = function () {
            var self = this;
            this._isInit = true;
            if (wd.InstanceUtils.isObjectInstance(this.entityObject)
                || !this._isFirstLevelObjectOfSceneOrSpacePartition()) {
                return;
            }
            this._shadowMapLayerChangeSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.SHADOWMAP_LAYER_CHANGE)
                .subscribe(function () {
                if (self.receive) {
                    self._addShadowMapsToObjectAndChildren();
                }
            });
            if (this.cast && this.receive) {
                this._addBuildShadowMapShaderAndShadowMapsToObjectAndChildren();
            }
            else if (this.cast) {
                this._addBuildShadowMapShaderToObjectAndChildren();
                return;
            }
            else if (this.receive) {
                this._addShadowMapsToObjectAndChildren();
            }
        };
        Shadow.prototype.dispose = function () {
            this._shadowMapLayerChangeSubscription && this._shadowMapLayerChangeSubscription.dispose();
        };
        Shadow.prototype._addAllShadowMaps = function (twoDShadowMapDataMap, cubemapShadowMapDataMap, mapManager) {
            twoDShadowMapDataMap.forEach(function (twoDShadowMapDataList) {
                twoDShadowMapDataList.forEach(function (_a) {
                    var shadowMap = _a.shadowMap;
                    mapManager.addTwoDShadowMap(shadowMap);
                });
            });
            cubemapShadowMapDataMap.forEach(function (cubemapShadowMapDataList) {
                cubemapShadowMapDataList.forEach(function (_a) {
                    var shadowMap = _a.shadowMap;
                    mapManager.addCubemapShadowMap(shadowMap);
                });
            });
        };
        Shadow.prototype._isFirstLevelObjectOfSceneOrSpacePartition = function () {
            var parent = this.entityObject.parent;
            if (!parent) {
                return false;
            }
            return wd.JudgeUtils.isEqual(parent, wd.Director.getInstance().scene) || wd.JudgeUtils.isSpacePartitionObject(parent);
        };
        Shadow.prototype._addBuildShadowMapShaderAndShadowMapsToObjectAndChildren = function () {
            var _this = this;
            var self = this, twoDShadowMapDataMap = wd.Director.getInstance().scene.gameObjectScene.shadowManager.twoDShadowMapDataMap, cubemapShadowMapDataMap = wd.Director.getInstance().scene.gameObjectScene.shadowManager.cubemapShadowMapDataMap;
            var handle = function (gameObject) {
                if (gameObject.hasComponent(wd.Geometry)) {
                    var geometry = gameObject.getComponent(wd.Geometry), material = geometry.material, mapManager = material.mapManager;
                    self._addBuildTwoDShadowMapShader(material, _this._createBuildTwoDShadowMapShader(gameObject, geometry));
                    self._addBuildCubemapShadowMapShader(material, _this._createBuildCubemapShadowMapShader(gameObject, geometry));
                    material.shader.libDirty = true;
                    mapManager.removeAllShdaowMaps();
                    self._addAllShadowMaps(twoDShadowMapDataMap, cubemapShadowMapDataMap, mapManager);
                }
                gameObject.forEach(function (child) {
                    handle(child);
                });
            };
            handle(this.entityObject);
        };
        Shadow.prototype._addBuildShadowMapShaderToObjectAndChildren = function () {
            var _this = this;
            var self = this;
            var handle = function (gameObject) {
                if (gameObject.hasComponent(wd.Geometry)) {
                    var geometry = gameObject.getComponent(wd.Geometry), material = geometry.material;
                    self._addBuildTwoDShadowMapShader(material, _this._createBuildTwoDShadowMapShader(gameObject, geometry));
                    self._addBuildCubemapShadowMapShader(material, _this._createBuildCubemapShadowMapShader(gameObject, geometry));
                }
                gameObject.forEach(function (child) {
                    handle(child);
                });
            };
            handle(this.entityObject);
        };
        Shadow.prototype._addBuildTwoDShadowMapShader = function (material, shader) {
            material.addShader(wd.EShaderTypeOfScene.BUILD_TWOD_SHADOWMAP, shader);
        };
        Shadow.prototype._addBuildCubemapShadowMapShader = function (material, shader) {
            material.addShader(wd.EShaderTypeOfScene.BUILD_CUBEMAP_SHADOWMAP, shader);
        };
        Shadow.prototype._createBuildTwoDShadowMapShader = function (gameObject, geometry) {
            var shader = this._createBuildShadowMapShader(gameObject, geometry);
            shader.addLib(wd.BuildTwoDShadowMapShaderLib.create());
            return shader;
        };
        Shadow.prototype._createBuildCubemapShadowMapShader = function (gameObject, geometry) {
            var shader = this._createBuildShadowMapShader(gameObject, geometry);
            shader.addLib(wd.BuildCubemapShadowMapShaderLib.create());
            return shader;
        };
        Shadow.prototype._createBuildShadowMapShader = function (gameObject, geometry) {
            var shader = wd.CommonShader.create();
            shader.addLib(wd.CommonShaderLib.create());
            wd.ShaderLibUtils.addVerticeShaderLib(geometry, shader);
            wd.InstanceUtils.addModelMatrixShaderLib(shader, gameObject);
            shader.addLib(wd.EndShaderLib.create());
            return shader;
        };
        Shadow.prototype._addShadowMapsToObjectAndChildren = function () {
            var self = this, twoDShadowMapDataMap = wd.Director.getInstance().scene.gameObjectScene.shadowManager.twoDShadowMapDataMap, cubemapShadowMapDataMap = wd.Director.getInstance().scene.gameObjectScene.shadowManager.cubemapShadowMapDataMap;
            var handle = function (gameObject) {
                if (gameObject.hasComponent(wd.Geometry)) {
                    var material = gameObject.getComponent(wd.Geometry).material, mapManager = material.mapManager;
                    material.shader.libDirty = true;
                    mapManager.removeAllShdaowMaps();
                    self._addAllShadowMaps(twoDShadowMapDataMap, cubemapShadowMapDataMap, mapManager);
                }
                gameObject.forEach(function (child) {
                    handle(child);
                });
            };
            handle(this.entityObject);
        };
        Shadow.prototype._removeShadowMapsOfObjectAndChildren = function () {
            var handle = function (gameObject) {
                if (gameObject.hasComponent(wd.Geometry)) {
                    var material = gameObject.getComponent(wd.Geometry).material, mapManager = material.mapManager;
                    material.shader.libDirty = true;
                    mapManager.removeAllShdaowMaps();
                }
                gameObject.forEach(function (child) {
                    handle(child);
                });
            };
            handle(this.entityObject);
        };
        Shadow.prototype._switchToShadowMapShaderLib = function (gameObject) {
            var material = gameObject.getComponent(wd.Geometry).material, shader = material.shader, mapManager = material.mapManager;
            shader.removeLib(function (lib) {
                return lib instanceof wd.NoShadowMapShaderLib;
            });
            if (this._isTwoDShadowMap(mapManager)) {
                shader.addLib(wd.TwoDShadowMapShaderLib.create());
            }
            if (this._isCubemapShadowMap(mapManager)) {
                shader.addLib(wd.CubemapShadowMapShaderLib.create());
            }
            shader.addLib(wd.TotalShadowMapShaderLib.create());
        };
        Shadow.prototype._switchToNoShadowMapShaderLib = function (gameObject) {
            var material = gameObject.getComponent(wd.Geometry).material, shader = material.shader;
            shader.removeLib(function (lib) {
                return lib instanceof wd.TwoDShadowMapShaderLib || lib instanceof wd.CubemapShadowMapShaderLib || lib instanceof wd.TotalShadowMapShaderLib;
            });
            if (!shader.hasLib(wd.NoShadowMapShaderLib)) {
                shader.addLib(wd.NoShadowMapShaderLib.create());
            }
        };
        Shadow.prototype._isTwoDShadowMap = function (mapManager) {
            return mapManager.getTwoDShadowMapList().getCount() > 0;
        };
        Shadow.prototype._isCubemapShadowMap = function (mapManager) {
            return mapManager.getCubemapShadowMapList().getCount() > 0;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Shadow.prototype, "receive", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Shadow.prototype, "cast", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Shadow.prototype, "layer", null);
        __decorate([
            wd.require(function (entityObject, isShareComponent) {
                if (isShareComponent === void 0) { isShareComponent = false; }
                wd.assert(entityObject instanceof wd.GameObject, wd.Log.info.FUNC_SHOULD("add to GameObject"));
            })
        ], Shadow.prototype, "addToObject", null);
        __decorate([
            wd.require(function (material, shader) {
                wd.assert(!material.hasShader(wd.EShaderTypeOfScene.BUILD_TWOD_SHADOWMAP), wd.Log.info.FUNC_SHOULD_NOT("material", "exist build twoD shadow map shader"));
            })
        ], Shadow.prototype, "_addBuildTwoDShadowMapShader", null);
        __decorate([
            wd.require(function (material, shader) {
                wd.assert(!material.hasShader(wd.EShaderTypeOfScene.BUILD_CUBEMAP_SHADOWMAP), wd.Log.info.FUNC_SHOULD_NOT("material", "exist build cubemap shadow map shader"));
            })
        ], Shadow.prototype, "_addBuildCubemapShadowMapShader", null);
        __decorate([
            wd.ensure(function (returnVal, gameObject) {
                var material = gameObject.getComponent(wd.Geometry).material, shader = material.shader;
                wd.assert(!shader.hasLib(wd.NoShadowMapShaderLib), wd.Log.info.FUNC_SHOULD_NOT("contain NoShadowMapShaderLib"));
                wd.assert(shader.getLibs().filter(function (lib) {
                    return lib instanceof wd.TwoDShadowMapShaderLib;
                }).getCount() <= 1, wd.Log.info.FUNC_SHOULD_NOT("has duplicate TwoDShadowMapShaderLib"));
                wd.assert(shader.getLibs().filter(function (lib) {
                    return lib instanceof wd.CubemapShadowMapShaderLib;
                }).getCount() <= 1, wd.Log.info.FUNC_SHOULD_NOT("has duplicate CubemapShadowMapShaderLib"));
            })
        ], Shadow.prototype, "_switchToShadowMapShaderLib", null);
        __decorate([
            wd.ensure(function (returnVal, gameObject) {
                var material = gameObject.getComponent(wd.Geometry).material, shader = material.shader;
                wd.assert(!shader.hasLib(wd.TwoDShadowMapShaderLib), wd.Log.info.FUNC_SHOULD_NOT("contain TwoDShadowMapShaderLib"));
                wd.assert(!shader.hasLib(wd.CubemapShadowMapShaderLib), wd.Log.info.FUNC_SHOULD_NOT("contain CubemapShadowMapShaderLib"));
                wd.assert(shader.getLibs().filter(function (lib) {
                    return lib instanceof wd.NoShadowMapShaderLib;
                }).getCount() <= 1, wd.Log.info.FUNC_SHOULD_NOT("has duplicate NoShadowMapShaderLib"));
            })
        ], Shadow.prototype, "_switchToNoShadowMapShaderLib", null);
        return Shadow;
    }(wd.Component));
    wd.Shadow = Shadow;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowUtils = (function () {
        function ShadowUtils() {
        }
        ShadowUtils.isReceive = function (gameObject) {
            var shadow = null, parent = gameObject, result = false;
            do {
                shadow = parent.getComponent(wd.Shadow);
                if (!!shadow && shadow.receive) {
                    result = true;
                    break;
                }
                parent = parent.parent;
            } while (parent);
            return result;
        };
        return ShadowUtils;
    }());
    wd.ShadowUtils = ShadowUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EShadowLayer) {
        EShadowLayer[EShadowLayer["DEFAULT"] = "default"] = "DEFAULT";
    })(wd.EShadowLayer || (wd.EShadowLayer = {}));
    var EShadowLayer = wd.EShadowLayer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Geometry = (function (_super) {
        __extends(Geometry, _super);
        function Geometry() {
            _super.apply(this, arguments);
            this._material = null;
            this.buffers = null;
            this.vaoManager = !!wd.GPUDetector.getInstance().extensionVAO ? wd.VAOManager.create() : null;
            this.drawMode = wd.EDrawMode.TRIANGLES;
        }
        Object.defineProperty(Geometry.prototype, "material", {
            get: function () {
                return this._material;
            },
            set: function (material) {
                if (!wd.JudgeUtils.isEqual(material, this._material)) {
                    this._material = material;
                    this._material.geometry = this;
                    if (this.entityObject) {
                        wd.EventManager.trigger(this.entityObject, wd.CustomEvent.create(wd.EEngineEvent.MATERIAL_CHANGE));
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "geometryData", {
            get: function () {
                if (this.buffers === null) {
                    return null;
                }
                return this.buffers.geometryData;
            },
            enumerable: true,
            configurable: true
        });
        Geometry.prototype.init = function () {
            var geometryData = null, computedData = this.computeData();
            this.buffers = this.createBufferContainer();
            geometryData = this.createGeometryData(computedData);
            this.buffers.geometryData = geometryData;
            this.buffers.init();
            this._material.init();
            this.computeNormals();
            this.vaoManager && this.vaoManager.init();
        };
        Geometry.prototype.hasFaceNormals = function () {
            return this.buffers.geometryData.hasFaceNormals();
        };
        Geometry.prototype.hasVertexNormals = function () {
            return this.buffers.geometryData.hasVertexNormals();
        };
        Geometry.prototype.hasColors = function () {
            return this.buffers.geometryData.hasColors();
        };
        Geometry.prototype.isSmoothShading = function () {
            return this._material.shading === wd.EShading.SMOOTH;
        };
        Geometry.prototype.dispose = function () {
            this.buffers.dispose();
            this._material.dispose();
            this.vaoManager && this.vaoManager.dispose();
        };
        Geometry.prototype.computeFaceNormals = function () {
            this.buffers.geometryData.computeFaceNormals();
        };
        Geometry.prototype.computeVertexNormals = function () {
            this.buffers.geometryData.computeVertexNormals();
        };
        Geometry.prototype.createBuffersFromGeometryData = function () {
            this.buffers.createBuffersFromGeometryData();
        };
        Geometry.prototype.computeNormals = function () {
            if (this.isSmoothShading()) {
                if (!this.hasVertexNormals()) {
                    this.computeVertexNormals();
                }
            }
            else {
                if (!this.hasFaceNormals()) {
                    this.computeFaceNormals();
                }
            }
        };
        Geometry.prototype.createBufferContainer = function () {
            return wd.BasicBufferContainer.create(this.entityObject);
        };
        Geometry.prototype.createGeometryData = function (computedData) {
            return this.createBasicGeometryData(computedData);
        };
        Geometry.prototype.createBasicGeometryData = function (computedData) {
            var vertices = computedData.vertices, _a = computedData.faces, faces = _a === void 0 ? [] : _a, texCoords = computedData.texCoords, colors = computedData.colors, geometryData = wd.BasicGeometryData.create(this);
            geometryData.vertices = vertices;
            geometryData.faces = faces;
            geometryData.texCoords = texCoords;
            geometryData.colors = colors;
            return geometryData;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Geometry.prototype, "material", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Geometry.prototype, "drawMode", void 0);
        __decorate([
            wd.ensure(function () {
                var geometryData = this.buffers.geometryData;
                wd.it("faces.count should be be " + geometryData.indices.length / 3 + ", but actual is " + geometryData.faces.length, function () {
                    wd.expect(geometryData.faces.length * 3).equals(geometryData.indices.length);
                });
            }),
            wd.execOnlyOnce("_isInit")
        ], Geometry.prototype, "init", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("must define buffers->geometryData", function () {
                    wd.expect(_this.buffers).exist;
                    wd.expect(_this.buffers.geometryData).exist;
                });
            })
        ], Geometry.prototype, "hasFaceNormals", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("must define buffers->geometryData", function () {
                    wd.expect(_this.buffers).exist;
                    wd.expect(_this.buffers.geometryData).exist;
                });
            })
        ], Geometry.prototype, "hasVertexNormals", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("must define buffers->geometryData", function () {
                    wd.expect(_this.buffers).exist;
                    wd.expect(_this.buffers.geometryData).exist;
                });
            })
        ], Geometry.prototype, "computeFaceNormals", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("not exist buffers", function () {
                    wd.expect(_this.buffers).exist;
                });
            })
        ], Geometry.prototype, "createBuffersFromGeometryData", null);
        __decorate([
            wd.virtual
        ], Geometry.prototype, "computeNormals", null);
        __decorate([
            wd.virtual
        ], Geometry.prototype, "createBufferContainer", null);
        __decorate([
            wd.virtual
        ], Geometry.prototype, "createGeometryData", null);
        return Geometry;
    }(wd.Component));
    wd.Geometry = Geometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var InstanceGeometry = (function (_super) {
        __extends(InstanceGeometry, _super);
        function InstanceGeometry() {
            _super.apply(this, arguments);
            this._customGeometry = wd.CustomGeometry.create();
            this._attributeData = wdCb.Collection.create();
            this.dirty = false;
        }
        Object.defineProperty(InstanceGeometry.prototype, "vertices", {
            get: function () {
                return this._customGeometry.vertices;
            },
            set: function (vertices) {
                this._customGeometry.vertices = vertices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceGeometry.prototype, "texCoords", {
            get: function () {
                return this._customGeometry.texCoords;
            },
            set: function (texCoords) {
                this._customGeometry.texCoords = texCoords;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceGeometry.prototype, "colors", {
            get: function () {
                return this._customGeometry.colors;
            },
            set: function (colors) {
                this._customGeometry.colors = colors;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceGeometry.prototype, "indices", {
            get: function () {
                return this._customGeometry.indices;
            },
            set: function (indices) {
                this._customGeometry.indices = indices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceGeometry.prototype, "normals", {
            get: function () {
                return this._customGeometry.normals;
            },
            set: function (normals) {
                this._customGeometry.normals = normals;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceGeometry.prototype, "instanceAttributeData", {
            get: function () {
                return this.attributeData.getChild((0));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceGeometry.prototype, "instanceCount", {
            get: function () {
                return this.attributeData.getCount();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstanceGeometry.prototype, "attributeData", {
            get: function () {
                return this._attributeData;
            },
            enumerable: true,
            configurable: true
        });
        InstanceGeometry.prototype.addInstanceAttributes = function (attributes) {
            var attributeListWithDefaultValue = wdCb.Collection.create();
            this.dirty = true;
            for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                var attributeData = attributes_1[_i];
                attributeListWithDefaultValue.addChild(wdCb.ExtendUtils.extend({
                    meshPerAttribute: 1
                }, attributeData));
            }
            this._attributeData.addChild(attributeListWithDefaultValue);
        };
        InstanceGeometry.prototype.clearInstanceAttributeData = function () {
            this.dirty = true;
            this._attributeData.removeAllChildren();
        };
        InstanceGeometry.prototype.computeData = function () {
            return {
                vertices: this.vertices,
                faces: wd.GeometryUtils.convertToFaces(this.indices, this.normals),
                texCoords: this.texCoords,
                colors: this.colors
            };
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], InstanceGeometry.prototype, "vertices", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], InstanceGeometry.prototype, "texCoords", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], InstanceGeometry.prototype, "colors", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], InstanceGeometry.prototype, "indices", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], InstanceGeometry.prototype, "normals", null);
        __decorate([
            wd.requireGetter(function () {
                var _this = this;
                wd.it("attributeData.length should > 0", function () {
                    wd.expect(_this.attributeData.getCount()).greaterThan(0);
                }, this);
            }),
            wd.ensureGetter(function (instanceAttributeData) {
                var _this = this;
                wd.it("each data of all instance datas should be the same except the data", function () {
                    _this.attributeData.forEach(function (dataList) {
                        dataList.forEach(function (data, index) {
                            wd.expect(data.attributeName).equals(instanceAttributeData.getChild(index).attributeName);
                            wd.expect(data.meshPerAttribute).equals(instanceAttributeData.getChild(index).meshPerAttribute);
                        });
                    });
                }, this);
            })
        ], InstanceGeometry.prototype, "instanceAttributeData", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                var sourceData = source[memberName], targetData = target[memberName];
                sourceData.forEach(function (dataList) {
                    targetData.addChild(dataList.clone(true));
                });
            })
        ], InstanceGeometry.prototype, "attributeData", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], InstanceGeometry.prototype, "dirty", void 0);
        __decorate([
            wd.require(function (attributes) {
                wd.it("attributeName shouldn't equal vertices|normals|indices|texCoords|colors", function () {
                    for (var _i = 0, attributes_2 = attributes; _i < attributes_2.length; _i++) {
                        var data = attributes_2[_i];
                        var name_3 = data.attributeName;
                        wd.expect(name_3).not.equals("vertices");
                        wd.expect(name_3).not.equals("normals");
                        wd.expect(name_3).not.equals("indices");
                        wd.expect(name_3).not.equals("texCoords");
                        wd.expect(name_3).not.equals("colors");
                    }
                });
                wd.it("data should be Array<number> or Float32Array", function () {
                    for (var _i = 0, attributes_3 = attributes; _i < attributes_3.length; _i++) {
                        var data = attributes_3[_i];
                        var d = data.data;
                        wd.expect(wd.JudgeUtils.isArrayExactly(d) || Object.prototype.toString.call(d) === "[object Float32Array]").true;
                    }
                });
            })
        ], InstanceGeometry.prototype, "addInstanceAttributes", null);
        return InstanceGeometry;
    }(wd.Geometry));
    wd.InstanceGeometry = InstanceGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicInstanceGeometry = (function (_super) {
        __extends(BasicInstanceGeometry, _super);
        function BasicInstanceGeometry() {
            _super.apply(this, arguments);
        }
        BasicInstanceGeometry.create = function () {
            var obj = new this();
            return obj;
        };
        return BasicInstanceGeometry;
    }(wd.InstanceGeometry));
    wd.BasicInstanceGeometry = BasicInstanceGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VAOManager = (function () {
        function VAOManager() {
            this._vaoMap = wdCb.Hash.create();
            this._extension = null;
        }
        VAOManager.create = function () {
            var obj = new this();
            return obj;
        };
        VAOManager.prototype.init = function () {
            this._extension = wd.GPUDetector.getInstance().extensionVAO;
        };
        VAOManager.prototype.dispose = function () {
            this._vaoMap.removeAllChildren();
        };
        VAOManager.prototype.getVAOData = function (toSendBuffersUidStr) {
            var isSetted = false, vao = this._vaoMap.getChild(toSendBuffersUidStr);
            if (!vao) {
                vao = this._extension.createVertexArrayOES();
                this._vaoMap.addChild(toSendBuffersUidStr, vao);
                isSetted = false;
            }
            else {
                isSetted = true;
            }
            return {
                vao: vao,
                isSetted: isSetted
            };
        };
        VAOManager.prototype.sendAllBufferData = function (toSendBuffersUidStr, toSendBufferArr) {
            var _a = this.getVAOData(toSendBuffersUidStr), vao = _a.vao, isSetted = _a.isSetted;
            wd.BufferTable.lastBindedElementBuffer = null;
            this._extension.bindVertexArrayOES(vao);
            if (isSetted) {
                return;
            }
            for (var pos = 0, len = toSendBufferArr.length; pos < len; pos++) {
                var buffer = toSendBufferArr[pos];
                if (!buffer) { }
                if (buffer) {
                    var gl = wd.DeviceManager.getInstance().gl;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
                    gl.vertexAttribPointer(pos, buffer.size, gl[buffer.type], false, 0, 0);
                    gl.enableVertexAttribArray(pos);
                }
            }
        };
        __decorate([
            wd.require(function () {
                wd.assert(!!wd.GPUDetector.getInstance().extensionVAO, wd.Log.info.FUNC_SHOULD("hardware", "support vao extension"));
            })
        ], VAOManager.prototype, "init", null);
        return VAOManager;
    }());
    wd.VAOManager = VAOManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LineGeometry = (function (_super) {
        __extends(LineGeometry, _super);
        function LineGeometry() {
            _super.apply(this, arguments);
            this._customGeometry = wd.CustomGeometry.create();
        }
        Object.defineProperty(LineGeometry.prototype, "vertices", {
            get: function () {
                return this._customGeometry.vertices;
            },
            set: function (vertices) {
                this._customGeometry.vertices = vertices;
            },
            enumerable: true,
            configurable: true
        });
        LineGeometry.prototype.computeData = function () {
            return {
                vertices: this.computeVertices()
            };
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], LineGeometry.prototype, "vertices", null);
        return LineGeometry;
    }(wd.Geometry));
    wd.LineGeometry = LineGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SolidLineGeometry = (function (_super) {
        __extends(SolidLineGeometry, _super);
        function SolidLineGeometry() {
            _super.apply(this, arguments);
        }
        SolidLineGeometry.create = function () {
            var geo = new this();
            geo.initWhenCreate();
            return geo;
        };
        SolidLineGeometry.prototype.initWhenCreate = function () {
            this.drawMode = wd.EDrawMode.LINE_STRIP;
        };
        SolidLineGeometry.prototype.computeVertices = function () {
            return this.vertices;
        };
        return SolidLineGeometry;
    }(wd.LineGeometry));
    wd.SolidLineGeometry = SolidLineGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DashLineGeometry = (function (_super) {
        __extends(DashLineGeometry, _super);
        function DashLineGeometry() {
            _super.apply(this, arguments);
            this.dashSize = 3;
            this.gapSize = 1;
            this.dashCount = 200;
        }
        DashLineGeometry.create = function () {
            var geo = new this();
            geo.initWhenCreate();
            return geo;
        };
        DashLineGeometry.prototype.initWhenCreate = function () {
            this.drawMode = wd.EDrawMode.LINES;
        };
        DashLineGeometry.prototype.computeVertices = function () {
            var dashSize = this.dashSize, gapSize = this.gapSize, dashCount = this.dashCount, points = this.vertices.slice(0), curvect = wd.Vector3.create(), lg = 0, count = 0, shft = 0, dashshft = 0, curshft = 0, vertices = [];
            for (var i = 0, len = points.length - 3; i < len; i += 3) {
                curvect.x = points[i + 3] - points[i];
                curvect.y = points[i + 4] - points[i + 1];
                curvect.z = points[i + 5] - points[i + 2];
                lg += curvect.length();
            }
            shft = lg / dashCount;
            dashshft = dashSize * shft / (dashSize + gapSize);
            for (var i = 0, len = points.length - 3; i < len; i += 3) {
                curvect.x = points[i + 3] - points[i];
                curvect.y = points[i + 4] - points[i + 1];
                curvect.z = points[i + 5] - points[i + 2];
                count = Math.floor(curvect.length() / shft);
                curvect.normalize();
                for (var j = 0; j < count; j++) {
                    curshft = shft * j;
                    vertices.push(points[i] + curshft * curvect.x, points[i + 1] + curshft * curvect.y, points[i + 2] + curshft * curvect.z);
                    vertices.push(points[i] + (curshft + dashshft) * curvect.x, points[i + 1] + (curshft + dashshft) * curvect.y, points[i + 2] + (curshft + dashshft) * curvect.z);
                }
            }
            return vertices;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DashLineGeometry.prototype, "dashSize", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DashLineGeometry.prototype, "gapSize", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DashLineGeometry.prototype, "dashCount", void 0);
        return DashLineGeometry;
    }(wd.LineGeometry));
    wd.DashLineGeometry = DashLineGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ConvexPolygonGeometry = (function (_super) {
        __extends(ConvexPolygonGeometry, _super);
        function ConvexPolygonGeometry() {
            _super.apply(this, arguments);
            this._customGeometry = wd.CustomGeometry.create();
        }
        ConvexPolygonGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        Object.defineProperty(ConvexPolygonGeometry.prototype, "vertices", {
            get: function () {
                return this._customGeometry.vertices;
            },
            set: function (vertices) {
                this._customGeometry.vertices = vertices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConvexPolygonGeometry.prototype, "texCoords", {
            get: function () {
                return this._customGeometry.texCoords;
            },
            set: function (texCoords) {
                this._customGeometry.texCoords = texCoords;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConvexPolygonGeometry.prototype, "colors", {
            get: function () {
                return this._customGeometry.colors;
            },
            set: function (colors) {
                this._customGeometry.colors = colors;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConvexPolygonGeometry.prototype, "indices", {
            get: function () {
                return this._customGeometry.indices;
            },
            set: function (indices) {
                this._customGeometry.indices = indices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConvexPolygonGeometry.prototype, "normals", {
            get: function () {
                return this._customGeometry.normals;
            },
            set: function (normals) {
                this._customGeometry.normals = normals;
            },
            enumerable: true,
            configurable: true
        });
        ConvexPolygonGeometry.prototype.computeData = function () {
            var indices = [];
            for (var i = 1, len = this.vertices.length / 3 - 1; i < len; i++) {
                indices.push(0, i + 1, i);
            }
            this.indices = indices;
            return {
                vertices: this.vertices,
                faces: wd.GeometryUtils.convertToFaces(this.indices, this.normals),
                texCoords: this.texCoords,
                colors: this.colors
            };
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ConvexPolygonGeometry.prototype, "vertices", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ConvexPolygonGeometry.prototype, "texCoords", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ConvexPolygonGeometry.prototype, "colors", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ConvexPolygonGeometry.prototype, "indices", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ConvexPolygonGeometry.prototype, "normals", null);
        return ConvexPolygonGeometry;
    }(wd.Geometry));
    wd.ConvexPolygonGeometry = ConvexPolygonGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GeometryUtils = (function () {
        function GeometryUtils() {
        }
        GeometryUtils.convertToFaces = function (indices, normals) {
            var hasNormals = this.hasData(normals), faces = [];
            for (var i = 0, len = indices.length; i < len; i += 3) {
                var a = indices[i], b = indices[i + 1], c = indices[i + 2], face = wd.Face3.create(a, b, c);
                if (hasNormals) {
                    face.vertexNormals.addChildren([
                        this.getThreeComponent(normals, a),
                        this.getThreeComponent(normals, b),
                        this.getThreeComponent(normals, c)
                    ]);
                    face.faceNormal = face.vertexNormals.getChild(0).clone();
                }
                faces.push(face);
            }
            return faces;
        };
        GeometryUtils.hasData = function (data) {
            return data && ((data.length && data.length > 0) || (data.getCount && data.getCount() > 0));
        };
        GeometryUtils.getThreeComponent = function (sourceData, index) {
            var startIndex = 3 * index;
            return wd.Vector3.create(sourceData[startIndex], sourceData[startIndex + 1], sourceData[startIndex + 2]);
        };
        GeometryUtils.iterateThreeComponent = function (dataArr, iterator) {
            for (var i = 0, len = dataArr.length; i < len; i += 3) {
                iterator(wd.Vector3.create(dataArr[i], dataArr[i + 1], dataArr[i + 2]));
            }
        };
        GeometryUtils.setThreeComponent = function (targetData, sourceData, index) {
            if (sourceData instanceof wd.Vector3) {
                targetData[index * 3] = sourceData.x;
                targetData[index * 3 + 1] = sourceData.y;
                targetData[index * 3 + 2] = sourceData.z;
            }
            else {
                targetData[index * 3] = sourceData[0];
                targetData[index * 3 + 1] = sourceData[1];
                targetData[index * 3 + 2] = sourceData[2];
            }
        };
        GeometryUtils.mergeFace = function (source, target) {
            if (!target) {
                return source;
            }
            for (var _i = 0, target_2 = target; _i < target_2.length; _i++) {
                var face = target_2[_i];
                source.push(face.clone());
            }
            return source;
        };
        __decorate([
            wd.require(function (data) {
                if (data) {
                    wd.assert(data instanceof wdCb.Collection || data instanceof wdCb.Hash || wd.JudgeUtils.isArrayExactly(data), wd.Log.info.FUNC_SHOULD("data", "be Array or Collection or Hash"));
                }
            })
        ], GeometryUtils, "hasData", null);
        __decorate([
            wd.require(function (dataArr, iterator) {
                wd.assert(dataArr.length % 3 === 0, wd.Log.info.FUNC_SHOULD("dataArr.length", "times of three"));
            })
        ], GeometryUtils, "iterateThreeComponent", null);
        return GeometryUtils;
    }());
    wd.GeometryUtils = GeometryUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomGeometry = (function (_super) {
        __extends(CustomGeometry, _super);
        function CustomGeometry() {
            _super.apply(this, arguments);
            this._vertices = [];
            this._texCoords = [];
            this._colors = [];
            this._indices = [];
            this._normals = [];
        }
        CustomGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        Object.defineProperty(CustomGeometry.prototype, "vertices", {
            get: function () {
                return this._vertices;
            },
            set: function (vertices) {
                this._vertices = vertices;
                if (this.buffers) {
                    this.buffers.geometryData.vertices = vertices;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomGeometry.prototype, "texCoords", {
            get: function () {
                return this._texCoords;
            },
            set: function (texCoords) {
                this._texCoords = texCoords;
                if (this.buffers) {
                    this.buffers.geometryData.texCoords = texCoords;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomGeometry.prototype, "colors", {
            get: function () {
                return this._colors;
            },
            set: function (colors) {
                this._colors = colors;
                if (this.buffers) {
                    this.buffers.geometryData.colors = colors;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomGeometry.prototype, "indices", {
            get: function () {
                return this._indices;
            },
            set: function (indices) {
                this._indices = indices;
                if (this.buffers) {
                    this.buffers.geometryData.faces = wd.GeometryUtils.convertToFaces(indices, this.normals);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CustomGeometry.prototype, "normals", {
            get: function () {
                return this._normals;
            },
            set: function (normals) {
                this._normals = normals;
                if (this.buffers) {
                    this.buffers.geometryData.faces = wd.GeometryUtils.convertToFaces(this.indices, normals);
                }
            },
            enumerable: true,
            configurable: true
        });
        CustomGeometry.prototype.computeData = function () {
            return {
                vertices: this.vertices,
                faces: wd.GeometryUtils.convertToFaces(this.indices, this.normals),
                texCoords: this.texCoords,
                colors: this.colors
            };
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], CustomGeometry.prototype, "vertices", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], CustomGeometry.prototype, "texCoords", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], CustomGeometry.prototype, "colors", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], CustomGeometry.prototype, "indices", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], CustomGeometry.prototype, "normals", null);
        return CustomGeometry;
    }(wd.Geometry));
    wd.CustomGeometry = CustomGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelGeometryMerger = (function () {
        function ModelGeometryMerger() {
        }
        ModelGeometryMerger.create = function () {
            var obj = new this();
            return obj;
        };
        ModelGeometryMerger.prototype.merge = function (targetGeometry, sourceGeometry, transform) {
            var sourceModelGeometryData = this._getSourceModelGeometryData(targetGeometry), targetModelGeometryData = this._getTargetModelGeometryData(sourceGeometry);
            sourceModelGeometryData = this._initModelGeometryData(sourceModelGeometryData);
            targetGeometry.faces = this._mergeTransformedFace(sourceModelGeometryData.faces, targetModelGeometryData.faces, transform, sourceModelGeometryData.vertices.length / 3);
            targetGeometry.vertices = this._mergeData(sourceModelGeometryData.vertices, this._transformVertices(targetModelGeometryData.vertices, transform));
            targetGeometry.texCoords = this._mergeData(sourceModelGeometryData.texCoords, targetModelGeometryData.texCoords);
            targetGeometry.colors = this._mergeData(sourceModelGeometryData.colors, targetModelGeometryData.colors);
            targetGeometry.jointIndices = this._mergeData(sourceModelGeometryData.jointIndices, targetModelGeometryData.jointIndices);
            targetGeometry.jointWeights = this._mergeData(sourceModelGeometryData.jointWeights, targetModelGeometryData.jointWeights);
        };
        ModelGeometryMerger.prototype._getSourceModelGeometryData = function (targetGeometry) {
            if (targetGeometry.geometryData !== null) {
                return targetGeometry.geometryData;
            }
            return {
                vertices: targetGeometry.vertices,
                texCoords: targetGeometry.texCoords,
                colors: targetGeometry.colors,
                jointIndices: targetGeometry.jointIndices,
                jointWeights: targetGeometry.jointWeights,
                faces: targetGeometry.faces
            };
        };
        ModelGeometryMerger.prototype._initModelGeometryData = function (geometryData) {
            return {
                vertices: geometryData.vertices || [],
                texCoords: geometryData.texCoords || [],
                colors: geometryData.colors || [],
                jointIndices: geometryData.jointIndices || [],
                jointWeights: geometryData.jointWeights || [],
                faces: geometryData.faces || []
            };
        };
        ModelGeometryMerger.prototype._getTargetModelGeometryData = function (targetGeometry) {
            if (targetGeometry.geometryData !== null) {
                return targetGeometry.geometryData;
            }
            if (targetGeometry instanceof wd.ModelGeometry) {
                return {
                    vertices: targetGeometry.vertices,
                    texCoords: targetGeometry.texCoords,
                    colors: targetGeometry.colors,
                    jointIndices: targetGeometry.jointIndices,
                    jointWeights: targetGeometry.jointWeights,
                    faces: targetGeometry.faces
                };
            }
            return targetGeometry.computeData();
        };
        ModelGeometryMerger.prototype._transformVertices = function (vertices, targetTransform) {
            var modelMatrix = targetTransform.localToWorldMatrix, resultVertices = [];
            for (var i = 0, len = vertices.length; i < len; i += 3) {
                var transformedVec3 = wd.Vector3.create(vertices[i], vertices[i + 1], vertices[i + 2]).applyMatrix4(modelMatrix);
                resultVertices.push(transformedVec3.x, transformedVec3.y, transformedVec3.z);
            }
            return resultVertices;
        };
        ModelGeometryMerger.prototype._mergeTransformedFace = function (sourceFaces, targetFaces, targetTransform, sourceVertexOffset) {
            var normalMatrix = null;
            if (!targetFaces) {
                return sourceFaces;
            }
            normalMatrix = targetTransform.normalMatrix;
            var _loop_1 = function(face) {
                var clonedFace = wd.Face3.create(face.aIndex + sourceVertexOffset, face.bIndex + sourceVertexOffset, face.cIndex + sourceVertexOffset);
                if (face.hasFaceNormal()) {
                    clonedFace.faceNormal = face.faceNormal.clone().applyMatrix3(normalMatrix);
                }
                if (face.vertexNormals) {
                    var clonedVertexNormals_1 = wdCb.Collection.create();
                    face.vertexNormals.forEach(function (normal) {
                        clonedVertexNormals_1.addChild(normal.clone().applyMatrix3(normalMatrix));
                    });
                    clonedFace.vertexNormals = clonedVertexNormals_1;
                }
                sourceFaces.push(clonedFace);
            };
            for (var _i = 0, targetFaces_1 = targetFaces; _i < targetFaces_1.length; _i++) {
                var face = targetFaces_1[_i];
                _loop_1(face);
            }
            return sourceFaces;
        };
        ModelGeometryMerger.prototype._mergeData = function (source, target) {
            if (!target) {
                return source;
            }
            return source.concat(target);
        };
        ModelGeometryMerger.prototype._mergeFace = function (source, target) {
            return wd.GeometryUtils.mergeFace(source, target);
        };
        __decorate([
            wd.require(function (vertices, targetTransform) {
                wd.assert(vertices && vertices.length > 0, wd.Log.info.FUNC_MUST("vertices.count", "> 0"));
            })
        ], ModelGeometryMerger.prototype, "_transformVertices", null);
        return ModelGeometryMerger;
    }());
    wd.ModelGeometryMerger = ModelGeometryMerger;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelGeometry = (function (_super) {
        __extends(ModelGeometry, _super);
        function ModelGeometry() {
            _super.apply(this, arguments);
            this.vertices = null;
            this.colors = null;
            this.texCoords = null;
            this.faces = null;
            this.morphVertices = null;
            this.morphFaceNormals = wdCb.Hash.create();
            this.morphVertexNormals = wdCb.Hash.create();
            this.jointIndices = null;
            this.jointWeights = null;
            this._merger = wd.ModelGeometryMerger.create();
        }
        ModelGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        ModelGeometry.prototype.hasMorphAnimation = function () {
            return this._hasMorphTargets() && (this.entityObject && wd.ClassUtils.hasComponent(this.entityObject, "MorphAnimation"));
        };
        ModelGeometry.prototype.hasSkinSkeletonAnimation = function () {
            return this._hasJoinData() && (this.entityObject && wd.ClassUtils.hasComponent(this.entityObject, "SkinSkeletonAnimation"));
        };
        ModelGeometry.prototype.hasMorphFaceNormals = function () {
            return this.buffers.geometryData.hasMorphFaceNormals();
        };
        ModelGeometry.prototype.hasMorphVertexNormals = function () {
            return this.buffers.geometryData.hasMorphVertexNormals();
        };
        ModelGeometry.prototype.computeMorphNormals = function () {
            this.buffers.geometryData.computeMorphNormals();
        };
        ModelGeometry.prototype.merge = function (geometry, transform) {
            this._merger.merge(this, geometry, transform);
        };
        ModelGeometry.prototype.computeNormals = function () {
            _super.prototype.computeNormals.call(this);
            if (this._hasMorphTargets()) {
                if (this.isSmoothShading()) {
                    if (!this.hasMorphVertexNormals()) {
                        this.computeMorphNormals();
                    }
                }
                else {
                    if (!this.hasMorphFaceNormals()) {
                        this.computeMorphNormals();
                    }
                }
            }
        };
        ModelGeometry.prototype.computeData = function () {
            return {
                vertices: this.vertices,
                faces: this.faces,
                texCoords: this.texCoords,
                colors: this.colors,
                jointIndices: this.jointIndices,
                jointWeights: this.jointWeights,
                morphVertices: this.morphVertices
            };
        };
        ModelGeometry.prototype.createBufferContainer = function () {
            if (this.hasMorphAnimation()) {
                var MorphBufferContainer_1 = wd.ClassUtils.getClass("MorphBufferContainer"), MorphAnimation_1 = wd.ClassUtils.getClass("MorphAnimation");
                return MorphBufferContainer_1.create(this.entityObject, this.entityObject.getComponent(MorphAnimation_1));
            }
            if (this.hasSkinSkeletonAnimation()) {
                var SkinSkeletonBufferContainer_1 = wd.ClassUtils.getClass("SkinSkeletonBufferContainer"), SkinSkeletonAnimation_1 = wd.ClassUtils.getClass("SkinSkeletonAnimation");
                return SkinSkeletonBufferContainer_1.create(this.entityObject);
            }
            return wd.BasicBufferContainer.create(this.entityObject);
        };
        ModelGeometry.prototype.createGeometryData = function (computedData) {
            if (this.hasMorphAnimation()) {
                var vertices = computedData.vertices, _a = computedData.faces, faces = _a === void 0 ? [] : _a, texCoords = computedData.texCoords, colors = computedData.colors, morphVertices = computedData.morphVertices, MorphGeometryData_1 = wd.ClassUtils.getClass("MorphGeometryData"), geometryData = MorphGeometryData_1.create(this);
                geometryData.vertices = vertices;
                geometryData.faces = faces;
                geometryData.texCoords = texCoords;
                geometryData.colors = colors;
                geometryData.morphVertices = morphVertices;
                return geometryData;
            }
            if (this.hasSkinSkeletonAnimation()) {
                var vertices = computedData.vertices, _b = computedData.faces, faces = _b === void 0 ? [] : _b, texCoords = computedData.texCoords, colors = computedData.colors, jointIndices = computedData.jointIndices, jointWeights = computedData.jointWeights, SkinSkeletonGeometryData_1 = wd.ClassUtils.getClass("SkinSkeletonGeometryData"), geometryData = SkinSkeletonGeometryData_1.create(this);
                geometryData.vertices = vertices;
                geometryData.faces = faces;
                geometryData.texCoords = texCoords;
                geometryData.colors = colors;
                geometryData.jointIndices = jointIndices;
                geometryData.jointWeights = jointWeights;
                return geometryData;
            }
            return this.createBasicGeometryData(computedData);
        };
        ModelGeometry.prototype._hasMorphTargets = function () {
            return this.morphVertices && this.morphVertices.getCount() > 0;
        };
        ModelGeometry.prototype._hasJoinData = function () {
            return this.jointIndices && this.jointIndices.length > 0;
        };
        ModelGeometry.prototype._getDeepCloneMorphData = function (source) {
            var result = wdCb.Hash.create();
            if (source) {
                source.forEach(function (data, key) {
                    result.addChild(key, data.clone(true));
                });
            }
            return result;
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ModelGeometry.prototype, "vertices", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ModelGeometry.prototype, "colors", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ModelGeometry.prototype, "texCoords", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.GeometryUtils.mergeFace([], source[memberName]);
            })
        ], ModelGeometry.prototype, "faces", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = this._getDeepCloneMorphData(source[memberName]);
            })
        ], ModelGeometry.prototype, "morphVertices", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = this._getDeepCloneMorphData(source[memberName]);
            })
        ], ModelGeometry.prototype, "morphFaceNormals", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = this._getDeepCloneMorphData(source[memberName]);
            })
        ], ModelGeometry.prototype, "morphVertexNormals", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ModelGeometry.prototype, "jointIndices", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName]);
            })
        ], ModelGeometry.prototype, "jointWeights", void 0);
        __decorate([
            wd.require(function () {
                wd.assert(this.buffers && this.buffers.geometryData, wd.Log.info.FUNC_MUST_DEFINE("buffers->geometryData"));
            })
        ], ModelGeometry.prototype, "hasMorphFaceNormals", null);
        __decorate([
            wd.require(function () {
                wd.assert(this.buffers && this.buffers.geometryData, wd.Log.info.FUNC_MUST_DEFINE("buffers->geometryData"));
            })
        ], ModelGeometry.prototype, "hasMorphVertexNormals", null);
        __decorate([
            wd.require(function () {
                wd.assert(this.buffers && this.buffers.geometryData, wd.Log.info.FUNC_MUST_DEFINE("buffers->geometryData"));
            })
        ], ModelGeometry.prototype, "computeMorphNormals", null);
        __decorate([
            wd.require(function () {
                var _this = this;
                if (this.hasMorphAnimation()) {
                    wd.it("entityObject with ModelGeometry should add MorphAnimation component", function () {
                        wd.ClassUtils.hasComponent(_this.entityObject, "MorphAnimation");
                    }, this);
                }
            })
        ], ModelGeometry.prototype, "createBufferContainer", null);
        __decorate([
            wd.ensure(function (hasJoinData) {
                var _this = this;
                wd.it("jointIndices and jointWeights should has data", function () {
                    if (!hasJoinData) {
                        return;
                    }
                    wd.expect(_this.jointWeights && _this.jointWeights.length > 0);
                });
            })
        ], ModelGeometry.prototype, "_hasJoinData", null);
        return ModelGeometry;
    }(wd.Geometry));
    wd.ModelGeometry = ModelGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BoxGeometry = (function (_super) {
        __extends(BoxGeometry, _super);
        function BoxGeometry() {
            _super.apply(this, arguments);
            this.width = null;
            this.height = null;
            this.depth = null;
            this.widthSegments = 1;
            this.heightSegments = 1;
            this.depthSegments = 1;
        }
        BoxGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        BoxGeometry.prototype.computeData = function () {
            var width = this.width, height = this.height, depth = this.depth, widthSegments = this.widthSegments, heightSegments = this.heightSegments, depthSegments = this.depthSegments, sides = {
                FRONT: 0,
                BACK: 1,
                TOP: 2,
                BOTTOM: 3,
                RIGHT: 4,
                LEFT: 5
            };
            var faceAxes = [
                [0, 1, 3],
                [4, 5, 7],
                [3, 2, 6],
                [1, 0, 4],
                [1, 4, 2],
                [5, 0, 6]
            ];
            var faceNormals = [
                [0, 0, 1],
                [0, 0, -1],
                [0, 1, 0],
                [0, -1, 0],
                [1, 0, 0],
                [-1, 0, 0]
            ];
            var corners = [
                wd.Vector3.create(-width, -height, depth),
                wd.Vector3.create(width, -height, depth),
                wd.Vector3.create(width, height, depth),
                wd.Vector3.create(-width, height, depth),
                wd.Vector3.create(width, -height, -depth),
                wd.Vector3.create(-width, -height, -depth),
                wd.Vector3.create(-width, height, -depth),
                wd.Vector3.create(width, height, -depth)
            ];
            var vertices = [];
            var normals = [];
            var texCoords = [];
            var indices = [];
            function generateFace(side, uSegments, vSegments) {
                var x, y, z, u, v;
                var i, j;
                var offset = vertices.length / 3;
                for (i = 0; i <= uSegments; i++) {
                    for (j = 0; j <= vSegments; j++) {
                        var temp1 = wd.Vector3.create();
                        var temp2 = wd.Vector3.create();
                        var temp3 = wd.Vector3.create();
                        var r = wd.Vector3.create();
                        temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
                        temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
                        temp3.sub2(temp2, corners[faceAxes[side][0]]);
                        r.add2(temp1, temp3);
                        u = i / uSegments;
                        v = j / vSegments;
                        vertices.push(r.x, r.y, r.z);
                        normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
                        texCoords.push(u, v);
                        if ((i < uSegments) && (j < vSegments)) {
                            indices.push(offset + j + i * (uSegments + 1), offset + j + (i + 1) * (uSegments + 1), offset + j + i * (uSegments + 1) + 1);
                            indices.push(offset + j + (i + 1) * (uSegments + 1), offset + j + (i + 1) * (uSegments + 1) + 1, offset + j + i * (uSegments + 1) + 1);
                        }
                    }
                }
            }
            generateFace(sides.FRONT, widthSegments, heightSegments);
            generateFace(sides.BACK, widthSegments, heightSegments);
            generateFace(sides.TOP, widthSegments, depthSegments);
            generateFace(sides.BOTTOM, widthSegments, depthSegments);
            generateFace(sides.RIGHT, depthSegments, heightSegments);
            generateFace(sides.LEFT, depthSegments, heightSegments);
            return {
                vertices: vertices,
                faces: wd.GeometryUtils.convertToFaces(indices, normals),
                texCoords: texCoords
            };
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BoxGeometry.prototype, "width", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BoxGeometry.prototype, "height", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BoxGeometry.prototype, "depth", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BoxGeometry.prototype, "widthSegments", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BoxGeometry.prototype, "heightSegments", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BoxGeometry.prototype, "depthSegments", void 0);
        return BoxGeometry;
    }(wd.Geometry));
    wd.BoxGeometry = BoxGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RectGeometry = (function (_super) {
        __extends(RectGeometry, _super);
        function RectGeometry() {
            _super.apply(this, arguments);
            this.width = null;
            this.height = null;
        }
        RectGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        RectGeometry.prototype.computeData = function () {
            var width = this.width, height = this.height, left = -width / 2, right = width / 2, up = height / 2, down = -height / 2, vertices = [], texCoords = [], indices = [], normals = [];
            vertices = [
                right, up, 0,
                left, up, 0,
                left, down, 0,
                right, down, 0
            ];
            indices = [
                0, 1, 2, 0, 2, 3
            ];
            texCoords = [
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0
            ];
            normals = [
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,
                0, 0, 1
            ];
            return {
                vertices: vertices,
                faces: wd.GeometryUtils.convertToFaces(indices, normals),
                texCoords: texCoords
            };
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], RectGeometry.prototype, "width", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], RectGeometry.prototype, "height", void 0);
        return RectGeometry;
    }(wd.Geometry));
    wd.RectGeometry = RectGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PlaneGeometry = (function (_super) {
        __extends(PlaneGeometry, _super);
        function PlaneGeometry() {
            _super.apply(this, arguments);
            this.width = null;
            this.height = null;
            this.widthSegments = 1;
            this.heightSegments = 1;
        }
        PlaneGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        PlaneGeometry.prototype.computeData = function () {
            var width = this.width, height = this.height, widthSegments = this.widthSegments, heightSegments = this.heightSegments, x = null, y = null, z = null, u = null, v = null, i = null, j = null, vertices = [], texCoords = [], normals = [], indices = [];
            for (i = 0; i <= widthSegments; i++) {
                for (j = 0; j <= heightSegments; j++) {
                    x = -width + 2.0 * width * i / widthSegments;
                    y = 0.0;
                    z = -(-height + 2.0 * height * j / heightSegments);
                    u = i / widthSegments;
                    v = j / heightSegments;
                    vertices.push(x, y, z);
                    normals.push(0.0, 1.0, 0.0);
                    texCoords.push(u, v);
                    if ((i < widthSegments) && (j < heightSegments)) {
                        indices.push(j + i * (widthSegments + 1), j + (i + 1) * (widthSegments + 1), j + i * (widthSegments + 1) + 1);
                        indices.push(j + (i + 1) * (widthSegments + 1), j + (i + 1) * (widthSegments + 1) + 1, j + i * (widthSegments + 1) + 1);
                    }
                }
            }
            return {
                vertices: vertices,
                faces: wd.GeometryUtils.convertToFaces(indices, normals),
                texCoords: texCoords
            };
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlaneGeometry.prototype, "width", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlaneGeometry.prototype, "height", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlaneGeometry.prototype, "widthSegments", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PlaneGeometry.prototype, "heightSegments", void 0);
        return PlaneGeometry;
    }(wd.Geometry));
    wd.PlaneGeometry = PlaneGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ESphereDrawMode) {
        ESphereDrawMode[ESphereDrawMode["LATITUDELONGTITUDE"] = 0] = "LATITUDELONGTITUDE";
    })(wd.ESphereDrawMode || (wd.ESphereDrawMode = {}));
    var ESphereDrawMode = wd.ESphereDrawMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SphereGeometry = (function (_super) {
        __extends(SphereGeometry, _super);
        function SphereGeometry() {
            _super.apply(this, arguments);
            this.radius = 1;
            this.sphereDrawMode = wd.ESphereDrawMode.LATITUDELONGTITUDE;
            this.segments = 20;
        }
        SphereGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        SphereGeometry.prototype.computeData = function () {
            var radius = this.radius, sphereDrawMode = this.sphereDrawMode, segments = this.segments;
            var _a = GetDataByLatitudeLongtitude.create(radius, segments).getData(), vertices = _a.vertices, indices = _a.indices, normals = _a.normals, texCoords = _a.texCoords;
            return {
                vertices: vertices,
                faces: wd.GeometryUtils.convertToFaces(indices, normals),
                texCoords: texCoords
            };
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], SphereGeometry.prototype, "radius", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], SphereGeometry.prototype, "sphereDrawMode", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], SphereGeometry.prototype, "segments", void 0);
        __decorate([
            wd.require(function () {
                wd.assert(this.sphereDrawMode === wd.ESphereDrawMode.LATITUDELONGTITUDE, wd.Log.info.FUNC_MUST_BE("sphereDrawMode", "ESphereDrawMode.LATITUDELONGTITUDE"));
            })
        ], SphereGeometry.prototype, "computeData", null);
        return SphereGeometry;
    }(wd.Geometry));
    wd.SphereGeometry = SphereGeometry;
    var GetDataByLatitudeLongtitude = (function () {
        function GetDataByLatitudeLongtitude(radius, bands) {
            this._radius = null;
            this._latitudeBands = null;
            this._longitudeBands = null;
            this._radius = radius;
            this._latitudeBands = bands;
            this._longitudeBands = bands;
        }
        GetDataByLatitudeLongtitude.create = function (radius, bands) {
            var geom = new this(radius, bands);
            return geom;
        };
        GetDataByLatitudeLongtitude.prototype.getData = function () {
            var vertices = [];
            var normals = [];
            var texCoords = [];
            var indices = [];
            for (var latNumber = 0; latNumber <= this._latitudeBands; latNumber++) {
                var theta = latNumber * Math.PI / this._latitudeBands;
                var sinTheta = Math.sin(theta);
                var cosTheta = Math.cos(theta);
                for (var longNumber = 0; longNumber <= this._longitudeBands; longNumber++) {
                    var phi = longNumber * 2 * Math.PI / this._longitudeBands;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);
                    var x = this._radius * cosPhi * sinTheta;
                    var y = this._radius * cosTheta;
                    var z = this._radius * sinPhi * sinTheta;
                    var u = 1 - (longNumber / this._longitudeBands);
                    var v = 1 - (latNumber / this._latitudeBands);
                    normals.push(x);
                    normals.push(y);
                    normals.push(z);
                    texCoords.push(u);
                    texCoords.push(v);
                    vertices.push(x);
                    vertices.push(y);
                    vertices.push(z);
                }
            }
            for (var latNumber = 0; latNumber < this._latitudeBands; latNumber++) {
                for (var longNumber = 0; longNumber < this._longitudeBands; longNumber++) {
                    var first = latNumber * (this._longitudeBands + 1) + longNumber;
                    var second = first + this._longitudeBands + 1;
                    indices.push(first + 1);
                    indices.push(second);
                    indices.push(first);
                    indices.push(first + 1);
                    indices.push(second + 1);
                    indices.push(second);
                }
            }
            return {
                vertices: vertices,
                indices: indices,
                normals: normals,
                texCoords: texCoords
            };
        };
        return GetDataByLatitudeLongtitude;
    }());
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TriangleGeometry = (function (_super) {
        __extends(TriangleGeometry, _super);
        function TriangleGeometry() {
            _super.apply(this, arguments);
            this.width = null;
            this.height = null;
        }
        TriangleGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        TriangleGeometry.prototype.computeData = function () {
            var width = this.width, height = this.height, left = -width / 2, right = width / 2, up = height / 2, down = -height / 2, vertices = null, texCoords = null, indices = null, normals = null;
            vertices = [
                0.0, up, 0,
                left, down, 0,
                right, down, 0
            ];
            indices = [
                0, 1, 2
            ];
            texCoords = [
                0.5, 1.0,
                0.0, 0.0,
                1.0, 0.0
            ];
            normals = [
                0, 0, 1,
                0, 0, 1,
                0, 0, 1
            ];
            return {
                vertices: vertices,
                faces: wd.GeometryUtils.convertToFaces(indices, normals),
                texCoords: texCoords
            };
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TriangleGeometry.prototype, "width", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TriangleGeometry.prototype, "height", void 0);
        return TriangleGeometry;
    }(wd.Geometry));
    wd.TriangleGeometry = TriangleGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainGeometry = (function (_super) {
        __extends(TerrainGeometry, _super);
        function TerrainGeometry() {
            _super.apply(this, arguments);
            this._rangeWidth = null;
            this._rangeHeight = null;
            this.heightMapAsset = null;
            this.subdivisions = 2;
            this.minHeight = 0;
            this.maxHeight = 10;
            this.isHeightMapStoreHeightInEachPixel = true;
            this._heightMapImageDataCache = null;
            this._heightMapImageDataCacheWidth = null;
            this._heightMapImageDataCacheHeight = null;
            this._heightCache = [];
        }
        TerrainGeometry.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(TerrainGeometry.prototype, "rangeWidth", {
            get: function () {
                if (this._rangeWidth !== null) {
                    return this._rangeWidth;
                }
                if (this._heightMapImageDataCacheWidth !== null) {
                    if (this.isHeightMapStoreHeightInEachPixel) {
                        return this._heightMapImageDataCacheWidth * 4;
                    }
                    else {
                        return this._heightMapImageDataCacheWidth;
                    }
                }
                return 256;
            },
            set: function (rangeWidth) {
                this._rangeWidth = rangeWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "rangeHeight", {
            get: function () {
                if (this._rangeHeight !== null) {
                    return this._rangeHeight;
                }
                if (this._heightMapImageDataCacheHeight !== null) {
                    return this._heightMapImageDataCacheHeight;
                }
                return 256;
            },
            set: function (rangeHeight) {
                this._rangeHeight = rangeHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "heightMapImageDataWidth", {
            get: function () {
                return this._heightMapImageDataCacheWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainGeometry.prototype, "heightMapImageDataHeight", {
            get: function () {
                return this._heightMapImageDataCacheHeight;
            },
            enumerable: true,
            configurable: true
        });
        TerrainGeometry.prototype.getHeightAtCoordinates = function (x, z) {
            var transform = this.entityObject.transform, heightFromHeightMapData = null;
            x += this.rangeWidth / 2;
            z += this.rangeHeight / 2;
            if (x > this.rangeWidth || z > this.rangeHeight || x < 0 || z < 0) {
                return 0;
            }
            if (!this._isReadHeightMapData()) {
                this._readHeightMapData();
            }
            var quadSubdivisionsCoordinateArr = this._getQuadHeightMapCoordinateArr(this._getQuadSubdivisionsCoordinateArr(x, z)), heightMinXMinZ = this._getCacheHeight(quadSubdivisionsCoordinateArr[0]), heightMaxXMinZ = this._getCacheHeight(quadSubdivisionsCoordinateArr[1]), heightMaxXMaxZ = this._getCacheHeight(quadSubdivisionsCoordinateArr[2]), heightMinXMaxZ = this._getCacheHeight(quadSubdivisionsCoordinateArr[3]);
            heightFromHeightMapData = this._getBilinearInterpolatedHeight(quadSubdivisionsCoordinateArr[4], heightMinXMinZ, heightMaxXMinZ, heightMaxXMaxZ, heightMinXMaxZ);
            return heightFromHeightMapData * transform.scale.y + transform.position.y;
        };
        TerrainGeometry.prototype._getQuadSubdivisionsCoordinateArr = function (x, z) {
            var quadSubdivisionsCoordinateArr = [], subdivisions = this.subdivisions, sx = x / this.rangeWidth * subdivisions, sz = z / this.rangeHeight * subdivisions, sFloorX = Math.floor(sx), sFloorZ = Math.floor(sz), sMinX = null, sMaxX = null, sMinZ = null, sMaxZ = null;
            if (sFloorX < subdivisions) {
                sMinX = sFloorX;
                sMaxX = sFloorX + 1;
            }
            else {
                sMinX = sFloorX - 1;
                sMaxX = sFloorX;
            }
            if (sFloorZ < subdivisions) {
                sMinZ = sFloorZ;
                sMaxZ = sFloorZ + 1;
            }
            else {
                sMinZ = sFloorZ - 1;
                sMaxZ = sFloorZ;
            }
            quadSubdivisionsCoordinateArr.push(wd.Vector2.create(sMinX, sMinZ));
            quadSubdivisionsCoordinateArr.push(wd.Vector2.create(sMaxX, sMinZ));
            quadSubdivisionsCoordinateArr.push(wd.Vector2.create(sMaxX, sMaxZ));
            quadSubdivisionsCoordinateArr.push(wd.Vector2.create(sMinX, sMaxZ));
            quadSubdivisionsCoordinateArr.push(wd.Vector2.create(sx - sMinX, sz - sMinZ));
            return quadSubdivisionsCoordinateArr;
        };
        TerrainGeometry.prototype._getQuadHeightMapCoordinateArr = function (quadSubdivisionsCoordinateArr) {
            for (var i = 0; i <= 3; i++) {
                var quadSubdivisionsCoordinate = quadSubdivisionsCoordinateArr[i];
                quadSubdivisionsCoordinate.x = this._computeHeightMapColInCanvasCoordinate(quadSubdivisionsCoordinate.x);
                quadSubdivisionsCoordinate.y = this._computeHeightMapRowInCanvasCoordinate(quadSubdivisionsCoordinate.y);
            }
            return quadSubdivisionsCoordinateArr;
        };
        TerrainGeometry.prototype._getBilinearInterpolatedHeight = function (offset, heightMinXMinZ, heightMaxXMinZ, heightMaxXMaxZ, heightMinXMaxZ) {
            return (heightMinXMinZ * (1 - offset.x) + heightMaxXMinZ * offset.x) * (1 - offset.y) + (heightMaxXMaxZ * offset.x + heightMinXMaxZ * (1 - offset.x)) * offset.y;
        };
        TerrainGeometry.prototype._getCacheHeight = function (coordinate) {
            var col = coordinate.x, row = coordinate.y, heightMapIndex = this._computeHeightMapIndex(row, col), cacheHeight = this._heightCache[heightMapIndex];
            if (cacheHeight !== void 0) {
                return cacheHeight;
            }
            var heightFromHeightMapData = this._getHeightByReadHeightMapData(heightMapIndex);
            this._heightCache[heightMapIndex] = heightFromHeightMapData;
            return heightFromHeightMapData;
        };
        TerrainGeometry.prototype.computeData = function () {
            if (!this._isReadHeightMapData()) {
                this._readHeightMapData();
            }
            return this._createGroundFromHeightMap();
        };
        TerrainGeometry.prototype._isReadHeightMapData = function () {
            return this._heightMapImageDataCache !== null;
        };
        TerrainGeometry.prototype._readHeightMapData = function () {
            var image = this.heightMapAsset.source, heightMapImageDataWidth = image.width, heightMapImageDataHeight = image.height, canvas = document.createElement("canvas"), context = canvas.getContext("2d");
            canvas.width = heightMapImageDataWidth;
            canvas.height = heightMapImageDataHeight;
            context.drawImage(image, 0, 0);
            this._heightMapImageDataCache = context.getImageData(0, 0, heightMapImageDataWidth, heightMapImageDataHeight).data;
            this._heightMapImageDataCacheWidth = heightMapImageDataWidth;
            this._heightMapImageDataCacheHeight = heightMapImageDataHeight;
        };
        TerrainGeometry.prototype._createGroundFromHeightMap = function () {
            var vertices = [], normals = [], texCoords = [], subdivisions = this.subdivisions, width = this.rangeWidth, height = this.rangeHeight, heightCache = this._heightCache;
            for (var row = 0; row < subdivisions; row++) {
                for (var col = 0; col < subdivisions; col++) {
                    var x = (col * width) / subdivisions - (width / 2.0), z = ((subdivisions - row) * height) / subdivisions - (height / 2.0), heightMapRow = this._computeHeightMapRowInTexCoordCoordinate(row), heightMapCol = this._computeHeightMapColInTexCoordCoordinate(col), heightMapIndex = this._computeHeightMapIndex(heightMapRow, heightMapCol), y = null;
                    y = this._getHeightByReadHeightMapData(heightMapIndex);
                    heightCache[heightMapIndex] = y;
                    vertices.push(x, y, z);
                    texCoords.push(col / subdivisions, 1.0 - row / subdivisions);
                }
            }
            return {
                vertices: vertices,
                faces: wd.GeometryUtils.convertToFaces(this._getIndices(), normals),
                texCoords: texCoords
            };
        };
        TerrainGeometry.prototype._computeHeightMapColInCanvasCoordinate = function (x) {
            var col = Math.floor(x / this.subdivisions * this._heightMapImageDataCacheWidth);
            if (col > 0) {
                col -= 1;
            }
            return col;
        };
        TerrainGeometry.prototype._computeHeightMapRowInCanvasCoordinate = function (z) {
            var row = Math.floor((z / this.subdivisions) * this._heightMapImageDataCacheHeight);
            if (row > 0) {
                row -= 1;
            }
            return row;
        };
        TerrainGeometry.prototype._computeHeightMapColInTexCoordCoordinate = function (x) {
            return this._computeHeightMapColInCanvasCoordinate(x);
        };
        TerrainGeometry.prototype._computeHeightMapRowInTexCoordCoordinate = function (z) {
            var row = Math.floor((1 - z / this.subdivisions) * this._heightMapImageDataCacheHeight);
            if (row > 0) {
                row -= 1;
            }
            return row;
        };
        TerrainGeometry.prototype._computeHeightMapIndex = function (heightMapRow, heightMapCol) {
            var index = (heightMapCol + heightMapRow * this._heightMapImageDataCacheWidth) * 4;
            return index;
        };
        TerrainGeometry.prototype._getHeightByReadHeightMapData = function (heightMapIndex) {
            var heightMapImageData = this._heightMapImageDataCache, r = heightMapImageData[heightMapIndex] / 256.0, g = heightMapImageData[heightMapIndex + 1] / 256.0, b = heightMapImageData[heightMapIndex + 2] / 256.0, gradient = r * 0.3 + g * 0.59 + b * 0.11, minHeight = this.minHeight, maxHeight = this.maxHeight;
            return minHeight + (maxHeight - minHeight) * gradient;
        };
        TerrainGeometry.prototype._getIndices = function () {
            var indices = [], subdivisions = this.subdivisions;
            for (var row = 0; row < subdivisions - 1; row++) {
                for (var col = 0; col < subdivisions - 1; col++) {
                    indices.push(col + row * subdivisions);
                    indices.push(col + 1 + row * subdivisions);
                    indices.push(col + 1 + (row + 1) * subdivisions);
                    indices.push(col + row * subdivisions);
                    indices.push(col + 1 + (row + 1) * subdivisions);
                    indices.push(col + (row + 1) * subdivisions);
                }
            }
            return indices;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TerrainGeometry.prototype, "rangeWidth", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TerrainGeometry.prototype, "rangeHeight", null);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                if (source[memberName]) {
                    target[memberName] = wd.ImageTextureAsset.create(source[memberName].source);
                }
            })
        ], TerrainGeometry.prototype, "heightMapAsset", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TerrainGeometry.prototype, "subdivisions", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TerrainGeometry.prototype, "minHeight", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TerrainGeometry.prototype, "maxHeight", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TerrainGeometry.prototype, "isHeightMapStoreHeightInEachPixel", void 0);
        return TerrainGeometry;
    }(wd.Geometry));
    wd.TerrainGeometry = TerrainGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GeometryData = (function () {
        function GeometryData(geometry) {
            this._vertices = null;
            this._faces = null;
            this._texCoords = null;
            this._colors = null;
            this._tangents = null;
            this.tangentDirty = true;
            this.colorDirty = true;
            this.geometry = null;
            this._normalCache = null;
            this._normalFromFaceCache = null;
            this._normalFromVertexCache = null;
            this._indiceCache = null;
            this._colorCache = null;
            this._normalDirty = true;
            this._indiceDirty = true;
            this.geometry = geometry;
        }
        Object.defineProperty(GeometryData.prototype, "vertices", {
            get: function () {
                return this._vertices;
            },
            set: function (vertices) {
                this._vertices = vertices;
                this.tangentDirty = true;
                this.geometry.buffers.removeCache(wd.EBufferDataType.VERTICE);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "normals", {
            get: function () {
                var geometry = this.geometry;
                if (geometry.isSmoothShading()) {
                    if (!this.hasVertexNormals()) {
                        this.computeVertexNormals();
                    }
                    return this.normalsFromVertexNormals;
                }
                if (!this.hasFaceNormals()) {
                    this.computeFaceNormals();
                }
                return this.normalsFromFaceNormal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "normalsFromFaceNormal", {
            get: function () {
                var normals = null;
                if (!this.hasFaceNormals()) {
                    return [];
                }
                normals = [];
                this._faces.forEach(function (face) {
                    var normal = face.faceNormal;
                    wd.GeometryUtils.setThreeComponent(normals, normal, face.aIndex);
                    wd.GeometryUtils.setThreeComponent(normals, normal, face.bIndex);
                    wd.GeometryUtils.setThreeComponent(normals, normal, face.cIndex);
                });
                this._fillEmptyData(normals);
                return normals;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "normalsFromVertexNormals", {
            get: function () {
                var normals = null;
                if (!this.hasVertexNormals()) {
                    return [];
                }
                normals = [];
                this._faces.forEach(function (face) {
                    wd.GeometryUtils.setThreeComponent(normals, face.vertexNormals.getChild(0), face.aIndex);
                    wd.GeometryUtils.setThreeComponent(normals, face.vertexNormals.getChild(1), face.bIndex);
                    wd.GeometryUtils.setThreeComponent(normals, face.vertexNormals.getChild(2), face.cIndex);
                });
                this._fillEmptyData(normals);
                return normals;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "indices", {
            get: function () {
                var indices = [];
                for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                    var face = _a[_i];
                    indices.push(face.aIndex, face.bIndex, face.cIndex);
                }
                return indices;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "faces", {
            get: function () {
                return this._faces;
            },
            set: function (faces) {
                this._faces = faces;
                this.geometry.buffers.removeCache(wd.EBufferDataType.NORMAL);
                this.geometry.buffers.removeCache(wd.EBufferDataType.INDICE);
                this.onChangeFace();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "texCoords", {
            get: function () {
                return this._texCoords;
            },
            set: function (texCoords) {
                this._texCoords = texCoords;
                this.tangentDirty = true;
                this.geometry.buffers.removeCache(wd.EBufferDataType.TEXCOORD);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "colors", {
            get: function () {
                return this._colors;
            },
            set: function (colors) {
                this._colors = colors;
                this.colorDirty = true;
                this.geometry.buffers.removeCache(wd.EBufferDataType.COLOR);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "tangents", {
            get: function () {
                if (this.tangentDirty) {
                    this.tangentDirty = false;
                    if (wd.GeometryUtils.hasData(this.normals) && wd.GeometryUtils.hasData(this.texCoords) && wd.GeometryUtils.hasData(this.indices)) {
                        this._tangents = this._calculateTangents(this._vertices, this.normals, this.texCoords, this.indices);
                    }
                }
                return this._tangents;
            },
            enumerable: true,
            configurable: true
        });
        GeometryData.prototype.dispose = function () {
        };
        GeometryData.prototype.computeFaceNormals = function () {
            var vertices = this._vertices;
            if (!wd.GeometryUtils.hasData(this.vertices)) {
                wd.Log.warn("has no vertices data, can't compute face normals");
                return;
            }
            for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                var face = _a[_i];
                face.faceNormal = this.computeFaceNormalsHelper(vertices, face.aIndex, face.bIndex, face.cIndex);
            }
        };
        GeometryData.prototype.computeVertexNormals = function () {
            var normals = null;
            if (!this.hasFaceNormals()) {
                this.computeFaceNormals();
            }
            normals = this.computeVertexNormalsHelper(this._vertices);
            for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                var face = _a[_i];
                face.vertexNormals = wdCb.Collection.create([
                    normals[face.aIndex],
                    normals[face.bIndex],
                    normals[face.cIndex]
                ]);
            }
        };
        GeometryData.prototype.hasFaceNormals = function () {
            for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                var face = _a[_i];
                if (!face.hasFaceNormal()) {
                    return false;
                }
            }
            return true;
        };
        GeometryData.prototype.hasVertexNormals = function () {
            for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                var face = _a[_i];
                if (!face.hasVertexNormal()) {
                    return false;
                }
            }
            return true;
        };
        GeometryData.prototype.hasColors = function () {
            return wd.GeometryUtils.hasData(this._colors);
        };
        GeometryData.prototype.onChangeFace = function () {
            this.tangentDirty = true;
            this._normalDirty = true;
            this._indiceDirty = true;
        };
        GeometryData.prototype.computeFaceNormalsHelper = function (vertices, aIndex, bIndex, cIndex) {
            var p0 = wd.GeometryUtils.getThreeComponent(vertices, aIndex), p1 = wd.GeometryUtils.getThreeComponent(vertices, bIndex), p2 = wd.GeometryUtils.getThreeComponent(vertices, cIndex), v0 = wd.Vector3.create().sub2(p2, p1), v1 = wd.Vector3.create().sub2(p0, p1);
            return wd.Vector3.create().cross(v0, v1).normalize();
        };
        GeometryData.prototype.computeVertexNormalsHelper = function (vertices) {
            var vl = vertices.length / 3, normals = null;
            normals = new Array(vl);
            for (var v = 0; v < vl; v++) {
                normals[v] = wd.Vector3.create();
            }
            for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                var face = _a[_i];
                var faceNormal = null;
                faceNormal = face.faceNormal;
                normals[face.aIndex].add(faceNormal);
                normals[face.bIndex].add(faceNormal);
                normals[face.cIndex].add(faceNormal);
            }
            for (var v = 0; v < vl; v++) {
                normals[v].normalize();
            }
            return normals;
        };
        GeometryData.prototype._fillEmptyData = function (data) {
            for (var i = 0, len = data.length; i < len; i++) {
                if (isNaN(data[i])) {
                    data[i] = 0;
                }
            }
        };
        GeometryData.prototype._calculateTangents = function (vertices, normals, texCoords, indices) {
            var triangleCount = indices.length / 3, vertexCount = vertices.length / 3, i1, i2, i3, x1, x2, y1, y2, z1, z2, s1, s2, t1, t2, r, sdir = wd.Vector3.create(), tdir = wd.Vector3.create(), v1 = wd.Vector3.create(), v2 = wd.Vector3.create(), v3 = wd.Vector3.create(), w1 = wd.Vector2.create(), w2 = wd.Vector2.create(), w3 = wd.Vector2.create(), i, tan1 = new Float32Array(vertexCount * 3), tan2 = new Float32Array(vertexCount * 3), n = wd.Vector3.create(), temp = wd.Vector3.create(), tangents = [];
            for (i = 0; i < triangleCount; i++) {
                i1 = indices[i * 3];
                i2 = indices[i * 3 + 1];
                i3 = indices[i * 3 + 2];
                v1.set(vertices[i1 * 3], vertices[i1 * 3 + 1], vertices[i1 * 3 + 2]);
                v2.set(vertices[i2 * 3], vertices[i2 * 3 + 1], vertices[i2 * 3 + 2]);
                v3.set(vertices[i3 * 3], vertices[i3 * 3 + 1], vertices[i3 * 3 + 2]);
                w1.set(texCoords[i1 * 2], texCoords[i1 * 2 + 1]);
                w2.set(texCoords[i2 * 2], texCoords[i2 * 2 + 1]);
                w3.set(texCoords[i3 * 2], texCoords[i3 * 2 + 1]);
                x1 = v2.x - v1.x;
                x2 = v3.x - v1.x;
                y1 = v2.y - v1.y;
                y2 = v3.y - v1.y;
                z1 = v2.z - v1.z;
                z2 = v3.z - v1.z;
                s1 = w2.x - w1.x;
                s2 = w3.x - w1.x;
                t1 = w2.y - w1.y;
                t2 = w3.y - w1.y;
                r = 1.0 / (s1 * t2 - s2 * t1);
                sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
                tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
                tan1[i1 * 3 + 0] += sdir.x;
                tan1[i1 * 3 + 1] += sdir.y;
                tan1[i1 * 3 + 2] += sdir.z;
                tan1[i2 * 3 + 0] += sdir.x;
                tan1[i2 * 3 + 1] += sdir.y;
                tan1[i2 * 3 + 2] += sdir.z;
                tan1[i3 * 3 + 0] += sdir.x;
                tan1[i3 * 3 + 1] += sdir.y;
                tan1[i3 * 3 + 2] += sdir.z;
                tan2[i1 * 3 + 0] += tdir.x;
                tan2[i1 * 3 + 1] += tdir.y;
                tan2[i1 * 3 + 2] += tdir.z;
                tan2[i2 * 3 + 0] += tdir.x;
                tan2[i2 * 3 + 1] += tdir.y;
                tan2[i2 * 3 + 2] += tdir.z;
                tan2[i3 * 3 + 0] += tdir.x;
                tan2[i3 * 3 + 1] += tdir.y;
                tan2[i3 * 3 + 2] += tdir.z;
            }
            t1 = wd.Vector3.create();
            t2 = wd.Vector3.create();
            for (i = 0; i < vertexCount; i++) {
                var ndott = null;
                n.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
                t1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);
                t2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);
                ndott = n.dot(t1);
                temp = n.clone().scale(ndott);
                temp.sub2(t1, temp).normalize();
                tangents[i * 4] = temp.x;
                tangents[i * 4 + 1] = temp.y;
                tangents[i * 4 + 2] = temp.z;
                temp.cross(n, t1);
                tangents[i * 4 + 3] = (temp.dot(t2) < 0.0) ? -1.0 : 1.0;
            }
            return tangents;
        };
        __decorate([
            wd.requireGetter(function () {
                wd.assert(this._faces.length > 0, wd.Log.info.FUNC_SHOULD("faces.count", "> 0"));
                for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                    var face = _a[_i];
                    if (this.geometry.isSmoothShading()) {
                        wd.assert(face.vertexNormals && face.vertexNormals.getCount() === 3, wd.Log.info.FUNC_SHOULD("faces->vertexNormals.count", "=== 3"));
                    }
                }
            }),
            wd.cacheGetter(function () {
                return !this._normalDirty && this._normalCache;
            }, function () {
                return this._normalCache;
            }, function (result) {
                this._normalCache = result;
                this._normalDirty = false;
            })
        ], GeometryData.prototype, "normals", null);
        __decorate([
            wd.requireGetter(function () {
                wd.assert(this._faces.length > 0, wd.Log.info.FUNC_SHOULD("geometry", "has faces"));
            }),
            wd.ensureGetter(function (normals) {
                for (var _i = 0, normals_1 = normals; _i < normals_1.length; _i++) {
                    var data = normals_1[_i];
                    wd.assert(wd.JudgeUtils.isNumber(data), wd.Log.info.FUNC_SHOULD("normals data", "be number"));
                }
            }),
            wd.cacheGetter(function () {
                return !this._normalDirty && this._normalFromFaceCache;
            }, function () {
                return this._normalFromFaceCache;
            }, function (result) {
                this._normalFromFaceCache = result;
                this._normalDirty = false;
            })
        ], GeometryData.prototype, "normalsFromFaceNormal", null);
        __decorate([
            wd.requireGetter(function () {
                wd.assert(this._faces.length > 0, wd.Log.info.FUNC_SHOULD("geometry", "has faces"));
            }),
            wd.ensureGetter(function (normals) {
                for (var _i = 0, normals_2 = normals; _i < normals_2.length; _i++) {
                    var data = normals_2[_i];
                    wd.assert(wd.JudgeUtils.isNumber(data), wd.Log.info.FUNC_SHOULD("normals data", "be number"));
                }
            }),
            wd.cacheGetter(function () {
                return !this._normalDirty && this._normalFromVertexCache;
            }, function () {
                return this._normalFromVertexCache;
            }, function (result) {
                this._normalFromVertexCache = result;
                this._normalDirty = false;
            })
        ], GeometryData.prototype, "normalsFromVertexNormals", null);
        __decorate([
            wd.cacheGetter(function () {
                return !this._indiceDirty && this._indiceCache;
            }, function () {
                return this._indiceCache;
            }, function (result) {
                this._indiceCache = result;
                this._indiceDirty = false;
            })
        ], GeometryData.prototype, "indices", null);
        __decorate([
            wd.ensureGetter(function (colors) {
                var _this = this;
                if (colors !== null && colors !== void 0) {
                    wd.it("colors.length:" + colors.length + " should === vertices.length:" + this._vertices.length, function () {
                        wd.expect(colors.length).equals(_this._vertices.length);
                    });
                }
            }),
            wd.cacheGetter(function () {
                return !this.colorDirty && this._colorCache;
            }, function () {
                return this._colorCache;
            }, function (result) {
                this._colorCache = result;
                this.colorDirty = false;
            })
        ], GeometryData.prototype, "colors", null);
        __decorate([
            wd.ensure(function () {
                for (var _i = 0, _a = this._faces; _i < _a.length; _i++) {
                    var face = _a[_i];
                    wd.assert(face.faceNormal instanceof wd.Vector3, wd.Log.info.FUNC_SHOULD_NOT("faceNormal", "be null"));
                }
            })
        ], GeometryData.prototype, "computeFaceNormals", null);
        __decorate([
            wd.virtual
        ], GeometryData.prototype, "onChangeFace", null);
        return GeometryData;
    }());
    wd.GeometryData = GeometryData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicGeometryData = (function (_super) {
        __extends(BasicGeometryData, _super);
        function BasicGeometryData() {
            _super.apply(this, arguments);
        }
        BasicGeometryData.create = function (geometry) {
            var obj = new this(geometry);
            return obj;
        };
        return BasicGeometryData;
    }(wd.GeometryData));
    wd.BasicGeometryData = BasicGeometryData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MorphGeometryData = (function (_super) {
        __extends(MorphGeometryData, _super);
        function MorphGeometryData() {
            _super.apply(this, arguments);
            this._morphTargets = null;
            this._morphNormalCache = null;
            this._morphNormalDirty = true;
        }
        MorphGeometryData.create = function (geometry) {
            var obj = new this(geometry);
            return obj;
        };
        Object.defineProperty(MorphGeometryData.prototype, "morphNormals", {
            get: function () {
                var geometry = this.geometry;
                this._morphNormalDirty = false;
                if (geometry.isSmoothShading()) {
                    if (!this.hasMorphVertexNormals()) {
                        this.computeMorphNormals();
                    }
                    return geometry.morphVertexNormals;
                }
                if (!this.hasMorphFaceNormals()) {
                    this.computeMorphNormals();
                }
                return geometry.morphFaceNormals;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MorphGeometryData.prototype, "morphVertices", {
            get: function () {
                return this._morphTargets;
            },
            set: function (morphVertices) {
                this._morphTargets = morphVertices;
                this._morphNormalDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MorphGeometryData.prototype.computeMorphNormals = function () {
            var geometry = this.geometry, self = this;
            this._morphTargets.forEach(function (frames, animName) {
                var faceNormalList = wdCb.Collection.create(), vertexNormalList = wdCb.Collection.create();
                frames.forEach(function (vertices) {
                    var tempGeometryData = MorphGeometryData.create(geometry), faceNormalsOfEachFrame = null, vertexNormalsOfEachFrame = null;
                    tempGeometryData.vertices = vertices;
                    tempGeometryData.faces = self._copyFaces(geometry.faces);
                    tempGeometryData.computeFaceNormals();
                    tempGeometryData.computeVertexNormals();
                    _a = self._getMorphNormals(tempGeometryData), faceNormalsOfEachFrame = _a[0], vertexNormalsOfEachFrame = _a[1];
                    faceNormalList.addChild(faceNormalsOfEachFrame);
                    vertexNormalList.addChild(vertexNormalsOfEachFrame);
                    var _a;
                });
                geometry.morphFaceNormals.addChild(animName, faceNormalList);
                geometry.morphVertexNormals.addChild(animName, vertexNormalList);
            });
        };
        MorphGeometryData.prototype.hasMorphFaceNormals = function () {
            return this.geometry.morphFaceNormals.getCount() > 0;
        };
        MorphGeometryData.prototype.hasMorphVertexNormals = function () {
            return this.geometry.morphVertexNormals.getCount() > 0;
        };
        MorphGeometryData.prototype.onChangeFace = function () {
            this._morphNormalDirty = true;
        };
        MorphGeometryData.prototype._copyFaces = function (faces) {
            var copyFaces = [];
            for (var _i = 0, faces_1 = faces; _i < faces_1.length; _i++) {
                var face = faces_1[_i];
                copyFaces.push(face.clone());
            }
            return copyFaces;
        };
        MorphGeometryData.prototype._getMorphNormals = function (geometryData) {
            return [geometryData.normalsFromFaceNormal, geometryData.normalsFromVertexNormals];
        };
        __decorate([
            wd.cacheGetter(function () {
                return !this._morphNormalDirty && this._morphNormalCache;
            }, function () {
                return this._morphNormalCache;
            }, function (result) {
                this._morphNormalCache = result;
            })
        ], MorphGeometryData.prototype, "morphNormals", null);
        return MorphGeometryData;
    }(wd.GeometryData));
    wd.MorphGeometryData = MorphGeometryData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SkinSkeletonGeometryData = (function (_super) {
        __extends(SkinSkeletonGeometryData, _super);
        function SkinSkeletonGeometryData() {
            _super.apply(this, arguments);
            this._jointIndices = null;
            this._jointWeights = null;
        }
        SkinSkeletonGeometryData.create = function (geometry) {
            var obj = new this(geometry);
            return obj;
        };
        Object.defineProperty(SkinSkeletonGeometryData.prototype, "jointIndices", {
            get: function () {
                return this._jointIndices;
            },
            set: function (jointIndices) {
                this._jointIndices = jointIndices;
                this.geometry.buffers.removeCache(wd.EBufferDataType.JOINT_INDICE);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinSkeletonGeometryData.prototype, "jointWeights", {
            get: function () {
                return this._jointWeights;
            },
            set: function (jointWeights) {
                this._jointWeights = jointWeights;
                this.geometry.buffers.removeCache(wd.EBufferDataType.JOINT_WEIGHT);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            wd.ensureGetter(function (jointIndices) {
                var _this = this;
                if (jointIndices === null || this._vertices === null) {
                    return;
                }
                wd.it("jointIndices should map to vertices(4 -> 1)", function () {
                    wd.expect(jointIndices.length / 4).equals(_this._vertices.length / 3);
                });
            })
        ], SkinSkeletonGeometryData.prototype, "jointIndices", null);
        __decorate([
            wd.ensureGetter(function (jointWeights) {
                var _this = this;
                wd.it("jointWeights should map to vertices(4 -> 1)", function () {
                    if (jointWeights === null || _this._vertices === null) {
                        return;
                    }
                    wd.expect(jointWeights.length / 4).equals(_this._vertices.length / 3);
                });
            })
        ], SkinSkeletonGeometryData.prototype, "jointWeights", null);
        return SkinSkeletonGeometryData;
    }(wd.GeometryData));
    wd.SkinSkeletonGeometryData = SkinSkeletonGeometryData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BufferContainer = (function () {
        function BufferContainer(entityObject) {
            this.geometryData = null;
            this.entityObject = null;
            this.container = wdCb.Hash.create();
            this._colorBuffer = null;
            this._texCoordBuffer = null;
            this._tangentBuffer = null;
            this._indiceBuffer = null;
            this.entityObject = entityObject;
        }
        BufferContainer.prototype.createBuffersFromGeometryData = function () {
            this.getChild(wd.EBufferDataType.VERTICE);
            this.getChild(wd.EBufferDataType.NORMAL);
            this.getChild(wd.EBufferDataType.TANGENT);
            this.getChild(wd.EBufferDataType.COLOR);
            this.getChild(wd.EBufferDataType.INDICE);
            this.getChild(wd.EBufferDataType.TEXCOORD);
        };
        BufferContainer.prototype.removeCache = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.container.removeChild(args[0]);
        };
        BufferContainer.prototype.getChild = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var type = args[0], result = null;
            switch (type) {
                case wd.EBufferDataType.VERTICE:
                    result = this.getVertice(type);
                    break;
                case wd.EBufferDataType.NORMAL:
                    result = this.getNormal(type);
                    break;
                case wd.EBufferDataType.TANGENT:
                    result = this._getTangent(type);
                    break;
                case wd.EBufferDataType.COLOR:
                    result = this._getColor(type);
                    break;
                case wd.EBufferDataType.INDICE:
                    result = this._getIndice(type);
                    break;
                case wd.EBufferDataType.TEXCOORD:
                    result = this._getTexCoord(type);
                    break;
                case wd.EBufferDataType.CUSTOM:
                    result = this.getCustomData(args[1]);
                    break;
                default:
                    result = this.getBuffer(type);
                    break;
            }
            return result;
        };
        BufferContainer.prototype.init = function () {
        };
        BufferContainer.prototype.dispose = function () {
            this.container.forEach(function (buffer) {
                buffer.dispose();
            });
            this.geometryData.dispose();
        };
        BufferContainer.prototype.getCustomData = function (dataName) {
            return null;
        };
        BufferContainer.prototype.getBuffer = function (type) {
            wd.Log.error(true, wdCb.Log.info.FUNC_UNKNOW("EBufferDataType: " + type));
            return null;
        };
        BufferContainer.prototype.createOnlyOnceAndUpdateArrayBuffer = function (bufferAttriName, data, size, type, offset, usage) {
            if (type === void 0) { type = wd.EBufferType.FLOAT; }
            if (offset === void 0) { offset = 0; }
            if (usage === void 0) { usage = wd.EBufferUsage.STATIC_DRAW; }
            var buffer = this[bufferAttriName];
            if (buffer) {
                buffer.resetData(data, size, type, offset);
                return;
            }
            this[bufferAttriName] = wd.ArrayBuffer.create(data, size, type, usage);
        };
        BufferContainer.prototype.createOnlyOnceAndUpdateElememntBuffer = function (bufferAttriName, data, type, offset, usage) {
            if (type === void 0) { type = null; }
            if (offset === void 0) { offset = 0; }
            if (usage === void 0) { usage = wd.EBufferUsage.STATIC_DRAW; }
            var buffer = this[bufferAttriName];
            if (buffer) {
                buffer.resetData(data, type, offset);
                return;
            }
            this[bufferAttriName] = wd.ElementBuffer.create(data, type, usage);
        };
        BufferContainer.prototype.hasData = function (data) {
            return !!data && data.length > 0;
        };
        BufferContainer.prototype._getTangent = function (type) {
            var geometryData = null;
            geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_tangentBuffer", geometryData, 3);
            return this._tangentBuffer;
        };
        BufferContainer.prototype._getColor = function (type) {
            var geometryData = null;
            geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_colorBuffer", geometryData, 3);
            return this._colorBuffer;
        };
        BufferContainer.prototype._getIndice = function (type) {
            var geometryData = null;
            geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateElememntBuffer("_indiceBuffer", geometryData);
            return this._indiceBuffer;
        };
        BufferContainer.prototype._getTexCoord = function (type) {
            var geometryData = null, isCreatBuffer = null;
            geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_texCoordBuffer", geometryData, 2);
            return this._texCoordBuffer;
        };
        BufferContainer.prototype._needReCalcuteTangent = function (type) {
            return this.geometryData.tangentDirty && type === wd.EBufferDataType.TANGENT;
        };
        __decorate([
            wd.virtual
        ], BufferContainer.prototype, "createBuffersFromGeometryData", null);
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.it("test arguments", function () {
                    if (args.length === 2) {
                        var dataName = args[1];
                        wd.expect(dataName).exist;
                        wd.expect(dataName).be.a("string");
                    }
                });
            })
        ], BufferContainer.prototype, "getChild", null);
        __decorate([
            wd.virtual
        ], BufferContainer.prototype, "getCustomData", null);
        __decorate([
            wd.virtual
        ], BufferContainer.prototype, "getBuffer", null);
        __decorate([
            wd.cache(function (type) {
                return this.container.hasChild(type) && !this._needReCalcuteTangent(type);
            }, function (type) {
                return this.container.getChild(type);
            }, function (result, type) {
                this.container.addChild(type, result);
            })
        ], BufferContainer.prototype, "_getTangent", null);
        __decorate([
            wd.cache(function (type) {
                return this.container.hasChild(type);
            }, function (type) {
                return this.container.getChild(type);
            }, function (result, type) {
                this.container.addChild(type, result);
            })
        ], BufferContainer.prototype, "_getColor", null);
        __decorate([
            wd.cache(function (type) {
                return this.container.hasChild(type);
            }, function (type) {
                return this.container.getChild(type);
            }, function (result, type) {
                this.container.addChild(type, result);
            })
        ], BufferContainer.prototype, "_getIndice", null);
        __decorate([
            wd.cache(function (type) {
                return this.container.hasChild(type);
            }, function (type) {
                return this.container.getChild(type);
            }, function (result, type) {
                this.container.addChild(type, result);
            })
        ], BufferContainer.prototype, "_getTexCoord", null);
        return BufferContainer;
    }());
    wd.BufferContainer = BufferContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonBufferContainer = (function (_super) {
        __extends(CommonBufferContainer, _super);
        function CommonBufferContainer() {
            _super.apply(this, arguments);
            this._verticeBuffer = null;
            this._normalBuffer = null;
        }
        CommonBufferContainer.prototype.getBufferForRenderSort = function () {
            var buffer = this.getChild(wd.EBufferDataType.VERTICE);
            if (!buffer) {
                return null;
            }
            return buffer;
        };
        CommonBufferContainer.prototype.getVertice = function (type) {
            var geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_verticeBuffer", geometryData, 3);
            return this._verticeBuffer;
        };
        CommonBufferContainer.prototype.getNormal = function (type) {
            var geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_normalBuffer", geometryData, 3);
            return this._normalBuffer;
        };
        __decorate([
            wd.cacheBufferForBufferContainer()
        ], CommonBufferContainer.prototype, "getVertice", null);
        __decorate([
            wd.cacheBufferForBufferContainer()
        ], CommonBufferContainer.prototype, "getNormal", null);
        return CommonBufferContainer;
    }(wd.BufferContainer));
    wd.CommonBufferContainer = CommonBufferContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicBufferContainer = (function (_super) {
        __extends(BasicBufferContainer, _super);
        function BasicBufferContainer() {
            _super.apply(this, arguments);
        }
        BasicBufferContainer.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        return BasicBufferContainer;
    }(wd.CommonBufferContainer));
    wd.BasicBufferContainer = BasicBufferContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MorphBufferContainer = (function (_super) {
        __extends(MorphBufferContainer, _super);
        function MorphBufferContainer(entityObject, animation) {
            _super.call(this, entityObject);
            this._animation = null;
            this._isCacheChangeFlag = {};
            this._isCacheChangeInLastLoop = {};
            this._currentVerticeBuffer = null;
            this._nextVerticeBuffer = null;
            this._currentNormalBuffer = null;
            this._nextNormalBuffer = null;
            this._animation = animation;
        }
        MorphBufferContainer.create = function (entityObject, animation) {
            var obj = new this(entityObject, animation);
            return obj;
        };
        MorphBufferContainer.prototype.getBufferForRenderSort = function () {
            return null;
        };
        MorphBufferContainer.prototype.getVertice = function (type) {
            return this._getMorphData(type, this.geometryData.morphVertices);
        };
        MorphBufferContainer.prototype.getNormal = function (type) {
            return this._getMorphData(type, this.geometryData.morphNormals);
        };
        MorphBufferContainer.prototype._getMorphData = function (type, morphDataTargets) {
            var cacheData = null, frames = null, result = null;
            if (this._isNotPlayAnimation()) {
                return this._getStaticData(type);
            }
            if (morphDataTargets.getCount() === 0) {
                return null;
            }
            frames = this._getFrames(morphDataTargets);
            cacheData = this.container.getChild(type);
            if (!cacheData) {
                var currentBuffer = this._getCurrentBufferWhichIsCreatedOnlyOnce(type, frames.getChild(this._animation.currentFrame), 3), nextBuffer = this._getNextBufferWhichIsCreatedOnlyOnce(type, frames.getChild(this._animation.nextFrame), 3);
                result = [currentBuffer, nextBuffer];
                this.container.addChild(type, result);
                this._isCacheChangeInLastLoop[type] = false;
            }
            else {
                if (this._animation.isFrameChange && (this._isCacheChangeInLastLoop[type] || this._isCacheNotChange(type))) {
                    var currentBuffer = cacheData[0], nextBuffer = cacheData[1], newCurrentBuffer = null, newNextBuffer = null;
                    newCurrentBuffer = nextBuffer;
                    newNextBuffer = currentBuffer.resetData(frames.getChild(this._animation.nextFrame));
                    result = [newCurrentBuffer, newNextBuffer];
                    this.container.addChild(type, result);
                    this._isCacheChangeFlag[type] = true;
                    this._isCacheChangeInLastLoop[type] = true;
                }
                else {
                    this._isCacheChangeFlag[type] = false;
                    this._isCacheChangeInLastLoop[type] = false;
                    result = cacheData;
                }
            }
            return result;
        };
        MorphBufferContainer.prototype._getFrames = function (morphDataTargets) {
            return morphDataTargets.getChild(this._animation.currentAnimName);
        };
        MorphBufferContainer.prototype._getCurrentBufferWhichIsCreatedOnlyOnce = function (type, data, size) {
            if (type === wd.EBufferDataType.VERTICE) {
                this.createOnlyOnceAndUpdateArrayBuffer("_currentVerticeBuffer", data, size, wd.EBufferType.FLOAT, 0, wd.EBufferUsage.DYNAMIC_DRAW);
                return this._currentVerticeBuffer;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_currentNormalBuffer", data, size, wd.EBufferType.FLOAT, 0, wd.EBufferUsage.DYNAMIC_DRAW);
            return this._currentNormalBuffer;
        };
        MorphBufferContainer.prototype._getNextBufferWhichIsCreatedOnlyOnce = function (type, data, size) {
            if (type === wd.EBufferDataType.VERTICE) {
                this.createOnlyOnceAndUpdateArrayBuffer("_nextVerticeBuffer", data, size, wd.EBufferType.FLOAT, 0, wd.EBufferUsage.DYNAMIC_DRAW);
                return this._nextVerticeBuffer;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_nextNormalBuffer", data, size, wd.EBufferType.FLOAT, 0, wd.EBufferUsage.DYNAMIC_DRAW);
            return this._nextNormalBuffer;
        };
        MorphBufferContainer.prototype._isCacheNotChange = function (type) {
            return !this._isCacheChangeFlag[type];
        };
        MorphBufferContainer.prototype._isNotPlayAnimation = function () {
            return this._animation.currentAnimName === null;
        };
        MorphBufferContainer.prototype._getStaticData = function (type) {
            var data = null, result = null;
            switch (type) {
                case wd.EBufferDataType.VERTICE:
                    data = this.geometryData.vertices;
                    break;
                case wd.EBufferDataType.NORMAL:
                    data = this.geometryData.normals;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_SHOULD("type", "be EBufferDataType.VERTICE or EBufferDataType.NORMAL"));
                    break;
            }
            if (!this.hasData(data)) {
                return null;
            }
            this._animation.interpolation = 0;
            result = [
                this._getCurrentBufferWhichIsCreatedOnlyOnce(type, data, 3),
                this._getNextBufferWhichIsCreatedOnlyOnce(type, data, 3),
            ];
            return result;
        };
        MorphBufferContainer.prototype._getStaticDataCacheData = function (type) {
            return "static_" + type;
        };
        __decorate([
            wd.require(function (type) {
                wd.assert(this.geometryData.morphVertices && this.geometryData.morphVertices.getCount() > 0, wd.Log.info.FUNC_SHOULD("set morphVertices"));
            })
        ], MorphBufferContainer.prototype, "getVertice", null);
        __decorate([
            wd.require(function (type) {
                wd.assert(this.geometryData.morphVertices && this.geometryData.morphVertices.getCount() > 0, wd.Log.info.FUNC_SHOULD("set morphVertices"));
            })
        ], MorphBufferContainer.prototype, "getNormal", null);
        __decorate([
            wd.ensure(function (frames) {
                wdCb.Log.error(!frames, wdCb.Log.info.FUNC_SHOULD("\"" + this._animation.currentAnimName + "\" animation", "contain frame data"));
            })
        ], MorphBufferContainer.prototype, "_getFrames", null);
        __decorate([
            wd.require(function (type, data, size) {
                wd.assert(type === wd.EBufferDataType.VERTICE || type === wd.EBufferDataType.NORMAL, wd.Log.info.FUNC_SHOULD("type", "be EBufferDataType.VERTICE or EBufferDataType.NORMAL"));
            })
        ], MorphBufferContainer.prototype, "_getCurrentBufferWhichIsCreatedOnlyOnce", null);
        __decorate([
            wd.require(function (type, data, size) {
                wd.assert(type === wd.EBufferDataType.VERTICE || type === wd.EBufferDataType.NORMAL, wd.Log.info.FUNC_SHOULD("type", "be EBufferDataType.VERTICE or EBufferDataType.NORMAL"));
            })
        ], MorphBufferContainer.prototype, "_getNextBufferWhichIsCreatedOnlyOnce", null);
        __decorate([
            wd.cacheBufferForBufferContainerWithFuncParam("_getStaticDataCacheData")
        ], MorphBufferContainer.prototype, "_getStaticData", null);
        return MorphBufferContainer;
    }(wd.BufferContainer));
    wd.MorphBufferContainer = MorphBufferContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SkinSkeletonBufferContainer = (function (_super) {
        __extends(SkinSkeletonBufferContainer, _super);
        function SkinSkeletonBufferContainer() {
            _super.apply(this, arguments);
            this._jointIndiceBuffer = null;
            this._jointWeightBuffer = null;
        }
        SkinSkeletonBufferContainer.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        SkinSkeletonBufferContainer.prototype.createBuffersFromGeometryData = function () {
            _super.prototype.createBuffersFromGeometryData.call(this);
            this.getChild(wd.EBufferDataType.JOINT_INDICE);
            this.getChild(wd.EBufferDataType.JOINT_WEIGHT);
        };
        SkinSkeletonBufferContainer.prototype.getBuffer = function (type) {
            var result = null;
            switch (type) {
                case wd.EBufferDataType.JOINT_INDICE:
                    result = this._getJointIndice(type);
                    break;
                case wd.EBufferDataType.JOINT_WEIGHT:
                    result = this._getJointWeight(type);
                    break;
                default:
                    wd.Log.error(true, wdCb.Log.info.FUNC_UNKNOW("EBufferDataType: " + type));
                    break;
            }
            return result;
        };
        SkinSkeletonBufferContainer.prototype._getJointIndice = function (type) {
            var geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_jointIndiceBuffer", geometryData, 4);
            return this._jointIndiceBuffer;
        };
        SkinSkeletonBufferContainer.prototype._getJointWeight = function (type) {
            var geometryData = this.geometryData[wd.BufferDataTable.getGeometryDataName(type)];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_jointWeightBuffer", geometryData, 4);
            return this._jointWeightBuffer;
        };
        __decorate([
            wd.cacheBufferForBufferContainer()
        ], SkinSkeletonBufferContainer.prototype, "_getJointIndice", null);
        __decorate([
            wd.cacheBufferForBufferContainer()
        ], SkinSkeletonBufferContainer.prototype, "_getJointWeight", null);
        return SkinSkeletonBufferContainer;
    }(wd.CommonBufferContainer));
    wd.SkinSkeletonBufferContainer = SkinSkeletonBufferContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Camera = (function () {
        function Camera() {
            this._worldToCameraMatrix = null;
            this._near = null;
            this._far = null;
            this._pMatrix = wd.Matrix4.create();
            this.entityObject = null;
            this.pMatrixDirty = false;
            this._isUserSpecifyThePMatrix = false;
        }
        Object.defineProperty(Camera.prototype, "cameraToWorldMatrix", {
            get: function () {
                return this.entityObject.transform.localToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "worldToCameraMatrix", {
            get: function () {
                if (this._worldToCameraMatrix) {
                    return this._worldToCameraMatrix;
                }
                return this.cameraToWorldMatrix.clone().invert();
            },
            set: function (matrix) {
                this._worldToCameraMatrix = matrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "near", {
            get: function () {
                return this._near;
            },
            set: function (near) {
                this._near = near;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            get: function () {
                return this._far;
            },
            set: function (far) {
                this._far = far;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "pMatrix", {
            get: function () {
                return this._pMatrix;
            },
            set: function (pMatrix) {
                this._isUserSpecifyThePMatrix = true;
                this._pMatrix = pMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Camera.prototype.init = function () {
            if (this.pMatrixDirty) {
                this._updateProjectionMatrix();
                this.pMatrixDirty = false;
            }
        };
        Camera.prototype.dispose = function () {
        };
        Camera.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Camera.prototype.update = function (elapsed) {
            if (this.pMatrixDirty) {
                this._updateProjectionMatrix();
                this.pMatrixDirty = false;
            }
        };
        Camera.prototype.getInvViewProjMat = function () {
            return this.pMatrix.clone().multiply(this.worldToCameraMatrix).invert();
        };
        Camera.prototype._updateProjectionMatrix = function () {
            if (this._isUserSpecifyThePMatrix) {
                return;
            }
            this.updateProjectionMatrix();
        };
        __decorate([
            wd.requireGetter(function () {
                wd.assert(this.entityObject, wd.Log.info.FUNC_MUST_DEFINE("entityObject"));
            })
        ], Camera.prototype, "cameraToWorldMatrix", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Camera.prototype, "_worldToCameraMatrix", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Camera.prototype, "near", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Camera.prototype, "far", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Camera.prototype, "pMatrix", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Camera.prototype, "_isUserSpecifyThePMatrix", void 0);
        __decorate([
            wd.virtual
        ], Camera.prototype, "init", null);
        __decorate([
            wd.virtual
        ], Camera.prototype, "dispose", null);
        return Camera;
    }());
    wd.Camera = Camera;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OrthographicCamera = (function (_super) {
        __extends(OrthographicCamera, _super);
        function OrthographicCamera() {
            _super.apply(this, arguments);
            this._left = null;
            this._right = null;
            this._bottom = null;
            this._top = null;
        }
        OrthographicCamera.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(OrthographicCamera.prototype, "left", {
            get: function () {
                return this._left;
            },
            set: function (left) {
                this._left = left;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrthographicCamera.prototype, "right", {
            get: function () {
                return this._right;
            },
            set: function (right) {
                this._right = right;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrthographicCamera.prototype, "bottom", {
            get: function () {
                return this._bottom;
            },
            set: function (bottom) {
                this._bottom = bottom;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrthographicCamera.prototype, "top", {
            get: function () {
                return this._top;
            },
            set: function (top) {
                this._top = top;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        OrthographicCamera.prototype.convertScreenToWorld = function (screenX, screenY, distanceFromCamera) {
            var device = wd.DeviceManager.getInstance(), width = device.view.width, height = device.view.height, normalizedDeviceCoordinate = wd.Vector3.create(2 * screenX / width - 1, (height - screenY) / height * 2 - 1, (distanceFromCamera - this.far) / (this.far - this.near) * 2 + 1);
            return this.getInvViewProjMat().multiplyPoint(normalizedDeviceCoordinate);
        };
        OrthographicCamera.prototype.convertWorldToScreen = function (worldX, worldY, worldZ, screenWidth, screenHeight) {
            wd.Log.error(true, "need implement");
            return null;
        };
        OrthographicCamera.prototype.updateProjectionMatrix = function () {
            this.pMatrix.setOrtho(this._left, this._right, this._bottom, this._top, this.near, this.far);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], OrthographicCamera.prototype, "left", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], OrthographicCamera.prototype, "right", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], OrthographicCamera.prototype, "bottom", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], OrthographicCamera.prototype, "top", null);
        return OrthographicCamera;
    }(wd.Camera));
    wd.OrthographicCamera = OrthographicCamera;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PerspectiveCamera = (function (_super) {
        __extends(PerspectiveCamera, _super);
        function PerspectiveCamera() {
            _super.apply(this, arguments);
            this._fovy = null;
            this._aspect = null;
        }
        PerspectiveCamera.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(PerspectiveCamera.prototype, "fovy", {
            get: function () {
                return this._fovy;
            },
            set: function (fovy) {
                this._fovy = fovy;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PerspectiveCamera.prototype, "aspect", {
            get: function () {
                return this._aspect;
            },
            set: function (aspect) {
                this._aspect = aspect;
                this.pMatrixDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        PerspectiveCamera.prototype.zoomIn = function (speed, min) {
            if (min === void 0) { min = 1; }
            this.fovy = Math.max(this.fovy - speed, min);
        };
        PerspectiveCamera.prototype.zoomOut = function (speed, max) {
            if (max === void 0) { max = 179; }
            this.fovy = Math.min(this.fovy + speed, max);
        };
        PerspectiveCamera.prototype.convertScreenToWorld = function (screenX, screenY, distanceFromCamera) {
            var device = wd.DeviceManager.getInstance(), width = device.view.width, height = device.view.height, normalizedDeviceCoordinate = wd.Vector3.create(2 * screenX / width - 1, 1 - 2 * screenY / height, 1), invViewProjMat = this.getInvViewProjMat(), point = null, w = null;
            point = invViewProjMat.multiplyPoint(normalizedDeviceCoordinate);
            w = normalizedDeviceCoordinate.x * invViewProjMat.values[3] +
                normalizedDeviceCoordinate.y * invViewProjMat.values[7] +
                normalizedDeviceCoordinate.z * invViewProjMat.values[11] +
                invViewProjMat.values[15];
            point.scale(1 / w);
            return wd.Vector3.create().lerp(this.entityObject.transform.position, point, distanceFromCamera / this.far);
        };
        PerspectiveCamera.prototype.convertWorldToScreen = function (worldX, worldY, worldZ, screenWidth, screenHeight) {
            var viewProjectionMatrix = this.worldToCameraMatrix.clone().applyMatrix(this.pMatrix), normalizedDeviceCoordinate = viewProjectionMatrix.multiplyVector4(wd.Vector4.create(worldX, worldY, worldZ, 1.0)), ndcSpacePos = wd.Vector3.create(normalizedDeviceCoordinate.x / normalizedDeviceCoordinate.w, normalizedDeviceCoordinate.y / normalizedDeviceCoordinate.w, normalizedDeviceCoordinate.z / normalizedDeviceCoordinate.w);
            return wd.Vector2.create(Math.round((ndcSpacePos.x + 1) / 2.0 * screenWidth), Math.round((1 - ndcSpacePos.y) / 2.0 * screenHeight));
        };
        PerspectiveCamera.prototype.updateProjectionMatrix = function () {
            this.pMatrix.setPerspective(this._fovy, this._aspect, this.near, this.far);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PerspectiveCamera.prototype, "fovy", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PerspectiveCamera.prototype, "aspect", null);
        return PerspectiveCamera;
    }(wd.Camera));
    wd.PerspectiveCamera = PerspectiveCamera;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CameraController = (function (_super) {
        __extends(CameraController, _super);
        function CameraController(cameraComponent) {
            _super.call(this);
            this.camera = null;
            this._worldToCameraMatrixCache = null;
            this._clearCacheSubscription = null;
            this.camera = cameraComponent;
        }
        Object.defineProperty(CameraController.prototype, "cameraToWorldMatrix", {
            get: function () {
                return this.camera.cameraToWorldMatrix;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraController.prototype, "worldToCameraMatrix", {
            get: function () {
                return this._getWorldToCameraMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraController.prototype, "pMatrix", {
            get: function () {
                return this.camera.pMatrix;
            },
            set: function (pMatrix) {
                this.camera.pMatrix = pMatrix;
            },
            enumerable: true,
            configurable: true
        });
        CameraController.prototype.init = function () {
            this.camera.entityObject = this.entityObject;
            this.camera.init();
            this.bindClearCacheEvent();
        };
        CameraController.prototype.update = function (elapsed) {
            this.camera.update(elapsed);
        };
        CameraController.prototype.dispose = function () {
            this.camera.dispose();
            this.disposeClearCacheEvent();
        };
        CameraController.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        CameraController.prototype.isIntersectWithRay = function (entityObject, screenX, screenY) {
            var shape = null;
            if (!entityObject.hasComponent(wd.Collider)) {
                return false;
            }
            shape = entityObject.getComponent(wd.Collider).shape;
            return shape.isIntersectWithRay(this.createRay(screenX, screenY));
        };
        CameraController.prototype.createRay = function (screenX, screenY) {
            var from = this.convertScreenToWorld(screenX, screenY, this.camera.near), to = this.convertScreenToWorld(screenX, screenY, this.camera.far);
            return wd.Ray.create(from, to.sub(from));
        };
        CameraController.prototype.convertScreenToWorld = function (screenX, screenY, distanceFromCamera) {
            return this.camera.convertScreenToWorld(screenX, screenY, distanceFromCamera);
        };
        CameraController.prototype.convertWorldToScreen = function (worldX, worldY, worldZ, screenWidth, screenHeight) {
            return this.camera.convertWorldToScreen(worldX, worldY, worldZ, screenWidth, screenHeight);
        };
        CameraController.prototype.getPlanes = function () {
            var frustumPlanes = [], transform = this.worldToCameraMatrix.applyMatrix(this.pMatrix, true);
            for (var index = 0; index < 6; index++) {
                frustumPlanes.push(wd.Plane.create(0, 0, 0, 0));
            }
            this._setPlanes(transform, frustumPlanes);
            return frustumPlanes;
        };
        CameraController.prototype.bindClearCacheEvent = function () {
            var self = this;
            this._clearCacheSubscription = wdFrp.fromArray([
                wd.EventManager.fromEvent(wd.EEngineEvent.ENDLOOP),
                wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.TRANSFORM_TRANSLATE),
                wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.TRANSFORM_ROTATE),
                wd.EventManager.fromEvent(this.entityObject, wd.EEngineEvent.TRANSFORM_SCALE)
            ])
                .mergeAll()
                .subscribe(function () {
                self._clearCache();
            });
        };
        CameraController.prototype.disposeClearCacheEvent = function () {
            this._clearCacheSubscription && this._clearCacheSubscription.dispose();
        };
        CameraController.prototype._setPlanes = function (transform, frustumPlanes) {
            frustumPlanes[0].normal.x = transform.values[3] + transform.values[2];
            frustumPlanes[0].normal.y = transform.values[7] + transform.values[6];
            frustumPlanes[0].normal.z = transform.values[11] + transform.values[10];
            frustumPlanes[0].d = transform.values[15] + transform.values[14];
            frustumPlanes[0].normalize();
            frustumPlanes[1].normal.x = transform.values[3] - transform.values[2];
            frustumPlanes[1].normal.y = transform.values[7] - transform.values[6];
            frustumPlanes[1].normal.z = transform.values[11] - transform.values[10];
            frustumPlanes[1].d = transform.values[15] - transform.values[14];
            frustumPlanes[1].normalize();
            frustumPlanes[2].normal.x = transform.values[3] + transform.values[0];
            frustumPlanes[2].normal.y = transform.values[7] + transform.values[4];
            frustumPlanes[2].normal.z = transform.values[11] + transform.values[8];
            frustumPlanes[2].d = transform.values[15] + transform.values[12];
            frustumPlanes[2].normalize();
            frustumPlanes[3].normal.x = transform.values[3] - transform.values[0];
            frustumPlanes[3].normal.y = transform.values[7] - transform.values[4];
            frustumPlanes[3].normal.z = transform.values[11] - transform.values[8];
            frustumPlanes[3].d = transform.values[15] - transform.values[12];
            frustumPlanes[3].normalize();
            frustumPlanes[4].normal.x = transform.values[3] - transform.values[1];
            frustumPlanes[4].normal.y = transform.values[7] - transform.values[5];
            frustumPlanes[4].normal.z = transform.values[11] - transform.values[9];
            frustumPlanes[4].d = transform.values[15] - transform.values[13];
            frustumPlanes[4].normalize();
            frustumPlanes[5].normal.x = transform.values[3] + transform.values[1];
            frustumPlanes[5].normal.y = transform.values[7] + transform.values[5];
            frustumPlanes[5].normal.z = transform.values[11] + transform.values[9];
            frustumPlanes[5].d = transform.values[15] + transform.values[13];
            frustumPlanes[5].normalize();
        };
        CameraController.prototype._clearCache = function () {
            this._worldToCameraMatrixCache = null;
        };
        CameraController.prototype._getWorldToCameraMatrix = function () {
            return this.camera.worldToCameraMatrix;
        };
        __decorate([
            wd.cacheGetter(function () {
                return this._worldToCameraMatrixCache !== null;
            }, function () {
                return this._worldToCameraMatrixCache;
            }, function (result) {
                this._worldToCameraMatrixCache = result;
            })
        ], CameraController.prototype, "worldToCameraMatrix", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], CameraController.prototype, "camera", void 0);
        __decorate([
            wd.virtual
        ], CameraController.prototype, "bindClearCacheEvent", null);
        __decorate([
            wd.virtual
        ], CameraController.prototype, "disposeClearCacheEvent", null);
        return CameraController;
    }(wd.Component));
    wd.CameraController = CameraController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RenderTargetRendererCameraController = (function (_super) {
        __extends(RenderTargetRendererCameraController, _super);
        function RenderTargetRendererCameraController() {
            _super.apply(this, arguments);
        }
        RenderTargetRendererCameraController.create = function (cameraComponent) {
            var obj = new this(cameraComponent);
            return obj;
        };
        RenderTargetRendererCameraController.prototype.bindClearCacheEvent = function () {
        };
        RenderTargetRendererCameraController.prototype.disposeClearCacheEvent = function () {
        };
        return RenderTargetRendererCameraController;
    }(wd.CameraController));
    wd.RenderTargetRendererCameraController = RenderTargetRendererCameraController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicCameraController = (function (_super) {
        __extends(BasicCameraController, _super);
        function BasicCameraController() {
            _super.apply(this, arguments);
        }
        BasicCameraController.create = function (cameraComponent) {
            var obj = new this(cameraComponent);
            return obj;
        };
        return BasicCameraController;
    }(wd.CameraController));
    wd.BasicCameraController = BasicCameraController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FlyCameraController = (function (_super) {
        __extends(FlyCameraController, _super);
        function FlyCameraController(cameraComponent) {
            _super.call(this, cameraComponent);
            this._control = null;
            if (cameraComponent instanceof wd.PerspectiveCamera) {
                this._control = wd.FlyPerspectiveCameraControl.create(cameraComponent);
            }
            else {
                this._control = wd.FlyOrthographicCameraControl.create(cameraComponent);
            }
        }
        FlyCameraController.create = function (cameraComponent) {
            var obj = new this(cameraComponent);
            return obj;
        };
        Object.defineProperty(FlyCameraController.prototype, "moveSpeed", {
            get: function () {
                return this._control.moveSpeed;
            },
            set: function (speed) {
                this._control.moveSpeed = speed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FlyCameraController.prototype, "rotateSpeed", {
            get: function () {
                return this._control.rotateSpeed;
            },
            set: function (speed) {
                this._control.rotateSpeed = speed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FlyCameraController.prototype, "zoomSpeed", {
            get: function () {
                return this._control.zoomSpeed;
            },
            set: function (speed) {
                this._control.zoomSpeed = speed;
            },
            enumerable: true,
            configurable: true
        });
        FlyCameraController.prototype.init = function () {
            _super.prototype.init.call(this);
            this._control.init(this.entityObject);
        };
        FlyCameraController.prototype.update = function (elapsed) {
            _super.prototype.update.call(this, elapsed);
            this._control.update(elapsed);
        };
        FlyCameraController.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._control.dispose();
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], FlyCameraController.prototype, "moveSpeed", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], FlyCameraController.prototype, "rotateSpeed", null);
        __decorate([
            wd.requireGetterAndSetter(function () {
                wd.assert(this._control instanceof wd.FlyPerspectiveCameraControl, wd.Log.info.FUNC_MUST_BE("FlyPerspectiveCameraControl"));
            }, function () {
                wd.assert(this._control instanceof wd.FlyPerspectiveCameraControl, wd.Log.info.FUNC_MUST_BE("FlyPerspectiveCameraControl"));
            }),
            wd.cloneAttributeAsBasicType()
        ], FlyCameraController.prototype, "zoomSpeed", null);
        return FlyCameraController;
    }(wd.CameraController));
    wd.FlyCameraController = FlyCameraController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FlyCameraControl = (function () {
        function FlyCameraControl(cameraComponent) {
            this.moveSpeed = 1.2;
            this.rotateSpeed = 100;
            this.cameraComponent = null;
            this._rotateX = 0;
            this._rotateY = 0;
            this._isRotate = false;
            this._pointDragSubscription = null;
            this._keydownSubscription = null;
            this._gameObject = null;
            this.cameraComponent = cameraComponent;
        }
        FlyCameraControl.prototype.init = function (entityObject) {
            var eulerAngles = entityObject.transform.eulerAngles;
            this._rotateX = eulerAngles.x;
            this._rotateY = eulerAngles.y;
            this._gameObject = entityObject;
            this._bindCanvasEvent();
            this._updateTransform();
            this._isRotate = false;
        };
        FlyCameraControl.prototype.update = function (elapsed) {
            if (!this._isRotate) {
                return;
            }
            this._isRotate = false;
            this._updateTransform();
        };
        FlyCameraControl.prototype.dispose = function () {
            this._removeEvent();
        };
        FlyCameraControl.prototype._move = function (event) {
            var speed = this.moveSpeed, entityObject = this._gameObject, keyState = event.keyState;
            if (keyState["a"] || keyState["left"]) {
                entityObject.transform.translateLocal(wd.Vector3.create(-speed, 0, 0));
            }
            else if (keyState["d"] || keyState["right"]) {
                entityObject.transform.translateLocal(wd.Vector3.create(speed, 0, 0));
            }
            else if (keyState["w"] || keyState["up"]) {
                entityObject.transform.translateLocal(wd.Vector3.create(0, 0, -speed));
            }
            else if (keyState["s"] || keyState["down"]) {
                entityObject.transform.translateLocal(wd.Vector3.create(0, 0, speed));
            }
        };
        FlyCameraControl.prototype._bindCanvasEvent = function () {
            var self = this, rotateSpeed = this.rotateSpeed, pointdrag = wd.EventManager.fromEvent(wd.Director.getInstance().scene, wd.EEngineEvent.POINT_DRAG), keydown = wd.EventManager.fromEvent(wd.EEventName.KEYDOWN), canvas = wd.Director.getInstance().view;
            this._pointDragSubscription = pointdrag
                .map(function (e) {
                var movementDelta = e.userData.movementDelta, dx = null, dy = null, factor = rotateSpeed / canvas.height;
                dx = factor * movementDelta.x;
                dy = factor * movementDelta.y;
                self._isRotate = true;
                return {
                    dx: dx,
                    dy: dy
                };
            })
                .subscribe(function (pos) {
                self._changeRotation(pos);
            });
            this._keydownSubscription = keydown.subscribe(function (e) {
                self._move(e);
                self.zoom(e);
            });
        };
        FlyCameraControl.prototype._changeRotation = function (_a) {
            var dx = _a.dx, dy = _a.dy;
            this._rotateY -= dx;
            this._rotateX -= dy;
        };
        FlyCameraControl.prototype._removeEvent = function () {
            this._pointDragSubscription.dispose();
            this._keydownSubscription.dispose();
        };
        FlyCameraControl.prototype._updateTransform = function () {
            this._gameObject.transform.eulerAngles = wd.Vector3.create(this._rotateX, this._rotateY, 0);
        };
        return FlyCameraControl;
    }());
    wd.FlyCameraControl = FlyCameraControl;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FlyPerspectiveCameraControl = (function (_super) {
        __extends(FlyPerspectiveCameraControl, _super);
        function FlyPerspectiveCameraControl() {
            _super.apply(this, arguments);
            this.zoomSpeed = 10;
        }
        FlyPerspectiveCameraControl.create = function (cameraComponent) {
            var obj = new this(cameraComponent);
            return obj;
        };
        FlyPerspectiveCameraControl.prototype.zoom = function (event) {
            var speed = this.zoomSpeed, keyState = event.keyState;
            if (keyState["g"]) {
                this.cameraComponent.zoomIn(speed);
            }
            else if (keyState["h"]) {
                this.cameraComponent.zoomOut(speed);
            }
        };
        return FlyPerspectiveCameraControl;
    }(wd.FlyCameraControl));
    wd.FlyPerspectiveCameraControl = FlyPerspectiveCameraControl;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FlyOrthographicCameraControl = (function (_super) {
        __extends(FlyOrthographicCameraControl, _super);
        function FlyOrthographicCameraControl() {
            _super.apply(this, arguments);
        }
        FlyOrthographicCameraControl.create = function (cameraComponent) {
            var obj = new this(cameraComponent);
            return obj;
        };
        FlyOrthographicCameraControl.prototype.zoom = function (event) {
        };
        return FlyOrthographicCameraControl;
    }(wd.FlyCameraControl));
    wd.FlyOrthographicCameraControl = FlyOrthographicCameraControl;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ArcballCameraController = (function (_super) {
        __extends(ArcballCameraController, _super);
        function ArcballCameraController() {
            _super.apply(this, arguments);
            this._distance = 10;
            this._minDistance = 0.05;
            this._phi = Math.PI / 2;
            this._theta = Math.PI / 2;
            this._thetaMargin = 0.05;
            this._target = wd.Vector3.create(0, 0, 0);
            this.moveSpeedX = 1;
            this.moveSpeedY = 1;
            this.rotateSpeed = 1;
            this.wheelSpeed = 1;
            this._isChange = true;
            this._pointDragSubscription = null;
            this._pointWheelSubscription = null;
            this._keydownSubscription = null;
        }
        ArcballCameraController.create = function (cameraComponent) {
            var obj = new this(cameraComponent);
            return obj;
        };
        Object.defineProperty(ArcballCameraController.prototype, "distance", {
            get: function () {
                return this._distance;
            },
            set: function (distance) {
                if (this._distance !== distance) {
                    this._changeDistance(distance);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ArcballCameraController.prototype, "minDistance", {
            get: function () {
                return this._minDistance;
            },
            set: function (minDistance) {
                this._minDistance = minDistance;
                if (minDistance > this._distance) {
                    this._changeDistance(minDistance);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ArcballCameraController.prototype, "phi", {
            get: function () {
                return this._phi;
            },
            set: function (phi) {
                if (this._phi !== phi) {
                    this._changePhi(phi);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ArcballCameraController.prototype, "theta", {
            get: function () {
                return this._theta;
            },
            set: function (theta) {
                if (this._theta !== theta) {
                    this._changeTheta(theta);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ArcballCameraController.prototype, "thetaMargin", {
            get: function () {
                return this._thetaMargin;
            },
            set: function (thetaMargin) {
                if (this._thetaMargin !== thetaMargin) {
                    this._thetaMargin = thetaMargin;
                    this._constrainTheta();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ArcballCameraController.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                if (!this._target.isEqual(target)) {
                    this._changeTarget(target);
                }
            },
            enumerable: true,
            configurable: true
        });
        ArcballCameraController.prototype.init = function () {
            _super.prototype.init.call(this);
            this._bindCanvasEvent();
            this._updateTransform();
            this._isChange = false;
        };
        ArcballCameraController.prototype.update = function (elapsed) {
            _super.prototype.update.call(this, elapsed);
            if (!this._isChange) {
                return;
            }
            this._isChange = false;
            this._updateTransform();
        };
        ArcballCameraController.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._removeEvent();
        };
        ArcballCameraController.prototype._bindCanvasEvent = function () {
            var self = this, scene = wd.Director.getInstance().scene, pointwheel = wd.EventManager.fromEvent(scene, wd.EEngineEvent.POINT_SCALE), pointdrag = wd.EventManager.fromEvent(scene, wd.EEngineEvent.POINT_DRAG), keydown = wd.EventManager.fromEvent(wd.EEventName.KEYDOWN);
            this._pointDragSubscription = pointdrag.subscribe(function (e) {
                self._changeOrbit(e.userData);
            });
            this._pointWheelSubscription = pointwheel.subscribe(function (e) {
                var pointEvent = e.userData;
                pointEvent.preventDefault();
                self._changeDistance(pointEvent);
            });
            this._keydownSubscription = keydown.subscribe(function (e) {
                self._changeTarget(e);
            });
        };
        ArcballCameraController.prototype._changeOrbit = function (e) {
            var movementDelta = e.movementDelta;
            this._isChange = true;
            this._changePhi(this._phi + movementDelta.x / (100 / this.rotateSpeed));
            this._changeTheta(this._theta - movementDelta.y / (100 / this.rotateSpeed));
        };
        ArcballCameraController.prototype._changePhi = function (phi) {
            this._isChange = true;
            this._phi = phi;
        };
        ArcballCameraController.prototype._changeTheta = function (theta) {
            this._isChange = true;
            this._theta = theta;
            this._constrainTheta();
        };
        ArcballCameraController.prototype._changeTarget = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._isChange = true;
            if (args[0] instanceof wd.Vector3) {
                this._target = args[0];
            }
            else {
                var e = args[0], moveSpeedX = this.moveSpeedX, moveSpeedY = this.moveSpeedY, dx = null, dy = null, keyState = e.keyState, transform = this.entityObject.transform;
                if (keyState["a"] || keyState["left"]) {
                    dx = -moveSpeedX;
                }
                else if (keyState["d"] || keyState["right"]) {
                    dx = moveSpeedX;
                }
                else if (keyState["w"] || keyState["up"]) {
                    dy = moveSpeedY;
                }
                else if (keyState["s"] || keyState["down"]) {
                    dy = -moveSpeedY;
                }
                this._target.add(wd.Vector3.create(transform.right.x * (dx), 0, transform.right.z * (dx)));
                this._target.add(wd.Vector3.create(transform.up.x * dy, transform.up.y * dy, 0));
            }
        };
        ArcballCameraController.prototype._changeDistance = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this._isChange = true;
            if (wd.JudgeUtils.isNumber(args[0])) {
                this._distance = args[0];
            }
            else {
                var e = args[0];
                this._distance -= this.wheelSpeed * e.wheel;
            }
            this._constrainDistance();
        };
        ArcballCameraController.prototype._constrainDistance = function () {
            this.distance = wd.MathUtils.bigThan(this.distance, this.minDistance);
        };
        ArcballCameraController.prototype._constrainTheta = function () {
            this._theta = wd.MathUtils.clamp(this._theta, this._thetaMargin, Math.PI - this._thetaMargin);
        };
        ArcballCameraController.prototype._removeEvent = function () {
            this._pointDragSubscription.dispose();
            this._pointWheelSubscription.dispose();
            this._keydownSubscription.dispose();
        };
        ArcballCameraController.prototype._updateTransform = function () {
            var x = null, y = null, z = null;
            x = ((this.distance) * Math.cos(this.phi) * Math.sin(this.theta) + this.target.x);
            z = ((this.distance) * Math.sin(this.phi) * Math.sin(this.theta) + this.target.z);
            y = ((this.distance) * Math.cos(this.theta) + this.target.y);
            this.entityObject.transform.position = wd.Vector3.create(x, y, z);
            this.entityObject.transform.lookAt(this.target);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "distance", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "minDistance", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "phi", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "theta", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "thetaMargin", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ArcballCameraController.prototype, "target", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "moveSpeedX", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "moveSpeedY", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "rotateSpeed", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ArcballCameraController.prototype, "wheelSpeed", void 0);
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.expect(args[0] instanceof wd.KeyboardEvent || args[0] instanceof wd.Vector3).true;
            })
        ], ArcballCameraController.prototype, "_changeTarget", null);
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.expect(wd.JudgeUtils.isNumber(args[0]) || args[0] instanceof wd.PointEvent).true;
            })
        ], ArcballCameraController.prototype, "_changeDistance", null);
        return ArcballCameraController;
    }(wd.CameraController));
    wd.ArcballCameraController = ArcballCameraController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RendererComponent = (function (_super) {
        __extends(RendererComponent, _super);
        function RendererComponent() {
            _super.apply(this, arguments);
        }
        return RendererComponent;
    }(wd.Component));
    wd.RendererComponent = RendererComponent;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        function MeshRenderer() {
            _super.apply(this, arguments);
        }
        MeshRenderer.create = function () {
            var obj = new this();
            return obj;
        };
        MeshRenderer.prototype.render = function (renderer, target, camera) {
            var geometry = target.getGeometry();
            if (!geometry) {
                return;
            }
            renderer.addCommand(this.createDrawCommand(target, geometry, camera));
        };
        MeshRenderer.prototype.createDrawCommand = function (target, geometry, camera) {
            var cmd = null, cameraComponent = camera.getComponent(wd.CameraController), material = geometry.material;
            cmd = this._createCommand(target, material);
            cmd.target = target;
            cmd.buffers = geometry.buffers;
            cmd.vaoManager = geometry.vaoManager;
            cmd.drawMode = geometry.drawMode;
            cmd.mMatrix = target.transform.localToWorldMatrix;
            if (target.data && target.data.vMatrix) {
                cmd.vMatrix = target.data.vMatrix;
            }
            else {
                cmd.vMatrix = cameraComponent.worldToCameraMatrix;
            }
            if (target.data && target.data.pMatrix) {
                cmd.pMatrix = target.data.pMatrix;
            }
            else {
                cmd.pMatrix = cameraComponent.pMatrix;
            }
            cmd.material = material;
            cmd.blend = material.blend;
            return cmd;
        };
        MeshRenderer.prototype._createCommand = function (target, material) {
            var cmd = null, glslData = null;
            var _a = this._getInstanceState(material), isModelMatrixInstance = _a.isModelMatrixInstance, isNormalMatrixInstance = _a.isNormalMatrixInstance, isOneToManyInstance = _a.isOneToManyInstance, isHardwareInstance = _a.isHardwareInstance, isBatchInstance = _a.isBatchInstance;
            glslData = this._getInstanceGLSLData(isOneToManyInstance, isModelMatrixInstance, isNormalMatrixInstance);
            if (isHardwareInstance) {
                if (isOneToManyInstance) {
                    cmd = this._createOneToManyHardwareInstanceCommand(target, material, glslData);
                }
                else {
                    cmd = this._createOneToOneHardwareInstanceCommand(target, material, glslData);
                }
            }
            else if (isBatchInstance) {
                if (isOneToManyInstance) {
                    cmd = this._createOneToManyBatchInstanceCommand(target, material, glslData);
                }
                else {
                    cmd = this._createOneToOneBatchInstanceCommand(target, material, glslData);
                }
            }
            else {
                cmd = wd.SingleDrawCommand.create();
                cmd.normalMatrix = this.entityObject.transform.normalMatrix;
            }
            return cmd;
        };
        MeshRenderer.prototype._getInstanceState = function (material) {
            if (material.geometry instanceof wd.InstanceGeometry) {
                var isHardwareInstance_1 = wd.InstanceUtils.isHardwareSupport(), isBatchInstance_1 = !isHardwareInstance_1;
                return {
                    isModelMatrixInstance: false,
                    isNormalMatrixInstance: false,
                    isOneToManyInstance: true,
                    isHardwareInstance: isHardwareInstance_1,
                    isBatchInstance: isBatchInstance_1
                };
            }
            var _a = material.shader.getInstanceState(), isModelMatrixInstance = _a.isModelMatrixInstance, isNormalMatrixInstance = _a.isNormalMatrixInstance, isHardwareInstance = _a.isHardwareInstance, isBatchInstance = _a.isBatchInstance;
            return {
                isModelMatrixInstance: isModelMatrixInstance,
                isNormalMatrixInstance: isNormalMatrixInstance,
                isOneToManyInstance: false,
                isHardwareInstance: isHardwareInstance,
                isBatchInstance: isBatchInstance
            };
        };
        MeshRenderer.prototype._getInstanceGLSLData = function (isOneToManyInstance, isModelMatrixInstance, isNormalMatrixInstance) {
            if (isOneToManyInstance) {
                return wd.EInstanceGLSLData.ONE_MANY;
            }
            if (isNormalMatrixInstance) {
                return wd.EInstanceGLSLData.NORMALMATRIX_MODELMATRIX;
            }
            return wd.EInstanceGLSLData.MODELMATRIX;
        };
        MeshRenderer.prototype._createOneToOneHardwareInstanceCommand = function (target, material, glslData) {
            var instanceComponent = target.getComponent(wd.OneToOneSourceInstance), cmd = wd.OneToOneHardwareInstanceCommand.create();
            cmd.instanceList = instanceComponent.toRenderInstanceListForDraw;
            cmd.instanceBuffer = instanceComponent.instanceBuffer;
            cmd.glslData = glslData;
            return cmd;
        };
        MeshRenderer.prototype._createOneToManyHardwareInstanceCommand = function (target, material, glslData) {
            var instanceComponent = target.getComponent(wd.OneToManySourceInstance), cmd = wd.OneToManyHardwareInstanceCommand.create();
            cmd.instanceBuffer = instanceComponent.instanceBuffer;
            cmd.geometry = material.geometry;
            cmd.glslData = glslData;
            return cmd;
        };
        MeshRenderer.prototype._createOneToOneBatchInstanceCommand = function (target, material, glslData) {
            var instanceComponent = target.getComponent(wd.OneToOneSourceInstance), cmd = wd.OneToOneBatchInstanceCommand.create();
            cmd.instanceList = instanceComponent.toRenderInstanceListForDraw;
            cmd.glslData = glslData;
            return cmd;
        };
        MeshRenderer.prototype._createOneToManyBatchInstanceCommand = function (target, material, glslData) {
            var instanceComponent = target.getComponent(wd.OneToManySourceInstance), cmd = wd.OneToManyBatchInstanceCommand.create();
            cmd.geometry = material.geometry;
            cmd.glslData = glslData;
            return cmd;
        };
        __decorate([
            wd.require(function (target, geometry, camera) {
                var controller = camera.getComponent(wd.CameraController);
                wd.it("camera must add Camera Component", function () {
                    wd.expect(!!controller && !!controller.camera).true;
                });
                wd.it("Mesh must add geometry component", function () {
                    wd.expect(!!geometry).true;
                });
            })
        ], MeshRenderer.prototype, "createDrawCommand", null);
        __decorate([
            wd.require(function (target) {
                if (wd.InstanceUtils.isInstance(target)) {
                    wd.it("if use instance to batch draw, target should be SourceInstance", function () {
                        wd.expect(wd.InstanceUtils.isSourceInstance(target)).true;
                    });
                }
            }),
            wd.ensure(function (cmd, target) {
                if (cmd instanceof wd.HardwareInstanceCommand) {
                    wd.it("hardware should support instance", function () {
                        wd.expect(wd.InstanceUtils.isHardwareSupport()).true;
                    });
                }
                else if (cmd instanceof wd.BatchInstanceCommand) {
                    wd.it("hardware shouldn't support instance", function () {
                        wd.expect(wd.InstanceUtils.isHardwareSupport()).false;
                    });
                }
            })
        ], MeshRenderer.prototype, "_createCommand", null);
        return MeshRenderer;
    }(wd.RendererComponent));
    wd.MeshRenderer = MeshRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SkyboxRenderer = (function (_super) {
        __extends(SkyboxRenderer, _super);
        function SkyboxRenderer() {
            _super.apply(this, arguments);
        }
        SkyboxRenderer.create = function () {
            var obj = new this();
            return obj;
        };
        SkyboxRenderer.prototype.render = function (renderer, target, camera) {
            renderer.skyboxCommand = this.createDrawCommand(target, target.getComponent(wd.Geometry), camera);
        };
        __decorate([
            wd.require(function (renderer, target, camera) {
                wd.it("target should has geometry", function () {
                    wd.expect(target.hasComponent(wd.Geometry)).true;
                });
            })
        ], SkyboxRenderer.prototype, "render", null);
        return SkyboxRenderer;
    }(wd.MeshRenderer));
    wd.SkyboxRenderer = SkyboxRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var UIRenderer = (function (_super) {
        __extends(UIRenderer, _super);
        function UIRenderer() {
            _super.apply(this, arguments);
            this._zIndex = 1;
            this._dirty = true;
            this.isClearCanvas = false;
            this.state = wd.EUIRendererState.NORMAL;
            this.context = null;
            this.canvas = null;
            this._referenceList = wdCb.Collection.create();
        }
        UIRenderer.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(UIRenderer.prototype, "zIndex", {
            get: function () {
                return this._zIndex;
            },
            set: function (zIndex) {
                if (zIndex !== this._zIndex) {
                    this._zIndex = zIndex;
                    if (this.canvas) {
                        wdCb.DomQuery.create(this.canvas).css("zIndex", zIndex);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIRenderer.prototype, "dirty", {
            get: function () {
                return this._dirty;
            },
            set: function (dirty) {
                if (dirty) {
                    this._dirty = true;
                }
                else {
                    this.resetDirty();
                }
            },
            enumerable: true,
            configurable: true
        });
        UIRenderer.prototype.resetDirty = function () {
            this._dirty = false;
        };
        UIRenderer.prototype.addToObject = function (object) {
            this._referenceList.addChild(object);
            this.entityObject = object;
        };
        UIRenderer.prototype.removeFromObject = function (object) {
            this._referenceList.removeChild(object);
            if (this._referenceList.getCount() > 0) {
                return;
            }
            _super.prototype.removeFromObject.call(this, object);
        };
        UIRenderer.prototype.init = function () {
        };
        UIRenderer.prototype.initWhenCreate = function () {
            this._createOverlayCanvas();
        };
        UIRenderer.prototype.dispose = function () {
            if (this._referenceList.getCount() > 0) {
                return;
            }
            wdCb.DomQuery.create(this.canvas).remove();
        };
        UIRenderer.prototype.render = function (renderer, target, camera) {
        };
        UIRenderer.prototype.clearCanvas = function () {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.isClearCanvas = true;
        };
        UIRenderer.prototype._createOverlayCanvas = function () {
            var canvas = null, view = null;
            if (this.canvas) {
                return;
            }
            canvas = wdCb.DomQuery.create("<canvas></canvas>").prependTo("body");
            view = wd.DeviceManager.getInstance().view;
            canvas.css("position", "absolute");
            canvas.css("left", view.x + "px");
            canvas.css("top", view.y + "px");
            canvas.css("zIndex", this.zIndex);
            canvas.attr("width", view.width);
            canvas.attr("height", view.height);
            this.canvas = canvas.get(0);
            this.context = this.canvas.getContext("2d");
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], UIRenderer.prototype, "zIndex", null);
        __decorate([
            wd.execOnlyOnce("_isInit")
        ], UIRenderer.prototype, "init", null);
        return UIRenderer;
    }(wd.RendererComponent));
    wd.UIRenderer = UIRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EUIRendererState) {
        EUIRendererState[EUIRendererState["NORMAL"] = 0] = "NORMAL";
        EUIRendererState[EUIRendererState["DIRTY"] = 1] = "DIRTY";
        EUIRendererState[EUIRendererState["NOT_DIRTY"] = 2] = "NOT_DIRTY";
    })(wd.EUIRendererState || (wd.EUIRendererState = {}));
    var EUIRendererState = wd.EUIRendererState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ColliderForFirstCheck = (function (_super) {
        __extends(ColliderForFirstCheck, _super);
        function ColliderForFirstCheck() {
            _super.apply(this, arguments);
        }
        ColliderForFirstCheck.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        return ColliderForFirstCheck;
    }(wd.Component));
    wd.ColliderForFirstCheck = ColliderForFirstCheck;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BoxColliderForFirstCheck = (function (_super) {
        __extends(BoxColliderForFirstCheck, _super);
        function BoxColliderForFirstCheck() {
            _super.apply(this, arguments);
            this._collider = wd.BoxCollider.create();
        }
        BoxColliderForFirstCheck.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(BoxColliderForFirstCheck.prototype, "shape", {
            get: function () {
                return this._collider.shape;
            },
            enumerable: true,
            configurable: true
        });
        BoxColliderForFirstCheck.prototype.init = function () {
            this._collider.entityObject = this.entityObject;
            this._collider.init();
        };
        BoxColliderForFirstCheck.prototype.update = function (elapsed) {
            this._collider.update(elapsed);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BoxColliderForFirstCheck.prototype, "_collider", void 0);
        return BoxColliderForFirstCheck;
    }(wd.ColliderForFirstCheck));
    wd.BoxColliderForFirstCheck = BoxColliderForFirstCheck;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Collider = (function (_super) {
        __extends(Collider, _super);
        function Collider() {
            _super.apply(this, arguments);
            this.enable = true;
            this.boundingRegion = null;
        }
        Object.defineProperty(Collider.prototype, "shape", {
            get: function () {
                return this.boundingRegion.shape;
            },
            enumerable: true,
            configurable: true
        });
        Collider.prototype.init = function () {
            this.boundingRegion = this.createBoundingRegion();
            this.boundingRegion.init();
            this.buildBoundingRegion();
        };
        Collider.prototype.addToComponentContainer = function () {
            var container = wd.CollisionComponentContainer.getInstance();
            if (!container.hasChild(this)) {
                container.addChild(this);
            }
        };
        Collider.prototype.removeFromComponentContainer = function () {
            wd.CollisionComponentContainer.getInstance().removeChild(this);
        };
        Collider.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Collider.prototype.update = function (elapsed) {
            this.boundingRegion.update();
        };
        Collider.prototype.updateShape = function () {
            this.boundingRegion.updateShape();
        };
        Collider.prototype.isIntersectWith = function (collider) {
            if (collider instanceof wd.BoxCollider) {
                return this.boundingRegion.isIntersectWithBox(collider.boundingRegion);
            }
            else if (collider instanceof wd.SphereCollider) {
                return this.boundingRegion.isIntersectWithSphere(collider.boundingRegion);
            }
            else {
                wd.Log.warn(wd.Log.info.FUNC_NOT_SUPPORT(this.type + " collider", "intersect with " + collider.type + " collider"));
            }
        };
        Collider.prototype.isCollide = function (targetObject) {
            var collider = null;
            collider = targetObject.getComponent(Collider);
            if (wd.ClassUtils.hasComponent(targetObject, "RigidBody")) {
                collider.updateShape();
            }
            return this.isIntersectWith(collider);
        };
        Collider.prototype._isSelf = function (entityObject) {
            return wd.JudgeUtils.isSelf(this.entityObject, entityObject);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Collider.prototype, "enable", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Collider.prototype, "boundingRegion", void 0);
        __decorate([
            wd.require(function (collider) {
                wd.assert(collider instanceof Collider, wd.Log.info.FUNC_SHOULD("target", "be collider"));
            })
        ], Collider.prototype, "isIntersectWith", null);
        __decorate([
            wd.require(function (targetObject) {
                wd.assert(!this._isSelf(targetObject), wd.Log.info.FUNC_SHOULD_NOT("targetObject", "be self"));
                wd.assert(targetObject.hasComponent(Collider), wd.Log.info.FUNC_SHOULD("targetObject", "contain Collider component"));
            })
        ], Collider.prototype, "isCollide", null);
        return Collider;
    }(wd.Component));
    wd.Collider = Collider;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BoxCollider = (function (_super) {
        __extends(BoxCollider, _super);
        function BoxCollider() {
            _super.apply(this, arguments);
            this.center = wd.Vector3.create(0, 0, 0);
            this.halfExtents = null;
            this.type = wd.EColliderType.BOX;
        }
        BoxCollider.create = function () {
            var obj = new this();
            return obj;
        };
        BoxCollider.prototype.createBoundingRegion = function () {
            return wd.BoxBoundingRegion.create(this.entityObject);
        };
        BoxCollider.prototype.buildBoundingRegion = function () {
            this.boundingRegion.build(this.center, this.halfExtents);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BoxCollider.prototype, "center", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BoxCollider.prototype, "halfExtents", void 0);
        return BoxCollider;
    }(wd.Collider));
    wd.BoxCollider = BoxCollider;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SphereCollider = (function (_super) {
        __extends(SphereCollider, _super);
        function SphereCollider() {
            _super.apply(this, arguments);
            this.center = wd.Vector3.create(0, 0, 0);
            this.radius = null;
            this.type = wd.EColliderType.SPHERE;
        }
        SphereCollider.create = function () {
            var obj = new this();
            return obj;
        };
        SphereCollider.prototype.createBoundingRegion = function () {
            return wd.SphereBoundingRegion.create(this.entityObject);
        };
        SphereCollider.prototype.buildBoundingRegion = function () {
            this.boundingRegion.build(this.center, this.radius);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], SphereCollider.prototype, "center", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], SphereCollider.prototype, "radius", void 0);
        return SphereCollider;
    }(wd.Collider));
    wd.SphereCollider = SphereCollider;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BoundingRegion = (function () {
        function BoundingRegion(entityObject) {
            this.shape = null;
            this.entityObject = null;
            this.isUserSpecifyTheRegion = false;
            this.originShape = null;
            this.debugObject = null;
            this.entityObject = entityObject;
        }
        BoundingRegion.prototype.init = function () {
            this.shape = this.createShape();
        };
        BoundingRegion.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        BoundingRegion.prototype.build = function (center) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var params = Array.prototype.slice.call(arguments, 0);
            if (this.isBuildUserSpecifyBoundingRegion.apply(this, params)) {
                this.isUserSpecifyTheRegion = true;
                this.shape.setFromShapeParam.apply(this.shape, params);
            }
            else {
                this.shape.setFromPoints(wd.ColliderUtils.getVertices(this.entityObject));
            }
            this.originShape = this.shape.clone();
            if (wd.DebugConfig.debugCollision) {
                this.debugObject = this.buildDebugObjectFromShape(this.shape);
                wd.Director.getInstance().scene.addChild(this.debugObject);
            }
        };
        BoundingRegion.prototype.update = function () {
            if (this.isNotTransformed()) {
                return;
            }
            if (wd.DebugConfig.debugCollision) {
                this.updateShape();
                this.updateDebugObjectFromShape(this.shape);
            }
            else if (!wd.ClassUtils.hasComponent(this.entityObject, "RigidBody")) {
                this.updateShape();
            }
        };
        BoundingRegion.prototype.isIntersectWithSphere = function (boundingRegion) {
            return this.shape.isIntersectWithSphere(boundingRegion.shape);
        };
        BoundingRegion.prototype.isIntersectWithBox = function (boundingRegion) {
            return this.shape.isIntersectWithBox(boundingRegion.shape);
        };
        BoundingRegion.prototype.buildDebugObjectFromShape = function (shape) {
            var material = null, geometry = null, renderer = null, entityObject = null;
            material = wd.BasicMaterial.create();
            material.color = wd.Color.create("rgb(255,0,0)");
            geometry = wd.CustomGeometry.create();
            geometry.material = material;
            geometry.drawMode = wd.EDrawMode.LINES;
            this.setDebugObjectGeometry(geometry, shape);
            renderer = wd.MeshRenderer.create();
            entityObject = wd.GameObject.create();
            entityObject.addComponent(geometry);
            entityObject.addComponent(renderer);
            entityObject.transform.translate(shape.center);
            entityObject.name = "debugBoundingRegion" + this.entityObject.uid;
            entityObject.init();
            return entityObject;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BoundingRegion.prototype, "shape", void 0);
        __decorate([
            wd.ensure(function (returnValue, center) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                }
                if (this.isBuildUserSpecifyBoundingRegion.apply(this, Array.prototype.slice.call(arguments, 1))) {
                    wd.assert(this.shape.center.isEqual(center), wd.Log.info.FUNC_SHOULD_NOT("transform shape when build"));
                }
            })
        ], BoundingRegion.prototype, "build", null);
        return BoundingRegion;
    }());
    wd.BoundingRegion = BoundingRegion;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BoxBoundingRegion = (function (_super) {
        __extends(BoxBoundingRegion, _super);
        function BoxBoundingRegion() {
            _super.apply(this, arguments);
        }
        BoxBoundingRegion.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        BoxBoundingRegion.prototype.updateShape = function () {
            var transform = this.entityObject.transform;
            if (this.isUserSpecifyTheRegion) {
                this.shape.setFromTranslationAndScale(this.originShape, transform.localToWorldMatrix);
            }
            else {
                if (transform.isRotate) {
                    this.shape.setFromObject(this.entityObject);
                }
                else {
                    this.shape.setFromTranslationAndScale(this.originShape, transform.localToWorldMatrix);
                }
            }
        };
        BoxBoundingRegion.prototype.createShape = function () {
            return wd.AABBShape.create();
        };
        BoxBoundingRegion.prototype.updateDebugObjectFromShape = function (shape) {
            var geometry = this.debugObject.getComponent(wd.CustomGeometry);
            this.setDebugObjectGeometry(geometry, shape);
            this.debugObject.transform.position = shape.center;
        };
        BoxBoundingRegion.prototype.setDebugObjectGeometry = function (geometry, shape) {
            var halfExtents = shape.halfExtents, x = halfExtents.x, y = halfExtents.y, z = halfExtents.z;
            geometry.vertices = [
                -x, -y, -z, -x, -y, z, x, -y, z, x, -y, -z,
                -x, y, -z, -x, y, z, x, y, z, x, y, -z
            ];
            geometry.indices = [
                0, 1, 1, 2, 2, 3, 3, 0,
                4, 5, 5, 6, 6, 7, 7, 4,
                0, 4, 1, 5, 2, 6, 3, 7
            ];
        };
        BoxBoundingRegion.prototype.isBuildUserSpecifyBoundingRegion = function (center, halfExtents) {
            return !!center && !!halfExtents;
        };
        BoxBoundingRegion.prototype.isNotTransformed = function () {
            var transform = this.entityObject.transform;
            return !transform.isRotate && !transform.isTranslate && !transform.isScale;
        };
        __decorate([
            wd.require(function (shape) {
                wd.assert(this.debugObject, wd.Log.info.FUNC_SHOULD("build debugObject"));
            })
        ], BoxBoundingRegion.prototype, "updateDebugObjectFromShape", null);
        __decorate([
            wd.require(function (geometry, shape) {
                wd.assert(shape.halfExtents && !shape.halfExtents.isZero(), wd.Log.info.FUNC_SHOULD_NOT("halfExtents", "be zero"));
            })
        ], BoxBoundingRegion.prototype, "setDebugObjectGeometry", null);
        return BoxBoundingRegion;
    }(wd.BoundingRegion));
    wd.BoxBoundingRegion = BoxBoundingRegion;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SphereBoundingRegion = (function (_super) {
        __extends(SphereBoundingRegion, _super);
        function SphereBoundingRegion() {
            _super.apply(this, arguments);
        }
        SphereBoundingRegion.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        SphereBoundingRegion.prototype.updateShape = function () {
            var transform = this.entityObject.transform;
            this.shape.setFromTranslationAndScale(this.originShape, transform.localToWorldMatrix);
        };
        SphereBoundingRegion.prototype.createShape = function () {
            return wd.SphereShape.create();
        };
        SphereBoundingRegion.prototype.updateDebugObjectFromShape = function (shape) {
            this.debugObject.transform.position = shape.center;
            var scaleTimes = shape.radius / this.originShape.radius;
            this.debugObject.transform.scale = wd.Vector3.create(scaleTimes, scaleTimes, scaleTimes);
        };
        SphereBoundingRegion.prototype.isNotTransformed = function () {
            var transform = this.entityObject.transform;
            return !transform.isTranslate && !transform.isScale;
        };
        SphereBoundingRegion.prototype.isBuildUserSpecifyBoundingRegion = function (center, radius) {
            return !!center && !!radius;
        };
        SphereBoundingRegion.prototype.setDebugObjectGeometry = function (geometry, shape) {
            var SEGMENTS = 40, RINGCOUNT = 3;
            var radius = shape.radius, vertices = [], x = 0;
            for (var ring = 0; ring < RINGCOUNT; ring++) {
                var xo = 0, yo = 1, zo = 2, theta = null;
                if (ring === 1) {
                    xo = 1;
                    yo = 0;
                    zo = 2;
                }
                else if (ring === 2) {
                    xo = 0;
                    yo = 2;
                    zo = 1;
                }
                for (var i = 0; i < SEGMENTS; i++) {
                    theta = 2 * Math.PI * (i / SEGMENTS);
                    vertices[x + xo] = radius * Math.cos(theta);
                    vertices[x + yo] = 0;
                    vertices[x + zo] = radius * Math.sin(theta);
                    x += 3;
                    theta = 2 * Math.PI * ((i + 1) / SEGMENTS);
                    vertices[x + xo] = radius * Math.cos(theta);
                    vertices[x + yo] = 0;
                    vertices[x + zo] = radius * Math.sin(theta);
                    x += 3;
                }
            }
            geometry.vertices = vertices;
        };
        __decorate([
            wd.require(function (shape) {
                wd.assert(this.debugObject, wd.Log.info.FUNC_SHOULD("build debugObject"));
            })
        ], SphereBoundingRegion.prototype, "updateDebugObjectFromShape", null);
        __decorate([
            wd.require(function (geometry, shape) {
                wd.assert(shape.radius > 0, wd.Log.info.FUNC_SHOULD("radius", "> 0"));
            })
        ], SphereBoundingRegion.prototype, "setDebugObjectGeometry", null);
        return SphereBoundingRegion;
    }(wd.BoundingRegion));
    wd.SphereBoundingRegion = SphereBoundingRegion;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BoundingRegionUtils = (function () {
        function BoundingRegionUtils() {
        }
        BoundingRegionUtils.isAABBInFrustum = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var boundingVectors = null, frustumPlanes = null;
            if (args.length === 2) {
                boundingVectors = args[0];
                frustumPlanes = args[1];
            }
            else if (args.length === 3) {
                var minPoint = args[0], maxPoint = args[1];
                boundingVectors = this.buildBoundingVectors(minPoint, maxPoint);
                frustumPlanes = args[2];
            }
            for (var p = 0; p < 6; p++) {
                for (var i = 0; i < 8; i++) {
                    if (frustumPlanes[p].dotCoordinate(boundingVectors[i]) < 0) {
                        return false;
                    }
                }
            }
            return true;
        };
        BoundingRegionUtils.isAABBIntersectFrustum = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var boundingVectors = null, frustumPlanes = null;
            if (args.length === 2) {
                boundingVectors = args[0];
                frustumPlanes = args[1];
            }
            else if (args.length === 3) {
                var minPoint = args[0], maxPoint = args[1];
                boundingVectors = this.buildBoundingVectors(minPoint, maxPoint);
                frustumPlanes = args[2];
            }
            for (var p = 0; p < 6; p++) {
                var inCount = 8;
                for (var i = 0; i < 8; i++) {
                    if (frustumPlanes[p].dotCoordinate(boundingVectors[i]) < 0) {
                        inCount--;
                    }
                    else {
                        break;
                    }
                }
                if (inCount === 0) {
                    return false;
                }
            }
            return true;
        };
        BoundingRegionUtils.buildBoundingVectors = function (minPoint, maxPoint) {
            var boundingVectors = [];
            boundingVectors.push(minPoint.clone());
            boundingVectors.push(maxPoint.clone());
            boundingVectors.push(minPoint.clone());
            boundingVectors[2].x = maxPoint.x;
            boundingVectors.push(minPoint.clone());
            boundingVectors[3].y = maxPoint.y;
            boundingVectors.push(minPoint.clone());
            boundingVectors[4].z = maxPoint.z;
            boundingVectors.push(maxPoint.clone());
            boundingVectors[5].z = minPoint.z;
            boundingVectors.push(maxPoint.clone());
            boundingVectors[6].x = minPoint.x;
            boundingVectors.push(maxPoint.clone());
            boundingVectors[7].y = minPoint.y;
            return boundingVectors;
        };
        return BoundingRegionUtils;
    }());
    wd.BoundingRegionUtils = BoundingRegionUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Shape = (function () {
        function Shape() {
            this.center = wd.Vector3.create(0, 0, 0);
        }
        Shape.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Shape.prototype.isBoxAndSphereIntersected = function (box, sphere) {
            var sphereCenter = sphere.center, sphereRadius = sphere.radius;
            return sphereCenter.distanceToSquared(box.closestPointTo(sphereCenter)) < Math.pow(sphereRadius, 2);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Shape.prototype, "center", void 0);
        return Shape;
    }());
    wd.Shape = Shape;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var AABBShape = (function (_super) {
        __extends(AABBShape, _super);
        function AABBShape() {
            _super.apply(this, arguments);
            this.halfExtents = wd.Vector3.create(0.5, 0.5, 0.5);
        }
        AABBShape.create = function () {
            var obj = new this();
            return obj;
        };
        AABBShape.getCenter = function (min, max) {
            return wd.Vector3.create().add2(max, min).scale(0.5);
        };
        AABBShape.getHalfExtents = function (min, max) {
            return wd.Vector3.create().sub2(max, min).scale(0.5);
        };
        AABBShape.prototype.setMinMax = function (min, max) {
            this.center = AABBShape.getCenter(min, max);
            this.halfExtents = AABBShape.getHalfExtents(min, max);
        };
        AABBShape.prototype.getMin = function () {
            return this.center.clone().sub(this.halfExtents);
        };
        AABBShape.prototype.getMax = function () {
            return this.center.clone().add(this.halfExtents);
        };
        AABBShape.prototype.setFromShapeParam = function (center, halfExtents) {
            this.center = center;
            this.halfExtents = halfExtents;
        };
        AABBShape.prototype.setFromPoints = function (points) {
            var self = this, min = this._getEmptyMin(), max = this._getEmptyMax();
            wd.GeometryUtils.iterateThreeComponent(points, function (point) {
                self._expandByPoint(point, min, max);
            });
            this.setMinMax(min, max);
            return this;
        };
        AABBShape.prototype.setFromTransformedAABB = function (aabb, matrix) {
            var bc = this.center, br = this.halfExtents, ac = aabb.center.values, ar = aabb.halfExtents.values, m = matrix.values, mx0 = m[0], mx1 = m[4], mx2 = m[8], my0 = m[1], my1 = m[5], my2 = m[9], mz0 = m[2], mz1 = m[6], mz2 = m[10], mx0a = Math.abs(mx0), mx1a = Math.abs(mx1), mx2a = Math.abs(mx2), my0a = Math.abs(my0), my1a = Math.abs(my1), my2a = Math.abs(my2), mz0a = Math.abs(mz0), mz1a = Math.abs(mz1), mz2a = Math.abs(mz2);
            bc.set(m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2], m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2], m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2]);
            br.set(mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2], my0a * ar[0] + my1a * ar[1] + my2a * ar[2], mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2]);
        };
        AABBShape.prototype.setFromTranslationAndScale = function (aabb, matrix) {
            var translation = matrix.getTranslation(), scale = matrix.getScale();
            this.center = aabb.center.clone().add(translation);
            this.halfExtents = aabb.halfExtents.clone().mul(scale);
        };
        AABBShape.prototype.setFromObject = function (entityObject) {
            var modelMatrix = entityObject.transform.localToWorldMatrix, vertices = wd.ColliderUtils.getVertices(entityObject), self = this, min = this._getEmptyMin(), max = this._getEmptyMax();
            wd.GeometryUtils.iterateThreeComponent(vertices, function (point) {
                point.applyMatrix4(modelMatrix);
                self._expandByPoint(point, min, max);
            });
            this.setMinMax(min, max);
        };
        AABBShape.prototype.isIntersectWithBox = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var aMax = this.getMax(), aMin = this.getMin(), bMax = null, bMin = null;
            if (args.length === 1) {
                var shape = args[0];
                bMin = shape.getMin();
                bMax = shape.getMax();
            }
            else if (args.length === 2) {
                bMin = args[0];
                bMax = args[1];
            }
            return (aMin.x <= bMax.x) && (aMax.x >= bMin.x) &&
                (aMin.y <= bMax.y) && (aMax.y >= bMin.y) &&
                (aMin.z <= bMax.z) && (aMax.z >= bMin.z);
        };
        AABBShape.prototype.isIntersectWithSphere = function (shape) {
            return this.isBoxAndSphereIntersected(this, shape);
        };
        AABBShape.prototype.isIntersectWithRay = function (ray) {
            return ray.isIntersectWithAABB(this);
        };
        AABBShape.prototype.closestPointTo = function (point) {
            var min = this.getMin(), max = this.getMax(), resultPoint = wd.Vector3.create();
            if (point.x < min.x) {
                resultPoint.x = min.x;
            }
            else if (point.x > max.x) {
                resultPoint.x = max.x;
            }
            else {
                resultPoint.x = point.x;
            }
            if (point.y < min.y) {
                resultPoint.y = min.y;
            }
            else if (point.y > max.y) {
                resultPoint.y = max.y;
            }
            else {
                resultPoint.y = point.y;
            }
            if (point.z < min.z) {
                resultPoint.z = min.z;
            }
            else if (point.z > max.z) {
                resultPoint.z = max.z;
            }
            else {
                resultPoint.z = point.z;
            }
            return resultPoint;
        };
        AABBShape.prototype.containPoint = function (point) {
            var min = this.getMin(), max = this.getMax();
            for (var i = 0; i < 3; ++i) {
                if (point.values[i] < min.values[i] || point.values[i] > max.values[i]) {
                    return false;
                }
            }
            return true;
        };
        AABBShape.prototype._getEmptyMin = function () {
            return wd.Vector3.create(Infinity, Infinity, Infinity);
        };
        AABBShape.prototype._getEmptyMax = function () {
            return wd.Vector3.create(-Infinity, -Infinity, -Infinity);
        };
        AABBShape.prototype._expandByPoint = function (point, min, max) {
            min.min(point);
            max.max(point);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], AABBShape.prototype, "halfExtents", void 0);
        __decorate([
            wd.require(function (entityObject) {
                var vertices = wd.ColliderUtils.getVertices(entityObject);
                wd.assert(vertices && vertices.length > 0, wd.Log.info.FUNC_MUST_DEFINE("vertices"));
            })
        ], AABBShape.prototype, "setFromObject", null);
        return AABBShape;
    }(wd.Shape));
    wd.AABBShape = AABBShape;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SphereShape = (function (_super) {
        __extends(SphereShape, _super);
        function SphereShape() {
            _super.apply(this, arguments);
            this.radius = 1;
        }
        SphereShape.create = function () {
            var obj = new this();
            return obj;
        };
        SphereShape.prototype.setFromShapeParam = function (center, radius) {
            this.center = center;
            this.radius = radius;
        };
        SphereShape.prototype.setFromPoints = function (points) {
            var aabb = wd.AABBShape.create();
            this.center = aabb.setFromPoints(points).center;
            this.radius = this._findMaxDistanceOfPointsToCenter(points);
        };
        SphereShape.prototype.setFromTranslationAndScale = function (sphere, matrix) {
            var translation = matrix.getTranslation(), scale = matrix.getScale();
            this.center = sphere.center.clone().add(translation);
            this.radius = sphere.radius * Math.max(scale.x, scale.y, scale.z);
        };
        SphereShape.prototype.isIntersectWithSphere = function (shape) {
            var radiusSum = this.radius + shape.radius;
            return shape.center.distanceToSquared(this.center) <= (Math.pow(radiusSum, 2));
        };
        SphereShape.prototype.isIntersectWithBox = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var shape = null;
            if (args.length === 1) {
                shape = args[0];
            }
            else if (args.length === 2) {
                var min = args[0], max = args[1];
                shape = wd.AABBShape.create();
                shape.setMinMax(min, max);
            }
            return this.isBoxAndSphereIntersected(shape, this);
        };
        SphereShape.prototype.isIntersectWithRay = function (ray) {
            return ray.isIntersectWithSphere(this);
        };
        SphereShape.prototype.containPoint = function (point) {
            return point.distanceToSquared(this.center) <= (Math.pow(this.radius, 2));
        };
        SphereShape.prototype._findMaxDistanceOfPointsToCenter = function (points) {
            var maxRadiusSq = 0, center = this.center;
            wd.GeometryUtils.iterateThreeComponent(points, function (point) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(point));
            });
            return Math.sqrt(maxRadiusSq);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], SphereShape.prototype, "radius", void 0);
        return SphereShape;
    }(wd.Shape));
    wd.SphereShape = SphereShape;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EColliderType) {
        EColliderType[EColliderType["BOX"] = "box"] = "BOX";
        EColliderType[EColliderType["SPHERE"] = "sphere"] = "SPHERE";
    })(wd.EColliderType || (wd.EColliderType = {}));
    var EColliderType = wd.EColliderType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ColliderUtils = (function () {
        function ColliderUtils() {
        }
        ColliderUtils.getVertices = function (entityObject) {
            if (!entityObject.hasComponent(wd.Geometry)) {
                if (entityObject.hasTag(wd.EWDTag.CONTAINER)) {
                    return entityObject.getChild(0).getComponent(wd.Geometry).vertices;
                }
                return null;
            }
            return entityObject.getComponent(wd.Geometry).geometryData.vertices;
        };
        __decorate([
            wd.require(function (entityObject) {
                wd.describe("if entityObject is EWDTag.CONTAINER", function () {
                    wd.it("children->vertices should has data", function () {
                        var firstChild = entityObject.getChild(0);
                        if (!firstChild) {
                            return;
                        }
                        var firstChildVertices = firstChild.getComponent(wd.Geometry).vertices;
                        wd.expect(firstChildVertices).exist;
                        wd.expect(firstChildVertices.length).greaterThan(0);
                    });
                    wd.it("first child->vertices.length should === second child->vertices.length", function () {
                        var firstChild = entityObject.getChild(0), secondChild = entityObject.getChild(1);
                        if (!firstChild || !secondChild) {
                            return;
                        }
                        var firstChildVertices = firstChild.getComponent(wd.Geometry).vertices, secondChildVertices = secondChild.getComponent(wd.Geometry).vertices;
                        wd.expect(firstChildVertices).exist;
                        wd.expect(secondChildVertices).exist;
                        wd.expect(firstChildVertices.length === secondChildVertices.length).true;
                    });
                }, function () {
                    return !entityObject.hasComponent(wd.Geometry) && entityObject.hasTag(wd.EWDTag.CONTAINER);
                });
            })
        ], ColliderUtils, "getVertices", null);
        return ColliderUtils;
    }());
    wd.ColliderUtils = ColliderUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Light = (function (_super) {
        __extends(Light, _super);
        function Light() {
            _super.apply(this, arguments);
            this._shadowMapWidth = null;
            this._shadowMapHeight = null;
            this.color = wd.Color.create("#ffffff");
            this.castShadow = false;
            this.shadowCameraNear = 0.1;
            this.shadowCameraFar = 5000;
            this.shadowBias = wd.ShaderChunk.NULL;
            this.shadowDarkness = 0;
        }
        Object.defineProperty(Light.prototype, "position", {
            get: function () {
                return this.entityObject.transform.position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Light.prototype, "shadowMapWidth", {
            get: function () {
                var maxCubemapTextureSize = wd.GPUDetector.getInstance().maxCubemapTextureSize;
                if (!this._shadowMapWidth || this._shadowMapWidth > maxCubemapTextureSize) {
                    return maxCubemapTextureSize;
                }
                return this._shadowMapWidth;
            },
            set: function (shadowMapWidth) {
                this._shadowMapWidth = shadowMapWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Light.prototype, "shadowMapHeight", {
            get: function () {
                var maxCubemapTextureSize = wd.GPUDetector.getInstance().maxCubemapTextureSize;
                if (!this._shadowMapHeight || this._shadowMapHeight > maxCubemapTextureSize) {
                    return maxCubemapTextureSize;
                }
                return this._shadowMapHeight;
            },
            set: function (shadowMapHeight) {
                this._shadowMapHeight = shadowMapHeight;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Light.prototype, "shadowMapWidth", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Light.prototype, "shadowMapHeight", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Light.prototype, "color", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Light.prototype, "castShadow", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Light.prototype, "shadowCameraNear", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Light.prototype, "shadowCameraFar", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Light.prototype, "shadowBias", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Light.prototype, "shadowDarkness", void 0);
        return Light;
    }(wd.Component));
    wd.Light = Light;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var AmbientLight = (function (_super) {
        __extends(AmbientLight, _super);
        function AmbientLight() {
            _super.apply(this, arguments);
        }
        AmbientLight.create = function () {
            var obj = new this();
            return obj;
        };
        AmbientLight.type = "ambientLight";
        return AmbientLight;
    }(wd.Light));
    wd.AmbientLight = AmbientLight;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SourceLight = (function (_super) {
        __extends(SourceLight, _super);
        function SourceLight() {
            _super.apply(this, arguments);
            this.intensity = 1;
        }
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], SourceLight.prototype, "intensity", void 0);
        return SourceLight;
    }(wd.Light));
    wd.SourceLight = SourceLight;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DirectionLight = (function (_super) {
        __extends(DirectionLight, _super);
        function DirectionLight() {
            _super.apply(this, arguments);
            this.shadowCameraLeft = -1000;
            this.shadowCameraRight = 1000;
            this.shadowCameraTop = 1000;
            this.shadowCameraBottom = -1000;
        }
        DirectionLight.create = function () {
            var obj = new this();
            return obj;
        };
        DirectionLight.type = "directionLight";
        DirectionLight.defaultPosition = wd.Vector3.create(0, 0, 1);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DirectionLight.prototype, "shadowCameraLeft", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DirectionLight.prototype, "shadowCameraRight", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DirectionLight.prototype, "shadowCameraTop", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DirectionLight.prototype, "shadowCameraBottom", void 0);
        return DirectionLight;
    }(wd.SourceLight));
    wd.DirectionLight = DirectionLight;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            _super.apply(this, arguments);
            this._rangeLevel = null;
            this._attenuation = wd.Attenuation.create();
        }
        PointLight.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(PointLight.prototype, "rangeLevel", {
            get: function () {
                return this._rangeLevel;
            },
            set: function (rangeLevel) {
                this._rangeLevel = rangeLevel;
                this._attenuation.rangeLevel = this._rangeLevel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "range", {
            get: function () {
                return this._attenuation.range;
            },
            set: function (range) {
                this._attenuation.range = range;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "constant", {
            get: function () {
                return this._attenuation.constant;
            },
            set: function (constant) {
                this._attenuation.constant = constant;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "linear", {
            get: function () {
                return this._attenuation.linear;
            },
            set: function (linear) {
                this._attenuation.linear = linear;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointLight.prototype, "quadratic", {
            get: function () {
                return this._attenuation.quadratic;
            },
            set: function (quadratic) {
                this._attenuation.quadratic = quadratic;
            },
            enumerable: true,
            configurable: true
        });
        PointLight.type = "pointLight";
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PointLight.prototype, "rangeLevel", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PointLight.prototype, "range", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PointLight.prototype, "constant", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PointLight.prototype, "linear", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], PointLight.prototype, "quadratic", null);
        return PointLight;
    }(wd.SourceLight));
    wd.PointLight = PointLight;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Attenuation = (function () {
        function Attenuation() {
            this._constant = 1;
            this._range = null;
            this._linear = 0;
            this._quadratic = 0;
            this._rangeLevel = 0;
        }
        Attenuation.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(Attenuation.prototype, "constant", {
            get: function () {
                return this._constant;
            },
            set: function (constant) {
                this._constant = constant;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attenuation.prototype, "range", {
            get: function () {
                return this._range;
            },
            set: function (range) {
                this._range = range;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attenuation.prototype, "linear", {
            get: function () {
                return this._linear;
            },
            set: function (linear) {
                this._linear = linear;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attenuation.prototype, "quadratic", {
            get: function () {
                return this._quadratic;
            },
            set: function (quadratic) {
                this._quadratic = quadratic;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Attenuation.prototype, "rangeLevel", {
            get: function () {
                return this._rangeLevel;
            },
            set: function (rangeLevel) {
                if (rangeLevel) {
                    this._rangeLevel = rangeLevel;
                    this.setByRangeLevel();
                }
            },
            enumerable: true,
            configurable: true
        });
        Attenuation.prototype.setByRangeLevel = function () {
            switch (this._rangeLevel) {
                case 0:
                    this._range = 7;
                    this._linear = 0.7;
                    this._quadratic = 1.8;
                    break;
                case 1:
                    this._range = 13;
                    this._linear = 0.35;
                    this._quadratic = 0.44;
                    break;
                case 2:
                    this._range = 20;
                    this._linear = 0.22;
                    this._quadratic = 0.20;
                    break;
                case 3:
                    this._range = 32;
                    this._linear = 0.14;
                    this._quadratic = 0.07;
                    break;
                case 4:
                    this._range = 50;
                    this._linear = 0.09;
                    this._quadratic = 0.032;
                    break;
                case 5:
                    this._range = 65;
                    this._linear = 0.07;
                    this._quadratic = 0.017;
                    break;
                case 6:
                    this._range = 100;
                    this._linear = 0.045;
                    this._quadratic = 0.0075;
                    break;
                case 7:
                    this._range = 160;
                    this._linear = 0.027;
                    this._quadratic = 0.0028;
                    break;
                case 8:
                    this._range = 200;
                    this._linear = 0.022;
                    this._quadratic = 0.0019;
                    break;
                case 9:
                    this._range = 325;
                    this._linear = 0.014;
                    this._quadratic = 0.0007;
                    break;
                case 10:
                    this._range = 600;
                    this._linear = 0.007;
                    this._quadratic = 0.0002;
                    break;
                case 11:
                    this._range = 3250;
                    this._linear = 0.0014;
                    this._quadratic = 0.000007;
                    break;
                default:
                    wd.Log.error(true, "over light range");
                    break;
            }
        };
        return Attenuation;
    }());
    wd.Attenuation = Attenuation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ELightModel) {
        ELightModel[ELightModel["PHONG"] = "PHONG"] = "PHONG";
        ELightModel[ELightModel["BLINN"] = "BLINN"] = "BLINN";
        ELightModel[ELightModel["LAMBERT"] = "LAMBERT"] = "LAMBERT";
        ELightModel[ELightModel["CONSTANT"] = "CONSTANT"] = "CONSTANT";
    })(wd.ELightModel || (wd.ELightModel = {}));
    var ELightModel = wd.ELightModel;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RenderTargetRenderer = (function () {
        function RenderTargetRenderer(renderTargetTexture) {
            this.texture = null;
            this.frameBufferOperator = null;
            this._isRenderListEmpty = false;
            this._renderCount = 0;
            this.texture = renderTargetTexture;
        }
        RenderTargetRenderer.prototype.initWhenCreate = function () {
            this.frameBufferOperator = wd.FrameBuffer.create(this.texture.width, this.texture.height);
        };
        RenderTargetRenderer.prototype.init = function () {
            this.texture.createEmptyTexture();
            this.initFrameBuffer();
        };
        RenderTargetRenderer.prototype.needRender = function () {
            var renderRate = this.texture.renderRate, needRender = false;
            if (renderRate === 0) {
                needRender = this._shouldRenderOnce();
            }
            else {
                needRender = this._shouldRenderAtRate(renderRate);
            }
            this._renderCount++;
            return needRender;
        };
        RenderTargetRenderer.prototype.render = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var renderer = args[0], renderList = this.getRenderList();
            this._isRenderListEmpty = this.isRenderListEmpty(renderList);
            this.beforeRender();
            if (args.length === 1) {
                this.renderFrameBufferTexture(renderList, renderer);
            }
            else {
                var camera = args[1];
                this.renderFrameBufferTexture(renderList, renderer, camera);
            }
            this.afterRender();
        };
        RenderTargetRenderer.prototype.dispose = function () {
            this.frameBufferOperator.dispose();
            this.disposeFrameBuffer();
            this.texture.dispose();
        };
        RenderTargetRenderer.prototype.beforeRender = function () {
        };
        RenderTargetRenderer.prototype.afterRender = function () {
        };
        RenderTargetRenderer.prototype.isRenderListEmptyWhenRender = function () {
            return this._isRenderListEmpty;
        };
        RenderTargetRenderer.prototype._shouldRenderOnce = function () {
            return this._renderCount === 0;
        };
        RenderTargetRenderer.prototype._shouldRenderAtRate = function (renderRate) {
            var renderCount = this._renderCount;
            if (renderCount === 0) {
                return true;
            }
            if (renderCount === renderRate) {
                this._renderCount = 0;
                return true;
            }
            return false;
        };
        __decorate([
            wd.require(function () {
                wd.assert(this.texture.renderRate >= 0, wd.Log.info.FUNC_SHOULD("renderTargetTexture->renderRate", ">= 0, but actual is " + this.texture.renderRate));
            }),
            wd.virtual
        ], RenderTargetRenderer.prototype, "needRender", null);
        __decorate([
            wd.virtual
        ], RenderTargetRenderer.prototype, "beforeRender", null);
        __decorate([
            wd.virtual
        ], RenderTargetRenderer.prototype, "afterRender", null);
        __decorate([
            wd.ensure(function (isRenderListEmpty) {
                if (isRenderListEmpty) {
                    wd.assert(this.isRenderListEmpty(this.getRenderList()), wd.Log.info.FUNC_SHOULD("renderList", "be empty"));
                }
            })
        ], RenderTargetRenderer.prototype, "isRenderListEmptyWhenRender", null);
        return RenderTargetRenderer;
    }());
    wd.RenderTargetRenderer = RenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ProceduralRenderTargetRenderer = (function (_super) {
        __extends(ProceduralRenderTargetRenderer, _super);
        function ProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
            this.frameBuffer = null;
            this._indexBuffer = null;
            this._vertexBuffer = null;
            this._shader = null;
            this._vaoManager = !!wd.GPUDetector.getInstance().extensionVAO ? wd.VAOManager.create() : null;
        }
        ProceduralRenderTargetRenderer.prototype.init = function () {
            _super.prototype.init.call(this);
            this._initBuffer();
            this._shader = this.createShader();
            this._shader.init();
            this._vaoManager && this._vaoManager.init();
        };
        ProceduralRenderTargetRenderer.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._indexBuffer.dispose();
            this._vertexBuffer.dispose();
            this._shader.dispose();
            this._vaoManager && this._vaoManager.dispose();
        };
        ProceduralRenderTargetRenderer.prototype.initFrameBuffer = function () {
            var frameBuffer = this.frameBufferOperator, gl = wd.DeviceManager.getInstance().gl;
            this.frameBuffer = frameBuffer.createFrameBuffer();
            frameBuffer.bindFrameBuffer(this.frameBuffer);
            frameBuffer.attachTexture(gl.TEXTURE_2D, this.texture.glTexture);
            frameBuffer.check();
            frameBuffer.unBindAll();
        };
        ProceduralRenderTargetRenderer.prototype.renderFrameBufferTexture = function (renderList, renderer) {
            this.frameBufferOperator.bindFrameBuffer(this.frameBuffer);
            this.texture.bindToUnit(0);
            this.frameBufferOperator.setViewport();
            renderer.addCommand(this._createRenderCommand());
            renderer.clear();
            renderer.webglState = wd.BasicState.create();
            renderer.render();
            this.frameBufferOperator.unBindFrameBuffer();
            this.frameBufferOperator.restoreViewport();
        };
        ProceduralRenderTargetRenderer.prototype.disposeFrameBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.deleteFramebuffer(this.frameBuffer);
        };
        ProceduralRenderTargetRenderer.prototype.getRenderList = function () {
            return null;
        };
        ProceduralRenderTargetRenderer.prototype.isRenderListEmpty = function () {
            return false;
        };
        ProceduralRenderTargetRenderer.prototype._initBuffer = function () {
            if (wd.BufferTable.hasBuffer(wd.BufferTableKey.PROCEDURAL_VERTEX)) {
                this._vertexBuffer = wd.BufferTable.getBuffer(wd.BufferTableKey.PROCEDURAL_VERTEX);
            }
            else {
                this._vertexBuffer = wd.ArrayBuffer.create([
                    1, 1,
                    -1, 1,
                    -1, -1,
                    1, -1
                ], 2, wd.EBufferType.FLOAT);
                wd.BufferTable.addBuffer(wd.BufferTableKey.PROCEDURAL_VERTEX, this._vertexBuffer);
            }
            if (wd.BufferTable.hasBuffer(wd.BufferTableKey.PROCEDURAL_INDEX)) {
                this._indexBuffer = wd.BufferTable.getBuffer(wd.BufferTableKey.PROCEDURAL_INDEX);
            }
            else {
                this._indexBuffer = wd.ElementBuffer.create([
                    0, 1, 2,
                    0, 2, 3
                ], wd.EBufferType.UNSIGNED_SHORT);
                wd.BufferTable.addBuffer(wd.BufferTableKey.PROCEDURAL_INDEX, this._indexBuffer);
            }
        };
        ProceduralRenderTargetRenderer.prototype._createRenderCommand = function () {
            var command = wd.ProceduralCommand.create();
            command.vertexBuffer = this._vertexBuffer;
            command.indexBuffer = this._indexBuffer;
            command.shader = this._shader;
            command.vaoManager = this._vaoManager;
            return command;
        };
        return ProceduralRenderTargetRenderer;
    }(wd.RenderTargetRenderer));
    wd.ProceduralRenderTargetRenderer = ProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomProceduralRenderTargetRenderer = (function (_super) {
        __extends(CustomProceduralRenderTargetRenderer, _super);
        function CustomProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        CustomProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        CustomProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CustomProceduralShader.create(this.texture);
            shader.addLib(wd.CustomProceduralShaderLib.create(this.texture));
            return shader;
        };
        return CustomProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.CustomProceduralRenderTargetRenderer = CustomProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonRenderTargetRenderer = (function (_super) {
        __extends(CommonRenderTargetRenderer, _super);
        function CommonRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        return CommonRenderTargetRenderer;
    }(wd.RenderTargetRenderer));
    wd.CommonRenderTargetRenderer = CommonRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDRenderTargetRenderer = (function (_super) {
        __extends(TwoDRenderTargetRenderer, _super);
        function TwoDRenderTargetRenderer() {
            _super.apply(this, arguments);
            this.frameBuffer = null;
            this._renderBuffer = null;
            this._lastCamera = null;
        }
        TwoDRenderTargetRenderer.prototype.isNeedCreateCamera = function () {
            return true;
        };
        TwoDRenderTargetRenderer.prototype.createCamera = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return null;
        };
        TwoDRenderTargetRenderer.prototype.setFrameBufferTexture = function () {
            var frameBuffer = this.frameBufferOperator, gl = wd.DeviceManager.getInstance().gl;
            frameBuffer.attachTexture(gl.TEXTURE_2D, this.texture.glTexture, wd.EFrameBufferAttachType.COLOR_ATTACHMENT0);
        };
        TwoDRenderTargetRenderer.prototype.createAndAttachDepthBuffer = function () {
            var frameBuffer = this.frameBufferOperator, gl = wd.DeviceManager.getInstance().gl;
            this._renderBuffer = frameBuffer.createRenderBuffer();
            frameBuffer.attachRenderBuffer("DEPTH_ATTACHMENT", this._renderBuffer);
        };
        TwoDRenderTargetRenderer.prototype.deleteRenderBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.deleteRenderbuffer(this._renderBuffer);
        };
        TwoDRenderTargetRenderer.prototype.isRenderListEmpty = function (renderList) {
            return renderList.getCount() === 0;
        };
        TwoDRenderTargetRenderer.prototype.initFrameBuffer = function () {
            var frameBuffer = this.frameBufferOperator;
            this.frameBuffer = frameBuffer.createFrameBuffer();
            frameBuffer.bindFrameBuffer(this.frameBuffer);
            this.setFrameBufferTexture();
            this.createAndAttachDepthBuffer();
            frameBuffer.check();
            frameBuffer.unBindAll();
        };
        TwoDRenderTargetRenderer.prototype.renderFrameBufferTexture = function (renderList, renderer, camera) {
            var renderCamera = null;
            if (this.isRenderListEmptyWhenRender()) {
                return;
            }
            this.texture.bindToUnit(0);
            if (this.isNeedCreateCamera()) {
                renderCamera = this.createCamera(camera);
                if (this._lastCamera) {
                    this._lastCamera.dispose();
                }
                this._lastCamera = renderCamera;
            }
            else {
                renderCamera = camera;
            }
            this.beforeRenderFrameBufferTexture(renderCamera);
            this.frameBufferOperator.bindFrameBuffer(this.frameBuffer);
            this.frameBufferOperator.setViewport();
            renderList.forEach(function (child) {
                child.render(renderer, renderCamera);
            });
            renderer.clear();
            this.renderRenderer(renderer);
            this.frameBufferOperator.unBindFrameBuffer();
            this.frameBufferOperator.restoreViewport();
        };
        TwoDRenderTargetRenderer.prototype.disposeFrameBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.deleteFramebuffer(this.frameBuffer);
            this.deleteRenderBuffer();
        };
        __decorate([
            wd.virtual
        ], TwoDRenderTargetRenderer.prototype, "isNeedCreateCamera", null);
        __decorate([
            wd.virtual
        ], TwoDRenderTargetRenderer.prototype, "createCamera", null);
        __decorate([
            wd.virtual
        ], TwoDRenderTargetRenderer.prototype, "setFrameBufferTexture", null);
        __decorate([
            wd.virtual
        ], TwoDRenderTargetRenderer.prototype, "createAndAttachDepthBuffer", null);
        __decorate([
            wd.virtual
        ], TwoDRenderTargetRenderer.prototype, "deleteRenderBuffer", null);
        __decorate([
            wd.require(function (renderList, renderer, camera) {
                wd.assert(!!camera, wd.Log.info.FUNC_SHOULD("pass param->camera"));
            })
        ], TwoDRenderTargetRenderer.prototype, "renderFrameBufferTexture", null);
        return TwoDRenderTargetRenderer;
    }(wd.CommonRenderTargetRenderer));
    wd.TwoDRenderTargetRenderer = TwoDRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MirrorRenderTargetRenderer = (function (_super) {
        __extends(MirrorRenderTargetRenderer, _super);
        function MirrorRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        MirrorRenderTargetRenderer.create = function (mirrorTexture) {
            var obj = new this(mirrorTexture);
            obj.initWhenCreate();
            return obj;
        };
        MirrorRenderTargetRenderer.prototype.beforeRenderFrameBufferTexture = function (renderCamera) {
        };
        MirrorRenderTargetRenderer.prototype.getRenderList = function () {
            return this.texture.renderList;
        };
        MirrorRenderTargetRenderer.prototype.renderRenderer = function (renderer) {
            this._setSceneSide(wd.ESide.FRONT);
            renderer.webglState = wd.BasicState.create();
            renderer.render();
            this._setSceneSide(null);
        };
        MirrorRenderTargetRenderer.prototype.beforeRender = function () {
            if (this.isRenderListEmptyWhenRender()) {
                wd.Director.getInstance().scene.glslData.addChild(wd.EShaderGLSLData.MIRROR, {
                    isRenderListEmpty: true
                });
            }
            else {
                wd.Director.getInstance().scene.glslData.addChild(wd.EShaderGLSLData.MIRROR, {
                    isRenderListEmpty: false
                });
            }
        };
        MirrorRenderTargetRenderer.prototype.createCamera = function (camera) {
            var mirrorCameraComponent = null, plane = null, cameraComponent = camera.getComponent(wd.CameraController), mirrorCameraViewMatrix = null, projectionMatrix = null;
            plane = this.texture.getPlane();
            mirrorCameraViewMatrix =
                plane.getReflectionMatrix().applyMatrix(cameraComponent.worldToCameraMatrix);
            projectionMatrix = this._setClipPlane(mirrorCameraViewMatrix, cameraComponent.pMatrix, plane);
            mirrorCameraComponent = wd.PerspectiveCamera.create();
            mirrorCameraComponent.worldToCameraMatrix = mirrorCameraViewMatrix.clone();
            mirrorCameraComponent.pMatrix = projectionMatrix;
            return wd.GameObject.create().addComponent(wd.RenderTargetRendererCameraController.create(mirrorCameraComponent)).init();
        };
        MirrorRenderTargetRenderer.prototype._setSceneSide = function (side) {
            var scene = wd.Director.getInstance().scene;
            scene.side = side;
        };
        MirrorRenderTargetRenderer.prototype._setClipPlane = function (vMatrix, pMatrix, plane) {
            var projectionMatrix = pMatrix.clone(), q = wd.Vector4.create(), clipPlane = this._getClipPlaneInCameraSpace(vMatrix, plane), c = wd.Vector4.create();
            q.x = (Math.sign(clipPlane.x) + projectionMatrix.values[8]) / projectionMatrix.values[0];
            q.y = (Math.sign(clipPlane.y) + projectionMatrix.values[9]) / projectionMatrix.values[5];
            q.z = -1.0;
            q.w = (1.0 + projectionMatrix.values[10]) / projectionMatrix.values[14];
            c = clipPlane.multiplyScalar(2.0 / clipPlane.dot(q));
            projectionMatrix.values[2] = c.x;
            projectionMatrix.values[6] = c.y;
            projectionMatrix.values[10] = c.z + 1.0;
            projectionMatrix.values[14] = c.w;
            return projectionMatrix;
        };
        MirrorRenderTargetRenderer.prototype._getClipPlaneInCameraSpace = function (vMatrix, plane) {
            var clipPlane = wd.Vector4.create(), p = vMatrix.multiplyPoint(this.texture.getPosition()), n = vMatrix.clone().invert().transpose().multiplyPoint(plane.normal).normalize();
            clipPlane.set(n.x, n.y, n.z, -p.dot(n));
            return clipPlane;
        };
        return MirrorRenderTargetRenderer;
    }(wd.TwoDRenderTargetRenderer));
    wd.MirrorRenderTargetRenderer = MirrorRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RefractionRenderTargetRenderer = (function (_super) {
        __extends(RefractionRenderTargetRenderer, _super);
        function RefractionRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        RefractionRenderTargetRenderer.create = function (refractionTexture) {
            var obj = new this(refractionTexture);
            obj.initWhenCreate();
            return obj;
        };
        RefractionRenderTargetRenderer.prototype.beforeRenderFrameBufferTexture = function (renderCamera) {
        };
        RefractionRenderTargetRenderer.prototype.getRenderList = function () {
            return this.texture.renderList;
        };
        RefractionRenderTargetRenderer.prototype.renderRenderer = function (renderer) {
            renderer.webglState = wd.BasicState.create();
            renderer.render();
        };
        RefractionRenderTargetRenderer.prototype.beforeRender = function () {
            if (this.isRenderListEmptyWhenRender()) {
                wd.Director.getInstance().scene.glslData.addChild(wd.EShaderGLSLData.REFRACTION, {
                    isRenderListEmpty: true
                });
            }
            else {
                wd.Director.getInstance().scene.glslData.addChild(wd.EShaderGLSLData.REFRACTION, {
                    isRenderListEmpty: false
                });
            }
        };
        RefractionRenderTargetRenderer.prototype.isNeedCreateCamera = function () {
            return false;
        };
        return RefractionRenderTargetRenderer;
    }(wd.TwoDRenderTargetRenderer));
    wd.RefractionRenderTargetRenderer = RefractionRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDShadowMapRenderTargetRenderer = (function (_super) {
        __extends(TwoDShadowMapRenderTargetRenderer, _super);
        function TwoDShadowMapRenderTargetRenderer(shadowMap, light, layer) {
            _super.call(this, shadowMap);
            this._light = null;
            this._layer = null;
            this._shadowMapRendererUtils = null;
            this._light = light;
            this._layer = layer;
        }
        TwoDShadowMapRenderTargetRenderer.create = function (shadowMap, light, layer) {
            var obj = new this(shadowMap, light, layer);
            obj.initWhenCreate();
            return obj;
        };
        TwoDShadowMapRenderTargetRenderer.prototype.initWhenCreate = function () {
            this._shadowMapRendererUtils = wd.TwoDShadowMapRenderTargetRendererUtils.create(this._light, this.texture);
            _super.prototype.initWhenCreate.call(this);
        };
        TwoDShadowMapRenderTargetRenderer.prototype.beforeRenderFrameBufferTexture = function (renderCamera) {
            wd.Director.getInstance().scene.glslData.appendChild(wd.EShaderGLSLData.TWOD_SHADOWMAP, {
                camera: renderCamera.getComponent(wd.CameraController),
                light: this._light,
                isRenderListEmpty: false
            });
        };
        TwoDShadowMapRenderTargetRenderer.prototype.getRenderList = function () {
            return wd.Director.getInstance().scene.gameObjectScene.shadowManager.getShadowRenderListByLayer(this._layer);
        };
        TwoDShadowMapRenderTargetRenderer.prototype.renderRenderer = function (renderer) {
            this._shadowMapRendererUtils.renderRenderer(renderer);
        };
        TwoDShadowMapRenderTargetRenderer.prototype.beforeRender = function () {
            if (this.isRenderListEmptyWhenRender()) {
                wd.Director.getInstance().scene.glslData.appendChild(wd.EShaderGLSLData.TWOD_SHADOWMAP, {
                    isRenderListEmpty: true
                });
                return;
            }
            this._shadowMapRendererUtils.beforeRender(wd.EShaderTypeOfScene.BUILD_TWOD_SHADOWMAP);
        };
        TwoDShadowMapRenderTargetRenderer.prototype.afterRender = function () {
            if (this.isRenderListEmptyWhenRender()) {
                return;
            }
            this._shadowMapRendererUtils.afterRender();
        };
        TwoDShadowMapRenderTargetRenderer.prototype.createCamera = function () {
            var orthoCameraComponent = wd.OrthographicCamera.create(), light = this._light, camera = wd.GameObject.create();
            orthoCameraComponent.left = light.shadowCameraLeft;
            orthoCameraComponent.right = light.shadowCameraRight;
            orthoCameraComponent.top = light.shadowCameraTop;
            orthoCameraComponent.bottom = light.shadowCameraBottom;
            orthoCameraComponent.near = light.shadowCameraNear;
            orthoCameraComponent.far = light.shadowCameraFar;
            camera.addComponent(wd.RenderTargetRendererCameraController.create(orthoCameraComponent));
            camera.transform.translate(light.position);
            camera.transform.lookAt(0, 0, 0);
            camera.init();
            return camera;
        };
        TwoDShadowMapRenderTargetRenderer.prototype.setFrameBufferTexture = function () {
            if (wd.GPUDetector.getInstance().extensionDepthTexture) {
                var frameBuffer = this.frameBufferOperator, gl = wd.DeviceManager.getInstance().gl;
                frameBuffer.attachTexture(gl.TEXTURE_2D, this._createEmptyColorTexture(), wd.EFrameBufferAttachType.COLOR_ATTACHMENT0);
                frameBuffer.attachTexture(gl.TEXTURE_2D, this.texture.glTexture, wd.EFrameBufferAttachType.DEPTH_ATTACHMENT);
                return;
            }
            _super.prototype.setFrameBufferTexture.call(this);
        };
        TwoDShadowMapRenderTargetRenderer.prototype.createAndAttachDepthBuffer = function () {
            if (wd.GPUDetector.getInstance().extensionDepthTexture) {
                return;
            }
            _super.prototype.createAndAttachDepthBuffer.call(this);
        };
        TwoDShadowMapRenderTargetRenderer.prototype.deleteRenderBuffer = function () {
            if (wd.GPUDetector.getInstance().extensionDepthTexture) {
                return;
            }
            _super.prototype.deleteRenderBuffer.call(this);
        };
        TwoDShadowMapRenderTargetRenderer.prototype._createEmptyColorTexture = function () {
            var gl = wd.DeviceManager.getInstance().gl, colorTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, colorTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.texture.width, this.texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            return colorTexture;
        };
        return TwoDShadowMapRenderTargetRenderer;
    }(wd.TwoDRenderTargetRenderer));
    wd.TwoDShadowMapRenderTargetRenderer = TwoDShadowMapRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapRenderTargetRenderer = (function (_super) {
        __extends(CubemapRenderTargetRenderer, _super);
        function CubemapRenderTargetRenderer() {
            _super.apply(this, arguments);
            this._frameBufferList = wdCb.Collection.create();
            this._renderBufferList = wdCb.Collection.create();
            this._lastCameraList = null;
            this._lastPosition = null;
        }
        CubemapRenderTargetRenderer.prototype.renderRenderer = function (renderer) {
            renderer.webglState = wd.BasicState.create();
            renderer.render();
        };
        CubemapRenderTargetRenderer.prototype.beforeRenderFrameBufferTexture = function (renderCamera) {
        };
        CubemapRenderTargetRenderer.prototype.initFrameBuffer = function () {
            var frameBufferOperator = this.frameBufferOperator, gl = wd.DeviceManager.getInstance().gl;
            for (var i = 0; i < 6; i++) {
                var frameBuffer = frameBufferOperator.createFrameBuffer(), renderBuffer = frameBufferOperator.createRenderBuffer();
                this._frameBufferList.addChild(frameBuffer);
                this._renderBufferList.addChild(renderBuffer);
                frameBufferOperator.bindFrameBuffer(frameBuffer);
                frameBufferOperator.attachTexture(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.texture.glTexture);
                frameBufferOperator.attachRenderBuffer("DEPTH_ATTACHMENT", renderBuffer);
                frameBufferOperator.check();
            }
            frameBufferOperator.unBindAll();
        };
        CubemapRenderTargetRenderer.prototype.renderFrameBufferTexture = function (renderList, renderer, camera) {
            var renderCamera = null, faceRenderList = null, newCameraList = null, position = null, isNeedCreateCamera = null;
            if (this.isRenderListEmptyWhenRender()) {
                return;
            }
            this.texture.bindToUnit(0);
            position = this.getPosition();
            isNeedCreateCamera = this._isNeedCreateCamera(position);
            if (isNeedCreateCamera) {
                newCameraList = wdCb.Collection.create();
            }
            for (var i = 0; i < 6; i++) {
                faceRenderList = renderList.getChild(this._convertIndexToFaceKey(i));
                if (this._isEmpty(faceRenderList)) {
                    continue;
                }
                if (isNeedCreateCamera) {
                    renderCamera = this.createCamera(i);
                    newCameraList.addChild(renderCamera);
                }
                else {
                    renderCamera = this._lastCameraList.getChild(i);
                }
                this.beforeRenderFrameBufferTexture(renderCamera);
                this.frameBufferOperator.bindFrameBuffer(this._frameBufferList.getChild(i));
                this.frameBufferOperator.setViewport();
                faceRenderList.forEach(function (child) {
                    child.render(renderer, renderCamera);
                });
                renderer.clear();
                this.renderRenderer(renderer);
            }
            if (isNeedCreateCamera) {
                if (this._lastCameraList) {
                    this._lastCameraList.forEach(function (camera) {
                        camera.dispose();
                    });
                }
                this._lastCameraList = newCameraList;
                this._lastPosition = position;
            }
            this.frameBufferOperator.unBindFrameBuffer();
            this.frameBufferOperator.restoreViewport();
        };
        CubemapRenderTargetRenderer.prototype.disposeFrameBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            this._frameBufferList.forEach(function (buffer) { return gl.deleteFramebuffer(buffer); });
            this._renderBufferList.forEach(function (buffer) { return gl.deleteRenderbuffer(buffer); });
        };
        CubemapRenderTargetRenderer.prototype.createCamera = function (index) {
            var cubeCameraComponent = wd.PerspectiveCamera.create(), camera = wd.GameObject.create(), pos = this.getPosition();
            cubeCameraComponent.fovy = 90;
            this.setCamera(cubeCameraComponent);
            camera.addComponent(wd.RenderTargetRendererCameraController.create(cubeCameraComponent));
            camera.transform.translate(pos);
            this._lookAtFace(camera, pos, index);
            camera.init();
            return camera;
        };
        CubemapRenderTargetRenderer.prototype.isRenderListEmpty = function (renderList) {
            var _this = this;
            var isEmpty = true;
            renderList.forEach(function (faceRenderList) {
                if (!_this._isEmpty(faceRenderList)) {
                    isEmpty = false;
                    return wdCb.$BREAK;
                }
            }, this);
            return isEmpty;
        };
        CubemapRenderTargetRenderer.prototype._isEmpty = function (faceRenderList) {
            if (faceRenderList === void 0 || null) {
                return true;
            }
            return faceRenderList.getCount() === 0;
        };
        CubemapRenderTargetRenderer.prototype._convertIndexToFaceKey = function (index) {
            var face = null;
            switch (index) {
                case 0:
                    face = "px";
                    break;
                case 1:
                    face = "nx";
                    break;
                case 2:
                    face = "py";
                    break;
                case 3:
                    face = "ny";
                    break;
                case 4:
                    face = "pz";
                    break;
                case 5:
                    face = "nz";
                    break;
                default:
                    break;
            }
            return face;
        };
        CubemapRenderTargetRenderer.prototype._lookAtFace = function (camera, position, index) {
            switch (index) {
                case 0:
                    camera.transform.lookAt(position.x + 1, position.y, position.z, 0, -1, 0);
                    break;
                case 1:
                    camera.transform.lookAt(position.x - 1, position.y, position.z, 0, -1, 0);
                    break;
                case 2:
                    camera.transform.lookAt(position.x, position.y + 1, position.z, 0, 0, 1);
                    break;
                case 3:
                    camera.transform.lookAt(position.x, position.y - 1, position.z, 0, 0, -1);
                    break;
                case 4:
                    camera.transform.lookAt(position.x, position.y, position.z + 1, 0, -1, 0);
                    break;
                case 5:
                    camera.transform.lookAt(position.x, position.y, position.z - 1, 0, -1, 0);
                    break;
                default:
                    break;
            }
        };
        CubemapRenderTargetRenderer.prototype._isNeedCreateCamera = function (position) {
            if (this._lastPosition === null || this._lastCameraList === null || this._lastCameraList.getCount() === 0) {
                return true;
            }
            return !position.isEqual(this._lastPosition);
        };
        __decorate([
            wd.virtual
        ], CubemapRenderTargetRenderer.prototype, "renderRenderer", null);
        __decorate([
            wd.virtual
        ], CubemapRenderTargetRenderer.prototype, "beforeRenderFrameBufferTexture", null);
        __decorate([
            wd.require(function (renderList, renderer, camera) {
                wd.assert(!!camera, wd.Log.info.FUNC_SHOULD("pass param->camera"));
            })
        ], CubemapRenderTargetRenderer.prototype, "renderFrameBufferTexture", null);
        return CubemapRenderTargetRenderer;
    }(wd.CommonRenderTargetRenderer));
    wd.CubemapRenderTargetRenderer = CubemapRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapShadowMapRenderTargetRenderer = (function (_super) {
        __extends(CubemapShadowMapRenderTargetRenderer, _super);
        function CubemapShadowMapRenderTargetRenderer(shadowMap, light, layer) {
            _super.call(this, shadowMap);
            this._light = null;
            this._layer = null;
            this._shadowMapRendererUtils = null;
            this._light = light;
            this._layer = layer;
        }
        CubemapShadowMapRenderTargetRenderer.create = function (shadowMap, light, layer) {
            var obj = new this(shadowMap, light, layer);
            obj.initWhenCreate();
            return obj;
        };
        CubemapShadowMapRenderTargetRenderer.prototype.initWhenCreate = function () {
            this._shadowMapRendererUtils = wd.CubemapShadowMapRenderTargetRendererUtils.create(this._light, this.texture);
            _super.prototype.initWhenCreate.call(this);
        };
        CubemapShadowMapRenderTargetRenderer.prototype.getRenderList = function () {
            var renderList = wd.Director.getInstance().scene.gameObjectScene.shadowManager.getShadowRenderListByLayer(this._layer);
            return wdCb.Hash.create({
                px: renderList,
                nx: renderList,
                py: renderList,
                ny: renderList,
                pz: renderList,
                nz: renderList,
            });
        };
        CubemapShadowMapRenderTargetRenderer.prototype.renderRenderer = function (renderer) {
            this._shadowMapRendererUtils.renderRenderer(renderer);
        };
        CubemapShadowMapRenderTargetRenderer.prototype.beforeRender = function () {
            var scene = null;
            if (this.isRenderListEmptyWhenRender()) {
                wd.Director.getInstance().scene.glslData.appendChild(wd.EShaderGLSLData.CUBEMAP_SHADOWMAP, {
                    light: this._light,
                    isRenderListEmpty: true
                });
                return;
            }
            wd.Director.getInstance().scene.glslData.appendChild(wd.EShaderGLSLData.CUBEMAP_SHADOWMAP, {
                light: this._light,
                isRenderListEmpty: false
            });
            scene = wd.Director.getInstance().scene;
            scene.glslData.appendChild(wd.EShaderGLSLData.BUILD_CUBEMAP_SHADOWMAP, {
                light: this._light
            });
            this._shadowMapRendererUtils.beforeRender(wd.EShaderTypeOfScene.BUILD_CUBEMAP_SHADOWMAP);
        };
        CubemapShadowMapRenderTargetRenderer.prototype.afterRender = function () {
            if (this.isRenderListEmptyWhenRender()) {
                return;
            }
            this._shadowMapRendererUtils.afterRender();
        };
        CubemapShadowMapRenderTargetRenderer.prototype.setCamera = function (camera) {
            var light = this._light;
            camera.aspect = light.shadowMapWidth / light.shadowMapHeight;
            camera.near = light.shadowCameraNear;
            camera.far = light.shadowCameraFar;
        };
        CubemapShadowMapRenderTargetRenderer.prototype.getPosition = function () {
            return this._light.position;
        };
        return CubemapShadowMapRenderTargetRenderer;
    }(wd.CubemapRenderTargetRenderer));
    wd.CubemapShadowMapRenderTargetRenderer = CubemapShadowMapRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DynamicCubemapRenderTargetRenderer = (function (_super) {
        __extends(DynamicCubemapRenderTargetRenderer, _super);
        function DynamicCubemapRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        DynamicCubemapRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        DynamicCubemapRenderTargetRenderer.prototype.getRenderList = function () {
            return this.texture.renderList;
        };
        DynamicCubemapRenderTargetRenderer.prototype.setCamera = function (camera) {
            camera.aspect = 1;
            camera.near = this.texture.near;
            camera.far = this.texture.far;
        };
        DynamicCubemapRenderTargetRenderer.prototype.getPosition = function () {
            return this.texture.getPosition();
        };
        DynamicCubemapRenderTargetRenderer.prototype.beforeRender = function () {
            if (this.isRenderListEmptyWhenRender()) {
                wd.Director.getInstance().scene.glslData.addChild(wd.EShaderGLSLData.DYNAMIC_CUBEMAP, {
                    isRenderListEmpty: true
                });
            }
            else {
                wd.Director.getInstance().scene.glslData.addChild(wd.EShaderGLSLData.DYNAMIC_CUBEMAP, {
                    isRenderListEmpty: false
                });
            }
        };
        return DynamicCubemapRenderTargetRenderer;
    }(wd.CubemapRenderTargetRenderer));
    wd.DynamicCubemapRenderTargetRenderer = DynamicCubemapRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowMapRenderTargetRendererUtils = (function () {
        function ShadowMapRenderTargetRendererUtils(_light, _texture) {
            this._texture = null;
            this._light = null;
            this._light = _light;
            this._texture = _texture;
        }
        ShadowMapRenderTargetRendererUtils.prototype.initWhenCreate = function () {
            this._texture.width = this._light.shadowMapWidth;
            this._texture.height = this._light.shadowMapHeight;
        };
        ShadowMapRenderTargetRendererUtils.prototype.beforeRender = function (shaderType) {
            wd.Director.getInstance().scene.useShaderType(shaderType);
        };
        ShadowMapRenderTargetRendererUtils.prototype.afterRender = function () {
            wd.Director.getInstance().scene.unUseShader();
        };
        ShadowMapRenderTargetRendererUtils.prototype.renderRenderer = function (renderer) {
            this.setWebglState(renderer);
            renderer.render();
        };
        return ShadowMapRenderTargetRendererUtils;
    }());
    wd.ShadowMapRenderTargetRendererUtils = ShadowMapRenderTargetRendererUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapShadowMapRenderTargetRendererUtils = (function (_super) {
        __extends(CubemapShadowMapRenderTargetRendererUtils, _super);
        function CubemapShadowMapRenderTargetRendererUtils() {
            _super.apply(this, arguments);
        }
        CubemapShadowMapRenderTargetRendererUtils.create = function (light, texture) {
            var obj = new this(light, texture);
            obj.initWhenCreate();
            return obj;
        };
        CubemapShadowMapRenderTargetRendererUtils.prototype.setWebglState = function (renderer) {
            renderer.webglState = wd.BuildCubemapShadowMapState.create();
        };
        return CubemapShadowMapRenderTargetRendererUtils;
    }(wd.ShadowMapRenderTargetRendererUtils));
    wd.CubemapShadowMapRenderTargetRendererUtils = CubemapShadowMapRenderTargetRendererUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDShadowMapRenderTargetRendererUtils = (function (_super) {
        __extends(TwoDShadowMapRenderTargetRendererUtils, _super);
        function TwoDShadowMapRenderTargetRendererUtils() {
            _super.apply(this, arguments);
        }
        TwoDShadowMapRenderTargetRendererUtils.create = function (light, texture) {
            var obj = new this(light, texture);
            obj.initWhenCreate();
            return obj;
        };
        TwoDShadowMapRenderTargetRendererUtils.prototype.setWebglState = function (renderer) {
            renderer.webglState = wd.BuildTwoDShadowMapState.create();
        };
        return TwoDShadowMapRenderTargetRendererUtils;
    }(wd.ShadowMapRenderTargetRendererUtils));
    wd.TwoDShadowMapRenderTargetRendererUtils = TwoDShadowMapRenderTargetRendererUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Renderer = (function () {
        function Renderer() {
            this._webglState = null;
            this.skyboxCommand = null;
        }
        Object.defineProperty(Renderer.prototype, "webglState", {
            get: function () {
                return this._webglState ? this._webglState : wd.BasicState.create();
            },
            set: function (webglState) {
                this._webglState = webglState;
            },
            enumerable: true,
            configurable: true
        });
        Renderer.prototype.init = function () {
        };
        __decorate([
            wd.virtual
        ], Renderer.prototype, "init", null);
        return Renderer;
    }());
    wd.Renderer = Renderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RENDER_GROUP_MAX = 31, RENDER_PRIORITY_MAX = 31, SHADER_ID_MAX = 1024, TEXTURE_ID_MAX = 1024, BUFFER_ID_MAX = 1024, TOTAL_BIT = 30, RENDER_GROUP_MOVE_LEFT_BIT = TOTAL_BIT - 5, RENDER_PRIORITY_MOVE_LEFT_BIT = TOTAL_BIT - 5 - 5, SHADER_ID_MOVE_LEFT_BIT = TOTAL_BIT - 5 - 5 - 10;
    var WebGLRenderer = (function (_super) {
        __extends(WebGLRenderer, _super);
        function WebGLRenderer() {
            _super.apply(this, arguments);
            this._commandQueue = wdCb.Collection.create();
            this._clearOptions = {
                color: wd.Color.create("#000000")
            };
        }
        WebGLRenderer.create = function () {
            var obj = new this();
            return obj;
        };
        WebGLRenderer.prototype.addCommand = function (command) {
            this._commandQueue.addChild(command);
            command.init();
        };
        WebGLRenderer.prototype.hasCommand = function () {
            return this._commandQueue.getCount() > 0 || !!this.skyboxCommand;
        };
        WebGLRenderer.prototype.clear = function () {
            wd.DeviceManager.getInstance().clear(this._clearOptions);
        };
        WebGLRenderer.prototype.render = function () {
            var _this = this;
            var deviceManager = wd.DeviceManager.getInstance(), webglState = this.webglState, transparentCommandArr = [], opaqueQuadCommandArr = [];
            this._commandQueue.forEach(function (command) {
                command.webglState = webglState;
                if (command.blend) {
                    transparentCommandArr.push(command);
                }
                else if (command instanceof wd.QuadCommand) {
                    _this._buildOpaqueCommandSortId(command);
                    opaqueQuadCommandArr.push(command);
                }
                else {
                    command.execute();
                }
            }, this);
            if (opaqueQuadCommandArr.length > 0) {
                this._sortOpaqueQuadCommand(opaqueQuadCommandArr);
                for (var _i = 0, opaqueQuadCommandArr_1 = opaqueQuadCommandArr; _i < opaqueQuadCommandArr_1.length; _i++) {
                    var command = opaqueQuadCommandArr_1[_i];
                    command.execute();
                }
            }
            if (transparentCommandArr.length > 0) {
                deviceManager.depthWrite = false;
                this._renderSortedTransparentCommands(transparentCommandArr);
                deviceManager.depthWrite = true;
            }
            if (this.skyboxCommand) {
                deviceManager.depthFunc = wd.EDepthFunction.LEQUAL;
                this.skyboxCommand.webglState = webglState;
                this.skyboxCommand.execute();
                deviceManager.depthFunc = wd.EDepthFunction.LESS;
            }
            this._clearCommand();
            this.webglState = null;
        };
        WebGLRenderer.prototype.init = function () {
            var deviceManager = wd.DeviceManager.getInstance();
            deviceManager.depthTest = true;
            deviceManager.blend = false;
            deviceManager.setColorWrite(true, true, true, true);
            deviceManager.side = wd.ESide.FRONT;
            deviceManager.depthWrite = true;
        };
        WebGLRenderer.prototype.setClearColor = function (color) {
            this._setClearOptions({
                color: color
            });
        };
        WebGLRenderer.prototype._renderSortedTransparentCommands = function (transparentCommandArr) {
            var self = this;
            for (var _i = 0, _a = wd.SortUtils.insertSort(transparentCommandArr, function (a, b) {
                return self._getObjectZDistanceInCameraCoordinate(a) < self._getObjectZDistanceInCameraCoordinate(b);
            }); _i < _a.length; _i++) {
                var command = _a[_i];
                command.execute();
            }
        };
        WebGLRenderer.prototype._getObjectZDistanceInCameraCoordinate = function (cmd) {
            return cmd.mMatrix.applyMatrix(cmd.vMatrix, true).getTranslation().z;
        };
        WebGLRenderer.prototype._clearCommand = function () {
            this._commandQueue.forEach(function (command) {
                command.dispose();
            });
            this._commandQueue.removeAllChildren();
            if (this.skyboxCommand) {
                this.skyboxCommand.dispose();
                this.skyboxCommand = null;
            }
        };
        WebGLRenderer.prototype._setClearOptions = function (clearOptions) {
            wdCb.ExtendUtils.extend(this._clearOptions, clearOptions);
        };
        WebGLRenderer.prototype._buildOpaqueCommandSortId = function (opaqueCommand) {
            var target = opaqueCommand.target, targetMaterial = opaqueCommand.material;
            opaqueCommand.sortId = ((target.renderGroup << RENDER_GROUP_MOVE_LEFT_BIT) | (target.renderPriority << RENDER_PRIORITY_MOVE_LEFT_BIT) | (this._buildShaderSortId(targetMaterial.shader) << SHADER_ID_MOVE_LEFT_BIT) | (this._mapEntityIdToRenderId(this._getTargetTexture(targetMaterial), TEXTURE_ID_MAX))) * BUFFER_ID_MAX
                + (this._mapEntityIdToRenderId(this._getTargetBuffer(targetMaterial), BUFFER_ID_MAX));
        };
        WebGLRenderer.prototype._buildShaderSortId = function (shader) {
            return this._mapEntityIdToRenderId(shader.program, SHADER_ID_MAX);
        };
        WebGLRenderer.prototype._getTargetTexture = function (material) {
            return material.getTextureForRenderSort();
        };
        WebGLRenderer.prototype._getTargetBuffer = function (material) {
            return material.geometry.buffers.getBufferForRenderSort();
        };
        WebGLRenderer.prototype._mapEntityIdToRenderId = function (entity, maxId) {
            if (!entity) {
                return 1;
            }
            return entity.uid % maxId;
        };
        WebGLRenderer.prototype._sortOpaqueQuadCommand = function (opaqueCommandArr) {
            wd.SortUtils.quickSort(opaqueCommandArr, function (commandA, commandB) {
                return commandA.sortId < commandB.sortId;
            }, true);
        };
        __decorate([
            wd.ensure(function () {
                wd.assert(!this._commandQueue.hasRepeatItems(), wd.Log.info.FUNC_SHOULD_NOT("has duplicate render command"));
            })
        ], WebGLRenderer.prototype, "addCommand", null);
        __decorate([
            wd.require(function () {
                wd.assert(!!this.webglState, wd.Log.info.FUNC_MUST_DEFINE("webglState"));
            })
        ], WebGLRenderer.prototype, "render", null);
        __decorate([
            wd.require(function (transparentCommandArr) {
                wd.assert(!!wd.Director.getInstance().scene.currentCamera, wd.Log.info.FUNC_NOT_EXIST("current camera"));
                for (var _i = 0, transparentCommandArr_1 = transparentCommandArr; _i < transparentCommandArr_1.length; _i++) {
                    var command = transparentCommandArr_1[_i];
                    wd.assert(command instanceof wd.QuadCommand, wd.Log.info.FUNC_MUST_BE("transparent command", "QuadCommand"));
                }
            })
        ], WebGLRenderer.prototype, "_renderSortedTransparentCommands", null);
        __decorate([
            wd.require(function (opaqueCommand) {
                var target = opaqueCommand.target;
                wd.assert(target.renderGroup <= RENDER_GROUP_MAX && target.renderGroup >= 0, wd.Log.info.FUNC_SHOULD("renderGroup:" + target.renderGroup, "in range:[0, " + RENDER_GROUP_MAX + "]"));
                wd.assert(target.renderPriority <= RENDER_PRIORITY_MAX && target.renderPriority >= 0, wd.Log.info.FUNC_SHOULD("renderPriority:" + target.renderPriority, "in range:[0, " + RENDER_PRIORITY_MAX + "]"));
            })
        ], WebGLRenderer.prototype, "_buildOpaqueCommandSortId", null);
        __decorate([
            wd.ensure(function (mappedId, entityId, maxId) {
                wd.assert(mappedId >= 0 && mappedId <= maxId, wd.Log.info.FUNC_SHOULD("mappedId:" + mappedId, "in range:[0, " + maxId + "]"));
            })
        ], WebGLRenderer.prototype, "_mapEntityIdToRenderId", null);
        __decorate([
            wd.require(function (opaqueCommandArr) {
                for (var _i = 0, opaqueCommandArr_1 = opaqueCommandArr; _i < opaqueCommandArr_1.length; _i++) {
                    var command = opaqueCommandArr_1[_i];
                    wd.assert(command instanceof wd.QuadCommand, wd.Log.info.FUNC_MUST_BE("command", "QuadCommand"));
                    wd.assert(command.blend === false, wd.Log.info.FUNC_MUST_BE("command", "opaque command"));
                }
            })
        ], WebGLRenderer.prototype, "_sortOpaqueQuadCommand", null);
        return WebGLRenderer;
    }(wd.Renderer));
    wd.WebGLRenderer = WebGLRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WebGLState = (function () {
        function WebGLState() {
        }
        WebGLState.prototype.getSide = function (material) {
            var scene = wd.Director.getInstance().scene;
            return scene.side ? scene.side : material.side;
        };
        return WebGLState;
    }());
    wd.WebGLState = WebGLState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicState = (function (_super) {
        __extends(BasicState, _super);
        function BasicState() {
            _super.apply(this, arguments);
        }
        BasicState.create = function () {
            var obj = new this();
            return obj;
        };
        BasicState.prototype.setState = function (material) {
            var deviceManager = wd.DeviceManager.getInstance();
            deviceManager.setColorWrite(material.redWrite, material.greenWrite, material.blueWrite, material.alphaWrite);
            deviceManager.polygonOffsetMode = material.polygonOffsetMode;
            deviceManager.side = this.getSide(material);
            deviceManager.blend = material.blend;
            if (material.blendFuncSeparate && material.blendEquationSeparate) {
                deviceManager.setBlendFuncSeparate(material.blendFuncSeparate);
                deviceManager.setBlendEquationSeparate(material.blendEquationSeparate);
            }
            else {
                deviceManager.setBlendFunc(material.blendSrc, material.blendDst);
                deviceManager.setBlendEquation(material.blendEquation);
            }
            if (material.alphaToCoverage) {
                deviceManager.alphaToCoverage = material.alphaToCoverage;
            }
        };
        __decorate([
            wd.require(function (material) {
                if (material.blendFuncSeparate && material.blendEquationSeparate) {
                }
                else {
                    wd.assert(!!material.blendSrc && !!material.blendDst && !!material.blendEquation, wdCb.Log.info.FUNC_MUST("material.blendSrc && material.blendDst && material.blendEquation", "be set"));
                }
            })
        ], BasicState.prototype, "setState", null);
        return BasicState;
    }(wd.WebGLState));
    wd.BasicState = BasicState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BuildShadowMapState = (function (_super) {
        __extends(BuildShadowMapState, _super);
        function BuildShadowMapState() {
            _super.apply(this, arguments);
        }
        BuildShadowMapState.prototype.setState = function (material) {
            var deviceManager = wd.DeviceManager.getInstance();
            deviceManager.side = this.getSide(material);
            deviceManager.blend = false;
        };
        return BuildShadowMapState;
    }(wd.WebGLState));
    wd.BuildShadowMapState = BuildShadowMapState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BuildTwoDShadowMapState = (function (_super) {
        __extends(BuildTwoDShadowMapState, _super);
        function BuildTwoDShadowMapState() {
            _super.apply(this, arguments);
        }
        BuildTwoDShadowMapState.create = function () {
            var obj = new this();
            return obj;
        };
        BuildTwoDShadowMapState.prototype.setState = function (material) {
            var deviceManager = wd.DeviceManager.getInstance();
            _super.prototype.setState.call(this, material);
            if (wd.GPUDetector.getInstance().extensionDepthTexture) {
                deviceManager.setColorWrite(false, false, false, false);
            }
        };
        return BuildTwoDShadowMapState;
    }(wd.BuildShadowMapState));
    wd.BuildTwoDShadowMapState = BuildTwoDShadowMapState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BuildCubemapShadowMapState = (function (_super) {
        __extends(BuildCubemapShadowMapState, _super);
        function BuildCubemapShadowMapState() {
            _super.apply(this, arguments);
        }
        BuildCubemapShadowMapState.create = function () {
            var obj = new this();
            return obj;
        };
        return BuildCubemapShadowMapState;
    }(wd.BuildShadowMapState));
    wd.BuildCubemapShadowMapState = BuildCubemapShadowMapState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EDrawMode) {
        EDrawMode[EDrawMode["POINTS"] = "POINTS"] = "POINTS";
        EDrawMode[EDrawMode["LINES"] = "LINES"] = "LINES";
        EDrawMode[EDrawMode["LINE_LOOP"] = "LINE_LOOP"] = "LINE_LOOP";
        EDrawMode[EDrawMode["LINE_STRIP"] = "LINE_STRIP"] = "LINE_STRIP";
        EDrawMode[EDrawMode["TRIANGLES"] = "TRIANGLES"] = "TRIANGLES";
        EDrawMode[EDrawMode["TRIANGLE_STRIP"] = "TRIANGLE_STRIP"] = "TRIANGLE_STRIP";
        EDrawMode[EDrawMode["TRANGLE_FAN"] = "TRIANGLE_FAN"] = "TRANGLE_FAN";
    })(wd.EDrawMode || (wd.EDrawMode = {}));
    var EDrawMode = wd.EDrawMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EBufferType) {
        EBufferType[EBufferType["BYTE"] = "BYTE"] = "BYTE";
        EBufferType[EBufferType["UNSIGNED_BYTE"] = "UNSIGNED_BYTE"] = "UNSIGNED_BYTE";
        EBufferType[EBufferType["SHORT"] = "SHORT"] = "SHORT";
        EBufferType[EBufferType["UNSIGNED_SHORT"] = "UNSIGNED_SHORT"] = "UNSIGNED_SHORT";
        EBufferType[EBufferType["INT"] = "INT"] = "INT";
        EBufferType[EBufferType["UNSIGNED_INT"] = "UNSIGNED_INT"] = "UNSIGNED_INT";
        EBufferType[EBufferType["FLOAT"] = "FLOAT"] = "FLOAT";
    })(wd.EBufferType || (wd.EBufferType = {}));
    var EBufferType = wd.EBufferType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EBufferDataType) {
        EBufferDataType[EBufferDataType["VERTICE"] = "VERTICE"] = "VERTICE";
        EBufferDataType[EBufferDataType["INDICE"] = "INDICE"] = "INDICE";
        EBufferDataType[EBufferDataType["NORMAL"] = "NORMAL"] = "NORMAL";
        EBufferDataType[EBufferDataType["TEXCOORD"] = "TEXCOORD"] = "TEXCOORD";
        EBufferDataType[EBufferDataType["TANGENT"] = "TANGENT"] = "TANGENT";
        EBufferDataType[EBufferDataType["COLOR"] = "COLOR"] = "COLOR";
        EBufferDataType[EBufferDataType["JOINT_INDICE"] = "JOINT_INDICE"] = "JOINT_INDICE";
        EBufferDataType[EBufferDataType["JOINT_WEIGHT"] = "JOINT_WEIGHT"] = "JOINT_WEIGHT";
        EBufferDataType[EBufferDataType["CUSTOM"] = "CUSTOM"] = "CUSTOM";
    })(wd.EBufferDataType || (wd.EBufferDataType = {}));
    var EBufferDataType = wd.EBufferDataType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EBufferUsage) {
        EBufferUsage[EBufferUsage["STREAM_DRAW"] = "STREAM_DRAW"] = "STREAM_DRAW";
        EBufferUsage[EBufferUsage["STATIC_DRAW"] = "STATIC_DRAW"] = "STATIC_DRAW";
        EBufferUsage[EBufferUsage["DYNAMIC_DRAW"] = "DYNAMIC_DRAW"] = "DYNAMIC_DRAW";
    })(wd.EBufferUsage || (wd.EBufferUsage = {}));
    var EBufferUsage = wd.EBufferUsage;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Buffer = (function (_super) {
        __extends(Buffer, _super);
        function Buffer() {
            _super.apply(this, arguments);
            this.buffer = null;
        }
        Buffer.prototype.dispose = function () {
            wd.DeviceManager.getInstance().gl.deleteBuffer(this.buffer);
            delete this.buffer;
        };
        return Buffer;
    }(wd.Entity));
    wd.Buffer = Buffer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var InstanceBuffer = (function (_super) {
        __extends(InstanceBuffer, _super);
        function InstanceBuffer() {
            _super.apply(this, arguments);
            this._capacity = 32 * 16 * 4;
            this._cacheMap = wdCb.Hash.create();
        }
        InstanceBuffer.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(InstanceBuffer.prototype, "float32InstanceArraySize", {
            get: function () {
                return this._capacity / 4;
            },
            enumerable: true,
            configurable: true
        });
        InstanceBuffer.prototype.initWhenCreate = function () {
            this.buffer = this._createBuffer();
        };
        InstanceBuffer.prototype.setCapacity = function (bufferCapacity) {
            var capacity = this._capacity;
            while (capacity < bufferCapacity) {
                capacity *= 2;
            }
            if (this._capacity < capacity) {
                this._capacity = capacity;
                if (this.buffer) {
                    wd.DeviceManager.getInstance().gl.deleteBuffer(this.buffer);
                }
                this.buffer = this._createBuffer();
            }
        };
        InstanceBuffer.prototype.resetData = function (data) {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);
        };
        InstanceBuffer.prototype.bindBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        };
        InstanceBuffer.prototype.addCache = function (key, value) {
            this._cacheMap.addChild(key, value);
        };
        InstanceBuffer.prototype.getCache = function (key) {
            return this._cacheMap.getChild(key);
        };
        InstanceBuffer.prototype._createBuffer = function () {
            var gl = wd.DeviceManager.getInstance().gl, buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, this._capacity, gl.DYNAMIC_DRAW);
            wd.BufferTable.resetBindedArrayBuffer();
            return buffer;
        };
        return InstanceBuffer;
    }(wd.Buffer));
    wd.InstanceBuffer = InstanceBuffer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonBuffer = (function (_super) {
        __extends(CommonBuffer, _super);
        function CommonBuffer() {
            _super.apply(this, arguments);
            this.type = null;
            this.count = null;
            this.usage = null;
        }
        CommonBuffer.prototype.resetBufferData = function (glBufferTargetStr, typedData, offset) {
            if (offset === void 0) { offset = 0; }
            var gl = wd.DeviceManager.getInstance().gl;
            if (this.usage === wd.EBufferUsage.STATIC_DRAW && offset === 0) {
                gl.bufferData(gl[glBufferTargetStr], typedData, gl.DYNAMIC_DRAW);
                return;
            }
            gl.bufferSubData(gl[glBufferTargetStr], offset, typedData);
        };
        return CommonBuffer;
    }(wd.Buffer));
    wd.CommonBuffer = CommonBuffer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ElementBuffer = (function (_super) {
        __extends(ElementBuffer, _super);
        function ElementBuffer() {
            _super.apply(this, arguments);
            this.data = null;
        }
        ElementBuffer.create = function (data, type, usage) {
            if (type === void 0) { type = null; }
            if (usage === void 0) { usage = wd.EBufferUsage.STATIC_DRAW; }
            var obj = new this();
            obj.initWhenCreate(data, type, usage);
            return obj;
        };
        Object.defineProperty(ElementBuffer.prototype, "typeSize", {
            get: function () {
                return this.data.BYTES_PER_ELEMENT;
            },
            enumerable: true,
            configurable: true
        });
        ElementBuffer.prototype.initWhenCreate = function (data, type, usage) {
            var gl = wd.DeviceManager.getInstance().gl, isNeed32Bits = null, typedData = null;
            this.buffer = gl.createBuffer();
            if (!this.buffer) {
                wd.Log.warn('Failed to create the this.buffer object');
                return null;
            }
            if (!data) {
                return null;
            }
            isNeed32Bits = this._checkIsNeed32Bits(data, type);
            typedData = this._convertToTypedArray(isNeed32Bits, data);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, typedData, gl[usage]);
            wd.BufferTable.resetBindedElementBuffer();
            this._saveData(typedData, this._getType(isNeed32Bits, type), usage);
            return this.buffer;
        };
        ElementBuffer.prototype.resetData = function (data, type, offset) {
            if (type === void 0) { type = null; }
            if (offset === void 0) { offset = 0; }
            var gl = wd.DeviceManager.getInstance().gl, isNeed32Bits = this._checkIsNeed32Bits(data, type), typedData = this._convertToTypedArray(isNeed32Bits, data);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
            this.resetBufferData("ELEMENT_ARRAY_BUFFER", typedData, offset);
            this._saveData(typedData, this._getType(isNeed32Bits, type), wd.EBufferUsage.DYNAMIC_DRAW);
            return this;
        };
        ElementBuffer.prototype._convertToTypedArray = function (isNeed32Bits, data) {
            return isNeed32Bits ? new Uint32Array(data) : new Uint16Array(data);
        };
        ElementBuffer.prototype._checkIsNeed32Bits = function (indices, type) {
            var isNeed32Bits = false;
            if (type !== null) {
                if (type === wd.EBufferType.UNSIGNED_INT) {
                    return true;
                }
                return false;
            }
            if (wd.GPUDetector.getInstance().extensionUintIndices) {
                for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                    var indice = indices_1[_i];
                    if (indice > 65535) {
                        isNeed32Bits = true;
                        break;
                    }
                }
            }
            else {
                isNeed32Bits = false;
            }
            return isNeed32Bits;
        };
        ElementBuffer.prototype._getType = function (isNeed32Bits, type) {
            return type === null ? (isNeed32Bits ? wd.EBufferType.UNSIGNED_INT : wd.EBufferType.UNSIGNED_SHORT) : type;
        };
        ElementBuffer.prototype._saveData = function (data, type, usage) {
            this.type = type;
            this.count = data.length;
            this.data = data;
            this.usage = usage;
        };
        __decorate([
            wd.ensureGetter(function (typeSize) {
                wd.assert(typeSize > 0, wd.Log.info.FUNC_SHOULD("typeSize", "> 0, but actual is " + typeSize));
            })
        ], ElementBuffer.prototype, "typeSize", null);
        __decorate([
            wd.require(function (data, type, offset) {
                if (type === void 0) { type = null; }
                if (offset === void 0) { offset = 0; }
                wd.assert(this.buffer, wd.Log.info.FUNC_MUST("create gl buffer"));
            })
        ], ElementBuffer.prototype, "resetData", null);
        __decorate([
            wd.require(function (isNeed32Bits, type) {
                if (type !== null) {
                    if (isNeed32Bits) {
                        wd.assert(type === wd.EBufferType.UNSIGNED_INT, wd.Log.info.FUNC_MUST_BE("type", "UNSIGNED_SHORT, but actual is " + type));
                    }
                    else {
                        wd.assert(type === wd.EBufferType.UNSIGNED_SHORT || type === wd.EBufferType.UNSIGNED_INT, wd.Log.info.FUNC_MUST_BE("type", "UNSIGNED_SHORT or UNSIGNED_INT, but actual is " + type));
                    }
                }
            })
        ], ElementBuffer.prototype, "_getType", null);
        return ElementBuffer;
    }(wd.CommonBuffer));
    wd.ElementBuffer = ElementBuffer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ArrayBuffer = (function (_super) {
        __extends(ArrayBuffer, _super);
        function ArrayBuffer() {
            _super.apply(this, arguments);
            this.size = null;
            this.data = null;
        }
        ArrayBuffer.create = function (data, size, type, usage) {
            if (type === void 0) { type = wd.EBufferType.FLOAT; }
            if (usage === void 0) { usage = wd.EBufferUsage.STATIC_DRAW; }
            var obj = new this();
            obj.initWhenCreate(data, size, type, usage);
            return obj;
        };
        ArrayBuffer.prototype.initWhenCreate = function (data, size, type, usage) {
            var gl = wd.DeviceManager.getInstance().gl, typedData = null;
            this.buffer = gl.createBuffer();
            if (!this.buffer) {
                wd.Log.warn('Failed to create the this.buffer object');
                return null;
            }
            if (!data) {
                return null;
            }
            typedData = this._convertToTypedArray(data, type);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, typedData, gl[usage]);
            wd.BufferTable.resetBindedArrayBuffer();
            this._saveData(typedData, size, type, usage);
            return this.buffer;
        };
        ArrayBuffer.prototype.resetData = function (data, size, type, offset) {
            if (size === void 0) { size = this.size; }
            if (type === void 0) { type = this.type; }
            if (offset === void 0) { offset = 0; }
            var gl = wd.DeviceManager.getInstance().gl, typedData = this._convertToTypedArray(data, type);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            this.resetBufferData("ARRAY_BUFFER", typedData, offset);
            this._saveData(typedData, size, type, wd.EBufferUsage.DYNAMIC_DRAW);
            return this;
        };
        ArrayBuffer.prototype._convertToTypedArray = function (data, type) {
            return new Float32Array(data);
        };
        ArrayBuffer.prototype._saveData = function (data, size, type, usage) {
            this.size = size;
            this.type = type;
            this.count = data.length / size;
            this.usage = usage;
            this.data = data;
        };
        __decorate([
            wd.require(function (data, size, type, offset) {
                if (size === void 0) { size = this.size; }
                if (type === void 0) { type = this.type; }
                if (offset === void 0) { offset = 0; }
                wd.assert(this.buffer, wd.Log.info.FUNC_MUST("create gl buffer"));
            })
        ], ArrayBuffer.prototype, "resetData", null);
        return ArrayBuffer;
    }(wd.CommonBuffer));
    wd.ArrayBuffer = ArrayBuffer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var _table = wdCb.Hash.create();
    _table.addChild(wd.EBufferDataType.VERTICE, "vertices");
    _table.addChild(wd.EBufferDataType.INDICE, "indices");
    _table.addChild(wd.EBufferDataType.NORMAL, "normals");
    _table.addChild(wd.EBufferDataType.TEXCOORD, "texCoords");
    _table.addChild(wd.EBufferDataType.COLOR, "colors");
    _table.addChild(wd.EBufferDataType.TANGENT, "tangents");
    _table.addChild(wd.EBufferDataType.JOINT_INDICE, "jointIndices");
    _table.addChild(wd.EBufferDataType.JOINT_WEIGHT, "jointWeights");
    var BufferDataTable = (function () {
        function BufferDataTable() {
        }
        BufferDataTable.getGeometryDataName = function (type) {
            var result = _table.getChild(type);
            return result;
        };
        __decorate([
            wd.ensure(function (result, type) {
                wd.Log.error(result === void 0, wd.Log.info.FUNC_NOT_EXIST(type, "in BufferDataTable"));
            })
        ], BufferDataTable, "getGeometryDataName", null);
        return BufferDataTable;
    }());
    wd.BufferDataTable = BufferDataTable;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Program = (function (_super) {
        __extends(Program, _super);
        function Program() {
            _super.apply(this, arguments);
            this.glProgram = null;
            this._getAttribLocationCache = wdCb.Hash.create();
            this._sender = wd.GLSLDataSender.create(this);
        }
        Program.create = function () {
            var obj = new this();
            return obj;
        };
        Program.prototype.use = function () {
            if (wd.JudgeUtils.isEqual(this, wd.ProgramTable.lastUsedProgram)) {
                return;
            }
            wd.ProgramTable.lastUsedProgram = this;
            wd.DeviceManager.getInstance().gl.useProgram(this.glProgram);
            this._sender.disableVertexAttribArray();
            wd.BufferTable.lastBindedArrayBufferListUidStr = null;
        };
        Program.prototype.getAttribLocation = function (name) {
            var pos = null, gl = wd.DeviceManager.getInstance().gl;
            pos = this._getAttribLocationCache.getChild(name);
            if (pos !== void 0) {
                return pos;
            }
            pos = gl.getAttribLocation(this.glProgram, name);
            this._getAttribLocationCache.addChild(name, pos);
            return pos;
        };
        Program.prototype.getUniformLocation = function (name) {
            return this._sender.getUniformLocation(name);
        };
        Program.prototype.sendUniformData = function (name, type, data) {
            if (data === null) {
                return;
            }
            switch (type) {
                case wd.EVariableType.FLOAT_1:
                    this._sender.sendFloat1(name, data);
                    break;
                case wd.EVariableType.FLOAT_2:
                    this._sender.sendFloat2(name, data);
                    break;
                case wd.EVariableType.FLOAT_3:
                    this._sender.sendFloat3(name, data);
                    break;
                case wd.EVariableType.FLOAT_4:
                    this._sender.sendFloat4(name, data);
                    break;
                case wd.EVariableType.VECTOR_2:
                    this._sender.sendVector2(name, data);
                    break;
                case wd.EVariableType.VECTOR_3:
                    this._sender.sendVector3(name, data);
                    break;
                case wd.EVariableType.VECTOR_4:
                    this._sender.sendVector4(name, data);
                    break;
                case wd.EVariableType.COLOR_3:
                    this._sender.sendColor3(name, data);
                    break;
                case wd.EVariableType.FLOAT_MAT3:
                    this._sender.sendMatrix3(name, data);
                    break;
                case wd.EVariableType.FLOAT_MAT4:
                    this._sender.sendMatrix4(name, data);
                    break;
                case wd.EVariableType.NUMBER_1:
                case wd.EVariableType.SAMPLER_CUBE:
                case wd.EVariableType.SAMPLER_2D:
                    this._sender.sendNum1(name, data);
                    break;
                case wd.EVariableType.FLOAT_MAT4_ARRAY:
                    this._sender.sendMatrix4Array(name, data);
                    break;
                case wd.EVariableType.SAMPLER_ARRAY:
                    this._sender.sendSampleArray(name, data);
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("EVariableType:", type));
                    break;
            }
        };
        Program.prototype.sendAttributeBuffer = function (name, type, buffer) {
            var pos = null;
            pos = this.getAttribLocation(name);
            if (pos === -1) {
                return;
            }
            this._sender.addBufferToToSendList(pos, buffer);
        };
        Program.prototype.sendStructureData = function (name, type, data) {
            this.sendUniformData(name, type, data);
        };
        Program.prototype.sendFloat1 = function (name, data) {
            this._sender.sendFloat1(name, data);
        };
        Program.prototype.sendFloat2 = function (name, data) {
            this._sender.sendFloat2(name, data);
        };
        Program.prototype.sendFloat3 = function (name, data) {
            this._sender.sendFloat3(name, data);
        };
        Program.prototype.sendFloat4 = function (name, data) {
            this._sender.sendFloat4(name, data);
        };
        Program.prototype.sendVector2 = function (name, data) {
            this._sender.sendVector2(name, data);
        };
        Program.prototype.sendVector3 = function (name, data) {
            this._sender.sendVector3(name, data);
        };
        Program.prototype.sendVector4 = function (name, data) {
            this._sender.sendVector4(name, data);
        };
        Program.prototype.sendColor3 = function (name, data) {
            this._sender.sendColor3(name, data);
        };
        Program.prototype.sendNum1 = function (name, data) {
            this._sender.sendNum1(name, data);
        };
        Program.prototype.sendMatrix3 = function (name, data) {
            this._sender.sendMatrix3(name, data);
        };
        Program.prototype.sendMatrix4 = function (name, data) {
            this._sender.sendMatrix4(name, data);
        };
        Program.prototype.sendMatrix4Array = function (name, data) {
            this._sender.sendMatrix4Array(name, data);
        };
        Program.prototype.sendSampleArray = function (name, data) {
            this._sender.sendSampleArray(name, data);
        };
        Program.prototype.sendAllBufferData = function (vaoManager) {
            this._sender.sendAllBufferData(vaoManager);
            this._sender.clearBufferList();
        };
        Program.prototype.initWithShader = function (shader) {
            var gl = wd.DeviceManager.getInstance().gl, vs = null, fs = null;
            if (this.glProgram) {
                this.dispose();
            }
            this.glProgram = wd.DeviceManager.getInstance().gl.createProgram();
            vs = shader.createVsShader();
            fs = shader.createFsShader();
            gl.attachShader(this.glProgram, vs);
            gl.attachShader(this.glProgram, fs);
            gl.bindAttribLocation(this.glProgram, 0, "a_position");
            gl.linkProgram(this.glProgram);
            wd.Log.error(gl.getProgramParameter(this.glProgram, gl.LINK_STATUS) === false, gl.getProgramInfoLog(this.glProgram));
            gl.deleteShader(vs);
            gl.deleteShader(fs);
            return this;
        };
        Program.prototype.dispose = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.deleteProgram(this.glProgram);
            this.glProgram = null;
            this._sender.dispose();
            this._clearAllCache();
        };
        Program.prototype._clearAllCache = function () {
            this._getAttribLocationCache.removeAllChildren();
            this._sender.clearAllCache();
        };
        __decorate([
            wd.require(function (name, type, buffer) {
                wd.assert(buffer instanceof wd.ArrayBuffer, wd.Log.info.FUNC_MUST_BE("ArrayBuffer"));
                wd.assert(type === wd.EVariableType.BUFFER, wd.Log.info.FUNC_SHOULD("type", "be EVariableType.BUFFER, but actual is " + type));
            })
        ], Program.prototype, "sendAttributeBuffer", null);
        return Program;
    }(wd.Entity));
    wd.Program = Program;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GLSLDataSender = (function () {
        function GLSLDataSender(program) {
            this._program = null;
            this._uniformCache = {};
            this._vertexAttribHistory = [];
            this._getUniformLocationCache = {};
            this._toSendBufferArr = [];
            this._toSendBuffersUidStr = "";
            this._program = program;
        }
        GLSLDataSender.create = function (program) {
            var obj = new this(program);
            return obj;
        };
        GLSLDataSender.prototype.sendFloat1 = function (name, data) {
            var gl = null, pos = null;
            if (this._uniformCache[name] == data) {
                return;
            }
            this._recordUniformData(name, data);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform1f(pos, Number(data));
        };
        GLSLDataSender.prototype.sendFloat2 = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name];
            if (recordedData && recordedData[0] === data[0] && recordedData[1] === data[1]) {
                return;
            }
            this._recordUniformData(name, data);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform2f(pos, data[0], data[1]);
        };
        GLSLDataSender.prototype.sendFloat3 = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name];
            if (recordedData && recordedData[0] === data[0] && recordedData[1] === data[1] && recordedData[2] === data[2]) {
                return;
            }
            this._recordUniformData(name, data);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform3f(pos, data[0], data[1], data[2]);
        };
        GLSLDataSender.prototype.sendFloat4 = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name];
            if (recordedData && recordedData[0] === data[0] && recordedData[1] === data[1] && recordedData[2] === data[2] && recordedData[3] === data[3]) {
                return;
            }
            this._recordUniformData(name, data);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform4f(pos, data[0], data[1], data[2], data[3]);
        };
        GLSLDataSender.prototype.sendVector2 = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name];
            if (recordedData && recordedData[0] == data.x && recordedData[1] == data.y) {
                return;
            }
            var x = data.x, y = data.y;
            this._recordUniformData(name, [x, y]);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform2f(pos, x, y);
        };
        GLSLDataSender.prototype.sendVector3 = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name];
            if (recordedData && recordedData[0] == data.x && recordedData[1] == data.y && recordedData[2] == data.z) {
                return;
            }
            var x = data.x, y = data.y, z = data.z;
            this._recordUniformData(name, [x, y, z]);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform3f(pos, x, y, z);
        };
        GLSLDataSender.prototype.sendVector4 = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name];
            if (recordedData && recordedData[0] == data.x && recordedData[1] == data.y && recordedData[2] == data.z && recordedData[3] == data.w) {
                return;
            }
            var x = data.x, y = data.y, z = data.z, w = data.w;
            this._recordUniformData(name, [x, y, z, w]);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform4f(pos, x, y, z, w);
        };
        GLSLDataSender.prototype.sendColor3 = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name], convertedData = null;
            if (recordedData && recordedData[0] == data.r && recordedData[1] == data.g && recordedData[2] == data.b) {
                return;
            }
            var r = data.r, g = data.g, b = data.b;
            this._recordUniformData(name, [r, g, b]);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform3f(pos, r, g, b);
        };
        GLSLDataSender.prototype.sendNum1 = function (name, data) {
            var gl = null, pos = null;
            if (this._uniformCache[name] === data) {
                return;
            }
            this._recordUniformData(name, data);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform1i(pos, data);
        };
        GLSLDataSender.prototype.sendMatrix3 = function (name, data) {
            var gl = wd.DeviceManager.getInstance().gl, pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniformMatrix3fv(pos, false, data.values);
        };
        GLSLDataSender.prototype.sendMatrix4 = function (name, data) {
            var gl = wd.DeviceManager.getInstance().gl, pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniformMatrix4fv(pos, false, data.values);
        };
        GLSLDataSender.prototype.sendMatrix4Array = function (name, data) {
            var gl = wd.DeviceManager.getInstance().gl, pos = this.getUniformLocation(name + "[0]");
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniformMatrix4fv(pos, false, data);
        };
        GLSLDataSender.prototype.sendSampleArray = function (name, data) {
            var gl = null, pos = null, recordedData = this._uniformCache[name], isEqual = true;
            if (recordedData) {
                for (var i = 0, len = data.length; i < len; i++) {
                    if (recordedData[i] !== data[i]) {
                        isEqual = false;
                        break;
                    }
                }
                if (isEqual) {
                    return;
                }
            }
            this._recordUniformData(name, data);
            gl = wd.DeviceManager.getInstance().gl;
            pos = this.getUniformLocation(name);
            if (this._isUniformDataNotExistByLocation(pos)) {
                return;
            }
            gl.uniform1iv(pos, data);
        };
        GLSLDataSender.prototype.getUniformLocation = function (name) {
            var pos = null, gl = wd.DeviceManager.getInstance().gl;
            pos = this._getUniformLocationCache[name];
            if (pos !== void 0) {
                return pos;
            }
            pos = gl.getUniformLocation(this._program.glProgram, name);
            this._getUniformLocationCache[name] = pos;
            return pos;
        };
        GLSLDataSender.prototype.addBufferToToSendList = function (pos, buffer) {
            this._toSendBufferArr[pos] = buffer;
            this._toSendBuffersUidStr += String(buffer.uid);
        };
        GLSLDataSender.prototype.sendAllBufferData = function (vaoManager) {
            var toSendBufferArr = this._toSendBufferArr;
            if (vaoManager) {
                vaoManager.sendAllBufferData(this._toSendBuffersUidStr, toSendBufferArr);
                return;
            }
            for (var pos = 0, len = toSendBufferArr.length; pos < len; pos++) {
                var buffer = toSendBufferArr[pos];
                if (!buffer) {
                    continue;
                }
                this.sendBuffer(pos, buffer);
            }
        };
        GLSLDataSender.prototype.clearBufferList = function () {
            this._toSendBufferArr = [];
            this._toSendBuffersUidStr = "";
        };
        GLSLDataSender.prototype.sendBuffer = function (pos, buffer) {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
            gl.vertexAttribPointer(pos, buffer.size, gl[buffer.type], false, 0, 0);
            if (this._vertexAttribHistory[pos] !== true) {
                gl.enableVertexAttribArray(pos);
                this._vertexAttribHistory[pos] = true;
            }
        };
        GLSLDataSender.prototype.disableVertexAttribArray = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            for (var i in this._vertexAttribHistory) {
                var iAsNumber = +i;
                if (iAsNumber > gl.VERTEX_ATTRIB_ARRAY_ENABLED || !this._vertexAttribHistory[iAsNumber]) {
                    continue;
                }
                this._vertexAttribHistory[iAsNumber] = false;
                gl.disableVertexAttribArray(iAsNumber);
            }
            this._vertexAttribHistory = [];
        };
        GLSLDataSender.prototype.clearAllCache = function () {
            this._getUniformLocationCache = {};
            this._uniformCache = {};
        };
        GLSLDataSender.prototype.dispose = function () {
            this.disableVertexAttribArray();
        };
        GLSLDataSender.prototype._recordUniformData = function (name, data) {
            this._uniformCache[name] = data;
        };
        GLSLDataSender.prototype._isUniformDataNotExistByLocation = function (pos) {
            return pos === null;
        };
        __decorate([
            wd.require(function (name, data) {
                wd.assert(wd.JudgeUtils.isNumber(data), wd.Log.info.FUNC_MUST_BE("data", "be number"));
            })
        ], GLSLDataSender.prototype, "sendNum1", null);
        __decorate([
            wd.require(function (name, data) {
                wd.it("data should be array, but actual is " + data, function () {
                    wd.expect(wd.JudgeUtils.isFloatArray(data) || wd.JudgeUtils.isArrayExactly(data)).true;
                });
                wd.it("name shouldn't be the first matrix of the array", function () {
                    wd.expect(/\[0\]$/.test(name)).false;
                });
            })
        ], GLSLDataSender.prototype, "sendMatrix4Array", null);
        __decorate([
            wd.require(function (name, data) {
                wd.assert(wd.JudgeUtils.isArrayExactly(data), wd.Log.info.FUNC_SHOULD("data", "be array, but actual is " + data));
                for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                    var unit = data_1[_i];
                    wd.assert(wd.JudgeUtils.isNumber(unit), wd.Log.info.FUNC_SHOULD("data", "be Array<number>, but actual is " + data));
                }
            })
        ], GLSLDataSender.prototype, "sendSampleArray", null);
        __decorate([
            wd.require(function () {
                wd.assert(!wd.ArrayUtils.hasRepeatItems(this._toSendBufferArr), wd.Log.info.FUNC_SHOULD_NOT("_toSendBufferArr", "has repeat buffer"));
            }),
            wd.cache(function () {
                return wd.BufferTable.lastBindedArrayBufferListUidStr === this._toSendBuffersUidStr;
            }, function () {
            }, function () {
                wd.BufferTable.lastBindedArrayBufferListUidStr = this._toSendBuffersUidStr;
            })
        ], GLSLDataSender.prototype, "sendAllBufferData", null);
        return GLSLDataSender;
    }());
    wd.GLSLDataSender = GLSLDataSender;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RenderCommand = (function () {
        function RenderCommand() {
            this._webglState = null;
            this.drawMode = wd.EDrawMode.TRIANGLES;
            this.blend = false;
            this.vaoManager = null;
        }
        Object.defineProperty(RenderCommand.prototype, "webglState", {
            get: function () {
                return this._webglState ? this._webglState : wd.BasicState.create();
            },
            set: function (webglState) {
                this._webglState = webglState;
            },
            enumerable: true,
            configurable: true
        });
        RenderCommand.prototype.init = function () {
        };
        RenderCommand.prototype.dispose = function () {
        };
        RenderCommand.prototype.drawElements = function (indexBuffer) {
            var startOffset = 0, gl = wd.DeviceManager.getInstance().gl;
            wd.BufferTable.bindIndexBuffer(indexBuffer);
            wd.GlUtils.drawElements(gl[this.drawMode], indexBuffer.count, gl[indexBuffer.type], indexBuffer.typeSize * startOffset);
        };
        RenderCommand.prototype.drawArray = function (vertexBuffer) {
            var startOffset = 0, gl = wd.DeviceManager.getInstance().gl;
            wd.GlUtils.drawArrays(gl[this.drawMode], startOffset, vertexBuffer.count);
        };
        __decorate([
            wd.virtual
        ], RenderCommand.prototype, "init", null);
        __decorate([
            wd.virtual
        ], RenderCommand.prototype, "dispose", null);
        return RenderCommand;
    }());
    wd.RenderCommand = RenderCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var QuadCommand = (function (_super) {
        __extends(QuadCommand, _super);
        function QuadCommand() {
            _super.apply(this, arguments);
            this.mMatrix = null;
            this.vMatrix = null;
            this.pMatrix = null;
            this.buffers = null;
            this.material = null;
            this.target = null;
            this.sortId = null;
        }
        Object.defineProperty(QuadCommand.prototype, "program", {
            get: function () {
                return this.material.program;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadCommand.prototype, "mvpMatrix", {
            get: function () {
                return this.mMatrix.applyMatrix(this.vMatrix, true).applyMatrix(this.pMatrix, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuadCommand.prototype, "vpMatrix", {
            get: function () {
                return this.vMatrix.applyMatrix(this.pMatrix, true);
            },
            enumerable: true,
            configurable: true
        });
        QuadCommand.prototype.execute = function () {
            var material = this.material;
            material.updateShader(this);
            this.draw(material);
        };
        __decorate([
            wd.requireGetter(function () {
                wd.assert(!!this.mMatrix && !!this.vMatrix && !!this.pMatrix, wd.Log.info.FUNC_NOT_EXIST("mMatrix or vMatrix or pMatrix"));
            })
        ], QuadCommand.prototype, "mvpMatrix", null);
        __decorate([
            wd.requireGetter(function () {
                wd.assert(!!this.vMatrix && !!this.pMatrix, wd.Log.info.FUNC_NOT_EXIST("vMatrix or pMatrix"));
            })
        ], QuadCommand.prototype, "vpMatrix", null);
        return QuadCommand;
    }(wd.RenderCommand));
    wd.QuadCommand = QuadCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SingleDrawCommand = (function (_super) {
        __extends(SingleDrawCommand, _super);
        function SingleDrawCommand() {
            _super.apply(this, arguments);
            this.normalMatrix = null;
        }
        SingleDrawCommand.create = function () {
            var obj = new this();
            return obj;
        };
        SingleDrawCommand.prototype.draw = function (material) {
            var vertexBuffer = null, indexBuffer = this.buffers.getChild(wd.EBufferDataType.INDICE);
            this.webglState.setState(material);
            if (indexBuffer) {
                this.drawElements(indexBuffer);
            }
            else {
                vertexBuffer = this.buffers.getChild(wd.EBufferDataType.VERTICE);
                this.drawArray(vertexBuffer);
            }
        };
        return SingleDrawCommand;
    }(wd.QuadCommand));
    wd.SingleDrawCommand = SingleDrawCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EInstanceGLSLData) {
        EInstanceGLSLData[EInstanceGLSLData["MODELMATRIX"] = 0] = "MODELMATRIX";
        EInstanceGLSLData[EInstanceGLSLData["NORMALMATRIX_MODELMATRIX"] = 1] = "NORMALMATRIX_MODELMATRIX";
        EInstanceGLSLData[EInstanceGLSLData["ONE_MANY"] = 2] = "ONE_MANY";
    })(wd.EInstanceGLSLData || (wd.EInstanceGLSLData = {}));
    var EInstanceGLSLData = wd.EInstanceGLSLData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var InstanceCommand = (function (_super) {
        __extends(InstanceCommand, _super);
        function InstanceCommand() {
            _super.apply(this, arguments);
        }
        return InstanceCommand;
    }(wd.QuadCommand));
    wd.InstanceCommand = InstanceCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var HardwareInstanceCommand = (function (_super) {
        __extends(HardwareInstanceCommand, _super);
        function HardwareInstanceCommand() {
            _super.apply(this, arguments);
            this.glslData = null;
            this.instanceBuffer = null;
        }
        return HardwareInstanceCommand;
    }(wd.InstanceCommand));
    wd.HardwareInstanceCommand = HardwareInstanceCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToOneHardwareInstanceCommand = (function (_super) {
        __extends(OneToOneHardwareInstanceCommand, _super);
        function OneToOneHardwareInstanceCommand() {
            _super.apply(this, arguments);
            this.instanceList = null;
        }
        OneToOneHardwareInstanceCommand.create = function () {
            var obj = new this();
            return obj;
        };
        OneToOneHardwareInstanceCommand.prototype.draw = function (material) {
            var drawer = null;
            if (!this._hasInstance()) {
                return;
            }
            this.webglState.setState(material);
            switch (this.glslData) {
                case wd.EInstanceGLSLData.MODELMATRIX:
                    drawer = wd.ModelMatrixHardwareInstanceDrawer.getInstance();
                    break;
                case wd.EInstanceGLSLData.NORMALMATRIX_MODELMATRIX:
                    drawer = wd.NormalMatrixModelMatrixHardwareInstanceDrawer.getInstance();
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("glslData:" + this.glslData));
                    break;
            }
            drawer.draw(this.instanceList, this.instanceBuffer, this.program, this.buffers, this.drawMode);
        };
        OneToOneHardwareInstanceCommand.prototype._hasInstance = function () {
            return !!this.instanceList && this.instanceList.getCount() > 0;
        };
        __decorate([
            wd.ensure(function (hasInstance) {
                wd.assert(wd.JudgeUtils.isBoolean(hasInstance), wd.Log.info.FUNC_SHOULD("return boolean value"));
                if (hasInstance) {
                    wd.assert(wd.InstanceUtils.isHardwareSupport(), wd.Log.info.FUNC_SHOULD("hardware", "support instance"));
                    wd.assert(!!this.instanceBuffer, wd.Log.info.FUNC_MUST_DEFINE("instanceBuffer"));
                }
            })
        ], OneToOneHardwareInstanceCommand.prototype, "_hasInstance", null);
        return OneToOneHardwareInstanceCommand;
    }(wd.HardwareInstanceCommand));
    wd.OneToOneHardwareInstanceCommand = OneToOneHardwareInstanceCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToManyHardwareInstanceCommand = (function (_super) {
        __extends(OneToManyHardwareInstanceCommand, _super);
        function OneToManyHardwareInstanceCommand() {
            _super.apply(this, arguments);
            this.geometry = null;
        }
        OneToManyHardwareInstanceCommand.create = function () {
            var obj = new this();
            return obj;
        };
        OneToManyHardwareInstanceCommand.prototype.draw = function (material) {
            var drawer = null;
            this.webglState.setState(material);
            drawer = wd.OneToManyHardwareInstanceDrawer.getInstance();
            drawer.draw(this.geometry, this.instanceBuffer, this.program, this.buffers, this.drawMode);
        };
        __decorate([
            wd.require(function (material) {
                var _this = this;
                wd.it("glslData should be ONE_MANY", function () {
                    wd.expect(_this.glslData).equals(wd.EInstanceGLSLData.ONE_MANY);
                }, this);
            })
        ], OneToManyHardwareInstanceCommand.prototype, "draw", null);
        return OneToManyHardwareInstanceCommand;
    }(wd.HardwareInstanceCommand));
    wd.OneToManyHardwareInstanceCommand = OneToManyHardwareInstanceCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ProceduralCommand = (function (_super) {
        __extends(ProceduralCommand, _super);
        function ProceduralCommand() {
            _super.apply(this, arguments);
            this.shader = null;
            this.indexBuffer = null;
            this.vertexBuffer = null;
        }
        ProceduralCommand.create = function () {
            var obj = new this();
            return obj;
        };
        ProceduralCommand.prototype.init = function () {
            this.blend = false;
            this.drawMode = wd.EDrawMode.TRIANGLES;
        };
        ProceduralCommand.prototype.execute = function () {
            this.shader.update(this);
            this.drawElements(this.indexBuffer);
        };
        return ProceduralCommand;
    }(wd.RenderCommand));
    wd.ProceduralCommand = ProceduralCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var InstanceDrawer = (function () {
        function InstanceDrawer() {
        }
        return InstanceDrawer;
    }());
    wd.InstanceDrawer = InstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var HardwareInstanceDrawer = (function (_super) {
        __extends(HardwareInstanceDrawer, _super);
        function HardwareInstanceDrawer() {
            _super.apply(this, arguments);
        }
        HardwareInstanceDrawer.prototype.unBind = function (instanceBuffer, offsetLocationArr) {
            var gl = wd.DeviceManager.getInstance().gl;
            var extension = wd.GPUDetector.getInstance().extensionInstancedArrays;
            gl.bindBuffer(gl.ARRAY_BUFFER, instanceBuffer.buffer);
            for (var _i = 0, offsetLocationArr_1 = offsetLocationArr; _i < offsetLocationArr_1.length; _i++) {
                var offsetLocation = offsetLocationArr_1[_i];
                gl.disableVertexAttribArray(offsetLocation);
                extension.vertexAttribDivisorANGLE(offsetLocation, 0);
            }
        };
        HardwareInstanceDrawer.prototype.drawElementsInstancedANGLE = function (indexBuffer, instancesCount, drawMode) {
            var startOffset = 0, gl = wd.DeviceManager.getInstance().gl;
            wd.BufferTable.bindIndexBuffer(indexBuffer);
            wd.GlUtils.drawElementsInstancedANGLE(gl[drawMode], indexBuffer.count, gl[indexBuffer.type], indexBuffer.typeSize * startOffset, instancesCount);
        };
        return HardwareInstanceDrawer;
    }(wd.InstanceDrawer));
    wd.HardwareInstanceDrawer = HardwareInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToOneHardwareInstanceDrawer = (function (_super) {
        __extends(OneToOneHardwareInstanceDrawer, _super);
        function OneToOneHardwareInstanceDrawer() {
            _super.apply(this, arguments);
        }
        OneToOneHardwareInstanceDrawer.prototype.draw = function (instanceList, instanceBuffer, program, buffers, drawMode) {
            var indexBuffer = null, offsetLocationArr = this.getOffsetLocationArray(program);
            this.setCapacity(instanceList, instanceBuffer);
            this.sendGLSLData(instanceList, instanceBuffer, offsetLocationArr);
            indexBuffer = buffers.getChild(wd.EBufferDataType.INDICE);
            if (indexBuffer) {
                this.drawElementsInstancedANGLE(indexBuffer, instanceList.getCount(), drawMode);
            }
            else {
                var vertexBuffer = buffers.getChild(wd.EBufferDataType.VERTICE);
                this._drawArraysInstancedANGLE(vertexBuffer, instanceList.getCount(), drawMode);
            }
            this.unBind(instanceBuffer, offsetLocationArr);
        };
        OneToOneHardwareInstanceDrawer.prototype._drawArraysInstancedANGLE = function (vertexBuffer, instancesCount, drawMode) {
            var startOffset = 0, gl = wd.DeviceManager.getInstance().gl;
            wd.GlUtils.drawArraysInstancedANGLE(gl[drawMode], startOffset, vertexBuffer.count, instancesCount);
        };
        __decorate([
            wd.require(function () {
                wd.assert(wd.InstanceUtils.isHardwareSupport(), wd.Log.info.FUNC_SHOULD("hardware", "support instance"));
            })
        ], OneToOneHardwareInstanceDrawer.prototype, "draw", null);
        return OneToOneHardwareInstanceDrawer;
    }(wd.HardwareInstanceDrawer));
    wd.OneToOneHardwareInstanceDrawer = OneToOneHardwareInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToManyHardwareInstanceDrawer = (function (_super) {
        __extends(OneToManyHardwareInstanceDrawer, _super);
        function OneToManyHardwareInstanceDrawer() {
            _super.call(this);
            this._geometry = null;
        }
        OneToManyHardwareInstanceDrawer.getInstance = function () { };
        OneToManyHardwareInstanceDrawer.prototype.draw = function (geometry, instanceBuffer, program, buffers, drawMode) {
            var indexBuffer = null, offsetLocationArr = null;
            this._geometry = geometry;
            offsetLocationArr = this.getOffsetLocationArray(program, instanceBuffer);
            this.setCapacity(instanceBuffer);
            this.sendGLSLData(instanceBuffer, offsetLocationArr);
            indexBuffer = buffers.getChild(wd.EBufferDataType.INDICE);
            this.drawElementsInstancedANGLE(indexBuffer, this._geometry.instanceCount, drawMode);
            this.unBind(instanceBuffer, offsetLocationArr);
            if (this._geometry.dirty) {
                this._geometry.dirty = false;
            }
        };
        OneToManyHardwareInstanceDrawer.prototype.getOffsetLocationArray = function (program, instanceBuffer) {
            return this._geometry.instanceAttributeData.map(function (attributeData) {
                return program.getAttribLocation(attributeData.attributeName);
            }).toArray();
        };
        OneToManyHardwareInstanceDrawer.prototype.setCapacity = function (instanceBuffer) {
            instanceBuffer.setCapacity(this._geometry.instanceCount * this._getStride(instanceBuffer));
        };
        OneToManyHardwareInstanceDrawer.prototype.sendGLSLData = function (instanceBuffer, offsetLocationArr) {
            var attributeArrayForInstance = new Float32Array(instanceBuffer.float32InstanceArraySize), offset = 0, attributeData = this._geometry.attributeData, instanceAttributeData = this._geometry.instanceAttributeData, gl = wd.DeviceManager.getInstance().gl, extension = wd.GPUDetector.getInstance().extensionInstancedArrays;
            if (this._geometry.dirty) {
                attributeData.forEach(function (instanceAttributeDataList) {
                    instanceAttributeDataList.forEach(function (data) {
                        attributeArrayForInstance.set(data.data, offset);
                        offset += data.data.length;
                    });
                });
                instanceBuffer.resetData(attributeArrayForInstance);
            }
            else {
                instanceBuffer.bindBuffer();
            }
            var stride = this._getStride(instanceBuffer);
            offset = 0;
            instanceAttributeData.forEach(function (attributeData, index) {
                var offsetLocation = offsetLocationArr[index], attributeDataLength = attributeData.data.length;
                gl.enableVertexAttribArray(offsetLocation);
                gl.vertexAttribPointer(offsetLocation, attributeDataLength, gl.FLOAT, false, stride, offset);
                extension.vertexAttribDivisorANGLE(offsetLocation, attributeData.meshPerAttribute);
                offset += 4 * attributeDataLength;
            });
        };
        OneToManyHardwareInstanceDrawer.prototype._getStride = function (instanceBuffer) {
            var stride = 0;
            this._geometry.instanceAttributeData.forEach(function (attributeData) {
                stride += 4 * attributeData.data.length;
            });
            return stride;
        };
        __decorate([
            wd.require(function (geometry, instanceBuffer, program, buffers, drawMode) {
                wd.it("hardware should support instance", function () {
                    wd.expect(wd.InstanceUtils.isHardwareSupport()).true;
                });
                wd.it("indexBuffer should exist", function () {
                    wd.expect(buffers.getChild(wd.EBufferDataType.INDICE)).exist;
                });
            })
        ], OneToManyHardwareInstanceDrawer.prototype, "draw", null);
        __decorate([
            wd.require(function (program, instanceBuffer) {
                var _this = this;
                wd.it("if cached, should geometry.dirty === false && has cache data", function () {
                    if (!_this._geometry.dirty) {
                        wd.expect(instanceBuffer.getCache("offsetLocationArray")).exist;
                    }
                });
            }),
            wd.cache(function (program, instanceBuffer) {
                return !this._geometry.dirty;
            }, function (program, instanceBuffer) {
                return instanceBuffer.getCache("offsetLocationArray");
            }, function (result, program, instanceBuffer) {
                instanceBuffer.addCache("offsetLocationArray", result);
            })
        ], OneToManyHardwareInstanceDrawer.prototype, "getOffsetLocationArray", null);
        __decorate([
            wd.require(function (instanceBuffer) {
                var _this = this;
                wd.it("if cached, should geometry.dirty === false && has cache data", function () {
                    if (!_this._geometry.dirty) {
                        wd.expect(instanceBuffer.getCache("stride")).exist;
                    }
                });
            }),
            wd.cache(function (instanceBuffer) {
                return !this._geometry.dirty;
            }, function (instanceBuffer) {
                return instanceBuffer.getCache("stride");
            }, function (result, instanceBuffer) {
                instanceBuffer.addCache("stride", result);
            })
        ], OneToManyHardwareInstanceDrawer.prototype, "_getStride", null);
        OneToManyHardwareInstanceDrawer = __decorate([
            wd.singleton()
        ], OneToManyHardwareInstanceDrawer);
        return OneToManyHardwareInstanceDrawer;
    }(wd.HardwareInstanceDrawer));
    wd.OneToManyHardwareInstanceDrawer = OneToManyHardwareInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelMatrixHardwareInstanceDrawer = (function (_super) {
        __extends(ModelMatrixHardwareInstanceDrawer, _super);
        function ModelMatrixHardwareInstanceDrawer() {
            _super.call(this);
        }
        ModelMatrixHardwareInstanceDrawer.getInstance = function () { };
        ModelMatrixHardwareInstanceDrawer.prototype.getOffsetLocationArray = function (program) {
            return [program.getAttribLocation("a_mVec4_0"), program.getAttribLocation("a_mVec4_1"), program.getAttribLocation("a_mVec4_2"), program.getAttribLocation("a_mVec4_3")];
        };
        ModelMatrixHardwareInstanceDrawer.prototype.setCapacity = function (instanceList, instanceBuffer) {
            instanceBuffer.setCapacity(instanceList.getCount() * 64);
        };
        ModelMatrixHardwareInstanceDrawer.prototype.sendGLSLData = function (instanceList, instanceBuffer, offsetLocationArr) {
            var matricesArrayForInstance = new Float32Array(instanceBuffer.float32InstanceArraySize), offset = 0, gl = wd.DeviceManager.getInstance().gl, extension = wd.GPUDetector.getInstance().extensionInstancedArrays;
            instanceList.forEach(function (instance) {
                var mMatrix = instance.transform.localToWorldMatrix;
                mMatrix.cloneToArray(matricesArrayForInstance, offset);
                offset += 16;
            });
            instanceBuffer.resetData(matricesArrayForInstance);
            for (var index = 0; index < 4; index++) {
                var offsetLocation = offsetLocationArr[index];
                gl.enableVertexAttribArray(offsetLocation);
                gl.vertexAttribPointer(offsetLocation, 4, gl.FLOAT, false, 4 * 4 * 4, index * 16);
                extension.vertexAttribDivisorANGLE(offsetLocation, 1);
            }
        };
        ModelMatrixHardwareInstanceDrawer = __decorate([
            wd.singleton()
        ], ModelMatrixHardwareInstanceDrawer);
        return ModelMatrixHardwareInstanceDrawer;
    }(wd.OneToOneHardwareInstanceDrawer));
    wd.ModelMatrixHardwareInstanceDrawer = ModelMatrixHardwareInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMatrixModelMatrixHardwareInstanceDrawer = (function (_super) {
        __extends(NormalMatrixModelMatrixHardwareInstanceDrawer, _super);
        function NormalMatrixModelMatrixHardwareInstanceDrawer() {
            _super.call(this);
        }
        NormalMatrixModelMatrixHardwareInstanceDrawer.getInstance = function () { };
        NormalMatrixModelMatrixHardwareInstanceDrawer.prototype.getOffsetLocationArray = function (program) {
            return [
                program.getAttribLocation("a_mVec4_0"), program.getAttribLocation("a_mVec4_1"), program.getAttribLocation("a_mVec4_2"), program.getAttribLocation("a_mVec4_3"),
                program.getAttribLocation("a_normalVec4_0"), program.getAttribLocation("a_normalVec4_1"), program.getAttribLocation("a_normalVec4_2")
            ];
        };
        NormalMatrixModelMatrixHardwareInstanceDrawer.prototype.setCapacity = function (instanceList, instanceBuffer) {
            instanceBuffer.setCapacity(instanceList.getCount() * 112);
        };
        NormalMatrixModelMatrixHardwareInstanceDrawer.prototype.sendGLSLData = function (instanceList, instanceBuffer, offsetLocationArr) {
            var matricesArrayForInstance = new Float32Array(instanceBuffer.float32InstanceArraySize), offset = 0, gl = wd.DeviceManager.getInstance().gl, extension = wd.GPUDetector.getInstance().extensionInstancedArrays;
            instanceList.forEach(function (instance) {
                var mMatrix = instance.transform.localToWorldMatrix, normalMatrix = instance.transform.normalMatrix;
                mMatrix.cloneToArray(matricesArrayForInstance, offset);
                offset += 16;
                normalMatrix.cloneToArray(matricesArrayForInstance, offset);
                offset += 9;
            });
            instanceBuffer.resetData(matricesArrayForInstance);
            for (var index = 0; index < 4; index++) {
                var offsetLocation = offsetLocationArr[index];
                gl.enableVertexAttribArray(offsetLocation);
                gl.vertexAttribPointer(offsetLocation, 4, gl.FLOAT, false, 100, index * 16);
                extension.vertexAttribDivisorANGLE(offsetLocation, 1);
            }
            for (var index = 4; index < 7; index++) {
                var offsetLocation = offsetLocationArr[index];
                gl.enableVertexAttribArray(offsetLocation);
                gl.vertexAttribPointer(offsetLocation, 3, gl.FLOAT, false, 100, (index - 4) * 12 + 64);
                extension.vertexAttribDivisorANGLE(offsetLocation, 1);
            }
        };
        NormalMatrixModelMatrixHardwareInstanceDrawer = __decorate([
            wd.singleton()
        ], NormalMatrixModelMatrixHardwareInstanceDrawer);
        return NormalMatrixModelMatrixHardwareInstanceDrawer;
    }(wd.OneToOneHardwareInstanceDrawer));
    wd.NormalMatrixModelMatrixHardwareInstanceDrawer = NormalMatrixModelMatrixHardwareInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BatchInstanceCommand = (function (_super) {
        __extends(BatchInstanceCommand, _super);
        function BatchInstanceCommand() {
            _super.apply(this, arguments);
            this.glslData = null;
        }
        return BatchInstanceCommand;
    }(wd.InstanceCommand));
    wd.BatchInstanceCommand = BatchInstanceCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToOneBatchInstanceCommand = (function (_super) {
        __extends(OneToOneBatchInstanceCommand, _super);
        function OneToOneBatchInstanceCommand() {
            _super.apply(this, arguments);
            this.instanceList = null;
        }
        OneToOneBatchInstanceCommand.create = function () {
            var obj = new this();
            return obj;
        };
        OneToOneBatchInstanceCommand.prototype.draw = function (material) {
            var drawer = null;
            if (!this._hasInstance()) {
                return;
            }
            this.webglState.setState(material);
            switch (this.glslData) {
                case wd.EInstanceGLSLData.MODELMATRIX:
                    drawer = wd.ModelMatrixBatchInstanceDrawer.getInstance();
                    break;
                case wd.EInstanceGLSLData.NORMALMATRIX_MODELMATRIX:
                    drawer = wd.NormalMatrixModelMatrixBatchInstanceDrawer.getInstance();
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("glslData:" + this.glslData));
                    break;
            }
            drawer.draw(this.instanceList, this.program, this.buffers, this.drawMode);
        };
        OneToOneBatchInstanceCommand.prototype._hasInstance = function () {
            return !!this.instanceList && this.instanceList.getCount() > 0;
        };
        __decorate([
            wd.ensure(function (hasInstance) {
                wd.assert(wd.JudgeUtils.isBoolean(hasInstance), wd.Log.info.FUNC_SHOULD("return boolean value"));
                if (hasInstance) {
                    wd.assert(!wd.InstanceUtils.isHardwareSupport(), wd.Log.info.FUNC_SHOULD_NOT("hardware", "support instance"));
                }
            })
        ], OneToOneBatchInstanceCommand.prototype, "_hasInstance", null);
        return OneToOneBatchInstanceCommand;
    }(wd.BatchInstanceCommand));
    wd.OneToOneBatchInstanceCommand = OneToOneBatchInstanceCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToManyBatchInstanceCommand = (function (_super) {
        __extends(OneToManyBatchInstanceCommand, _super);
        function OneToManyBatchInstanceCommand() {
            _super.apply(this, arguments);
            this.geometry = null;
        }
        OneToManyBatchInstanceCommand.create = function () {
            var obj = new this();
            return obj;
        };
        OneToManyBatchInstanceCommand.prototype.draw = function (material) {
            var drawer = null;
            drawer = wd.OneToManyBatchInstanceDrawer.getInstance();
            drawer.draw(this.geometry, this.program, this.buffers, this.drawMode);
        };
        return OneToManyBatchInstanceCommand;
    }(wd.BatchInstanceCommand));
    wd.OneToManyBatchInstanceCommand = OneToManyBatchInstanceCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BatchInstanceDrawer = (function (_super) {
        __extends(BatchInstanceDrawer, _super);
        function BatchInstanceDrawer() {
            _super.apply(this, arguments);
        }
        return BatchInstanceDrawer;
    }(wd.InstanceDrawer));
    wd.BatchInstanceDrawer = BatchInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToOneBatchInstanceDrawer = (function (_super) {
        __extends(OneToOneBatchInstanceDrawer, _super);
        function OneToOneBatchInstanceDrawer() {
            _super.apply(this, arguments);
        }
        OneToOneBatchInstanceDrawer.prototype.draw = function (instanceList, program, buffers, drawMode) {
            var _this = this;
            var indexBuffer = null, uniformDataNameArr = null, gl = wd.DeviceManager.getInstance().gl;
            uniformDataNameArr = this.getUniformDataNameArray(program);
            indexBuffer = buffers.getChild(wd.EBufferDataType.INDICE);
            if (indexBuffer) {
                wd.BufferTable.bindIndexBuffer(indexBuffer);
                instanceList.forEach(function (instance) {
                    var startOffset = 0;
                    _this.sendGLSLData(program, instance, uniformDataNameArr);
                    wd.GlUtils.drawElements(gl[drawMode], indexBuffer.count, gl[indexBuffer.type], indexBuffer.typeSize * startOffset);
                }, this);
            }
            else {
                var vertexBuffer_1 = buffers.getChild(wd.EBufferDataType.VERTICE);
                instanceList.forEach(function (instance) {
                    var startOffset = 0;
                    _this.sendGLSLData(program, instance, uniformDataNameArr);
                    wd.GlUtils.drawArrays(gl[drawMode], startOffset, vertexBuffer_1.count);
                }, this);
            }
        };
        __decorate([
            wd.require(function (instanceList, program, buffers, drawMode) {
                wd.it("hardware shouldn't support instance", function () {
                    wd.expect(wd.InstanceUtils.isHardwareSupport()).false;
                });
            })
        ], OneToOneBatchInstanceDrawer.prototype, "draw", null);
        return OneToOneBatchInstanceDrawer;
    }(wd.BatchInstanceDrawer));
    wd.OneToOneBatchInstanceDrawer = OneToOneBatchInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var OneToManyBatchInstanceDrawer = (function (_super) {
        __extends(OneToManyBatchInstanceDrawer, _super);
        function OneToManyBatchInstanceDrawer() {
            _super.call(this);
            this._geometry = null;
        }
        OneToManyBatchInstanceDrawer.getInstance = function () { };
        OneToManyBatchInstanceDrawer.prototype.draw = function (geometry, program, buffers, drawMode) {
            var _this = this;
            var indexBuffer = null, startOffset = null, gl = wd.DeviceManager.getInstance().gl;
            this._geometry = geometry;
            indexBuffer = buffers.getChild(wd.EBufferDataType.INDICE);
            wd.BufferTable.bindIndexBuffer(indexBuffer);
            this._geometry.attributeData.forEach(function (instanceAttributeDataList) {
                _this.sendGLSLData(program, instanceAttributeDataList);
                startOffset = 0;
                wd.GlUtils.drawElements(gl[drawMode], indexBuffer.count, gl[indexBuffer.type], indexBuffer.typeSize * startOffset);
            }, this);
        };
        OneToManyBatchInstanceDrawer.prototype.sendGLSLData = function (program, instanceAttributeDataList) {
            var _this = this;
            instanceAttributeDataList.forEach(function (data) {
                var d = data.data;
                program.sendUniformData(data.attributeName, _this._getVariableType(d.length), d);
            });
        };
        OneToManyBatchInstanceDrawer.prototype._getVariableType = function (size) {
            switch (size) {
                case 1:
                    return wd.EVariableType.FLOAT_1;
                case 2:
                    return wd.EVariableType.FLOAT_2;
                case 3:
                    return wd.EVariableType.FLOAT_3;
                case 4:
                    return wd.EVariableType.FLOAT_4;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("size:" + size));
                    break;
            }
        };
        __decorate([
            wd.require(function (geometry, program, buffers, drawMode) {
                wd.it("hardware shouldn't support instance", function () {
                    wd.expect(wd.InstanceUtils.isHardwareSupport()).false;
                });
                wd.it("indexBuffer should exist", function () {
                    wd.expect(buffers.getChild(wd.EBufferDataType.INDICE)).exist;
                });
            })
        ], OneToManyBatchInstanceDrawer.prototype, "draw", null);
        OneToManyBatchInstanceDrawer = __decorate([
            wd.singleton()
        ], OneToManyBatchInstanceDrawer);
        return OneToManyBatchInstanceDrawer;
    }(wd.BatchInstanceDrawer));
    wd.OneToManyBatchInstanceDrawer = OneToManyBatchInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelMatrixBatchInstanceDrawer = (function (_super) {
        __extends(ModelMatrixBatchInstanceDrawer, _super);
        function ModelMatrixBatchInstanceDrawer() {
            _super.call(this);
        }
        ModelMatrixBatchInstanceDrawer.getInstance = function () { };
        ModelMatrixBatchInstanceDrawer.prototype.getUniformDataNameArray = function (program) {
            return ["u_mMatrix"];
        };
        ModelMatrixBatchInstanceDrawer.prototype.sendGLSLData = function (program, instance, _a) {
            var modelMatrixUniformDataName = _a[0];
            program.sendUniformData(modelMatrixUniformDataName, wd.EVariableType.FLOAT_MAT4, instance.transform.localToWorldMatrix);
        };
        ModelMatrixBatchInstanceDrawer = __decorate([
            wd.singleton()
        ], ModelMatrixBatchInstanceDrawer);
        return ModelMatrixBatchInstanceDrawer;
    }(wd.OneToOneBatchInstanceDrawer));
    wd.ModelMatrixBatchInstanceDrawer = ModelMatrixBatchInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMatrixModelMatrixBatchInstanceDrawer = (function (_super) {
        __extends(NormalMatrixModelMatrixBatchInstanceDrawer, _super);
        function NormalMatrixModelMatrixBatchInstanceDrawer() {
            _super.call(this);
        }
        NormalMatrixModelMatrixBatchInstanceDrawer.getInstance = function () { };
        NormalMatrixModelMatrixBatchInstanceDrawer.prototype.getUniformDataNameArray = function (program) {
            return ["u_mMatrix", "u_normalMatrix"];
        };
        NormalMatrixModelMatrixBatchInstanceDrawer.prototype.sendGLSLData = function (program, instance, _a) {
            var modelMatrixUniformDataName = _a[0], normalMatrixUniformDataName = _a[1];
            program.sendUniformData(modelMatrixUniformDataName, wd.EVariableType.FLOAT_MAT4, instance.transform.localToWorldMatrix);
            program.sendUniformData(normalMatrixUniformDataName, wd.EVariableType.FLOAT_MAT3, instance.transform.normalMatrix);
        };
        NormalMatrixModelMatrixBatchInstanceDrawer = __decorate([
            wd.singleton()
        ], NormalMatrixModelMatrixBatchInstanceDrawer);
        return NormalMatrixModelMatrixBatchInstanceDrawer;
    }(wd.OneToOneBatchInstanceDrawer));
    wd.NormalMatrixModelMatrixBatchInstanceDrawer = NormalMatrixModelMatrixBatchInstanceDrawer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GlUtils = (function () {
        function GlUtils() {
        }
        GlUtils.drawElements = function (mode, count, type, offset) {
            var DebugStatistics = wd.ClassUtils.getClass("DebugStatistics");
            if (!!DebugStatistics) {
                DebugStatistics.count.drawCalls++;
                DebugStatistics.count.renderGameObjects++;
            }
            this._getGl().drawElements(mode, count, type, offset);
        };
        GlUtils.drawArrays = function (mode, first, count) {
            var DebugStatistics = wd.ClassUtils.getClass("DebugStatistics");
            if (!!DebugStatistics) {
                DebugStatistics.count.drawCalls++;
                DebugStatistics.count.renderGameObjects++;
            }
            this._getGl().drawArrays(mode, first, count);
        };
        GlUtils.drawElementsInstancedANGLE = function (mode, count, type, offset, instancesCount) {
            var extension = wd.GPUDetector.getInstance().extensionInstancedArrays, DebugStatistics = wd.ClassUtils.getClass("DebugStatistics");
            if (!!DebugStatistics) {
                DebugStatistics.count.drawCalls++;
                DebugStatistics.count.renderGameObjects += instancesCount;
            }
            extension.drawElementsInstancedANGLE(mode, count, type, offset, instancesCount);
        };
        GlUtils.drawArraysInstancedANGLE = function (mode, startOffset, count, instancesCount) {
            var extension = wd.GPUDetector.getInstance().extensionInstancedArrays, DebugStatistics = wd.ClassUtils.getClass("DebugStatistics");
            if (!!DebugStatistics) {
                DebugStatistics.count.drawCalls++;
                DebugStatistics.count.renderGameObjects += instancesCount;
            }
            extension.drawArraysInstancedANGLE(mode, startOffset, count, instancesCount);
        };
        GlUtils._getGl = function () {
            return wd.DeviceManager.getInstance().gl;
        };
        return GlUtils;
    }());
    wd.GlUtils = GlUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FrameBuffer = (function () {
        function FrameBuffer(width, height) {
            this.width = null;
            this.height = null;
            this._originScissorTest = null;
            this._glTarget = null;
            this.width = width;
            this.height = height;
        }
        FrameBuffer.create = function (width, height) {
            var obj = new this(width, height);
            return obj;
        };
        Object.defineProperty(FrameBuffer.prototype, "gl", {
            get: function () {
                return wd.DeviceManager.getInstance().gl;
            },
            enumerable: true,
            configurable: true
        });
        FrameBuffer.prototype.createFrameBuffer = function () {
            return this.gl.createFramebuffer();
        };
        FrameBuffer.prototype.bindFrameBuffer = function (buffer) {
            var gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);
        };
        FrameBuffer.prototype.setViewport = function () {
            var deviceManager = wd.DeviceManager.getInstance();
            deviceManager.setViewport(0, 0, this.width, this.height);
            this._originScissorTest = deviceManager.scissorTest;
            deviceManager.scissorTest = false;
        };
        FrameBuffer.prototype.restoreViewport = function () {
            var deviceManager = wd.DeviceManager.getInstance(), view = deviceManager.view;
            deviceManager.setViewport(0, 0, view.width, view.height);
            deviceManager.scissorTest = this._originScissorTest;
        };
        FrameBuffer.prototype.dispose = function () {
            this.unBindAll();
        };
        FrameBuffer.prototype.unBindAll = function () {
            var gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        };
        FrameBuffer.prototype.unBindFrameBuffer = function () {
            var gl = this.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        };
        FrameBuffer.prototype.createRenderBuffer = function () {
            var gl = this.gl, renderBuffer = gl.createRenderbuffer();
            return renderBuffer;
        };
        FrameBuffer.prototype.attachTexture = function (glTarget, texture, attachType) {
            if (attachType === void 0) { attachType = wd.EFrameBufferAttachType.COLOR_ATTACHMENT0; }
            var gl = this.gl;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl[attachType], glTarget, texture, 0);
            this._glTarget = glTarget;
        };
        FrameBuffer.prototype.attachRenderBuffer = function (type, renderBuffer) {
            var gl = this.gl;
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl[type], gl.RENDERBUFFER, renderBuffer);
        };
        FrameBuffer.prototype.check = function () {
            var gl = this.gl, e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (e !== gl.FRAMEBUFFER_COMPLETE) {
                wd.Log.error(true, "Frame buffer object is incomplete:" + e.toString());
            }
        };
        __decorate([
            wd.ensure(function () {
                var deviceManager = wd.DeviceManager.getInstance();
                wd.assert(deviceManager.scissorTest !== null, wd.Log.info.FUNC_SHOULD_NOT("DeviceManager->scissorTest", "be null"));
            })
        ], FrameBuffer.prototype, "restoreViewport", null);
        __decorate([
            wd.require(function () {
            })
        ], FrameBuffer.prototype, "unBindAll", null);
        __decorate([
            wd.ensure(function (renderBuffer) {
                wd.assert(!!renderBuffer, wd.Log.info.FUNC_NOT_EXIST("renderbuffer object"));
            })
        ], FrameBuffer.prototype, "createRenderBuffer", null);
        return FrameBuffer;
    }());
    wd.FrameBuffer = FrameBuffer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EFrameBufferAttachType) {
        EFrameBufferAttachType[EFrameBufferAttachType["COLOR_ATTACHMENT0"] = "COLOR_ATTACHMENT0"] = "COLOR_ATTACHMENT0";
        EFrameBufferAttachType[EFrameBufferAttachType["DEPTH_ATTACHMENT"] = "DEPTH_ATTACHMENT"] = "DEPTH_ATTACHMENT";
    })(wd.EFrameBufferAttachType || (wd.EFrameBufferAttachType = {}));
    var EFrameBufferAttachType = wd.EFrameBufferAttachType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Shader = (function () {
        function Shader() {
            this._attributes = wdCb.Hash.create();
            this._uniforms = wdCb.Hash.create();
            this._vsSource = "";
            this._fsSource = "";
            this.libDirty = false;
            this.definitionDataDirty = false;
            this.mapManager = wd.MapManager.create();
            this.libs = wdCb.Collection.create();
            this.sourceBuilder = this.createShaderSourceBuilder();
            this._programCache = null;
            this._instanceStateCache = null;
        }
        Object.defineProperty(Shader.prototype, "attributes", {
            get: function () {
                return this._attributes;
            },
            set: function (attributes) {
                if (this._isNotEqual(attributes, this._attributes)) {
                    this.definitionDataDirty = true;
                }
                this._attributes = attributes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shader.prototype, "uniforms", {
            get: function () {
                return this._uniforms;
            },
            set: function (uniforms) {
                if (this._isNotEqual(uniforms, this._uniforms)) {
                    this.definitionDataDirty = true;
                }
                this._uniforms = uniforms;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shader.prototype, "vsSource", {
            get: function () {
                return this._vsSource;
            },
            set: function (vsSource) {
                if (vsSource !== this._vsSource) {
                    this.definitionDataDirty = true;
                }
                this._vsSource = vsSource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shader.prototype, "fsSource", {
            get: function () {
                return this._fsSource;
            },
            set: function (fsSource) {
                if (fsSource !== this._fsSource) {
                    this.definitionDataDirty = true;
                }
                this._fsSource = fsSource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shader.prototype, "dirty", {
            get: function () {
                return this.libDirty || this.definitionDataDirty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shader.prototype, "program", {
            get: function () {
                return wd.ProgramTable.getProgram(this._getProgramTableKey());
            },
            enumerable: true,
            configurable: true
        });
        Shader.prototype.createVsShader = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            return this._initShader(gl.createShader(gl.VERTEX_SHADER), this.vsSource);
        };
        Shader.prototype.createFsShader = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            return this._initShader(gl.createShader(gl.FRAGMENT_SHADER), this.fsSource);
        };
        Shader.prototype.init = function (material) {
            this.libs.forEach(function (lib) {
                lib.init();
            });
            this.judgeRefreshShader(null, material);
            this.mapManager.init();
        };
        Shader.prototype.dispose = function () {
            this.attributes.removeAllChildren();
            this.uniforms.removeAllChildren();
            this.libs.forEach(function (lib) {
                lib.dispose();
            });
            this.mapManager.dispose();
            this._clearAllCache();
        };
        Shader.prototype.hasLib = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (args[0] instanceof wd.ShaderLib) {
                var lib = args[0];
                return this.libs.hasChild(lib);
            }
            else {
                var _class_2 = args[0];
                return this.libs.hasChildWithFunc(function (lib) {
                    return lib instanceof _class_2;
                });
            }
        };
        Shader.prototype.addLib = function (lib) {
            this.libs.addChild(lib);
            lib.shader = this;
            this.libDirty = true;
        };
        Shader.prototype.addShaderLibToTop = function (lib) {
            this.libs.unShiftChild(lib);
            lib.shader = this;
            this.libDirty = true;
        };
        Shader.prototype.getLib = function (libClass) {
            return this.libs.findOne(function (lib) {
                return lib instanceof libClass;
            });
        };
        Shader.prototype.getLibs = function () {
            return this.libs;
        };
        Shader.prototype.removeLib = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.libDirty = true;
            return this.libs.removeChild(args[0]);
        };
        Shader.prototype.removeAllLibs = function () {
            this.libDirty = true;
            this.libs.removeAllChildren();
        };
        Shader.prototype.sortLib = function (func) {
            this.libDirty = true;
            this.libs.sort(func, true);
        };
        Shader.prototype.getInstanceState = function () {
            var isModelMatrixInstance = false, isNormalMatrixInstance = false, isHardwareInstance = false, isBatchInstance = false;
            this.libs.forEach(function (lib) {
                if (!(lib instanceof wd.InstanceShaderLib)) {
                    return;
                }
                if (lib instanceof wd.NormalMatrixHardwareInstanceShaderLib) {
                    isNormalMatrixInstance = true;
                    isHardwareInstance = true;
                    return wdCb.$BREAK;
                }
                if (lib instanceof wd.NormalMatrixBatchInstanceShaderLib) {
                    isNormalMatrixInstance = true;
                    isBatchInstance = true;
                    return wdCb.$BREAK;
                }
                if (lib instanceof wd.ModelMatrixHardwareInstanceShaderLib) {
                    isModelMatrixInstance = true;
                    isHardwareInstance = true;
                    return;
                }
                if (lib instanceof wd.ModelMatrixBatchInstanceShaderLib) {
                    isModelMatrixInstance = true;
                    isBatchInstance = true;
                    return;
                }
            });
            return {
                isModelMatrixInstance: isModelMatrixInstance,
                isNormalMatrixInstance: isNormalMatrixInstance,
                isHardwareInstance: isHardwareInstance,
                isBatchInstance: isBatchInstance
            };
        };
        Shader.prototype.judgeRefreshShader = function (cmd, material) {
            if (this.libDirty) {
                this._instanceStateCache = null;
                this.buildDefinitionData(cmd, material);
            }
            if (this.definitionDataDirty) {
                this._programCache = null;
                this._registerAndUpdateProgram();
                this._programCache = null;
            }
            this.libDirty = false;
            this.definitionDataDirty = false;
        };
        Shader.prototype._registerAndUpdateProgram = function () {
            var key = this._getProgramTableKey();
            if (wd.ProgramTable.hasProgram(key)) {
                return;
            }
            wd.ProgramTable.addProgram(key, wd.Program.create());
            this._updateProgram();
        };
        Shader.prototype._updateProgram = function () {
            this.program.initWithShader(this);
        };
        Shader.prototype._getProgramTableKey = function () {
            return this.vsSource + "\n" + this.fsSource;
        };
        Shader.prototype._initShader = function (shader, source) {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                return shader;
            }
            else {
                wd.Log.log(gl.getShaderInfoLog(shader));
                wd.Log.log("attributes:\n", this.attributes);
                wd.Log.log("uniforms:\n", this.uniforms);
                wd.Log.log("source:\n", source);
            }
        };
        Shader.prototype._isNotEqual = function (list1, list2) {
            var result = false;
            list1.forEach(function (data, key) {
                var list2Data = list2.getChild(key);
                if (!list2Data || data.type !== list2Data.type || data.value !== list2Data.value) {
                    result = true;
                    return wdCb.$BREAK;
                }
            });
            return result;
        };
        Shader.prototype._clearAllCache = function () {
            this._programCache = null;
            this._instanceStateCache = null;
        };
        __decorate([
            wd.ensureGetter(function (program) {
                wd.it("program should exist(its table key is " + this._getProgramTableKey(), function () {
                    wd.expect(program).exist;
                }, this);
            }),
            wd.cacheGetter(function () {
                return this._programCache !== null;
            }, function () {
                return this._programCache;
            }, function (program) {
                this._programCache = program;
            })
        ], Shader.prototype, "program", null);
        __decorate([
            wd.execOnlyOnce("_isInit")
        ], Shader.prototype, "init", null);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("should set ShaderLib.shader to be this", function () {
                    _this.libs.forEach(function (lib) {
                        wd.expect(lib.shader === _this).true;
                    });
                }, this);
                wd.it("libDirty should be true", function () {
                    wd.expect(_this.libDirty).true;
                }, this);
            })
        ], Shader.prototype, "addLib", null);
        __decorate([
            wd.ensure(function (val, lib) {
                var _this = this;
                wd.it("should add shader lib to the top", function () {
                    wd.expect(wd.JudgeUtils.isEqual(lib, _this.libs.getChild(0))).true;
                }, this);
                wd.it("should set ShaderLib.shader to be this", function () {
                    _this.libs.forEach(function (lib) {
                        wd.expect(lib.shader === _this).true;
                    });
                }, this);
                wd.it("libDirty should be true", function () {
                    wd.expect(_this.libDirty).true;
                }, this);
            })
        ], Shader.prototype, "addShaderLibToTop", null);
        __decorate([
            wd.ensure(function (_a) {
                var isModelMatrixInstance = _a.isModelMatrixInstance, isNormalMatrixInstance = _a.isNormalMatrixInstance, isHardwareInstance = _a.isHardwareInstance, isBatchInstance = _a.isBatchInstance;
                if (isNormalMatrixInstance) {
                    wd.it("if is normalMatrixInstance, should also be modelMatrixInstance", function () {
                        wd.expect(isModelMatrixInstance).true;
                    });
                }
                wd.it("shouldn't both be hardware insstance and batch instance", function () {
                    wd.expect(isHardwareInstance && isBatchInstance).false;
                });
            }),
            wd.cache(function () {
                return this._instanceStateCache;
            }, function () {
                return this._instanceStateCache;
            }, function (instanceState) {
                this._instanceStateCache = instanceState;
            })
        ], Shader.prototype, "getInstanceState", null);
        return Shader;
    }());
    wd.Shader = Shader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomShader = (function (_super) {
        __extends(CustomShader, _super);
        function CustomShader() {
            _super.apply(this, arguments);
        }
        CustomShader.create = function () {
            var obj = new this();
            return obj;
        };
        CustomShader.prototype.update = function (cmd, material) {
            var program = null;
            this.judgeRefreshShader(cmd, material);
            program = this.program;
            program.use();
            this.libs.forEach(function (lib) {
                lib.sendShaderVariables(program, cmd, material);
            });
            this.mapManager.bindAndUpdate();
            this.mapManager.sendData(program);
        };
        CustomShader.prototype.read = function (definitionData) {
            this.sourceBuilder.clearShaderDefinition();
            this.sourceBuilder.read(definitionData);
            this.libDirty = true;
        };
        CustomShader.prototype.getSampler2DUniformsAfterRead = function () {
            return this.sourceBuilder.uniforms.filter(function (uniform, name) {
                return uniform.type === wd.EVariableType.SAMPLER_2D;
            });
        };
        CustomShader.prototype.buildDefinitionData = function (cmd, material) {
            this.sourceBuilder.build();
            this.attributes = this.sourceBuilder.attributes;
            this.uniforms = this.sourceBuilder.uniforms;
            this.vsSource = this.sourceBuilder.vsSource;
            this.fsSource = this.sourceBuilder.fsSource;
        };
        CustomShader.prototype.createShaderSourceBuilder = function () {
            return wd.CustomShaderSourceBuilder.create();
        };
        return CustomShader;
    }(wd.Shader));
    wd.CustomShader = CustomShader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EngineShader = (function (_super) {
        __extends(EngineShader, _super);
        function EngineShader() {
            _super.apply(this, arguments);
        }
        EngineShader.prototype.buildDefinitionData = function (cmd, material) {
            this.libs.forEach(function (lib) {
                lib.setShaderDefinition(cmd, material);
            });
            this.sourceBuilder.clearShaderDefinition();
            this.sourceBuilder.build(this.libs);
            this.attributes = this.sourceBuilder.attributes;
            this.uniforms = this.sourceBuilder.uniforms;
            this.vsSource = this.sourceBuilder.vsSource;
            this.fsSource = this.sourceBuilder.fsSource;
        };
        EngineShader.prototype.createShaderSourceBuilder = function () {
            return wd.EngineShaderSourceBuilder.create();
        };
        return EngineShader;
    }(wd.Shader));
    wd.EngineShader = EngineShader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonShader = (function (_super) {
        __extends(CommonShader, _super);
        function CommonShader() {
            _super.apply(this, arguments);
        }
        CommonShader.create = function () {
            var obj = new this();
            return obj;
        };
        CommonShader.prototype.update = function (cmd, material) {
            var program = null;
            this.judgeRefreshShader(cmd, material);
            program = this.program;
            program.use();
            this.libs.forEach(function (lib) {
                lib.sendShaderVariables(program, cmd, material);
            });
            this.mapManager.bindAndUpdate();
            this.mapManager.sendData(program);
        };
        return CommonShader;
    }(wd.EngineShader));
    wd.CommonShader = CommonShader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ProceduralShader = (function (_super) {
        __extends(ProceduralShader, _super);
        function ProceduralShader() {
            _super.apply(this, arguments);
        }
        ProceduralShader.prototype.init = function () {
            this.addLib(wd.CommonProceduralShaderLib.create());
            _super.prototype.init.call(this, null);
        };
        ProceduralShader.prototype.update = function (cmd) {
            var program = null;
            this.judgeRefreshShader(cmd, null);
            program = this.program;
            program.use();
            this.libs.forEach(function (lib) {
                lib.sendShaderVariables(program, cmd);
            });
        };
        return ProceduralShader;
    }(wd.EngineShader));
    wd.ProceduralShader = ProceduralShader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonProceduralShader = (function (_super) {
        __extends(CommonProceduralShader, _super);
        function CommonProceduralShader() {
            _super.apply(this, arguments);
        }
        CommonProceduralShader.create = function () {
            var obj = new this();
            return obj;
        };
        return CommonProceduralShader;
    }(wd.ProceduralShader));
    wd.CommonProceduralShader = CommonProceduralShader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomProceduralShader = (function (_super) {
        __extends(CustomProceduralShader, _super);
        function CustomProceduralShader(texture) {
            _super.call(this);
            this._texture = null;
            this._texture = texture;
        }
        CustomProceduralShader.create = function (texture) {
            var obj = new this(texture);
            return obj;
        };
        CustomProceduralShader.prototype.update = function (cmd) {
            _super.prototype.update.call(this, cmd);
            this._texture.mapManager.bindAndUpdate();
            this._texture.mapManager.sendData(this.program);
        };
        return CustomProceduralShader;
    }(wd.ProceduralShader));
    wd.CustomProceduralShader = CustomProceduralShader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EShaderGLSLData) {
        EShaderGLSLData[EShaderGLSLData["MIRROR"] = "MIRROR"] = "MIRROR";
        EShaderGLSLData[EShaderGLSLData["DYNAMIC_CUBEMAP"] = "DYNAMIC_CUBEMAP"] = "DYNAMIC_CUBEMAP";
        EShaderGLSLData[EShaderGLSLData["REFRACTION"] = "REFRACTION"] = "REFRACTION";
        EShaderGLSLData[EShaderGLSLData["TWOD_SHADOWMAP"] = "TWOD_SHADOWMAP"] = "TWOD_SHADOWMAP";
        EShaderGLSLData[EShaderGLSLData["BUILD_CUBEMAP_SHADOWMAP"] = "BUILD_CUBEMAP_SHADOWMAP"] = "BUILD_CUBEMAP_SHADOWMAP";
        EShaderGLSLData[EShaderGLSLData["CUBEMAP_SHADOWMAP"] = "CUBEMAP_SHADOWMAP"] = "CUBEMAP_SHADOWMAP";
    })(wd.EShaderGLSLData || (wd.EShaderGLSLData = {}));
    var EShaderGLSLData = wd.EShaderGLSLData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EShaderTypeOfScene) {
        EShaderTypeOfScene[EShaderTypeOfScene["BUILD_TWOD_SHADOWMAP"] = "BUILD_TWOD_SHADOWMAP"] = "BUILD_TWOD_SHADOWMAP";
        EShaderTypeOfScene[EShaderTypeOfScene["BUILD_CUBEMAP_SHADOWMAP"] = "BUILD_CUBEMAP_SHADOWMAP"] = "BUILD_CUBEMAP_SHADOWMAP";
    })(wd.EShaderTypeOfScene || (wd.EShaderTypeOfScene = {}));
    var EShaderTypeOfScene = wd.EShaderTypeOfScene;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EShaderMapKeyOfScene) {
        EShaderMapKeyOfScene[EShaderMapKeyOfScene["BUILD_TWOD_SHADOWMAP_INSTANCE"] = "BUILD_TWOD_SHADOWMAP_INSTANCE"] = "BUILD_TWOD_SHADOWMAP_INSTANCE";
        EShaderMapKeyOfScene[EShaderMapKeyOfScene["BUILD_TWOD_SHADOWMAP_NO_INSTANCE"] = "BUILD_TWOD_SHADOWMAP_NO_INSTANCE"] = "BUILD_TWOD_SHADOWMAP_NO_INSTANCE";
        EShaderMapKeyOfScene[EShaderMapKeyOfScene["BUILD_CUBEMAP_SHADOWMAP_INSTANCE"] = "BUILD_CUBEMAP_SHADOWMAP_INSTANCE"] = "BUILD_CUBEMAP_SHADOWMAP_INSTANCE";
        EShaderMapKeyOfScene[EShaderMapKeyOfScene["BUILD_CUBEMAP_SHADOWMAP_NO_INSTANCE"] = "BUILD_CUBEMAP_SHADOWMAP_NO_INSTANCE"] = "BUILD_CUBEMAP_SHADOWMAP_NO_INSTANCE";
    })(wd.EShaderMapKeyOfScene || (wd.EShaderMapKeyOfScene = {}));
    var EShaderMapKeyOfScene = wd.EShaderMapKeyOfScene;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EShaderMapKey) {
        EShaderMapKey[EShaderMapKey["DEFAULT"] = "DEFAULT"] = "DEFAULT";
    })(wd.EShaderMapKey || (wd.EShaderMapKey = {}));
    var EShaderMapKey = wd.EShaderMapKey;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MapManager = (function () {
        function MapManager() {
            this._material = null;
            this._textureDirty = false;
            this._allMapsCache = null;
            this._allSingleMapsCache = null;
            this._shadowMapController = wd.ClassUtils.createClassInstanceOrEmpty("ShadowMapController", "EmptyShadowMapController", this);
            this._arrayMapController = wd.MapArrayController.create();
            this._envMapController = wd.EnvMapController.create();
            this._commonMapController = wd.CommonMapController.create();
        }
        MapManager.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(MapManager.prototype, "material", {
            get: function () {
                return this._material;
            },
            set: function (material) {
                this._material = material;
                this._envMapController.material = material;
                this._commonMapController.material = material;
            },
            enumerable: true,
            configurable: true
        });
        MapManager.prototype.init = function () {
            var mapArr = this._getAllMaps();
            for (var i = 0, len = mapArr.length; i < len; i++) {
                var texture = mapArr[i];
                texture.init();
            }
        };
        MapManager.prototype.addMap = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var map = null;
            if (args[0] instanceof wd.TextureAsset) {
                var asset = args[0];
                map = asset.toTexture();
            }
            else if (args[0] instanceof wd.Texture) {
                map = args[0];
            }
            if (args.length === 1) {
                this._commonMapController.addMap(map);
            }
            else {
                this._commonMapController.addMap(map, args[1]);
            }
            this._textureDirty = true;
        };
        MapManager.prototype.addMapArray = function (samplerName, mapArray) {
            this._arrayMapController.addMapArray(samplerName, mapArray);
            this._textureDirty = true;
        };
        MapManager.prototype.addTwoDShadowMap = function (shadowMap) {
            this._shadowMapController.addTwoDShadowMap(shadowMap);
            this._textureDirty = true;
        };
        MapManager.prototype.getTwoDShadowMapList = function () {
            return this._shadowMapController.getTwoDShadowMapList();
        };
        MapManager.prototype.hasTwoDShadowMap = function (shadowMap) {
            return this._shadowMapController.hasTwoDShadowMap(shadowMap);
        };
        MapManager.prototype.addCubemapShadowMap = function (shadowMap) {
            this._shadowMapController.addCubemapShadowMap(shadowMap);
            this._textureDirty = true;
        };
        MapManager.prototype.getCubemapShadowMapList = function () {
            return this._shadowMapController.getCubemapShadowMapList();
        };
        MapManager.prototype.hasCubemapShadowMap = function (shadowMap) {
            return this._shadowMapController.hasCubemapShadowMap(shadowMap);
        };
        MapManager.prototype.getMapList = function () {
            return this._commonMapController.getMapList();
        };
        MapManager.prototype.hasMap = function (map) {
            return this._commonMapController.hasMap(map);
        };
        MapManager.prototype.getMapCount = function () {
            return this.getMapList().getCount();
        };
        MapManager.prototype.getEnvMap = function () {
            return this._envMapController.getEnvMap();
        };
        MapManager.prototype.setEnvMap = function (envMap) {
            if (!envMap) {
                this._envMapController.setEnvMap(null);
                this._textureDirty = true;
                return;
            }
            this._envMapController.setEnvMap(envMap);
            this._textureDirty = true;
        };
        MapManager.prototype.removeChild = function (map) {
            for (var _i = 0, _a = this._getAllControllerArr(); _i < _a.length; _i++) {
                var controller = _a[_i];
                controller.removeChild(map);
            }
            this._textureDirty = true;
        };
        MapManager.prototype.removeAllChildren = function () {
            for (var _i = 0, _a = this._getAllControllerArr(); _i < _a.length; _i++) {
                var controller = _a[_i];
                controller.removeAllChildren();
            }
            this._textureDirty = true;
        };
        MapManager.prototype.removeAllShdaowMaps = function () {
            this._shadowMapController.removeAllChildren();
            this._textureDirty = true;
        };
        MapManager.prototype.dispose = function () {
            var mapArr = this._getAllMaps();
            for (var i = 0, len = mapArr.length; i < len; i++) {
                var texture = mapArr[i];
                texture.dispose();
            }
            this.removeAllChildren();
        };
        MapManager.prototype.bindAndUpdate = function () {
            var mapArr = this._getAllMaps();
            for (var i = 0, len = mapArr.length; i < len; i++) {
                var texture = mapArr[i];
                texture.bindToUnit(i);
                if (texture.needUpdate) {
                    texture.update(i);
                }
            }
        };
        MapManager.prototype.sendData = function (program) {
            this._sendSingleMapData(program);
            this._arrayMapController.sendMapData(program, this._getMaxUnitOfBindedSingleMap());
        };
        MapManager.prototype._sendSingleMapData = function (program) {
            var mapArr = this._getAllSingleMaps(), len = mapArr.length;
            for (var i = 0; i < len; i++) {
                var texture = mapArr[i];
                texture.sendData(program, texture.getSamplerName(i), i);
            }
        };
        MapManager.prototype._getAllMaps = function () {
            return [].concat(this._getAllSingleMaps(), this._arrayMapController.getAllMapArr());
        };
        MapManager.prototype._getMaxUnitOfBindedSingleMap = function () {
            return this._getAllSingleMaps().length;
        };
        MapManager.prototype._getAllSingleMaps = function () {
            var arr = [];
            for (var _i = 0, _a = this._getAllSingleMapControllerArr(); _i < _a.length; _i++) {
                var controller = _a[_i];
                var map = controller.getAllMapArr();
                if (map !== null) {
                    arr = arr.concat(map);
                }
            }
            return arr;
        };
        MapManager.prototype._getAllSingleMapControllerArr = function () {
            return [this._shadowMapController, this._envMapController, this._commonMapController];
        };
        MapManager.prototype._getAllControllerArr = function () {
            return [this._shadowMapController, this._envMapController, this._arrayMapController, this._commonMapController];
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.it("arguments[0] should be TextureAsset or Texture", function () {
                    wd.expect(args[0] instanceof wd.TextureAsset || args[0] instanceof wd.Texture).true;
                });
            })
        ], MapManager.prototype, "addMap", null);
        __decorate([
            wd.require(function (samplerName, mapArray) {
                wd.it("mapArray should be array", function () {
                    wd.expect(wd.JudgeUtils.isArrayExactly(mapArray)).true;
                });
                var _loop_2 = function(map) {
                    wd.it("mapArray should be Array<Texture>", function () {
                        wd.expect(map).instanceof(wd.Texture);
                    });
                };
                for (var _i = 0, mapArray_1 = mapArray; _i < mapArray_1.length; _i++) {
                    var map = mapArray_1[_i];
                    _loop_2(map);
                }
            })
        ], MapManager.prototype, "addMapArray", null);
        __decorate([
            wd.require(function (shadowMap) {
                var _this = this;
                if (!wd.JudgeUtils.isClass(this._shadowMapController, "EmptyShadowMapController")) {
                    wd.it("shouldn't add the shadowMap which is already exist", function () {
                        wd.expect(_this._shadowMapController.hasTwoDShadowMap(shadowMap)).false;
                    });
                }
            })
        ], MapManager.prototype, "addTwoDShadowMap", null);
        __decorate([
            wd.require(function (shadowMap) {
                var _this = this;
                if (!wd.JudgeUtils.isClass(this._shadowMapController, "EmptyShadowMapController")) {
                    wd.it("shouldn't add the shadowMap which is already exist", function () {
                        wd.expect(_this._shadowMapController.hasCubemapShadowMap(shadowMap)).false;
                    });
                }
            })
        ], MapManager.prototype, "addCubemapShadowMap", null);
        __decorate([
            wd.ensure(function (mapList) {
                mapList.forEach(function (map) {
                    wd.it("mapList should only contain BasicTexture or ProceduralTexture", function () {
                        wd.expect(map instanceof wd.BasicTexture || map instanceof wd.ProceduralTexture).true;
                    });
                });
            })
        ], MapManager.prototype, "getMapList", null);
        __decorate([
            wd.require(function (program) {
                var mapMap = {}, maps = this._getAllMaps();
                var _loop_3 = function(i, len) {
                    var map = maps[i], samplerName = map.getSamplerName(i);
                    wd.it("shouldn't has duplicate maps, but actual has the ones with the same samplerName:" + samplerName, function () {
                        wd.expect(mapMap[samplerName]).not.equal(1);
                    });
                    mapMap[samplerName] = 1;
                };
                for (var i = 0, len = maps.length; i < len; i++) {
                    _loop_3(i, len);
                }
            })
        ], MapManager.prototype, "sendData", null);
        __decorate([
            wd.ensure(function (mapArr) {
                var _loop_4 = function(map) {
                    wd.it("all maps should be Texture", function () {
                        wd.expect(map).instanceof(wd.Texture);
                    });
                };
                for (var _i = 0, mapArr_1 = mapArr; _i < mapArr_1.length; _i++) {
                    var map = mapArr_1[_i];
                    _loop_4(map);
                }
            }),
            wd.cache(function () {
                return !this._textureDirty && this._allMapsCache;
            }, function () {
                return this._allMapsCache;
            }, function (mapList) {
                this._allMapsCache = mapList;
                this._textureDirty = false;
            })
        ], MapManager.prototype, "_getAllMaps", null);
        __decorate([
            wd.cache(function () {
                return !this._textureDirty && this._allSingleMapsCache;
            }, function () {
                return this._allSingleMapsCache;
            }, function (mapList) {
                this._allSingleMapsCache = mapList;
                this._textureDirty = false;
            })
        ], MapManager.prototype, "_getAllSingleMaps", null);
        return MapManager;
    }());
    wd.MapManager = MapManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MapController = (function () {
        function MapController() {
        }
        MapController.prototype.hasMapHelper = function (source, target) {
            if (!source) {
                return false;
            }
            return source.hasChild(target);
        };
        MapController.prototype.setMapOption = function (map, option) {
            map.variableData = option;
        };
        return MapController;
    }());
    wd.MapController = MapController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowMapController = (function (_super) {
        __extends(ShadowMapController, _super);
        function ShadowMapController() {
            _super.apply(this, arguments);
            this._twoDShadowMapList = wdCb.Collection.create();
            this._cubemapShadowMapList = wdCb.Collection.create();
        }
        ShadowMapController.create = function () {
            var obj = new this();
            return obj;
        };
        ShadowMapController.prototype.addTwoDShadowMap = function (shadowMap) {
            this.setMapOption(shadowMap, {
                samplerData: this._twoDShadowMapList.getCount()
            });
            this._twoDShadowMapList.addChild(shadowMap);
        };
        ShadowMapController.prototype.addCubemapShadowMap = function (shadowMap) {
            this.setMapOption(shadowMap, {
                samplerData: this._cubemapShadowMapList.getCount()
            });
            this._cubemapShadowMapList.addChild(shadowMap);
        };
        ShadowMapController.prototype.hasTwoDShadowMap = function (shadowMap) {
            return this.hasMapHelper(this._twoDShadowMapList, shadowMap);
        };
        ShadowMapController.prototype.hasCubemapShadowMap = function (shadowMap) {
            return this.hasMapHelper(this._cubemapShadowMapList, shadowMap);
        };
        ShadowMapController.prototype.getTwoDShadowMapList = function () {
            return this._twoDShadowMapList;
        };
        ShadowMapController.prototype.getCubemapShadowMapList = function () {
            return this._cubemapShadowMapList;
        };
        ShadowMapController.prototype.getAllMapArr = function () {
            return this._twoDShadowMapList.clone(false).addChildren(this._cubemapShadowMapList).toArray();
        };
        ShadowMapController.prototype.removeChild = function (map) {
            this._twoDShadowMapList.removeChild(map);
            this._cubemapShadowMapList.removeChild(map);
        };
        ShadowMapController.prototype.removeAllChildren = function () {
            this._twoDShadowMapList.removeAllChildren();
            this._cubemapShadowMapList.removeAllChildren();
        };
        return ShadowMapController;
    }(wd.MapController));
    wd.ShadowMapController = ShadowMapController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EmptyShadowMapController = (function () {
        function EmptyShadowMapController() {
        }
        EmptyShadowMapController.create = function () {
            var obj = new this();
            return obj;
        };
        EmptyShadowMapController.prototype.addTwoDShadowMap = function (shadowMap) {
        };
        EmptyShadowMapController.prototype.addCubemapShadowMap = function (shadowMap) {
        };
        EmptyShadowMapController.prototype.hasTwoDShadowMap = function (shadowMap) {
            return false;
        };
        EmptyShadowMapController.prototype.hasCubemapShadowMap = function (shadowMap) {
            return false;
        };
        EmptyShadowMapController.prototype.getTwoDShadowMapList = function () {
            return null;
        };
        EmptyShadowMapController.prototype.getCubemapShadowMapList = function () {
            return null;
        };
        EmptyShadowMapController.prototype.getAllMapArr = function () {
            return null;
        };
        EmptyShadowMapController.prototype.removeChild = function (map) {
        };
        EmptyShadowMapController.prototype.removeAllChildren = function () {
        };
        return EmptyShadowMapController;
    }());
    wd.EmptyShadowMapController = EmptyShadowMapController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EnvMapController = (function (_super) {
        __extends(EnvMapController, _super);
        function EnvMapController() {
            _super.apply(this, arguments);
            this.material = null;
            this._map = null;
        }
        EnvMapController.create = function () {
            var obj = new this();
            return obj;
        };
        EnvMapController.prototype.setEnvMap = function (envMap) {
            if (!envMap) {
                this._map = null;
                return;
            }
            envMap.material = this.material;
            this._map = envMap;
        };
        EnvMapController.prototype.getEnvMap = function () {
            return this._map;
        };
        EnvMapController.prototype.getAllMapArr = function () {
            return this._map !== null ? [this._map] : [];
        };
        EnvMapController.prototype.removeChild = function (map) {
            if (wd.JudgeUtils.isEqual(this._map, map)) {
                this._map = null;
            }
        };
        EnvMapController.prototype.removeAllChildren = function () {
            this._map = null;
        };
        return EnvMapController;
    }(wd.MapController));
    wd.EnvMapController = EnvMapController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MapArrayController = (function (_super) {
        __extends(MapArrayController, _super);
        function MapArrayController() {
            _super.apply(this, arguments);
            this._mapArrayList = wdCb.Collection.create();
        }
        MapArrayController.create = function () {
            var obj = new this();
            return obj;
        };
        MapArrayController.prototype.addMapArray = function (samplerName, mapArray) {
            this._mapArrayList.addChild({
                samplerName: samplerName,
                mapArray: mapArray
            });
        };
        MapArrayController.prototype.sendMapData = function (program, maxUnitOfBindedSingleMap) {
            var self = this;
            this._mapArrayList.forEach(function (mapData) {
                var arrayMapCount = mapData.mapArray.length;
                program.sendUniformData(mapData.samplerName + "[0]", wd.EVariableType.SAMPLER_ARRAY, self._generateMapArrayUnitArray(maxUnitOfBindedSingleMap, maxUnitOfBindedSingleMap + arrayMapCount));
                maxUnitOfBindedSingleMap += arrayMapCount;
            });
        };
        MapArrayController.prototype.getAllMapArr = function () {
            var arrayMap = [];
            this._mapArrayList.forEach(function (mapData) {
                arrayMap = arrayMap.concat(mapData.mapArray);
            });
            return arrayMap;
        };
        MapArrayController.prototype.removeChild = function (map) {
            this._mapArrayList.removeChild(map);
        };
        MapArrayController.prototype.removeAllChildren = function () {
            this._mapArrayList.removeAllChildren();
        };
        MapArrayController.prototype._generateMapArrayUnitArray = function (startUnit, endUnit) {
            var arr = [];
            while (endUnit > startUnit) {
                arr.push(startUnit);
                startUnit++;
            }
            return arr;
        };
        __decorate([
            wd.ensure(function (mapArr) {
                for (var _i = 0, mapArr_2 = mapArr; _i < mapArr_2.length; _i++) {
                    var map = mapArr_2[_i];
                    wd.assert(map instanceof wd.Texture, wd.Log.info.FUNC_SHOULD("each element", "be Texture"));
                }
            })
        ], MapArrayController.prototype, "getAllMapArr", null);
        __decorate([
            wd.ensure(function (arr, startUnit, endUnit) {
                wd.assert(arr.length === endUnit - startUnit, wd.Log.info.FUNC_SHOULD("length", "be " + (endUnit - startUnit) + ", but actual is " + arr.length));
                if (arr.length > 0) {
                    wd.assert(arr[0] === startUnit, wd.Log.info.FUNC_SHOULD("first element", "be " + startUnit + ", but actual is " + arr[0]));
                    wd.assert(arr[arr.length - 1] === endUnit - 1, wd.Log.info.FUNC_SHOULD("last element", "be " + (endUnit - 1) + ", but actual is " + arr[arr.length - 1]));
                }
            })
        ], MapArrayController.prototype, "_generateMapArrayUnitArray", null);
        return MapArrayController;
    }(wd.MapController));
    wd.MapArrayController = MapArrayController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonMapController = (function (_super) {
        __extends(CommonMapController, _super);
        function CommonMapController() {
            _super.apply(this, arguments);
            this.material = null;
            this._list = wdCb.Collection.create();
        }
        CommonMapController.create = function () {
            var obj = new this();
            return obj;
        };
        CommonMapController.prototype.addMap = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var map = args[0];
            if (args.length === 2) {
                var option = args[1];
                this.setMapOption(map, option);
            }
            map.material = this.material;
            this._list.addChild(map);
        };
        CommonMapController.prototype.getAllMapArr = function () {
            return this._list.toArray();
        };
        CommonMapController.prototype.getMapList = function () {
            return this._list.filter(function (map) {
                return map instanceof wd.BasicTexture || map instanceof wd.ProceduralTexture;
            });
        };
        CommonMapController.prototype.hasMap = function (map) {
            return this.hasMapHelper(this._list, map);
        };
        CommonMapController.prototype.removeChild = function (map) {
            this._list.removeChild(map);
        };
        CommonMapController.prototype.removeAllChildren = function () {
            this._list.removeAllChildren();
        };
        return CommonMapController;
    }(wd.MapController));
    wd.CommonMapController = CommonMapController;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShaderSourceBuilder = (function () {
        function ShaderSourceBuilder() {
            this.attributes = wdCb.Hash.create();
            this.uniforms = wdCb.Hash.create();
            this.vsSource = null;
            this.fsSource = null;
        }
        ShaderSourceBuilder.prototype.dispose = function () {
            this.clearShaderDefinition();
        };
        ShaderSourceBuilder.prototype.convertAttributesData = function () {
            var self = this;
            this.attributes
                .filter(function (data) {
                return data.value !== wd.EVariableCategory.ENGINE && wd.JudgeUtils.isArrayExactly(data.value);
            })
                .forEach(function (data, key) {
                data.value = wd.BufferUtils.convertArrayToArrayBuffer(data.type, data.value);
            });
        };
        __decorate([
            wd.require(function () {
                this.attributes.forEach(function (data) {
                    wd.assert(!wd.JudgeUtils.isFloatArray(data.value), wd.Log.info.FUNC_SHOULD_NOT("attribute->value", "be Float array"));
                });
            })
        ], ShaderSourceBuilder.prototype, "convertAttributesData", null);
        return ShaderSourceBuilder;
    }());
    wd.ShaderSourceBuilder = ShaderSourceBuilder;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomShaderSourceBuilder = (function (_super) {
        __extends(CustomShaderSourceBuilder, _super);
        function CustomShaderSourceBuilder() {
            _super.apply(this, arguments);
        }
        CustomShaderSourceBuilder.create = function () {
            var obj = new this();
            return obj;
        };
        CustomShaderSourceBuilder.prototype.read = function (definitionData) {
            if (definitionData.attributes) {
                this.attributes = wdCb.Hash.create(definitionData.attributes);
            }
            if (definitionData.uniforms) {
                this.uniforms = wdCb.Hash.create(definitionData.uniforms);
            }
            this.vsSource = wd.LoaderManager.getInstance().get(definitionData.vsSourceId);
            this.fsSource = wd.LoaderManager.getInstance().get(definitionData.fsSourceId);
        };
        CustomShaderSourceBuilder.prototype.build = function () {
            this.convertAttributesData();
        };
        CustomShaderSourceBuilder.prototype.clearShaderDefinition = function () {
            this.attributes.removeAllChildren();
            this.uniforms.removeAllChildren();
            this.vsSource = null;
            this.fsSource = null;
        };
        return CustomShaderSourceBuilder;
    }(wd.ShaderSourceBuilder));
    wd.CustomShaderSourceBuilder = CustomShaderSourceBuilder;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EngineShaderSourceBuilder = (function (_super) {
        __extends(EngineShaderSourceBuilder, _super);
        function EngineShaderSourceBuilder() {
            _super.apply(this, arguments);
            this.vsSourceTop = "";
            this.vsSourceDefine = "";
            this.vsSourceVarDeclare = "";
            this.vsSourceFuncDeclare = "";
            this.vsSourceFuncDefine = "";
            this.vsSourceBody = "";
            this.fsSourceTop = "";
            this.fsSourceDefine = "";
            this.fsSourceVarDeclare = "";
            this.fsSourceFuncDeclare = "";
            this.fsSourceFuncDefine = "";
            this.fsSourceBody = "";
            this.vsSourceDefineList = wdCb.Collection.create();
            this.fsSourceDefineList = wdCb.Collection.create();
            this.vsSourceExtensionList = wdCb.Collection.create();
            this.fsSourceExtensionList = wdCb.Collection.create();
        }
        EngineShaderSourceBuilder.create = function () {
            var obj = new this();
            return obj;
        };
        EngineShaderSourceBuilder.prototype.build = function (libs) {
            this._readLibSource(libs);
            if (this.vsSource === null) {
                this._buildVsSource();
            }
            if (this.fsSource === null) {
                this._buildFsSource();
            }
            this.convertAttributesData();
        };
        EngineShaderSourceBuilder.prototype.clearShaderDefinition = function () {
            this.attributes.removeAllChildren();
            this.uniforms.removeAllChildren();
            this.vsSourceDefineList.removeAllChildren();
            this.fsSourceDefineList.removeAllChildren();
            this.vsSourceTop = "";
            this.vsSourceDefine = "";
            this.vsSourceVarDeclare = "";
            this.vsSourceFuncDeclare = "";
            this.vsSourceFuncDefine = "";
            this.vsSourceBody = "";
            this.vsSource = null;
            this.fsSourceTop = "";
            this.fsSourceDefine = "";
            this.fsSourceVarDeclare = "";
            this.fsSourceFuncDeclare = "";
            this.fsSourceFuncDefine = "";
            this.fsSourceBody = "";
            this.fsSource = null;
        };
        EngineShaderSourceBuilder.prototype._readLibSource = function (libs) {
            var setSourceLibs = libs.filter(function (lib) {
                return lib.vsSource !== null || lib.fsSource !== null;
            });
            this._judgeAndSetVsSource(setSourceLibs);
            this._judgeAndSetFsSource(setSourceLibs);
            this._judgeAndSetPartSource(libs);
        };
        EngineShaderSourceBuilder.prototype._judgeAndSetVsSource = function (setSourceLibs) {
            var setVsSourceLib = setSourceLibs.findOne(function (lib) {
                return lib.vsSource !== null;
            });
            if (setVsSourceLib) {
                this.vsSource = setVsSourceLib.vsSource;
            }
        };
        EngineShaderSourceBuilder.prototype._judgeAndSetFsSource = function (setSourceLibs) {
            var setFsSourceLib = setSourceLibs.findOne(function (lib) {
                return lib.fsSource !== null;
            });
            if (setFsSourceLib) {
                this.fsSource = setFsSourceLib.fsSource;
            }
        };
        EngineShaderSourceBuilder.prototype._judgeAndSetPartSource = function (libs) {
            var vsSource = this.vsSource, fsSource = this.fsSource, attributes = this.attributes, uniforms = this.uniforms, vsSourceDefineList = this.vsSourceDefineList, fsSourceDefineList = this.fsSourceDefineList, vsSourceExtensionList = this.vsSourceExtensionList, fsSourceExtensionList = this.fsSourceExtensionList, vsSourceTop = "", vsSourceDefine = "", vsSourceVarDeclare = "", vsSourceFuncDeclare = "", vsSourceFuncDefine = "", vsSourceBody = "", fsSourceTop = "", fsSourceDefine = "", fsSourceVarDeclare = "", fsSourceFuncDeclare = "", fsSourceFuncDefine = "", fsSourceBody = "";
            libs.forEach(function (lib) {
                attributes.addChildren(lib.attributes);
                uniforms.addChildren(lib.uniforms);
                if (vsSource === null) {
                    vsSourceTop += lib.vsSourceTop;
                    vsSourceDefine += lib.vsSourceDefine;
                    vsSourceVarDeclare += lib.vsSourceVarDeclare;
                    vsSourceFuncDeclare += lib.vsSourceFuncDeclare;
                    vsSourceFuncDefine += lib.vsSourceFuncDefine;
                    vsSourceBody += lib.vsSourceBody;
                    vsSourceDefineList.addChildren(lib.vsSourceDefineList);
                    vsSourceExtensionList.addChildren(lib.vsSourceExtensionList);
                }
                if (fsSource === null) {
                    fsSourceTop += lib.fsSourceTop;
                    fsSourceDefine += lib.fsSourceDefine;
                    fsSourceVarDeclare += lib.fsSourceVarDeclare;
                    fsSourceFuncDeclare += lib.fsSourceFuncDeclare;
                    fsSourceFuncDefine += lib.fsSourceFuncDefine;
                    fsSourceBody += lib.fsSourceBody;
                    fsSourceDefineList.addChildren(lib.fsSourceDefineList);
                    fsSourceExtensionList.addChildren(lib.fsSourceExtensionList);
                }
            });
            if (vsSource === null) {
                this.vsSourceTop = vsSourceTop;
                this.vsSourceDefine = vsSourceDefine;
                this.vsSourceVarDeclare = vsSourceVarDeclare;
                this.vsSourceFuncDeclare = vsSourceFuncDeclare;
                this.vsSourceFuncDefine = vsSourceFuncDefine;
                this.vsSourceBody = vsSourceBody;
            }
            if (fsSource === null) {
                this.fsSourceTop = fsSourceTop;
                this.fsSourceDefine = fsSourceDefine;
                this.fsSourceVarDeclare = fsSourceVarDeclare;
                this.fsSourceFuncDeclare = fsSourceFuncDeclare;
                this.fsSourceFuncDefine = fsSourceFuncDefine;
                this.fsSourceBody = fsSourceBody;
            }
        };
        EngineShaderSourceBuilder.prototype._buildVsSource = function () {
            this.vsSource = this._buildVsSourceTop() + this._buildVsSourceDefine() + this._buildVsSourceVarDeclare() + this._buildVsSourceFuncDeclare() + this._buildVsSourceFuncDefine() + this._buildVsSourceBody();
        };
        EngineShaderSourceBuilder.prototype._buildFsSource = function () {
            this.fsSource = this._buildFsSourceTop() + this._buildFsSourceDefine() + this._buildFsSourceVarDeclare() + this._buildFsSourceFuncDeclare() + this._buildFsSourceFuncDefine() + this._buildFsSourceBody();
        };
        EngineShaderSourceBuilder.prototype._buildVsSourceTop = function () {
            return this._buildVsSourceExtension() + this._getPrecisionSource() + this.vsSourceTop;
        };
        EngineShaderSourceBuilder.prototype._buildVsSourceDefine = function () {
            return this._buildSourceDefine(this.vsSourceDefineList) + this.vsSourceDefine;
        };
        EngineShaderSourceBuilder.prototype._buildVsSourceExtension = function () {
            return this._buildSourceExtension(this.vsSourceExtensionList);
        };
        EngineShaderSourceBuilder.prototype._buildVsSourceVarDeclare = function () {
            return this._generateAttributeSource() + this._generateUniformSource(this.vsSourceVarDeclare, this.vsSourceFuncDefine, this.vsSourceBody) + this.vsSourceVarDeclare;
        };
        EngineShaderSourceBuilder.prototype._buildVsSourceFuncDeclare = function () {
            return this.vsSourceFuncDeclare;
        };
        EngineShaderSourceBuilder.prototype._buildVsSourceFuncDefine = function () {
            return this.vsSourceFuncDefine;
        };
        EngineShaderSourceBuilder.prototype._buildVsSourceBody = function () {
            return wd.ShaderSnippet.main_begin + this.vsSourceBody + wd.ShaderSnippet.main_end;
        };
        EngineShaderSourceBuilder.prototype._buildFsSourceTop = function () {
            return this._buildFsSourceExtension() + this._getPrecisionSource() + this.fsSourceTop;
        };
        EngineShaderSourceBuilder.prototype._buildFsSourceDefine = function () {
            return this._buildSourceDefine(this.fsSourceDefineList) + this.fsSourceDefine;
        };
        EngineShaderSourceBuilder.prototype._buildFsSourceExtension = function () {
            return this._buildSourceExtension(this.fsSourceExtensionList);
        };
        EngineShaderSourceBuilder.prototype._buildFsSourceVarDeclare = function () {
            return this._generateUniformSource(this.fsSourceVarDeclare, this.fsSourceFuncDefine, this.fsSourceBody) + this.fsSourceVarDeclare;
        };
        EngineShaderSourceBuilder.prototype._buildFsSourceFuncDeclare = function () {
            return this.fsSourceFuncDeclare;
        };
        EngineShaderSourceBuilder.prototype._buildFsSourceFuncDefine = function () {
            return this.fsSourceFuncDefine;
        };
        EngineShaderSourceBuilder.prototype._buildFsSourceBody = function () {
            return wd.ShaderSnippet.main_begin + this.fsSourceBody + wd.ShaderSnippet.main_end;
        };
        EngineShaderSourceBuilder.prototype._buildSourceDefine = function (defineList) {
            var result = "";
            defineList.forEach(function (sourceDefine) {
                if (sourceDefine.value === void 0) {
                    result += "#define " + sourceDefine.name + "\n";
                }
                else {
                    result += "#define " + sourceDefine.name + " " + sourceDefine.value + "\n";
                }
            });
            return result;
        };
        EngineShaderSourceBuilder.prototype._buildSourceExtension = function (extensionList) {
            var result = "";
            extensionList.forEach(function (name) {
                result += "#extension " + name + " : enable\n";
            });
            return result;
        };
        EngineShaderSourceBuilder.prototype._getPrecisionSource = function () {
            var precision = wd.GPUDetector.getInstance().precision, result = null;
            switch (precision) {
                case wd.EGPUPrecision.HIGHP:
                    result = wd.ShaderChunk.highp_fragment.top;
                    break;
                case wd.EGPUPrecision.MEDIUMP:
                    result = wd.ShaderChunk.mediump_fragment.top;
                    break;
                case wd.EGPUPrecision.LOWP:
                    result = wd.ShaderChunk.lowp_fragment.top;
                    break;
                default:
                    result = "";
                    break;
            }
            return result;
        };
        EngineShaderSourceBuilder.prototype._generateAttributeSource = function () {
            var result = "";
            this.attributes.filter(function (data, key) {
                return !!data;
            }).forEach(function (data, key) {
                result += "attribute " + wd.VariableTypeTable.getVariableType(data.type) + " " + key + ";\n";
            });
            return result;
        };
        EngineShaderSourceBuilder.prototype._generateUniformSource = function (sourceVarDeclare, sourceFuncDefine, sourceBody) {
            var result = "", self = this;
            this.uniforms.filter(function (data, key) {
                return !!data && data.type !== wd.EVariableType.STRUCTURE && data.type !== wd.EVariableType.STRUCTURES && !self._isExistInSource(key, sourceVarDeclare) && (self._isExistInSource(key, sourceFuncDefine) || self._isExistInSource(key, sourceBody));
            }).forEach(function (data, key) {
                result += "uniform " + wd.VariableTypeTable.getVariableType(data.type) + " " + key + ";\n";
            });
            return result;
        };
        EngineShaderSourceBuilder.prototype._isExistInSource = function (key, source) {
            return source.indexOf(key) !== -1;
        };
        __decorate([
            wd.require(function (libs) {
                wd.assert(this.vsSource === null, wd.Log.info.FUNC_SHOULD("vsSource", "be null"));
                wd.assert(this.fsSource === null, wd.Log.info.FUNC_SHOULD("fsSource", "be null"));
            })
        ], EngineShaderSourceBuilder.prototype, "build", null);
        return EngineShaderSourceBuilder;
    }(wd.ShaderSourceBuilder));
    wd.EngineShaderSourceBuilder = EngineShaderSourceBuilder;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EVariableType) {
        EVariableType[EVariableType["FLOAT_1"] = "FLOAT_1"] = "FLOAT_1";
        EVariableType[EVariableType["FLOAT_2"] = "FLOAT_2"] = "FLOAT_2";
        EVariableType[EVariableType["FLOAT_3"] = "FLOAT_3"] = "FLOAT_3";
        EVariableType[EVariableType["FLOAT_4"] = "FLOAT_4"] = "FLOAT_4";
        EVariableType[EVariableType["VECTOR_2"] = "VECTOR_2"] = "VECTOR_2";
        EVariableType[EVariableType["VECTOR_3"] = "VECTOR_3"] = "VECTOR_3";
        EVariableType[EVariableType["VECTOR_4"] = "VECTOR_4"] = "VECTOR_4";
        EVariableType[EVariableType["COLOR_3"] = "COLOR_3"] = "COLOR_3";
        EVariableType[EVariableType["FLOAT_MAT3"] = "FLOAT_MAT3"] = "FLOAT_MAT3";
        EVariableType[EVariableType["FLOAT_MAT4"] = "FLOAT_MAT4"] = "FLOAT_MAT4";
        EVariableType[EVariableType["BUFFER"] = "BUFFER"] = "BUFFER";
        EVariableType[EVariableType["SAMPLER_CUBE"] = "SAMPLER_CUBE"] = "SAMPLER_CUBE";
        EVariableType[EVariableType["SAMPLER_2D"] = "SAMPLER_2D"] = "SAMPLER_2D";
        EVariableType[EVariableType["NUMBER_1"] = "NUMBER_1"] = "NUMBER_1";
        EVariableType[EVariableType["STRUCTURE"] = "STRUCTURE"] = "STRUCTURE";
        EVariableType[EVariableType["STRUCTURES"] = "STRUCTURES"] = "STRUCTURES";
        EVariableType[EVariableType["SAMPLER_ARRAY"] = "SAMPLER_ARRAY"] = "SAMPLER_ARRAY";
        EVariableType[EVariableType["FLOAT_MAT4_ARRAY"] = "FLOAT_MAT4_ARRAY"] = "FLOAT_MAT4_ARRAY";
    })(wd.EVariableType || (wd.EVariableType = {}));
    var EVariableType = wd.EVariableType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EVariableSemantic) {
        EVariableSemantic[EVariableSemantic["POSITION"] = "POSITION"] = "POSITION";
        EVariableSemantic[EVariableSemantic["NORMAL"] = "NORMAL"] = "NORMAL";
        EVariableSemantic[EVariableSemantic["TEXCOORD"] = "TEXCOORD"] = "TEXCOORD";
        EVariableSemantic[EVariableSemantic["TANGENT"] = "TANGENT"] = "TANGENT";
        EVariableSemantic[EVariableSemantic["COLOR"] = "COLOR"] = "COLOR";
        EVariableSemantic[EVariableSemantic["MODEL"] = "MODEL"] = "MODEL";
        EVariableSemantic[EVariableSemantic["VIEW"] = "VIEW"] = "VIEW";
        EVariableSemantic[EVariableSemantic["PROJECTION"] = "PROJECTION"] = "PROJECTION";
        EVariableSemantic[EVariableSemantic["MODEL_VIEW"] = "MODEL_VIEW"] = "MODEL_VIEW";
        EVariableSemantic[EVariableSemantic["MODEL_VIEW_PROJECTION"] = "MODEL_VIEW_PROJECTION"] = "MODEL_VIEW_PROJECTION";
        EVariableSemantic[EVariableSemantic["MODEL_INVERSE"] = "MODEL_INVERSE"] = "MODEL_INVERSE";
        EVariableSemantic[EVariableSemantic["VIEW_INVERSE"] = "VIEW_INVERSE"] = "VIEW_INVERSE";
        EVariableSemantic[EVariableSemantic["PROJECTION_INVERSE"] = "PROJECTION_INVERSE"] = "PROJECTION_INVERSE";
        EVariableSemantic[EVariableSemantic["MODEL_VIEW_INVERSE"] = "MODEL_VIEW_INVERSE"] = "MODEL_VIEW_INVERSE";
        EVariableSemantic[EVariableSemantic["MODEL_VIEW_PROJECTION_INVERSE"] = "MODEL_VIEW_PROJECTION_INVERSE"] = "MODEL_VIEW_PROJECTION_INVERSE";
        EVariableSemantic[EVariableSemantic["MODEL_INVERSE_TRANSPOSE"] = "MODEL_INVERSE_TRANSPOSE"] = "MODEL_INVERSE_TRANSPOSE";
        EVariableSemantic[EVariableSemantic["MODEL_VIEW_INVERSE_TRANSPOSE"] = "MODEL_VIEW_INVERSE_TRANSPOSE"] = "MODEL_VIEW_INVERSE_TRANSPOSE";
        EVariableSemantic[EVariableSemantic["VIEWPORT"] = "VIEWPORT"] = "VIEWPORT";
    })(wd.EVariableSemantic || (wd.EVariableSemantic = {}));
    var EVariableSemantic = wd.EVariableSemantic;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EVariableCategory) {
        EVariableCategory[EVariableCategory["ENGINE"] = "ENGINE"] = "ENGINE";
        EVariableCategory[EVariableCategory["CUSTOM"] = "CUSTOM"] = "CUSTOM";
    })(wd.EVariableCategory || (wd.EVariableCategory = {}));
    var EVariableCategory = wd.EVariableCategory;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VariableLib = (function () {
        function VariableLib() {
        }
        VariableLib.a_position = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_positionVec2 = {
            type: wd.EVariableType.FLOAT_2,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_currentFramePosition = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_nextFramePosition = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_normal = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_currentFrameNormal = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_nextFrameNormal = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_color = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_texCoord = {
            type: wd.EVariableType.FLOAT_2,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_tangent = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_color = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_mMatrix = {
            type: wd.EVariableType.FLOAT_MAT4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_vMatrix = {
            type: wd.EVariableType.FLOAT_MAT4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_pMatrix = {
            type: wd.EVariableType.FLOAT_MAT4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_mvpMatrix = {
            type: wd.EVariableType.FLOAT_MAT4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_vpMatrix = {
            type: wd.EVariableType.FLOAT_MAT4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_normalMatrix = {
            type: wd.EVariableType.FLOAT_MAT3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_samplerCube0 = {
            type: wd.EVariableType.SAMPLER_CUBE,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_sampler2D0 = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_sampler2D1 = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_lightMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMap1Sampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMap2Sampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMap3Sampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_specularMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_emissionMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_normalMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_reflectionMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_refractionMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_cameraPos = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_refractionRatio = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_reflectivity = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_map0SourceRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_map1SourceRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMapSourceRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_map0RepeatRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_map1RepeatRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMapRepeatRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_combineMode = {
            type: wd.EVariableType.NUMBER_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_mixRatio = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_lightMapIntensity = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuse = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_specular = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_emission = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_shininess = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_lightModel = {
            type: wd.EVariableType.NUMBER_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_isBothSide = {
            type: wd.EVariableType.NUMBER_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_opacity = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_ambient = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_directionLights = {
            type: wd.EVariableType.STRUCTURES,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_pointLights = {
            type: wd.EVariableType.STRUCTURES,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_vpMatrixFromLight = {
            type: wd.EVariableType.FLOAT_MAT4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_lightPos = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_farPlane = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_interpolation = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_tilesHeightNumber = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_tilesWidthNumber = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_amplitude = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_jointColor = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_time = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_speed = {
            type: wd.EVariableType.VECTOR_2,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_shift = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_alphaThreshold = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_fireColor = {
            type: wd.EVariableType.STRUCTURE,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_layerHeightDatas = {
            type: wd.EVariableType.STRUCTURES,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_layerSampler2Ds = {
            type: wd.EVariableType.SAMPLER_ARRAY,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_herb1Color = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_herb2Color = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_herb3Color = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_groundColor = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_ampScale = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_woodColor = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_roadColor = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_skyColor = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_cloudColor = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_brickColor = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_waveData = {
            type: wd.EVariableType.STRUCTURE,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_windMatrix = {
            type: wd.EVariableType.FLOAT_MAT4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_bumpMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_bumpMap1Sampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_bumpMap2Sampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_bumpMap3Sampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_levelData = {
            type: wd.EVariableType.STRUCTURE,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_mVec4_0 = {
            type: wd.EVariableType.FLOAT_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_mVec4_1 = {
            type: wd.EVariableType.FLOAT_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_mVec4_2 = {
            type: wd.EVariableType.FLOAT_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_mVec4_3 = {
            type: wd.EVariableType.FLOAT_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_normalVec4_0 = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_normalVec4_1 = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_normalVec4_2 = {
            type: wd.EVariableType.FLOAT_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_isRenderListEmpty = {
            type: wd.EVariableType.NUMBER_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_isReflectionRenderListEmpty = {
            type: wd.EVariableType.NUMBER_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_isRefractionRenderListEmpty = {
            type: wd.EVariableType.NUMBER_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_bitmapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_page = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_pageSampler2Ds = {
            type: wd.EVariableType.SAMPLER_ARRAY,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_mixMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMap1RepeatRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMap2RepeatRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_diffuseMap3RepeatRegion = {
            type: wd.EVariableType.VECTOR_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_grassMapDatas = {
            type: wd.EVariableType.STRUCTURES,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_quadIndex = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_grassMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_windData = {
            type: wd.EVariableType.STRUCTURES,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_vertexIndex = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_grassRangeWidth = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_grassRangeHeight = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_terrainRangeWidth = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_terrainRangeHeight = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_terrainMinHeight = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_terrainMaxHeight = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_terrainSubdivisions = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_terrainScaleY = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_terrainPositionY = {
            type: wd.EVariableType.FLOAT_1,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_heightMapSampler = {
            type: wd.EVariableType.SAMPLER_2D,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_lightColor = {
            type: wd.EVariableType.VECTOR_3,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_jointIndice = {
            type: wd.EVariableType.FLOAT_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.a_jointWeight = {
            type: wd.EVariableType.FLOAT_4,
            value: wd.EVariableCategory.ENGINE
        };
        VariableLib.u_jointMatrices = {
            type: wd.EVariableType.FLOAT_MAT4_ARRAY,
            value: wd.EVariableCategory.ENGINE
        };
        return VariableLib;
    }());
    wd.VariableLib = VariableLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var _table = wdCb.Hash.create();
    _table.addChild(wd.EVariableType.FLOAT_1, "float");
    _table.addChild(wd.EVariableType.FLOAT_2, "vec2");
    _table.addChild(wd.EVariableType.FLOAT_3, "vec3");
    _table.addChild(wd.EVariableType.FLOAT_4, "vec4");
    _table.addChild(wd.EVariableType.VECTOR_2, "vec2");
    _table.addChild(wd.EVariableType.VECTOR_3, "vec3");
    _table.addChild(wd.EVariableType.VECTOR_4, "vec4");
    _table.addChild(wd.EVariableType.FLOAT_MAT3, "mat3");
    _table.addChild(wd.EVariableType.FLOAT_MAT4, "mat4");
    _table.addChild(wd.EVariableType.NUMBER_1, "int");
    _table.addChild(wd.EVariableType.SAMPLER_CUBE, "samplerCube");
    _table.addChild(wd.EVariableType.SAMPLER_2D, "sampler2D");
    var VariableTypeTable = (function () {
        function VariableTypeTable() {
        }
        VariableTypeTable.getVariableType = function (type) {
            var result = _table.getChild(type);
            wd.Log.error(result === void 0, wd.Log.info.FUNC_NOT_EXIST(type, "in VariableTypeTable"));
            return result;
        };
        return VariableTypeTable;
    }());
    wd.VariableTypeTable = VariableTypeTable;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var _table = wdCb.Hash.create();
    _table.addChild("lightMap", "u_lightMapSampler");
    _table.addChild("diffuseMap", "u_diffuseMapSampler");
    _table.addChild("diffuseMap1", "u_diffuseMap1Sampler");
    _table.addChild("diffuseMap2", "u_diffuseMap2Sampler");
    _table.addChild("diffuseMap3", "u_diffuseMap3Sampler");
    _table.addChild("specularMap", "u_specularMapSampler");
    _table.addChild("emissionMap", "u_emissionMapSampler");
    _table.addChild("normalMap", "u_normalMapSampler");
    _table.addChild("reflectionMap", "u_reflectionMapSampler");
    _table.addChild("refractionMap", "u_refractionMapSampler");
    _table.addChild("bitmap", "u_bitmapSampler");
    _table.addChild("bumpMap", "u_bumpMapSampler");
    _table.addChild("bumpMap1", "u_bumpMap1Sampler");
    _table.addChild("bumpMap2", "u_bumpMap2Sampler");
    _table.addChild("bumpMap3", "u_bumpMap3Sampler");
    _table.addChild("mixMap", "u_mixMapSampler");
    _table.addChild("grassMap", "u_grassMapSampler");
    _table.addChild("heightMap", "u_heightMapSampler");
    var VariableNameTable = (function () {
        function VariableNameTable() {
        }
        VariableNameTable.getVariableName = function (name) {
            return _table.getChild(name);
        };
        __decorate([
            wd.ensure(function (variableName) {
                wd.it("variableName should in VariableNameTable", function () {
                    wd.expect(variableName).exist;
                });
            })
        ], VariableNameTable, "getVariableName", null);
        return VariableNameTable;
    }());
    wd.VariableNameTable = VariableNameTable;
})(wd || (wd = {}));
var wd;
(function (wd) {
    wd.POINT_LIGHT_GLSLDATA_STRUCTURE_MEMBER_NAME = [
        {
            position: "u_pointLights[0].position",
            color: "u_pointLights[0].color",
            intensity: "u_pointLights[0].intensity",
            constant: "u_pointLights[0].constant",
            linear: "u_pointLights[0].linear",
            quadratic: "u_pointLights[0].quadratic",
            range: "u_pointLights[0].range"
        }, {
            position: "u_pointLights[1].position",
            color: "u_pointLights[1].color",
            intensity: "u_pointLights[1].intensity",
            constant: "u_pointLights[1].constant",
            linear: "u_pointLights[1].linear",
            quadratic: "u_pointLights[1].quadratic",
            range: "u_pointLights[1].range"
        }, {
            position: "u_pointLights[2].position",
            color: "u_pointLights[2].color",
            intensity: "u_pointLights[2].intensity",
            constant: "u_pointLights[2].constant",
            linear: "u_pointLights[2].linear",
            quadratic: "u_pointLights[2].quadratic",
            range: "u_pointLights[2].range"
        }, {
            position: "u_pointLights[3].position",
            color: "u_pointLights[3].color",
            intensity: "u_pointLights[3].intensity",
            constant: "u_pointLights[3].constant",
            linear: "u_pointLights[3].linear",
            quadratic: "u_pointLights[3].quadratic",
            range: "u_pointLights[3].range"
        }
    ];
    wd.DIRECTION_LIGHT_GLSLDATA_STRUCTURE_MEMBER_NAME = [
        {
            position: "u_directionLights[0].position",
            color: "u_directionLights[0].color",
            intensity: "u_directionLights[0].intensity"
        }, {
            position: "u_directionLights[1].position",
            color: "u_directionLights[1].color",
            intensity: "u_directionLights[1].intensity"
        }, {
            position: "u_directionLights[2].position",
            color: "u_directionLights[2].color",
            intensity: "u_directionLights[2].intensity"
        }, {
            position: "u_directionLights[3].position",
            color: "u_directionLights[3].color",
            intensity: "u_directionLights[3].intensity"
        }
    ];
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShaderLib = (function () {
        function ShaderLib() {
            this.shader = null;
        }
        ShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        ShaderLib.prototype.init = function () {
        };
        ShaderLib.prototype.dispose = function () {
        };
        __decorate([
            wd.virtual
        ], ShaderLib.prototype, "sendShaderVariables", null);
        __decorate([
            wd.virtual
        ], ShaderLib.prototype, "init", null);
        __decorate([
            wd.virtual
        ], ShaderLib.prototype, "dispose", null);
        return ShaderLib;
    }());
    wd.ShaderLib = ShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomShaderLib = (function (_super) {
        __extends(CustomShaderLib, _super);
        function CustomShaderLib() {
            _super.apply(this, arguments);
        }
        CustomShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CustomShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var shader = this.shader;
            shader.attributes.forEach(function (attribute, name) {
                wd.CustomShaderLibUtils.sendAttributeBufferWithSemantic(name, attribute.type, attribute.value, program, cmd);
            });
            shader.uniforms.forEach(function (uniform, name) {
                if (uniform.type !== wd.EVariableType.SAMPLER_2D) {
                    wd.CustomShaderLibUtils.sendUniformDataWithSemantic(name, uniform.type, uniform.value, program, cmd);
                }
            });
        };
        return CustomShaderLib;
    }(wd.ShaderLib));
    wd.CustomShaderLib = CustomShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EngineShaderLib = (function (_super) {
        __extends(EngineShaderLib, _super);
        function EngineShaderLib() {
            _super.apply(this, arguments);
            this.type = null;
            this.attributes = wdCb.Hash.create();
            this.uniforms = wdCb.Hash.create();
            this.vsSourceTop = "";
            this.vsSourceDefine = "";
            this.vsSourceVarDeclare = "";
            this.vsSourceFuncDeclare = "";
            this.vsSourceFuncDefine = "";
            this.vsSourceBody = "";
            this.vsSource = null;
            this.fsSourceTop = "";
            this.fsSourceDefine = "";
            this.fsSourceVarDeclare = "";
            this.fsSourceFuncDeclare = "";
            this.fsSourceFuncDefine = "";
            this.fsSourceBody = "";
            this.fsSource = null;
            this.vsSourceDefineList = wdCb.Collection.create();
            this.fsSourceDefineList = wdCb.Collection.create();
            this.vsSourceExtensionList = wdCb.Collection.create();
            this.fsSourceExtensionList = wdCb.Collection.create();
        }
        EngineShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            var vs = null, fs = null;
            this._clearShaderDefinition();
            vs = this.getVsChunk();
            fs = this.getFsChunk();
            vs && this.setVsSource(vs);
            fs && this.setFsSource(fs);
        };
        EngineShaderLib.prototype.sendAttributeBuffer = function (program, name, data) {
            program.sendAttributeBuffer(name, wd.EVariableType.BUFFER, data);
        };
        EngineShaderLib.prototype.sendUniformData = function (program, name, data) {
            program.sendUniformData(name, wd.VariableLib[name].type, data);
        };
        EngineShaderLib.prototype.getVsChunk = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var type = args.length === 0 ? this.type : args[0];
            return this._getChunk(type, EShaderLibType.vs);
        };
        EngineShaderLib.prototype.getFsChunk = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var type = args.length === 0 ? this.type : args[0];
            return this._getChunk(type, EShaderLibType.fs);
        };
        EngineShaderLib.prototype.setVsSource = function (vs, operator) {
            if (operator === void 0) { operator = "="; }
            if (wd.JudgeUtils.isString(vs)) {
                this.vsSource = vs;
            }
            else {
                this._setSource(vs, EShaderLibType.vs, operator);
            }
        };
        EngineShaderLib.prototype.setFsSource = function (fs, operator) {
            if (operator === void 0) { operator = "="; }
            if (wd.JudgeUtils.isString(fs)) {
                this.fsSource = fs;
            }
            else {
                this._setSource(fs, EShaderLibType.fs, operator);
            }
        };
        EngineShaderLib.prototype.addAttributeVariable = function (variableArr) {
            this._addVariable(this.attributes, variableArr);
        };
        EngineShaderLib.prototype.addUniformVariable = function (variableArr) {
            this._addVariable(this.uniforms, variableArr);
        };
        EngineShaderLib.prototype._addVariable = function (target, variableArr) {
            variableArr.forEach(function (variable) {
                wd.assert(wd.VariableLib[variable], wd.Log.info.FUNC_SHOULD(variable, "exist in VariableLib"));
                target.addChild(variable, wd.VariableLib[variable]);
            });
        };
        EngineShaderLib.prototype._clearShaderDefinition = function () {
            this.attributes.removeAllChildren();
            this.uniforms.removeAllChildren();
            this.vsSourceDefineList.removeAllChildren();
            this.fsSourceDefineList.removeAllChildren();
            this.vsSourceExtensionList.removeAllChildren();
            this.fsSourceExtensionList.removeAllChildren();
            this.vsSourceTop = "";
            this.vsSourceDefine = "";
            this.vsSourceVarDeclare = "";
            this.vsSourceFuncDeclare = "";
            this.vsSourceFuncDefine = "";
            this.vsSourceBody = "";
            this.vsSource = null;
            this.fsSourceTop = "";
            this.fsSourceDefine = "";
            this.fsSourceVarDeclare = "";
            this.fsSourceFuncDeclare = "";
            this.fsSourceFuncDefine = "";
            this.fsSourceBody = "";
            this.fsSource = null;
        };
        EngineShaderLib.prototype._getChunk = function (type, sourceType) {
            var key = null;
            if (!type) {
                return null;
            }
            if (type.indexOf(".glsl") > -1) {
                key = "" + wdCb.PathUtils.basename(type, ".glsl");
            }
            else {
                if (sourceType === EShaderLibType.vs) {
                    key = type + "_vertex";
                }
                else {
                    key = type + "_fragment";
                }
            }
            return wd.ShaderChunk[key] ? wd.ShaderChunk[key] : wd.ShaderChunk.empty;
        };
        EngineShaderLib.prototype._setSource = function (chunk, sourceType, operator) {
            if (!chunk) {
                return;
            }
            switch (operator) {
                case "+":
                    this[(sourceType + "SourceTop")] += chunk.top;
                    this[(sourceType + "SourceDefine")] += chunk.define;
                    this[(sourceType + "SourceVarDeclare")] += chunk.varDeclare;
                    this[(sourceType + "SourceFuncDeclare")] += chunk.funcDeclare;
                    this[(sourceType + "SourceFuncDefine")] += chunk.funcDefine;
                    this[(sourceType + "SourceBody")] += chunk.body;
                    break;
                case "=":
                    this[(sourceType + "SourceTop")] = chunk.top;
                    this[(sourceType + "SourceDefine")] = chunk.define;
                    this[(sourceType + "SourceVarDeclare")] = chunk.varDeclare;
                    this[(sourceType + "SourceFuncDeclare")] = chunk.funcDeclare;
                    this[(sourceType + "SourceFuncDefine")] = chunk.funcDefine;
                    this[(sourceType + "SourceBody")] = chunk.body;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("opertor:", operator));
                    break;
            }
        };
        __decorate([
            wd.virtual
        ], EngineShaderLib.prototype, "setShaderDefinition", null);
        __decorate([
            wd.require(function (program, name, data) {
                wd.assert(!!wd.VariableLib[name], name + " should exist in VariableLib");
            })
        ], EngineShaderLib.prototype, "sendUniformData", null);
        __decorate([
            wd.require(function () {
                wd.assert(this.vsSource === null, wd.Log.info.FUNC_SHOULD("vsSource", "be null"));
            })
        ], EngineShaderLib.prototype, "setVsSource", null);
        __decorate([
            wd.require(function () {
                wd.assert(this.fsSource === null, wd.Log.info.FUNC_SHOULD("fsSource", "be null"));
            })
        ], EngineShaderLib.prototype, "setFsSource", null);
        __decorate([
            wd.require(function (target, variableArr) {
                variableArr.forEach(function (variable) {
                    wd.it("should exist in VariableLib", function () {
                        wd.expect(wd.VariableLib[variable]).exist;
                    });
                });
            })
        ], EngineShaderLib.prototype, "_addVariable", null);
        return EngineShaderLib;
    }(wd.ShaderLib));
    wd.EngineShaderLib = EngineShaderLib;
    var EShaderLibType;
    (function (EShaderLibType) {
        EShaderLibType[EShaderLibType["vs"] = "vs"] = "vs";
        EShaderLibType[EShaderLibType["fs"] = "fs"] = "fs";
    })(EShaderLibType || (EShaderLibType = {}));
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonShaderLib = (function (_super) {
        __extends(CommonShaderLib, _super);
        function CommonShaderLib() {
            _super.apply(this, arguments);
            this.type = "common";
        }
        CommonShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CommonShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_vMatrix", cmd.vMatrix);
            this.sendUniformData(program, "u_pMatrix", cmd.pMatrix);
        };
        CommonShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_vMatrix", "u_pMatrix"]);
            this.vsSourceDefine = wd.ShaderChunk.common_define.define + wd.ShaderChunk.common_vertex.define;
            this.vsSourceFuncDefine = wd.ShaderChunk.common_function.funcDefine + wd.ShaderChunk.common_vertex.funcDefine;
            this.fsSourceDefine = wd.ShaderChunk.common_define.define + wd.ShaderChunk.common_fragment.define;
            this.fsSourceFuncDefine = wd.ShaderChunk.common_function.funcDefine + wd.ShaderChunk.common_fragment.funcDefine;
        };
        return CommonShaderLib;
    }(wd.EngineShaderLib));
    wd.CommonShaderLib = CommonShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EndShaderLib = (function (_super) {
        __extends(EndShaderLib, _super);
        function EndShaderLib() {
            _super.apply(this, arguments);
            this.type = "end";
        }
        EndShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        EndShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            program.sendAllBufferData(cmd.vaoManager);
        };
        return EndShaderLib;
    }(wd.EngineShaderLib));
    wd.EndShaderLib = EndShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VerticeCommonShaderLib = (function (_super) {
        __extends(VerticeCommonShaderLib, _super);
        function VerticeCommonShaderLib() {
            _super.apply(this, arguments);
            this.type = "vertice_common";
        }
        VerticeCommonShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        VerticeCommonShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this._sendAttributeVariables(program, cmd);
        };
        VerticeCommonShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_position"]);
        };
        VerticeCommonShaderLib.prototype._sendAttributeVariables = function (program, cmd) {
            var verticeBuffer = cmd.buffers.getChild(wd.EBufferDataType.VERTICE);
            if (!verticeBuffer) {
                return;
            }
            this.sendAttributeBuffer(program, "a_position", verticeBuffer);
        };
        return VerticeCommonShaderLib;
    }(wd.EngineShaderLib));
    wd.VerticeCommonShaderLib = VerticeCommonShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalCommonShaderLib = (function (_super) {
        __extends(NormalCommonShaderLib, _super);
        function NormalCommonShaderLib() {
            _super.apply(this, arguments);
            this.type = "normal_common";
        }
        NormalCommonShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NormalCommonShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this._sendAttributeVariables(program, cmd);
        };
        NormalCommonShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_normal"]);
        };
        NormalCommonShaderLib.prototype._sendAttributeVariables = function (program, cmd) {
            var normalBuffer = cmd.buffers.getChild(wd.EBufferDataType.NORMAL);
            if (!normalBuffer) {
                return;
            }
            this.sendAttributeBuffer(program, "a_normal", normalBuffer);
        };
        return NormalCommonShaderLib;
    }(wd.EngineShaderLib));
    wd.NormalCommonShaderLib = NormalCommonShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicShaderLib = (function (_super) {
        __extends(BasicShaderLib, _super);
        function BasicShaderLib() {
            _super.apply(this, arguments);
            this.type = "basic";
        }
        BasicShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        BasicShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_opacity", material.opacity);
        };
        BasicShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_opacity"]);
            this.vsSourceBody = wd.ShaderSnippet.setPos_mvp;
        };
        return BasicShaderLib;
    }(wd.EngineShaderLib));
    wd.BasicShaderLib = BasicShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicMaterialColorShaderLib = (function (_super) {
        __extends(BasicMaterialColorShaderLib, _super);
        function BasicMaterialColorShaderLib() {
            _super.apply(this, arguments);
            this.type = "basic_materialColor";
        }
        BasicMaterialColorShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        BasicMaterialColorShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_color", material.color.toVector3());
        };
        BasicMaterialColorShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_color"]);
        };
        return BasicMaterialColorShaderLib;
    }(wd.EngineShaderLib));
    wd.BasicMaterialColorShaderLib = BasicMaterialColorShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicVertexColorShaderLib = (function (_super) {
        __extends(BasicVertexColorShaderLib, _super);
        function BasicVertexColorShaderLib() {
            _super.apply(this, arguments);
            this.type = "basic_vertexColor";
        }
        BasicVertexColorShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        BasicVertexColorShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var colorBuffer = cmd.buffers.getChild(wd.EBufferDataType.COLOR);
            if (!!colorBuffer) {
                this.sendAttributeBuffer(program, "a_color", colorBuffer);
            }
        };
        BasicVertexColorShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_color"]);
        };
        return BasicVertexColorShaderLib;
    }(wd.EngineShaderLib));
    wd.BasicVertexColorShaderLib = BasicVertexColorShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EndBasicShaderLib = (function (_super) {
        __extends(EndBasicShaderLib, _super);
        function EndBasicShaderLib() {
            _super.apply(this, arguments);
            this.type = "end_basic";
        }
        EndBasicShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        EndBasicShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            if (material.alphaTest !== null) {
                this.fsSourceBody += "if (gl_FragColor.a < " + material.alphaTest + "){\n    discard;\n}\n";
            }
        };
        return EndBasicShaderLib;
    }(wd.EngineShaderLib));
    wd.EndBasicShaderLib = EndBasicShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonMorphShaderLib = (function (_super) {
        __extends(CommonMorphShaderLib, _super);
        function CommonMorphShaderLib() {
            _super.apply(this, arguments);
            this.type = "common_morph";
        }
        CommonMorphShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CommonMorphShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var anim = cmd.target.getComponent(wd.MorphAnimation);
            this.sendUniformData(program, "u_interpolation", anim.interpolation);
        };
        CommonMorphShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_interpolation"]);
        };
        __decorate([
            wd.require(function (program, cmd, material) {
                wd.it("entityObject should has MorphAnimation component", function () {
                    wd.expect(cmd.target.hasComponent(wd.MorphAnimation)).true;
                });
            })
        ], CommonMorphShaderLib.prototype, "sendShaderVariables", null);
        return CommonMorphShaderLib;
    }(wd.EngineShaderLib));
    wd.CommonMorphShaderLib = CommonMorphShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VerticeMorphShaderLib = (function (_super) {
        __extends(VerticeMorphShaderLib, _super);
        function VerticeMorphShaderLib() {
            _super.apply(this, arguments);
            this.type = "vertice_morph";
        }
        VerticeMorphShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        VerticeMorphShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var morphVerticeData = cmd.buffers.getChild(wd.EBufferDataType.VERTICE);
            if (!morphVerticeData) {
                return;
            }
            this.sendAttributeBuffer(program, "a_currentFramePosition", morphVerticeData[0]);
            this.sendAttributeBuffer(program, "a_nextFramePosition", morphVerticeData[1]);
        };
        VerticeMorphShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_currentFramePosition", "a_nextFramePosition"]);
        };
        __decorate([
            wd.require(function (program, cmd, material) {
                wd.it("entityObject should has MorphAnimation component", function () {
                    wd.expect(cmd.target.hasComponent(wd.MorphAnimation)).true;
                });
            })
        ], VerticeMorphShaderLib.prototype, "sendShaderVariables", null);
        return VerticeMorphShaderLib;
    }(wd.EngineShaderLib));
    wd.VerticeMorphShaderLib = VerticeMorphShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMorphShaderLib = (function (_super) {
        __extends(NormalMorphShaderLib, _super);
        function NormalMorphShaderLib() {
            _super.apply(this, arguments);
            this.type = "normal_morph";
        }
        NormalMorphShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NormalMorphShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var morphNormalData = cmd.buffers.getChild(wd.EBufferDataType.NORMAL);
            if (!morphNormalData) {
                return;
            }
            this.sendAttributeBuffer(program, "a_currentFrameNormal", morphNormalData[0]);
            this.sendAttributeBuffer(program, "a_nextFrameNormal", morphNormalData[1]);
        };
        NormalMorphShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_currentFrameNormal", "a_nextFrameNormal"]);
        };
        return NormalMorphShaderLib;
    }(wd.EngineShaderLib));
    wd.NormalMorphShaderLib = NormalMorphShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VerticeSkinSkeletonShaderLib = (function (_super) {
        __extends(VerticeSkinSkeletonShaderLib, _super);
        function VerticeSkinSkeletonShaderLib() {
            _super.apply(this, arguments);
            this.type = "vertice_skinSkeleton";
        }
        VerticeSkinSkeletonShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        VerticeSkinSkeletonShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var jointIndiceBuffer = cmd.buffers.getChild(wd.EBufferDataType.JOINT_INDICE), jointWeightBuffer = cmd.buffers.getChild(wd.EBufferDataType.JOINT_WEIGHT);
            if (!!jointIndiceBuffer) {
                this.sendAttributeBuffer(program, "a_jointIndice", jointIndiceBuffer);
            }
            if (!!jointWeightBuffer) {
                this.sendAttributeBuffer(program, "a_jointWeight", jointWeightBuffer);
            }
            this._sendJointMatrices(program, cmd);
        };
        VerticeSkinSkeletonShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_jointIndice", "a_jointWeight"]);
            this.vsSourceDefineList.addChild({
                name: "MAX_JOINT_COUNT",
                value: material.geometry.entityObject.getComponent(wd.SkinSkeletonAnimation).maxJoints
            });
        };
        VerticeSkinSkeletonShaderLib.prototype._sendJointMatrices = function (program, cmd) {
            var anim = cmd.target.getComponent(wd.SkinSkeletonAnimation);
            this.sendUniformData(program, "u_jointMatrices", anim.jointMatrices);
        };
        __decorate([
            wd.require(function (program, cmd, material) {
                wd.it("entityObject should has SkinSkeletonAnimation component", function () {
                    wd.expect(cmd.target.hasComponent(wd.SkinSkeletonAnimation)).true;
                });
            })
        ], VerticeSkinSkeletonShaderLib.prototype, "sendShaderVariables", null);
        return VerticeSkinSkeletonShaderLib;
    }(wd.EngineShaderLib));
    wd.VerticeSkinSkeletonShaderLib = VerticeSkinSkeletonShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ProceduralShaderLib = (function (_super) {
        __extends(ProceduralShaderLib, _super);
        function ProceduralShaderLib() {
            _super.apply(this, arguments);
        }
        ProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
        };
        ProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd, null);
        };
        __decorate([
            wd.virtual
        ], ProceduralShaderLib.prototype, "sendShaderVariables", null);
        __decorate([
            wd.virtual
        ], ProceduralShaderLib.prototype, "setShaderDefinition", null);
        return ProceduralShaderLib;
    }(wd.EngineShaderLib));
    wd.ProceduralShaderLib = ProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomProceduralShaderLib = (function (_super) {
        __extends(CustomProceduralShaderLib, _super);
        function CustomProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "custom_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        CustomProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        CustomProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture, uniformMap = texture.uniformMap;
            uniformMap.forEach(function (uniform, name) {
                wd.CustomShaderLibUtils.sendUniformData(name, uniform.type, uniform.value, program);
            });
        };
        CustomProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            var texture = this._proceduralTexture;
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.setFsSource(texture.fsSource);
        };
        return CustomProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.CustomProceduralShaderLib = CustomProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonProceduralShaderLib = (function (_super) {
        __extends(CommonProceduralShaderLib, _super);
        function CommonProceduralShaderLib() {
            _super.apply(this, arguments);
            this.type = "common_proceduralTexture";
        }
        CommonProceduralShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CommonProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            this.sendAttributeBuffer(program, "a_positionVec2", cmd.vertexBuffer);
            program.sendAllBufferData(cmd.vaoManager);
        };
        CommonProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addAttributeVariable(["a_positionVec2"]);
        };
        return CommonProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.CommonProceduralShaderLib = CommonProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SkyboxShaderLib = (function (_super) {
        __extends(SkyboxShaderLib, _super);
        function SkyboxShaderLib() {
            _super.apply(this, arguments);
            this.type = "skybox";
        }
        SkyboxShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        SkyboxShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        SkyboxShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_samplerCube0"]);
        };
        return SkyboxShaderLib;
    }(wd.EngineShaderLib));
    wd.SkyboxShaderLib = SkyboxShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EnvMapShaderLib = (function (_super) {
        __extends(EnvMapShaderLib, _super);
        function EnvMapShaderLib() {
            _super.apply(this, arguments);
        }
        EnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_samplerCube0"
            ]);
            this.vsSourceBody = this.getVsChunk().body;
        };
        return EnvMapShaderLib;
    }(wd.EngineShaderLib));
    wd.EnvMapShaderLib = EnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonEnvMapShaderLib = (function (_super) {
        __extends(CommonEnvMapShaderLib, _super);
        function CommonEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "common_envMap";
        }
        CommonEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CommonEnvMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            wd.RenderTargerRendererShaderLibUtils.judgeAndSendIsRenderListEmptyVariable(program, wd.EShaderGLSLData.DYNAMIC_CUBEMAP);
        };
        CommonEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_isRenderListEmpty"
            ]);
        };
        return CommonEnvMapShaderLib;
    }(wd.EnvMapShaderLib));
    wd.CommonEnvMapShaderLib = CommonEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ForBasicEnvMapShaderLib = (function (_super) {
        __extends(ForBasicEnvMapShaderLib, _super);
        function ForBasicEnvMapShaderLib() {
            _super.apply(this, arguments);
        }
        ForBasicEnvMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            _super.prototype.sendShaderVariables.call(this, program, cmd, material);
            this.sendUniformData(program, "u_cameraPos", wd.Director.getInstance().scene.currentCamera.transform.position);
        };
        ForBasicEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_cameraPos"]);
        };
        ForBasicEnvMapShaderLib.prototype.setEnvMapSource = function () {
            var vs = this.getVsChunk("forBasic_envMap"), fs = this.getFsChunk("forBasic_envMap");
            this.vsSourceTop = vs.top;
            this.vsSourceDefine = vs.define;
            this.vsSourceVarDeclare = vs.varDeclare;
            this.vsSourceFuncDeclare = vs.funcDeclare;
            this.vsSourceFuncDefine = vs.funcDefine;
            this.vsSourceBody += vs.body;
            this.setFsSource(fs);
        };
        return ForBasicEnvMapShaderLib;
    }(wd.EnvMapShaderLib));
    wd.ForBasicEnvMapShaderLib = ForBasicEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicForBasicEnvMapShaderLib = (function (_super) {
        __extends(BasicForBasicEnvMapShaderLib, _super);
        function BasicForBasicEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "basic_forBasic_envMap";
        }
        BasicForBasicEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return BasicForBasicEnvMapShaderLib;
    }(wd.ForBasicEnvMapShaderLib));
    wd.BasicForBasicEnvMapShaderLib = BasicForBasicEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ReflectionForBasicEnvMapShaderLib = (function (_super) {
        __extends(ReflectionForBasicEnvMapShaderLib, _super);
        function ReflectionForBasicEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "reflection_forBasic_envMap";
        }
        ReflectionForBasicEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        ReflectionForBasicEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.setEnvMapSource();
            this.setFsSource(this.getFsChunk(), "+");
        };
        return ReflectionForBasicEnvMapShaderLib;
    }(wd.ForBasicEnvMapShaderLib));
    wd.ReflectionForBasicEnvMapShaderLib = ReflectionForBasicEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RefractionForBasicEnvMapShaderLib = (function (_super) {
        __extends(RefractionForBasicEnvMapShaderLib, _super);
        function RefractionForBasicEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "refraction_forBasic_envMap";
        }
        RefractionForBasicEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        RefractionForBasicEnvMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            _super.prototype.sendShaderVariables.call(this, program, cmd, material);
            this.sendUniformData(program, "u_refractionRatio", material.refractionRatio);
        };
        RefractionForBasicEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_refractionRatio"]);
            this.setEnvMapSource();
            this.setFsSource(this.getFsChunk(), "+");
        };
        return RefractionForBasicEnvMapShaderLib;
    }(wd.ForBasicEnvMapShaderLib));
    wd.RefractionForBasicEnvMapShaderLib = RefractionForBasicEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FresnelForBasicEnvMapShaderLib = (function (_super) {
        __extends(FresnelForBasicEnvMapShaderLib, _super);
        function FresnelForBasicEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "fresnel_forBasic_envMap";
        }
        FresnelForBasicEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        FresnelForBasicEnvMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            _super.prototype.sendShaderVariables.call(this, program, cmd, material);
            this.sendUniformData(program, "u_refractionRatio", material.refractionRatio);
            this.sendUniformData(program, "u_reflectivity", material.reflectivity);
        };
        FresnelForBasicEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_refractionRatio", "u_reflectivity"]);
            this.setEnvMapSource();
            this.setFsSource(this.getFsChunk(), "+");
        };
        return FresnelForBasicEnvMapShaderLib;
    }(wd.ForBasicEnvMapShaderLib));
    wd.FresnelForBasicEnvMapShaderLib = FresnelForBasicEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ForLightEnvMapShaderLib = (function (_super) {
        __extends(ForLightEnvMapShaderLib, _super);
        function ForLightEnvMapShaderLib() {
            _super.apply(this, arguments);
        }
        ForLightEnvMapShaderLib.prototype.setEnvMapSource = function () {
            var vs = this.getVsChunk("forLight_envMap"), fs = this.getFsChunk("forLight_envMap");
            this.vsSourceTop = vs.top;
            this.vsSourceDefine = vs.define;
            this.vsSourceVarDeclare = vs.varDeclare;
            this.vsSourceFuncDeclare = vs.funcDeclare;
            this.vsSourceFuncDefine = vs.funcDefine;
            this.vsSourceBody += vs.body;
            this.setFsSource(fs);
        };
        return ForLightEnvMapShaderLib;
    }(wd.EnvMapShaderLib));
    wd.ForLightEnvMapShaderLib = ForLightEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicForLightEnvMapShaderLib = (function (_super) {
        __extends(BasicForLightEnvMapShaderLib, _super);
        function BasicForLightEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "basic_forLight_envMap";
        }
        BasicForLightEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return BasicForLightEnvMapShaderLib;
    }(wd.ForLightEnvMapShaderLib));
    wd.BasicForLightEnvMapShaderLib = BasicForLightEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ReflectionForLightEnvMapShaderLib = (function (_super) {
        __extends(ReflectionForLightEnvMapShaderLib, _super);
        function ReflectionForLightEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "reflection_forLight_envMap";
        }
        ReflectionForLightEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        ReflectionForLightEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.setEnvMapSource();
            this.setFsSource(this.getFsChunk(), "+");
        };
        return ReflectionForLightEnvMapShaderLib;
    }(wd.ForLightEnvMapShaderLib));
    wd.ReflectionForLightEnvMapShaderLib = ReflectionForLightEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RefractionForLightEnvMapShaderLib = (function (_super) {
        __extends(RefractionForLightEnvMapShaderLib, _super);
        function RefractionForLightEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "refraction_forLight_envMap";
        }
        RefractionForLightEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        RefractionForLightEnvMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            _super.prototype.sendShaderVariables.call(this, program, cmd, material);
            this.sendUniformData(program, "u_refractionRatio", material.refractionRatio);
        };
        RefractionForLightEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_refractionRatio"]);
            this.setEnvMapSource();
            this.setFsSource(this.getFsChunk(), "+");
        };
        return RefractionForLightEnvMapShaderLib;
    }(wd.ForLightEnvMapShaderLib));
    wd.RefractionForLightEnvMapShaderLib = RefractionForLightEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FresnelForLightEnvMapShaderLib = (function (_super) {
        __extends(FresnelForLightEnvMapShaderLib, _super);
        function FresnelForLightEnvMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "fresnel_forLight_envMap";
        }
        FresnelForLightEnvMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        FresnelForLightEnvMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            _super.prototype.sendShaderVariables.call(this, program, cmd, material);
            if (material.reflectivity !== null) {
                this.sendUniformData(program, "u_reflectivity", material.reflectivity);
            }
            else {
                this.sendUniformData(program, "u_reflectivity", wd.ShaderChunk.NULL);
                this.sendUniformData(program, "u_refractionRatio", material.refractionRatio);
            }
        };
        FresnelForLightEnvMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_refractionRatio", "u_reflectivity"]);
            this.setEnvMapSource();
            this.setFsSource(this.getFsChunk(), "+");
        };
        return FresnelForLightEnvMapShaderLib;
    }(wd.ForLightEnvMapShaderLib));
    wd.FresnelForLightEnvMapShaderLib = FresnelForLightEnvMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MapShaderLib = (function (_super) {
        __extends(MapShaderLib, _super);
        function MapShaderLib() {
            _super.apply(this, arguments);
        }
        MapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var texCoordBuffer = cmd.buffers.getChild(wd.EBufferDataType.TEXCOORD), mapList = null, map0 = null;
            if (!texCoordBuffer) {
                return;
            }
            this.sendAttributeBuffer(program, "a_texCoord", texCoordBuffer);
            mapList = material.mapList;
            map0 = mapList.getChild(0);
            this.sendUniformData(program, "u_map0SourceRegion", map0.sourceRegionForGLSL);
            this.sendUniformData(program, "u_map0RepeatRegion", map0.repeatRegion);
            this.sendMapShaderVariables(program, cmd, material);
        };
        MapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_texCoord"]);
            this.addUniformVariable(["u_sampler2D0", "u_map0SourceRegion", "u_map0RepeatRegion"]);
            this._setMapSource();
        };
        MapShaderLib.prototype.sendMapShaderVariables = function (program, cmd, material) {
        };
        MapShaderLib.prototype._setMapSource = function () {
            var vs = this.getVsChunk("map_forBasic"), fs = this.getFsChunk("map_forBasic");
            this.vsSourceTop = vs.top;
            this.vsSourceDefine = vs.define;
            this.vsSourceVarDeclare = vs.varDeclare;
            this.vsSourceFuncDeclare = vs.funcDeclare;
            this.vsSourceFuncDefine = vs.funcDefine;
            this.vsSourceBody = vs.body;
            this.setFsSource(fs);
        };
        __decorate([
            wd.virtual
        ], MapShaderLib.prototype, "sendMapShaderVariables", null);
        return MapShaderLib;
    }(wd.EngineShaderLib));
    wd.MapShaderLib = MapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicMapShaderLib = (function (_super) {
        __extends(BasicMapShaderLib, _super);
        function BasicMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "map_forBasic";
        }
        BasicMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return BasicMapShaderLib;
    }(wd.MapShaderLib));
    wd.BasicMapShaderLib = BasicMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MultiMapShaderLib = (function (_super) {
        __extends(MultiMapShaderLib, _super);
        function MultiMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "multi_map_forBasic";
        }
        MultiMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        MultiMapShaderLib.prototype.sendMapShaderVariables = function (program, cmd, material) {
            var mapList = material.mapList, map1 = mapList.getChild(1);
            this.sendUniformData(program, "u_combineMode", material.mapCombineMode);
            this.sendUniformData(program, "u_mixRatio", material.mapMixRatio);
            this.sendUniformData(program, "u_map1SourceRegion", map1.sourceRegionForGLSL);
            this.sendUniformData(program, "u_map1RepeatRegion", map1.repeatRegion);
        };
        MultiMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_sampler2D1", "u_combineMode", "u_mixRatio",
                "u_map1SourceRegion", "u_map1RepeatRegion"
            ]);
            this.vsSourceVarDeclare += this.getVsChunk().varDeclare;
            this.vsSourceBody += this.getVsChunk().body;
            this.fsSourceVarDeclare = this.getFsChunk().varDeclare;
            this.fsSourceFuncDefine = this.getFsChunk().funcDefine;
            this.fsSourceBody = this.getFsChunk().body;
        };
        return MultiMapShaderLib;
    }(wd.MapShaderLib));
    wd.MultiMapShaderLib = MultiMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightCommonShaderLib = (function (_super) {
        __extends(LightCommonShaderLib, _super);
        function LightCommonShaderLib() {
            _super.apply(this, arguments);
            this.type = "lightCommon";
        }
        LightCommonShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        LightCommonShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        LightCommonShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.setVsSource(this.getVsChunk("light_common.glsl"));
            this.setVsSource(this.getVsChunk(), "+");
            this.setFsSource(this.getFsChunk("light_common.glsl"));
            this.setFsSource(this.getFsChunk(), "+");
        };
        return LightCommonShaderLib;
    }(wd.EngineShaderLib));
    wd.LightCommonShaderLib = LightCommonShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightSetWorldPositionShaderLib = (function (_super) {
        __extends(LightSetWorldPositionShaderLib, _super);
        function LightSetWorldPositionShaderLib() {
            _super.apply(this, arguments);
            this.type = "light_setWorldPosition";
        }
        LightSetWorldPositionShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return LightSetWorldPositionShaderLib;
    }(wd.EngineShaderLib));
    wd.LightSetWorldPositionShaderLib = LightSetWorldPositionShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightShaderLib = (function (_super) {
        __extends(LightShaderLib, _super);
        function LightShaderLib() {
            _super.apply(this, arguments);
            this.type = "light";
        }
        LightShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        LightShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_cameraPos", wd.Director.getInstance().scene.currentCamera.transform.position);
            this.sendUniformData(program, "u_shininess", material.shininess);
            this.sendUniformData(program, "u_opacity", material.opacity);
            this.sendUniformData(program, "u_lightModel", this._convertLightModelToGLSLVariable(material.lightModel));
            this._sendLightVariables(program);
        };
        LightShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_normalMatrix", "u_cameraPos", "u_shininess", "u_ambient", "u_opacity", "u_isBothSide", "u_lightModel"]);
            this._setLightDefinition(material);
        };
        LightShaderLib.prototype._sendLightVariables = function (program) {
            var scene = wd.Director.getInstance().scene, directionLights = scene.directionLights, ambientLight = scene.ambientLight, pointLights = scene.pointLights;
            if (ambientLight) {
                this.sendUniformData(program, "u_ambient", ambientLight.getComponent(wd.AmbientLight).color.toVector3());
            }
            if (pointLights) {
                this._sendPointLightVariables(program, pointLights);
            }
            if (directionLights) {
                this._sendDirectionLightVariables(program, directionLights);
            }
        };
        LightShaderLib.prototype._sendPointLightVariables = function (program, pointLights) {
            pointLights.forEach(function (pointLight, index) {
                var lightComponent = pointLight.getComponent(wd.PointLight), structureMemberNameData = wd.POINT_LIGHT_GLSLDATA_STRUCTURE_MEMBER_NAME[index];
                program.sendVector3(structureMemberNameData.position, wd.LightUtils.getPointLightPosition(lightComponent));
                program.sendColor3(structureMemberNameData.color, lightComponent.color);
                program.sendFloat1(structureMemberNameData.intensity, lightComponent.intensity);
                program.sendFloat1(structureMemberNameData.constant, lightComponent.constant);
                program.sendFloat1(structureMemberNameData.linear, lightComponent.linear);
                program.sendFloat1(structureMemberNameData.quadratic, lightComponent.quadratic);
                if (lightComponent.range !== null) {
                    program.sendFloat1(structureMemberNameData.range, lightComponent.range);
                }
                else {
                    program.sendFloat1(structureMemberNameData.range, wd.ShaderChunk.NULL);
                }
            });
        };
        LightShaderLib.prototype._sendDirectionLightVariables = function (program, directionLights) {
            directionLights.forEach(function (directionLight, index) {
                var lightComponent = directionLight.getComponent(wd.DirectionLight), structureMemberNameData = wd.DIRECTION_LIGHT_GLSLDATA_STRUCTURE_MEMBER_NAME[index];
                program.sendVector3(structureMemberNameData.position, wd.LightUtils.getDirectionLightPosition(lightComponent));
                program.sendColor3(structureMemberNameData.color, lightComponent.color);
                program.sendFloat1(structureMemberNameData.intensity, lightComponent.intensity);
            });
        };
        LightShaderLib.prototype._setLightDefinition = function (material) {
            var scene = wd.Director.getInstance().scene, directionLights = scene.directionLights, pointLights = scene.pointLights, direction_lights_count = 0, point_lights_count = 0;
            if (directionLights) {
                this.addUniformVariable(["u_directionLights"]);
                direction_lights_count = directionLights.getCount();
            }
            if (pointLights) {
                this.addUniformVariable(["u_pointLights"]);
                point_lights_count = pointLights.getCount();
            }
            this._addDefine(this.vsSourceDefineList, direction_lights_count, point_lights_count);
            this._addDefine(this.fsSourceDefineList, direction_lights_count, point_lights_count);
            if (material.side === wd.ESide.BOTH) {
                this.fsSourceDefineList.addChildren([{
                        name: "BOTH_SIDE"
                    }]);
            }
        };
        LightShaderLib.prototype._addDefine = function (list, direction_lights_count, point_lights_count) {
            list.addChildren([{
                    name: "DIRECTION_LIGHTS_COUNT",
                    value: direction_lights_count
                }, {
                    name: "POINT_LIGHTS_COUNT",
                    value: point_lights_count
                }]);
        };
        LightShaderLib.prototype._convertLightModelToGLSLVariable = function (lightModel) {
            switch (lightModel) {
                case wd.ELightModel.BLINN:
                    return 1;
                case wd.ELightModel.PHONG:
                    return 2;
                case wd.ELightModel.CONSTANT:
                    return 3;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("lightModel:" + lightModel));
                    break;
            }
        };
        __decorate([
            wd.require(function (lightModel) {
                wd.assert(lightModel !== wd.ELightModel.LAMBERT, wd.Log.info.FUNC_SHOULD_NOT("lightModel", "=== ELightModel.LAMBERT"));
            })
        ], LightShaderLib.prototype, "_convertLightModelToGLSLVariable", null);
        return LightShaderLib;
    }(wd.EngineShaderLib));
    wd.LightShaderLib = LightShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightEndShaderLib = (function (_super) {
        __extends(LightEndShaderLib, _super);
        function LightEndShaderLib() {
            _super.apply(this, arguments);
            this.type = "lightEnd";
        }
        LightEndShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        LightEndShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            if (material.alphaTest !== null) {
                this.fsSourceBody += "if (totalColor.a < " + material.alphaTest + "){\n    discard;\n}\n";
            }
        };
        return LightEndShaderLib;
    }(wd.EngineShaderLib));
    wd.LightEndShaderLib = LightEndShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BaseLightMapShaderLib = (function (_super) {
        __extends(BaseLightMapShaderLib, _super);
        function BaseLightMapShaderLib() {
            _super.apply(this, arguments);
        }
        BaseLightMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        return BaseLightMapShaderLib;
    }(wd.EngineShaderLib));
    wd.BaseLightMapShaderLib = BaseLightMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonLightMapShaderLib = (function (_super) {
        __extends(CommonLightMapShaderLib, _super);
        function CommonLightMapShaderLib() {
            _super.apply(this, arguments);
        }
        CommonLightMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CommonLightMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var texCoordBuffer = cmd.buffers.getChild(wd.EBufferDataType.TEXCOORD);
            if (!texCoordBuffer) {
                return;
            }
            this.sendAttributeBuffer(program, "a_texCoord", texCoordBuffer);
            this.sendUniformData(program, "u_specular", material.specularColor.toVector3());
        };
        CommonLightMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_texCoord"]);
            this.addUniformVariable(["u_specular"]);
        };
        return CommonLightMapShaderLib;
    }(wd.EngineShaderLib));
    wd.CommonLightMapShaderLib = CommonLightMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightMapShaderLib = (function (_super) {
        __extends(LightMapShaderLib, _super);
        function LightMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "lightMap";
        }
        LightMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        LightMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_lightMapIntensity", material.lightMapIntensity);
        };
        LightMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("lightMap"), "u_lightMapIntensity"
            ]);
        };
        return LightMapShaderLib;
    }(wd.BaseLightMapShaderLib));
    wd.LightMapShaderLib = LightMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DiffuseMapShaderLib = (function (_super) {
        __extends(DiffuseMapShaderLib, _super);
        function DiffuseMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "diffuseMap";
        }
        DiffuseMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        DiffuseMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var diffuseMap = material.diffuseMap;
            this.sendUniformData(program, "u_diffuseMapSourceRegion", diffuseMap.sourceRegionForGLSL);
            this.sendUniformData(program, "u_diffuseMapRepeatRegion", diffuseMap.repeatRegion);
            return this;
        };
        DiffuseMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("diffuseMap"),
                "u_diffuseMapSourceRegion", "u_diffuseMapRepeatRegion"
            ]);
        };
        __decorate([
            wd.require(function (program, cmd, material) {
                var diffuseMap = material.diffuseMap;
                wd.assert(!!diffuseMap, wd.Log.info.FUNC_MUST_DEFINE("diffuseMap"));
                wd.assert(!!diffuseMap.sourceRegionForGLSL && !!diffuseMap.repeatRegion, wd.Log.info.FUNC_SHOULD("material.diffuseMap", "has sourceRegionForGLSL,repeatRegion data"));
            })
        ], DiffuseMapShaderLib.prototype, "sendShaderVariables", null);
        return DiffuseMapShaderLib;
    }(wd.BaseLightMapShaderLib));
    wd.DiffuseMapShaderLib = DiffuseMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SpecularMapShaderLib = (function (_super) {
        __extends(SpecularMapShaderLib, _super);
        function SpecularMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "specularMap";
        }
        SpecularMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        SpecularMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("specularMap")
            ]);
        };
        return SpecularMapShaderLib;
    }(wd.BaseLightMapShaderLib));
    wd.SpecularMapShaderLib = SpecularMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EmissionMapShaderLib = (function (_super) {
        __extends(EmissionMapShaderLib, _super);
        function EmissionMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "emissionMap";
        }
        EmissionMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        EmissionMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("emissionMap")
            ]);
        };
        return EmissionMapShaderLib;
    }(wd.BaseLightMapShaderLib));
    wd.EmissionMapShaderLib = EmissionMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMapShaderLib = (function (_super) {
        __extends(NormalMapShaderLib, _super);
        function NormalMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "normalMap";
        }
        NormalMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NormalMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var tangentBuffer = null;
            _super.prototype.sendShaderVariables.call(this, program, cmd, material);
            tangentBuffer = cmd.buffers.getChild(wd.EBufferDataType.TANGENT);
            if (!tangentBuffer) {
                return;
            }
            this.sendAttributeBuffer(program, "a_tangent", tangentBuffer);
        };
        NormalMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_tangent"]);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("normalMap")
            ]);
        };
        return NormalMapShaderLib;
    }(wd.BaseLightMapShaderLib));
    wd.NormalMapShaderLib = NormalMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NoLightMapShaderLib = (function (_super) {
        __extends(NoLightMapShaderLib, _super);
        function NoLightMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "noLightMap";
        }
        NoLightMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NoLightMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        return NoLightMapShaderLib;
    }(wd.EngineShaderLib));
    wd.NoLightMapShaderLib = NoLightMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NoDiffuseMapShaderLib = (function (_super) {
        __extends(NoDiffuseMapShaderLib, _super);
        function NoDiffuseMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "noDiffuseMap";
        }
        NoDiffuseMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NoDiffuseMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_diffuse", material.color.toVector3());
        };
        NoDiffuseMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_diffuse"]);
        };
        return NoDiffuseMapShaderLib;
    }(wd.EngineShaderLib));
    wd.NoDiffuseMapShaderLib = NoDiffuseMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NoSpecularMapShaderLib = (function (_super) {
        __extends(NoSpecularMapShaderLib, _super);
        function NoSpecularMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "noSpecularMap";
        }
        NoSpecularMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return NoSpecularMapShaderLib;
    }(wd.EngineShaderLib));
    wd.NoSpecularMapShaderLib = NoSpecularMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NoEmissionMapShaderLib = (function (_super) {
        __extends(NoEmissionMapShaderLib, _super);
        function NoEmissionMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "noEmissionMap";
        }
        NoEmissionMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NoEmissionMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_emission", material.emissionColor.toVector3());
        };
        NoEmissionMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_emission"]);
        };
        return NoEmissionMapShaderLib;
    }(wd.EngineShaderLib));
    wd.NoEmissionMapShaderLib = NoEmissionMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NoNormalMapShaderLib = (function (_super) {
        __extends(NoNormalMapShaderLib, _super);
        function NoNormalMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "noNormalMap";
        }
        NoNormalMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NoNormalMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        NoNormalMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            var noNormalMap_light_fragment = null;
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            noNormalMap_light_fragment = wd.ShaderChunk.noNormalMap_light_fragment;
            this.fsSourceVarDeclare = noNormalMap_light_fragment.varDeclare;
            this.fsSourceFuncDefine += noNormalMap_light_fragment.funcDefine;
        };
        return NoNormalMapShaderLib;
    }(wd.EngineShaderLib));
    wd.NoNormalMapShaderLib = NoNormalMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NoShadowMapShaderLib = (function (_super) {
        __extends(NoShadowMapShaderLib, _super);
        function NoShadowMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "noShadowMap";
        }
        NoShadowMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NoShadowMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        return NoShadowMapShaderLib;
    }(wd.EngineShaderLib));
    wd.NoShadowMapShaderLib = NoShadowMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomShaderLibUtils = (function () {
        function CustomShaderLibUtils() {
        }
        CustomShaderLibUtils.sendUniformData = function (name, type, value, program) {
            if (type === wd.EVariableType.STRUCTURE) {
                this._sendStructureData(name, value, program);
            }
            else {
                program.sendUniformData(name, type, value);
            }
        };
        CustomShaderLibUtils.sendUniformDataWithSemantic = function (name, type, value, program, cmd) {
            if (type === wd.EVariableType.STRUCTURE) {
                this._sendStructureDataWithSemantic(name, value, program, cmd);
            }
            else {
                program.sendUniformData(name, type, this._getUniformData(value, cmd));
            }
        };
        CustomShaderLibUtils.sendAttributeBufferWithSemantic = function (name, type, value, program, cmd) {
            program.sendAttributeBuffer(name, this._getAttributeType(type), this._getAttributeData(value, type, cmd));
        };
        CustomShaderLibUtils._sendStructureData = function (name, data, program) {
            for (var fieldName in data) {
                if (data.hasOwnProperty(fieldName)) {
                    var fieldValue = data[fieldName];
                    program.sendStructureData(name + "." + fieldName, fieldValue.type, fieldValue.value);
                }
            }
        };
        CustomShaderLibUtils._sendStructureDataWithSemantic = function (name, data, program, cmd) {
            for (var fieldName in data) {
                if (data.hasOwnProperty(fieldName)) {
                    var fieldValue = data[fieldName];
                    program.sendStructureData(name + "." + fieldName, fieldValue.type, this._getUniformData(fieldValue.value, cmd));
                }
            }
        };
        CustomShaderLibUtils._getAttributeData = function (data, type, cmd) {
            switch (data) {
                case wd.EVariableSemantic.POSITION:
                    return cmd.buffers.getChild(wd.EBufferDataType.VERTICE);
                case wd.EVariableSemantic.TEXCOORD:
                    return cmd.buffers.getChild(wd.EBufferDataType.TEXCOORD);
                case wd.EVariableSemantic.COLOR:
                    return cmd.buffers.getChild(wd.EBufferDataType.COLOR);
                case wd.EVariableSemantic.NORMAL:
                    return cmd.buffers.getChild(wd.EBufferDataType.NORMAL);
                case wd.EVariableSemantic.TANGENT:
                    return cmd.buffers.getChild(wd.EBufferDataType.TANGENT);
                default:
                    return data;
            }
        };
        CustomShaderLibUtils._getAttributeType = function (type) {
            return wd.EVariableType.BUFFER;
        };
        CustomShaderLibUtils._getUniformData = function (data, cmd) {
            switch (data) {
                case wd.EVariableSemantic.MODEL:
                    return cmd.mMatrix;
                case wd.EVariableSemantic.VIEW:
                    return cmd.vMatrix;
                case wd.EVariableSemantic.PROJECTION:
                    return cmd.pMatrix;
                case wd.EVariableSemantic.MODEL_VIEW_PROJECTION:
                    return cmd.mvpMatrix;
                case wd.EVariableSemantic.MODEL_INVERSE:
                    return cmd.mMatrix.clone().invert();
                case wd.EVariableSemantic.VIEW_INVERSE:
                    return cmd.vMatrix.clone().invert();
                case wd.EVariableSemantic.PROJECTION_INVERSE:
                    return cmd.pMatrix.clone().invert();
                case wd.EVariableSemantic.MODEL_VIEW_INVERSE:
                    return cmd.mMatrix.applyMatrix(cmd.vMatrix, true).invert();
                case wd.EVariableSemantic.MODEL_VIEW_PROJECTION_INVERSE:
                    return cmd.mMatrix.applyMatrix(cmd.vMatrix, true).applyMatrix(cmd.pMatrix, false).invert();
                case wd.EVariableSemantic.MODEL_INVERSE_TRANSPOSE:
                    return cmd.normalMatrix;
                case wd.EVariableSemantic.MODEL_VIEW_INVERSE_TRANSPOSE:
                    return cmd.mMatrix.applyMatrix(cmd.vMatrix, true).invertTo3x3().transpose();
                case wd.EVariableSemantic.VIEWPORT:
                    return wd.DeviceManager.getInstance().getViewport();
                default:
                    return data;
            }
        };
        __decorate([
            wd.require(function (name, type, value, program) {
                wd.assert(type !== wd.EVariableType.SAMPLER_2D && type !== wd.EVariableType.SAMPLER_CUBE, wd.Log.info.FUNC_SHOULD_NOT("type", "be SAMPLER_2D or SAMPLER_CUBE, but actual is " + type));
                wd.assert(type !== wd.EVariableType.STRUCTURES, wd.Log.info.FUNC_NOT_SUPPORT("type === STRUCTURES"));
                if (type === wd.EVariableType.STRUCTURE) {
                    wd.assert(wd.JudgeUtils.isDirectObject(value), wd.Log.info.FUNC_MUST_BE("value", "object when type === STRUCTURE"));
                }
            })
        ], CustomShaderLibUtils, "sendUniformData", null);
        __decorate([
            wd.require(function (name, type, value, program, cmd) {
                wd.assert(type !== wd.EVariableType.SAMPLER_2D && type !== wd.EVariableType.SAMPLER_CUBE, wd.Log.info.FUNC_SHOULD_NOT("type", "be SAMPLER_2D or SAMPLER_CUBE, but actual is " + type));
                wd.assert(type !== wd.EVariableType.STRUCTURES, wd.Log.info.FUNC_NOT_SUPPORT("type === STRUCTURES"));
                if (type === wd.EVariableType.STRUCTURE) {
                    wd.assert(wd.JudgeUtils.isDirectObject(value), wd.Log.info.FUNC_MUST_BE("value", "object when type === STRUCTURE"));
                }
            })
        ], CustomShaderLibUtils, "sendUniformDataWithSemantic", null);
        __decorate([
            wd.require(function (data, type, cmd) {
                wd.assert(data !== "INDICE", wd.Log.info.FUNC_NOT_SUPPORT("semantic:INDICE"));
                switch (data) {
                    case "POSITION":
                    case "COLOR":
                    case "NORMAL":
                    case "TANGENT":
                        wd.assert(type === wd.EVariableType.FLOAT_3, wd.Log.info.FUNC_SHOULD("type", "be EVariableType.FLOAT_3"));
                        break;
                    case "TEXCOORD":
                        wd.assert(type === wd.EVariableType.FLOAT_2, wd.Log.info.FUNC_SHOULD("type", "be EVariableType.FLOAT_2"));
                        break;
                }
            }),
            wd.ensure(function (data) {
                wd.assert(data && data instanceof wd.Buffer, wd.Log.info.FUNC_SHOULD("attributeData", "be Buffer, but actual is " + data));
            })
        ], CustomShaderLibUtils, "_getAttributeData", null);
        return CustomShaderLibUtils;
    }());
    wd.CustomShaderLibUtils = CustomShaderLibUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RenderTargerRendererShaderLibUtils = (function () {
        function RenderTargerRendererShaderLibUtils() {
        }
        RenderTargerRendererShaderLibUtils.judgeAndSendIsRenderListEmptyVariable = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var glslData = null, program = args[0], glslDataKey = args[1], variableName = null;
            glslData = wd.Director.getInstance().scene.glslData.getChild(glslDataKey);
            if (!glslData) {
                return;
            }
            if (args.length === 3) {
                variableName = args[2];
            }
            else {
                variableName = "u_isRenderListEmpty";
            }
            if (glslData.isRenderListEmpty) {
                program.sendUniformData(variableName, wd.EVariableType.NUMBER_1, 1);
            }
            else {
                program.sendUniformData(variableName, wd.EVariableType.NUMBER_1, 0);
            }
        };
        return RenderTargerRendererShaderLibUtils;
    }());
    wd.RenderTargerRendererShaderLibUtils = RenderTargerRendererShaderLibUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var InstanceShaderLib = (function (_super) {
        __extends(InstanceShaderLib, _super);
        function InstanceShaderLib() {
            _super.apply(this, arguments);
        }
        return InstanceShaderLib;
    }(wd.EngineShaderLib));
    wd.InstanceShaderLib = InstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NoInstanceShaderLib = (function (_super) {
        __extends(NoInstanceShaderLib, _super);
        function NoInstanceShaderLib() {
            _super.apply(this, arguments);
        }
        return NoInstanceShaderLib;
    }(wd.EngineShaderLib));
    wd.NoInstanceShaderLib = NoInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelMatrixInstanceShaderLib = (function (_super) {
        __extends(ModelMatrixInstanceShaderLib, _super);
        function ModelMatrixInstanceShaderLib() {
            _super.apply(this, arguments);
        }
        return ModelMatrixInstanceShaderLib;
    }(wd.InstanceShaderLib));
    wd.ModelMatrixInstanceShaderLib = ModelMatrixInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMatrixModelMatrixInstanceShaderLib = (function (_super) {
        __extends(NormalMatrixModelMatrixInstanceShaderLib, _super);
        function NormalMatrixModelMatrixInstanceShaderLib() {
            _super.apply(this, arguments);
        }
        return NormalMatrixModelMatrixInstanceShaderLib;
    }(wd.InstanceShaderLib));
    wd.NormalMatrixModelMatrixInstanceShaderLib = NormalMatrixModelMatrixInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelMatrixHardwareInstanceShaderLib = (function (_super) {
        __extends(ModelMatrixHardwareInstanceShaderLib, _super);
        function ModelMatrixHardwareInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "modelMatrix_hardware_instance";
        }
        ModelMatrixHardwareInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        ModelMatrixHardwareInstanceShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        ModelMatrixHardwareInstanceShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_mVec4_0", "a_mVec4_1", "a_mVec4_2", "a_mVec4_3"
            ]);
        };
        return ModelMatrixHardwareInstanceShaderLib;
    }(wd.ModelMatrixInstanceShaderLib));
    wd.ModelMatrixHardwareInstanceShaderLib = ModelMatrixHardwareInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMatrixHardwareInstanceShaderLib = (function (_super) {
        __extends(NormalMatrixHardwareInstanceShaderLib, _super);
        function NormalMatrixHardwareInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "normalMatrix_hardware_instance";
        }
        NormalMatrixHardwareInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NormalMatrixHardwareInstanceShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        NormalMatrixHardwareInstanceShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_normalVec4_0", "a_normalVec4_1", "a_normalVec4_2"]);
        };
        return NormalMatrixHardwareInstanceShaderLib;
    }(wd.NormalMatrixModelMatrixInstanceShaderLib));
    wd.NormalMatrixHardwareInstanceShaderLib = NormalMatrixHardwareInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelMatrixBatchInstanceShaderLib = (function (_super) {
        __extends(ModelMatrixBatchInstanceShaderLib, _super);
        function ModelMatrixBatchInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "modelMatrix_batch_instance";
        }
        ModelMatrixBatchInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        ModelMatrixBatchInstanceShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        ModelMatrixBatchInstanceShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_mMatrix"]);
        };
        return ModelMatrixBatchInstanceShaderLib;
    }(wd.ModelMatrixInstanceShaderLib));
    wd.ModelMatrixBatchInstanceShaderLib = ModelMatrixBatchInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMatrixBatchInstanceShaderLib = (function (_super) {
        __extends(NormalMatrixBatchInstanceShaderLib, _super);
        function NormalMatrixBatchInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "normalMatrix_batch_instance";
        }
        NormalMatrixBatchInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NormalMatrixBatchInstanceShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        NormalMatrixBatchInstanceShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_normalMatrix"]);
        };
        return NormalMatrixBatchInstanceShaderLib;
    }(wd.NormalMatrixModelMatrixInstanceShaderLib));
    wd.NormalMatrixBatchInstanceShaderLib = NormalMatrixBatchInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelMatrixNoInstanceShaderLib = (function (_super) {
        __extends(ModelMatrixNoInstanceShaderLib, _super);
        function ModelMatrixNoInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "modelMatrix_noInstance";
        }
        ModelMatrixNoInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        ModelMatrixNoInstanceShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_mMatrix", cmd.mMatrix);
        };
        ModelMatrixNoInstanceShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_mMatrix"]);
        };
        return ModelMatrixNoInstanceShaderLib;
    }(wd.NoInstanceShaderLib));
    wd.ModelMatrixNoInstanceShaderLib = ModelMatrixNoInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var NormalMatrixNoInstanceShaderLib = (function (_super) {
        __extends(NormalMatrixNoInstanceShaderLib, _super);
        function NormalMatrixNoInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "normalMatrix_noInstance";
        }
        NormalMatrixNoInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        NormalMatrixNoInstanceShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_normalMatrix", cmd.normalMatrix);
        };
        NormalMatrixNoInstanceShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_normalMatrix"]);
        };
        return NormalMatrixNoInstanceShaderLib;
    }(wd.NoInstanceShaderLib));
    wd.NormalMatrixNoInstanceShaderLib = NormalMatrixNoInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShaderChunk = (function () {
        function ShaderChunk() {
        }
        ShaderChunk.empty = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
        ShaderChunk.NULL = -1.0;
        ShaderChunk.basic_materialColor_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "vec4 totalColor = vec4(u_color, 1.0);\n", };
        ShaderChunk.basic_vertexColor_fragment = { top: "", define: "", varDeclare: "varying vec3 v_color;\n", funcDeclare: "", funcDefine: "", body: "vec4 totalColor = vec4(v_color, 1.0);\n", };
        ShaderChunk.basic_vertexColor_vertex = { top: "", define: "", varDeclare: "varying vec3 v_color;\n", funcDeclare: "", funcDefine: "", body: "v_color = a_color;\n", };
        ShaderChunk.end_basic_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_FragColor = vec4(totalColor.rgb, totalColor.a * u_opacity);\n", };
        ShaderChunk.common_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 flipNormal(vec3 normal){\n    vec3 normalForRefraction = normal;\n    normalForRefraction.y = -normalForRefraction.y;\n    normalForRefraction.z = -normalForRefraction.z;\n\n    return normalForRefraction;\n}\n", body: "", };
        ShaderChunk.normal_morph_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "vec3 a_normal = a_currentFrameNormal + (a_nextFrameNormal - a_currentFrameNormal) * u_interpolation;\n", };
        ShaderChunk.vertice_morph_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "vec3 a_position = a_currentFramePosition + (a_nextFramePosition - a_currentFramePosition) * u_interpolation;\n", };
        ShaderChunk.vertice_skinSkeleton_vertex = { top: "", define: "", varDeclare: "uniform mat4 u_jointMatrices[MAX_JOINT_COUNT];\n", funcDeclare: "", funcDefine: "mat4 getJointMatrix(const in float i) {\n        return u_jointMatrices[int(i)];\n    }\n\n    mat4 getVertexBlendedJointMatrix() {\n        return getJointMatrix(a_jointIndice.x) * a_jointWeight.x + getJointMatrix(a_jointIndice.y) * a_jointWeight.y + getJointMatrix(a_jointIndice.z) * a_jointWeight.z + getJointMatrix(a_jointIndice.w) * a_jointWeight.w;\n    }\n", body: "vec3 a_position = vec3(getVertexBlendedJointMatrix() * vec4(a_position, 1.0));\n", };
        ShaderChunk.common_define = { top: "", define: "#define NULL -1.0\n", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.common_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.common_function = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "mat2 transpose(mat2 m) {\n  return mat2(  m[0][0], m[1][0],   // new col 0\n                m[0][1], m[1][1]    // new col 1\n             );\n  }\nmat3 transpose(mat3 m) {\n  return mat3(  m[0][0], m[1][0], m[2][0],  // new col 0\n                m[0][1], m[1][1], m[2][1],  // new col 1\n                m[0][2], m[1][2], m[2][2]   // new col 1\n             );\n  }\n\nbool isRenderListEmpty(int isRenderListEmpty){\n  return isRenderListEmpty == 1;\n}\n", body: "", };
        ShaderChunk.common_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.highp_fragment = { top: "precision highp float;\nprecision highp int;\n", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.lowp_fragment = { top: "precision lowp float;\nprecision lowp int;\n", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.mediump_fragment = { top: "precision mediump float;\nprecision mediump int;\n", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.noNormalMap_light_fragment = { top: "", define: "", varDeclare: "varying vec3 v_normal;\n", funcDeclare: "", funcDefine: "#if POINT_LIGHTS_COUNT > 0\nvec3 getPointLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getPointLightDirByLightPos(u_pointLights[x].position);\n        }\n    }\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvec3 getDirectionLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getDirectionLightDirByLightPos(u_directionLights[x].position);\n        }\n    }\n\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n\nvec3 getViewDir(){\n    return normalize(u_cameraPos - v_worldPosition);\n}\n", body: "", };
        ShaderChunk.map_forBasic_fragment = { top: "", define: "", varDeclare: "varying vec2 v_mapCoord0;\n", funcDeclare: "", funcDefine: "", body: "totalColor *= texture2D(u_sampler2D0, v_mapCoord0);\n", };
        ShaderChunk.map_forBasic_vertex = { top: "", define: "", varDeclare: "varying vec2 v_mapCoord0;\n", funcDeclare: "", funcDefine: "", body: "vec2 sourceTexCoord0 = a_texCoord * u_map0SourceRegion.zw + u_map0SourceRegion.xy;\n\n    v_mapCoord0 = sourceTexCoord0 * u_map0RepeatRegion.zw + u_map0RepeatRegion.xy;\n", };
        ShaderChunk.multi_map_forBasic_fragment = { top: "", define: "", varDeclare: "varying vec2 v_mapCoord0;\nvarying vec2 v_mapCoord1;\n", funcDeclare: "", funcDefine: "vec4 getMapColor(){\n            vec4 color0 = texture2D(u_sampler2D0, v_mapCoord0);\n            vec4 color1 = texture2D(u_sampler2D1, v_mapCoord1);\n\n            if(u_combineMode == 0){\n                return mix(color0, color1, u_mixRatio);\n            }\n            else if(u_combineMode == 1){\n                return color0 * color1;\n            }\n            else if(u_combineMode == 2){\n                return color0 + color1;\n            }\n\n            /*!\n            solve error in window7 chrome/firefox:\n            not all control paths return a value.\n            failed to create d3d shaders\n            */\n            return vec4(1.0);\n		}\n", body: "totalColor *= getMapColor();\n", };
        ShaderChunk.multi_map_forBasic_vertex = { top: "", define: "", varDeclare: "varying vec2 v_mapCoord1;\n", funcDeclare: "", funcDefine: "", body: "vec2 sourceTexCoord1 = a_texCoord * u_map1SourceRegion.zw + u_map1SourceRegion.xy;\n\n    v_mapCoord1 = sourceTexCoord1 * u_map1RepeatRegion.zw + u_map1RepeatRegion.xy;\n", };
        ShaderChunk.common_proceduralTexture_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float rand(vec2 n) {\n	return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n	const vec2 d = vec2(0.0, 1.0);\n	vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n	return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat turbulence(vec2 P)\n{\n	float val = 0.0;\n	float freq = 1.0;\n	for (int i = 0; i < 4; i++)\n	{\n		val += abs(noise(P*freq) / freq);\n		freq *= 2.07;\n	}\n	return val;\n}\n\nfloat fbm(vec2 n) {\n	float total = 0.0, amplitude = 1.0;\n	for (int i = 0; i < 4; i++) {\n		total += noise(n) * amplitude;\n		n += n;\n		amplitude *= 0.5;\n	}\n	return total;\n}\n\nfloat round(float number){\n	return sign(number)*floor(abs(number) + 0.5);\n}\n", body: "", };
        ShaderChunk.common_proceduralTexture_vertex = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\nconst vec2 MADD=vec2(0.5,0.5);\n", funcDeclare: "", funcDefine: "", body: "v_texCoord=a_positionVec2*MADD+MADD;\n\n    gl_Position=vec4(a_positionVec2, 0.0 ,1.0);\n", };
        ShaderChunk.skybox_fragment = { top: "", define: "", varDeclare: "varying vec3 v_dir;\n", funcDeclare: "", funcDefine: "", body: "gl_FragColor = textureCube(u_samplerCube0, v_dir);\n", };
        ShaderChunk.skybox_vertex = { top: "", define: "", varDeclare: "varying vec3 v_dir;\n", funcDeclare: "", funcDefine: "", body: "vec4 pos = u_pMatrix * mat4(mat3(u_vMatrix)) * mMatrix * vec4(a_position, 1.0);\n\n    gl_Position = pos.xyww;\n\n    v_dir = a_position;\n", };
        ShaderChunk.lightCommon_fragment = { top: "", define: "", varDeclare: "varying vec3 v_worldPosition;\n#if POINT_LIGHTS_COUNT > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\nstruct DirectionLight {\n    vec3 position;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.lightCommon_vertex = { top: "", define: "", varDeclare: "varying vec3 v_worldPosition;\n#if POINT_LIGHTS_COUNT > 0\n    struct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\n    struct DirectionLight {\n    vec3 position;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.lightEnd_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_FragColor = totalColor;\n", };
        ShaderChunk.light_common = { top: "", define: "", varDeclare: "", funcDeclare: "vec3 getDirectionLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition);\n", funcDefine: "vec3 getDirectionLightDirByLightPos(vec3 lightPos){\n    return lightPos - vec3(0.0);\n    //return vec3(0.0) - lightPos;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos){\n    return lightPos - v_worldPosition;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition){\n    return lightPos - worldPosition;\n}\n", body: "", };
        ShaderChunk.light_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float getBlinnShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 halfAngle = normalize(lightDir + viewDir);\n        float blinnTerm = dot(normal, halfAngle);\n\n        blinnTerm = clamp(blinnTerm, 0.0, 1.0);\n        blinnTerm = dotResultBetweenNormAndLight != 0.0 ? blinnTerm : 0.0;\n        blinnTerm = pow(blinnTerm, shininess);\n\n        return blinnTerm;\n}\n\nfloat getPhongShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float phongTerm = dot(viewDir, reflectDir);\n\n        phongTerm = clamp(phongTerm, 0.0, 1.0);\n        phongTerm = dotResultBetweenNormAndLight != 0.0 ? phongTerm : 0.0;\n        phongTerm = pow(phongTerm, shininess);\n\n        return phongTerm;\n}\n\nvec4 calcLight(vec3 lightDir, vec3 color, float intensity, float attenuation, vec3 normal, vec3 viewDir)\n{\n        vec3 materialLight = getMaterialLight();\n        vec4 materialDiffuse = getMaterialDiffuse();\n        vec3 materialSpecular = u_specular;\n        vec3 materialEmission = getMaterialEmission();\n\n        float specularStrength = getSpecularStrength();\n\n        float dotResultBetweenNormAndLight = dot(normal, lightDir);\n        float diff = max(dotResultBetweenNormAndLight, 0.0);\n\n        vec3 emissionColor = materialEmission;\n\n        vec3 ambientColor = (u_ambient + materialLight) * materialDiffuse.rgb;\n\n\n        if(u_lightModel == 3){\n            return vec4(emissionColor + ambientColor, 1.0);\n        }\n\n        vec4 diffuseColor = vec4(color * materialDiffuse.rgb * diff * intensity, materialDiffuse.a);\n\n        float spec = 0.0;\n\n        if(u_lightModel == 2){\n                spec = getPhongShininess(u_shininess, normal, lightDir, viewDir, diff);\n        }\n        else if(u_lightModel == 1){\n                spec = getBlinnShininess(u_shininess, normal, lightDir, viewDir, diff);\n        }\n\n        vec3 specularColor = spec * materialSpecular * specularStrength * intensity;\n\n        return vec4(emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor), diffuseColor.a);\n//        return vec4(emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor), 1.0);\n}\n\n\n\n\n#if POINT_LIGHTS_COUNT > 0\n        vec4 calcPointLight(vec3 lightDir, PointLight light, vec3 normal, vec3 viewDir)\n{\n        //lightDir is not normalize computing distance\n        float distance = length(lightDir);\n\n        float attenuation = 0.0;\n\n        if(light.range == NULL || distance < light.range)\n        {\n            attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n        }\n\n        lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\n        vec4 calcDirectionLight(vec3 lightDir, DirectionLight light, vec3 normal, vec3 viewDir)\n{\n        float attenuation = 1.0;\n\n        lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\nvec4 calcTotalLight(vec3 norm, vec3 viewDir){\n    vec4 totalLight = vec4(0.0);\n\n    #if POINT_LIGHTS_COUNT > 0\n                for(int i = 0; i < POINT_LIGHTS_COUNT; i++){\n                totalLight += calcPointLight(getPointLightDir(i), u_pointLights[i], norm, viewDir);\n        }\n    #endif\n\n    #if DIRECTION_LIGHTS_COUNT > 0\n                for(int i = 0; i < DIRECTION_LIGHTS_COUNT; i++){\n                totalLight += calcDirectionLight(getDirectionLightDir(i), u_directionLights[i], norm, viewDir);\n        }\n    #endif\n\n        return totalLight;\n}\n", body: "vec3 normal = normalize(getNormal());\n\n#ifdef BOTH_SIDE\nnormal = normal * (-1.0 + 2.0 * float(gl_FrontFacing));\n#endif\n\nvec3 viewDir = normalize(getViewDir());\n\nvec4 totalColor = calcTotalLight(normal, viewDir);\n\ntotalColor.a *= u_opacity;\n\ntotalColor.rgb = totalColor.rgb * getShadowVisibility();\n", };
        ShaderChunk.light_setWorldPosition_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "v_worldPosition = vec3(mMatrix * vec4(a_position, 1.0));\n", };
        ShaderChunk.light_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_Position = u_pMatrix * u_vMatrix * vec4(v_worldPosition, 1.0);\n", };
        ShaderChunk.basic_forBasic_envMap_fragment = { top: "", define: "", varDeclare: "varying vec3 v_dir;\n", funcDeclare: "", funcDefine: "", body: "totalColor *= textureCube(u_samplerCube0, v_dir);\n", };
        ShaderChunk.basic_forBasic_envMap_vertex = { top: "", define: "", varDeclare: "varying vec3 v_dir;\n", funcDeclare: "", funcDefine: "", body: "v_dir = a_position;\n", };
        ShaderChunk.forBasic_envMap_fragment = { top: "", define: "", varDeclare: "varying vec3 v_normal;\nvarying vec3 v_position;\n", funcDeclare: "", funcDefine: "", body: "vec3 inDir = normalize(v_position - u_cameraPos);\n", };
        ShaderChunk.forBasic_envMap_vertex = { top: "", define: "", varDeclare: "varying vec3 v_normal;\nvarying vec3 v_position;\n", funcDeclare: "", funcDefine: "", body: "v_normal = normalize( normalMatrix * a_normal);\n    v_position = vec3(mMatrix * vec4(a_position, 1.0));\n", };
        ShaderChunk.fresnel_forBasic_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float computeFresnelRatio(vec3 inDir, vec3 normal, float refractionRatio){\n    float f = pow(1.0 - refractionRatio, 2.0) / pow(1.0 + refractionRatio, 2.0);\n    float fresnelPower = 5.0;\n    float ratio = f + (1.0 - f) * pow((1.0 - dot(inDir, normal)), fresnelPower);\n\n    return ratio / 100.0;\n}\nvec4 getEnvMapTotalColor(vec3 inDir, vec3 normal){\n    vec3 reflectDir = reflect(inDir, normal);\n    vec3 refractDir = refract(inDir, flipNormal(normal), u_refractionRatio);\n\n    vec4 reflectColor = textureCube(u_samplerCube0, reflectDir);\n    vec4 refractColor = textureCube(u_samplerCube0, refractDir);\n\n    vec4 totalColor = vec4(0.0);\n\n	if(u_reflectivity != NULL){\n        totalColor = mix(reflectColor, refractColor, u_reflectivity);\n	}\n	else{\n        totalColor = mix(reflectColor, refractColor, computeFresnelRatio(inDir, normal, u_refractionRatio));\n	}\n\n	return totalColor;\n}\n", body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= getEnvMapTotalColor(inDir, normalize(v_normal));\n}\n", };
        ShaderChunk.reflection_forBasic_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, reflect(inDir, normalize(v_normal)));\n}\n", };
        ShaderChunk.refraction_forBasic_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, refract(inDir, v_normal, u_refractionRatio));\n}\n", };
        ShaderChunk.basic_forLight_envMap_fragment = { top: "", define: "", varDeclare: "varying vec3 v_basicEnvMap_dir;\n", funcDeclare: "", funcDefine: "", body: "totalColor *= textureCube(u_samplerCube0, v_basicEnvMap_dir);\n", };
        ShaderChunk.basic_forLight_envMap_vertex = { top: "", define: "", varDeclare: "varying vec3 v_basicEnvMap_dir;\n", funcDeclare: "", funcDefine: "", body: "v_basicEnvMap_dir = a_position;\n", };
        ShaderChunk.forLight_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "vec3 inDir = normalize(v_worldPosition - u_cameraPos);\n", };
        ShaderChunk.forLight_envMap_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.fresnel_forLight_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float computeFresnelRatio(vec3 inDir, vec3 normal, float refractionRatio){\n    float f = pow(1.0 - refractionRatio, 2.0) / pow(1.0 + refractionRatio, 2.0);\n    float fresnelPower = 5.0;\n    float ratio = f + (1.0 - f) * pow((1.0 - dot(inDir, normal)), fresnelPower);\n\n    return ratio / 100.0;\n}\n\nvec4 getEnvMapTotalColor(vec3 inDir, vec3 normal){\n    vec3 reflectDir = reflect(inDir, normal);\n\n/*!\n//todo why only fresnel->refraction need flip normal, but refraction don't need?\n*/\n    vec3 refractDir = refract(inDir, flipNormal(normal), u_refractionRatio);\n\n    vec4 reflectColor = textureCube(u_samplerCube0, reflectDir);\n    vec4 refractColor = textureCube(u_samplerCube0, refractDir);\n\n\n    vec4 totalColor = vec4(0.0);\n\n	if(u_reflectivity != NULL){\n        totalColor = mix(reflectColor, refractColor, u_reflectivity);\n	}\n	else{\n        totalColor = mix(reflectColor, refractColor, computeFresnelRatio(inDir, normal, u_refractionRatio));\n	}\n\n	return totalColor;\n}\n", body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n	totalColor *= getEnvMapTotalColor(inDir, normalize(getNormal()));\n}\n", };
        ShaderChunk.reflection_forLight_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, reflect(inDir, normalize(getNormal())));\n}\n", };
        ShaderChunk.refraction_forLight_envMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= textureCube(u_samplerCube0, refract(inDir, flipNormal(normal), u_refractionRatio));\n}\n", };
        ShaderChunk.modelMatrix_batch_instance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat4 mMatrix = u_mMatrix;\n", };
        ShaderChunk.normalMatrix_batch_instance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat3 normalMatrix = u_normalMatrix;\n", };
        ShaderChunk.modelMatrix_hardware_instance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat4 mMatrix = mat4(a_mVec4_0, a_mVec4_1, a_mVec4_2, a_mVec4_3);\n", };
        ShaderChunk.normalMatrix_hardware_instance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat3 normalMatrix = mat3(a_normalVec4_0, a_normalVec4_1, a_normalVec4_2);\n", };
        ShaderChunk.modelMatrix_noInstance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat4 mMatrix = u_mMatrix;\n", };
        ShaderChunk.normalMatrix_noInstance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat3 normalMatrix = u_normalMatrix;\n", };
        ShaderChunk.diffuseMap_fragment = { top: "", define: "", varDeclare: "varying vec2 v_diffuseMapTexCoord;\n", funcDeclare: "", funcDefine: "vec4 getMaterialDiffuse() {\n        return texture2D(u_diffuseMapSampler, v_diffuseMapTexCoord);\n    }\n", body: "", };
        ShaderChunk.diffuseMap_vertex = { top: "", define: "", varDeclare: "varying vec2 v_diffuseMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "//todo optimize(combine, reduce compute numbers)\n    //todo BasicTexture extract textureMatrix\n    vec2 sourceTexCoord = a_texCoord * u_diffuseMapSourceRegion.zw + u_diffuseMapSourceRegion.xy;\n    v_diffuseMapTexCoord = sourceTexCoord * u_diffuseMapRepeatRegion.zw + u_diffuseMapRepeatRegion.xy;\n", };
        ShaderChunk.emissionMap_fragment = { top: "", define: "", varDeclare: "varying vec2 v_emissionMapTexCoord;\n", funcDeclare: "", funcDefine: "vec3 getMaterialEmission() {\n        return texture2D(u_emissionMapSampler, v_emissionMapTexCoord).rgb;\n    }\n", body: "", };
        ShaderChunk.emissionMap_vertex = { top: "", define: "", varDeclare: "varying vec2 v_emissionMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "v_emissionMapTexCoord = a_texCoord;\n", };
        ShaderChunk.lightMap_fragment = { top: "", define: "", varDeclare: "varying vec2 v_lightMapTexCoord;\n", funcDeclare: "", funcDefine: "vec3 getMaterialLight() {\n        return texture2D(u_lightMapSampler, v_lightMapTexCoord).rgb * u_lightMapIntensity;\n    }\n", body: "", };
        ShaderChunk.lightMap_vertex = { top: "", define: "", varDeclare: "varying vec2 v_lightMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "v_lightMapTexCoord = a_texCoord;\n", };
        ShaderChunk.noDiffuseMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec4 getMaterialDiffuse() {\n        return vec4(u_diffuse, 1.0);\n    }\n", body: "", };
        ShaderChunk.noEmissionMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialEmission() {\n        return u_emission;\n    }\n", body: "", };
        ShaderChunk.noLightMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialLight() {\n        return vec3(0.0);\n    }\n", body: "", };
        ShaderChunk.noNormalMap_fragment = { top: "", define: "", varDeclare: "//varying vec3 v_normal;\n//", funcDeclare: "vec3 getNormal();\n\n", funcDefine: "//#if POINT_LIGHTS_COUNT > 0\n//vec3 getPointLightDir(int index){\n//    //workaround '[] : Index expression must be constant' error\n//    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n//        if(x == index){\n//            return getPointLightDirByLightPos(u_pointLights[x].position);\n//        }\n//    }\n//    /*!\n//    solve error in window7 chrome/firefox:\n//    not all control paths return a value.\n//    failed to create d3d shaders\n//    */\n//    return vec3(0.0);\n//}\n//#endif\n//\n//#if DIRECTION_LIGHTS_COUNT > 0\n//vec3 getDirectionLightDir(int index){\n//    //workaround '[] : Index expression must be constant' error\n//    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n//        if(x == index){\n//            return getDirectionLightDirByLightPos(u_directionLights[x].position);\n//        }\n//    }\n//\n//    /*!\n//    solve error in window7 chrome/firefox:\n//    not all control paths return a value.\n//    failed to create d3d shaders\n//    */\n//    return vec3(0.0);\n//}\n//#endif\n//\n//\n//vec3 getViewDir(){\n//    return normalize(u_cameraPos - v_worldPosition);\n//}\nvec3 getNormal(){\n    return v_normal;\n}\n\n", body: "", };
        ShaderChunk.noNormalMap_vertex = { top: "", define: "", varDeclare: "varying vec3 v_normal;\n", funcDeclare: "", funcDefine: "", body: "v_normal = normalize(normalMatrix * a_normal);\n", };
        ShaderChunk.noSpecularMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float getSpecularStrength() {\n        return 1.0;\n    }\n", body: "", };
        ShaderChunk.normalMap_fragment = { top: "", define: "", varDeclare: "varying vec2 v_normalMapTexCoord;\nvarying vec3 v_viewDir;\n#if POINT_LIGHTS_COUNT > 0\nvarying vec3 v_pointLightDir[POINT_LIGHTS_COUNT];\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvarying vec3 v_directionLightDir[DIRECTION_LIGHTS_COUNT];\n#endif\n\n", funcDeclare: "vec3 getNormal();\n\nvec3 getLightDir(vec3 lightPos);\n\n", funcDefine: "#if POINT_LIGHTS_COUNT > 0\nvec3 getPointLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return v_pointLightDir[x];\n        }\n    }\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\n\nvec3 getDirectionLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return v_directionLightDir[x];\n        }\n    }\n\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n\nvec3 getViewDir(){\n    return v_viewDir;\n}\nvec3 getNormal(){\n        // Obtain normal from normal map in range [0,1]\n        vec3 normal = texture2D(u_normalMapSampler, v_normalMapTexCoord).rgb;\n\n        // Transform normal vector to range [-1,1]\n        return normalize(normal * 2.0 - 1.0);  // this normal is in tangent space\n}\n", body: "", };
        ShaderChunk.normalMap_vertex = { top: "", define: "", varDeclare: "varying vec2 v_normalMapTexCoord;\n	varying vec3 v_viewDir;\n\n\n#if POINT_LIGHTS_COUNT > 0\nvarying vec3 v_pointLightDir[POINT_LIGHTS_COUNT];\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvarying vec3 v_directionLightDir[DIRECTION_LIGHTS_COUNT];\n#endif\n\n", funcDeclare: "", funcDefine: "mat3 computeTBN(mat3 normalMatrix){\n            vec3 T = normalize(normalMatrix * a_tangent);\n            vec3 N = normalize(normalMatrix * a_normal);\n            // re-orthogonalize T with respect to N\n            T = normalize(T - dot(T, N) * N);\n            // then retrieve perpendicular vector B with the cross product of T and N\n            vec3 B = cross(T, N);\n\n\n            return transpose(mat3(T, B, N));\n        }\n", body: "mat3 TBN = computeTBN(normalMatrix);\n\n    //v_tangentLightPos = TBN * light.position;\n    //v_tangentCameraPos  = TBN * u_cameraPos;\n    //v_tangentPos  = TBN * v_position;\n\n\n    vec3 tangentPosition = TBN * vec3(mMatrix * vec4(a_position, 1.0));\n\n    v_normalMapTexCoord = a_texCoord;\n\n    v_viewDir = normalize(TBN * u_cameraPos - tangentPosition);\n\n\n#if POINT_LIGHTS_COUNT > 0\n       for(int i = 0; i < POINT_LIGHTS_COUNT; i++){\n            //not normalize for computing distance\n            v_pointLightDir[i] = TBN * getPointLightDirByLightPos(u_pointLights[i].position, tangentPosition);\n       }\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\n       for(int i = 0; i < DIRECTION_LIGHTS_COUNT; i++){\n            v_directionLightDir[i] = normalize(- TBN * getDirectionLightDirByLightPos(u_directionLights[i].position));\n       }\n#endif\n\n", };
        ShaderChunk.specularMap_fragment = { top: "", define: "", varDeclare: "varying vec2 v_specularMapTexCoord;\n", funcDeclare: "", funcDefine: "float getSpecularStrength() {\n        return texture2D(u_specularMapSampler, v_specularMapTexCoord).r;\n    }\n", body: "", };
        ShaderChunk.specularMap_vertex = { top: "", define: "", varDeclare: "varying vec2 v_specularMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "v_specularMapTexCoord = a_texCoord;\n", };
        ShaderChunk.noShadowMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getShadowVisibility() {\n        return vec3(1.0);\n    }\n", body: "", };
        ShaderChunk.multiPages_bitmapFont_fragment = { top: "", define: "", varDeclare: "uniform sampler2D u_pageSampler2Ds[PAGE_COUNT];\nvarying vec2 v_bitmapCoord;\nvarying float v_page;\n", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.multiPages_bitmapFont_vertex = { top: "", define: "", varDeclare: "varying float v_page;\n", funcDeclare: "", funcDefine: "", body: "v_page = a_page;\n", };
        ShaderChunk.sdf_bitmapFont_smoothStep_fallback = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float sdfSmoothStep(float value) {\n    /*! gl_FragCoord.w is wrong, need fix! */\n    float afwidth = (1.0 / 32.0) * (1.4142135623730951 / (2.0 * gl_FragCoord.w));\n    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);\n}\n", body: "", };
        ShaderChunk.sdf_bitmapFont_smoothStep_standardDerivatives = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float sdfSmoothStep(float value) {\n      float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);\n}\n", body: "", };
        ShaderChunk.sdf_bitmapFont_smooth_fragment = { top: "", define: "", varDeclare: "varying vec2 v_bitmapCoord;\n", funcDeclare: "", funcDefine: "", body: "gl_FragColor.a *= sdfSmoothStep(texture2D(u_bitmapSampler, v_bitmapCoord).a);\n", };
        ShaderChunk.common_heightMap = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float _getHeightFromHeightMap(vec2 heightMapSampleTexCoord){\nheightMapSampleTexCoord.x /= u_terrainSubdivisions;\nheightMapSampleTexCoord.y =  1.0 - heightMapSampleTexCoord.y / u_terrainSubdivisions;\n\n    vec4 data = texture2D(u_heightMapSampler, heightMapSampleTexCoord);\n    /*!\n     compute gradient from rgb heightMap->r,g,b components\n     */\n    float r = data.r,\n    g = data.g,\n    b = data.b,\n    gradient = r * 0.3 + g * 0.59 + b * 0.11;\n\n    return u_terrainMinHeight + (u_terrainMaxHeight - u_terrainMinHeight) * gradient;\n}\n\n\nfloat _getBilinearInterpolatedHeight(vec2 offset, float heightMinXMinZ, float heightMaxXMinZ, float heightMaxXMaxZ, float heightMinXMaxZ){\n    return (heightMinXMinZ * (1.0 - offset.x) + heightMaxXMinZ * offset.x) * (1.0 - offset.y) + (heightMaxXMaxZ * offset.x + heightMinXMaxZ * (1.0 - offset.x)) * offset.y;\n}\n\n\nfloat getHeightFromHeightMap(float x, float z){\n    x += u_terrainRangeWidth / 2.0;\n    z += u_terrainRangeHeight / 2.0;\n\n    if(x > u_terrainRangeWidth || z > u_terrainRangeHeight || x < 0.0 || z < 0.0){\n        return 0.0;\n    }\n\n\n\n/*!\n1.get grid subdivisions row,col\n2.get grid height\n3.get bilinear interpolated height\n*/\n\n\n\n    float sx = x / u_terrainRangeWidth * u_terrainSubdivisions,\n        sz = z / u_terrainRangeHeight * u_terrainSubdivisions;\n\n    float sFloorX = floor(sx),\n        sFloorZ = floor(sz);\n\n    float sMinX,\n    sMaxX,\n    sMinZ,\n    sMaxZ;\n\n    if(sFloorX < u_terrainSubdivisions){\n        sMinX = sFloorX;\n        sMaxX = sFloorX + 1.0;\n    }\n    else{\n        sMinX = sFloorX - 1.0;\n        sMaxX = sFloorX;\n    }\n\n    if(sFloorZ < u_terrainSubdivisions){\n        sMinZ = sFloorZ;\n        sMaxZ = sFloorZ + 1.0;\n    }\n    else{\n        sMinZ = sFloorZ - 1.0;\n        sMaxZ = sFloorZ;\n    }\n\n    vec2 quadSubdivisionsCoordinateArr[5];\n\n    quadSubdivisionsCoordinateArr[0] = vec2(sMinX, sMinZ);\n    quadSubdivisionsCoordinateArr[1] = vec2(sMaxX, sMinZ);\n    quadSubdivisionsCoordinateArr[2] = vec2(sMaxX, sMaxZ);\n    quadSubdivisionsCoordinateArr[3] = vec2(sMinX, sMaxZ);\n\n    quadSubdivisionsCoordinateArr[4] = vec2(sx - sMinX, sz - sMinZ);\n\n\n    float heightMinXMinZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[0]);\n    float heightMaxXMinZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[1]);\n    float heightMaxXMaxZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[2]);\n    float heightMinXMaxZ = _getHeightFromHeightMap(quadSubdivisionsCoordinateArr[3]);\n\n    return _getBilinearInterpolatedHeight(quadSubdivisionsCoordinateArr[4], heightMinXMinZ, heightMaxXMinZ, heightMaxXMaxZ, heightMinXMaxZ);\n}\n", body: "", };
        ShaderChunk.common_light = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getDirectionLightDir(vec3 lightPos){\n    return normalize(lightPos - vec3(0.0));\n}\n", body: "", };
        ShaderChunk.mirror_fragment = { top: "", define: "", varDeclare: "varying vec4 v_reflectionMapCoord;\n", funcDeclare: "", funcDefine: "//todo add more blend way to mix reflectionMap color and textureColor\n		float blendOverlay(float base, float blend) {\n			return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n		}\n		vec4 getReflectionMapColor(in vec4 materialColor){\n			vec4 color = texture2DProj(u_reflectionMapSampler, v_reflectionMapCoord);\n\n			color = vec4(blendOverlay(materialColor.r, color.r), blendOverlay(materialColor.g, color.g), blendOverlay(materialColor.b, color.b), 1.0);\n\n			return color;\n		}\n", body: "if(!isRenderListEmpty(u_isRenderListEmpty)){\n    totalColor *= getReflectionMapColor(totalColor);\n}\n", };
        ShaderChunk.mirror_vertex = { top: "", define: "", varDeclare: "varying vec4 v_reflectionMapCoord;\n", funcDeclare: "", funcDefine: "", body: "mat4 textureMatrix = mat4(\n                        0.5, 0.0, 0.0, 0.0,\n                        0.0, 0.5, 0.0, 0.0,\n                        0.0, 0.0, 0.5, 0.0,\n                        0.5, 0.5, 0.5, 1.0\n);\n\nv_reflectionMapCoord = textureMatrix * gl_Position;\n", };
        ShaderChunk.brick_proceduralTexture_fragment = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\n", funcDeclare: "", funcDefine: "", body: "float brickW = 1.0 / u_tilesWidthNumber;\n	float brickH = 1.0 / u_tilesWidthNumber;\n	float jointWPercentage = 0.01;\n	float jointHPercentage = 0.05;\n	vec3 color = u_brickColor;\n	float yi = v_texCoord.y / brickH;\n	float nyi = round(yi);\n	float xi = v_texCoord.x / brickW;\n\n	if (mod(floor(yi), 2.0) == 0.0){\n		xi = xi - 0.5;\n	}\n\n	float nxi = round(xi);\n	vec2 brickv_texCoord = vec2((xi - floor(xi)) / brickH, (yi - floor(yi)) /  brickW);\n\n	if (yi < nyi + jointHPercentage && yi > nyi - jointHPercentage){\n		color = mix(u_jointColor, vec3(0.37, 0.25, 0.25), (yi - nyi) / jointHPercentage + 0.2);\n	}\n	else if (xi < nxi + jointWPercentage && xi > nxi - jointWPercentage){\n		color = mix(u_jointColor, vec3(0.44, 0.44, 0.44), (xi - nxi) / jointWPercentage + 0.2);\n	}\n	else {\n		float u_brickColorSwitch = mod(floor(yi) + floor(xi), 3.0);\n\n		if (u_brickColorSwitch == 0.0)\n			color = mix(color, vec3(0.33, 0.33, 0.33), 0.3);\n		else if (u_brickColorSwitch == 2.0)\n			color = mix(color, vec3(0.11, 0.11, 0.11), 0.3);\n	}\n\n	gl_FragColor = vec4(color, 1.0);\n", };
        ShaderChunk.cloud_proceduralTexture_fragment = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\n", funcDeclare: "", funcDefine: "", body: "gl_FragColor = mix(u_skyColor, u_cloudColor, fbm(v_texCoord * 12.0));\n", };
        ShaderChunk.water_bump_fragment = { top: "", define: "", varDeclare: "varying vec2 v_bumpTexCoord;\n", funcDeclare: "", funcDefine: "", body: "// fetch bump texture, unpack from [0..1] to [-1..1]\n	vec3 bumpNormal = 2.0 * texture2D(u_bumpMapSampler, v_bumpTexCoord).rgb - 1.0;\n	vec2 perturbation = u_waveData.height * bumpNormal.rg;\n", };
        ShaderChunk.water_bump_vertex = { top: "", define: "", varDeclare: "struct WaveData {\n    float length;\n    float height;\n};\nuniform WaveData u_waveData;\nvarying vec2 v_bumpTexCoord;\n", funcDeclare: "", funcDefine: "", body: "vec2 bumpTexCoord = vec2(u_windMatrix * vec4(a_texCoord, 0.0, 1.0));\n	v_bumpTexCoord = bumpTexCoord / u_waveData.length;\n", };
        ShaderChunk.water_fragment = { top: "", define: "", varDeclare: "struct WaveData {\n    float length;\n    float height;\n};\nuniform WaveData u_waveData;\nstruct LevelData {\n    float fresnelLevel;\n    float reflectionLevel;\n    float refractionLevel;\n};\nuniform LevelData u_levelData;\n\nvarying vec4 v_reflectionAndRefractionMapCoord;\n", funcDeclare: "", funcDefine: "", body: "vec2 projectedTexCoords = v_reflectionAndRefractionMapCoord.xy / v_reflectionAndRefractionMapCoord.w + perturbation;\n\n\n\n\n//totalColor = vec4(1.0 - fresnelTerm);\n//totalColor *= vec4(refractionColor, 1.0);\n//totalColor *= vec4(mix(reflectionColor, refractionColor, fresnelTerm), 1.0);\n//totalColor += vec4(reflectionColor * fresnelTerm * u_levelData.reflectionLevel + (1.0 - fresnelTerm) * refractionColor * u_levelData.refractionLevel, 1.0);\n\n//totalColor += vec4(reflectionColor * fresnelTerm * u_levelData.reflectionLevel + (1.0 - fresnelTerm) * refractionColor * u_levelData.refractionLevel, 1.0);\n\ntotalColor += vec4(getLightEffectColor(projectedTexCoords), 1.0);\n\n\n//totalColor *= vec4(mix(reflectionColor, refractionColor, 0.5), 1.0);\n", };
        ShaderChunk.water_fresnel_fragment = { top: "", define: "", varDeclare: "varying vec3 v_position;\n", funcDeclare: "", funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n	vec3 reflectionColor;\n	vec3 refractionColor;\n\n    vec3 inDir = normalize(v_position - u_cameraPos);\n\n	float fresnelTerm = max(dot(inDir, v_normal), 0.0);\n	fresnelTerm = clamp((1.0 - fresnelTerm) * u_levelData.fresnelLevel, 0., 1.);\n\n    if(!isRenderListEmpty(u_isReflectionRenderListEmpty)){\n        reflectionColor = texture2D(u_reflectionMapSampler, projectedTexCoords).rgb;\n        reflectionColor = reflectionColor * fresnelTerm * u_levelData.reflectionLevel;\n	}\n	else{\n        reflectionColor = vec3(0.0);\n	}\n\n    if(!isRenderListEmpty(u_isRefractionRenderListEmpty)){\n        refractionColor = texture2D(u_refractionMapSampler, projectedTexCoords).rgb;\n        refractionColor = (1.0 - fresnelTerm) * refractionColor * u_levelData.refractionLevel;\n	}\n	else{\n        refractionColor = vec3(0.0);\n	}\n\n	return reflectionColor + refractionColor;\n}\n", body: "", };
        ShaderChunk.water_fresnel_vertex = { top: "", define: "", varDeclare: "varying vec3 v_position;\n", funcDeclare: "", funcDefine: "", body: "v_position = a_position;\n", };
        ShaderChunk.water_noBump_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "vec2 perturbation = vec2(0.0);\n", };
        ShaderChunk.water_noLightEffect_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n    return vec3(0.0);\n}\n", body: "", };
        ShaderChunk.water_reflection_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n    if(!isRenderListEmpty(u_isReflectionRenderListEmpty)){\n        return texture2D(u_reflectionMapSampler, projectedTexCoords).rgb * u_levelData.reflectionLevel;\n    }\n    return vec3(0.0);\n}\n", body: "", };
        ShaderChunk.water_refraction_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getLightEffectColor(vec2 projectedTexCoords){\n    if(!isRenderListEmpty(u_isRefractionRenderListEmpty)){\n        return texture2D(u_refractionMapSampler, projectedTexCoords).rgb * u_levelData.refractionLevel;\n    }\n    return vec3(0.0);\n}\n", body: "", };
        ShaderChunk.water_vertex = { top: "", define: "", varDeclare: "varying vec4 v_reflectionAndRefractionMapCoord;\n", funcDeclare: "", funcDefine: "", body: "mat4 textureMatrix = mat4(\n                        0.5, 0.0, 0.0, 0.0,\n                        0.0, 0.5, 0.0, 0.0,\n                        0.0, 0.0, 0.5, 0.0,\n                        0.5, 0.5, 0.5, 1.0\n);\n\nv_reflectionAndRefractionMapCoord = textureMatrix * gl_Position;\n", };
        ShaderChunk.fire_proceduralTexture_fragment = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\nstruct FireColor {\n    vec3 c1;\n    vec3 c2;\n    vec3 c3;\n    vec3 c4;\n    vec3 c5;\n    vec3 c6;\n};\nuniform FireColor u_fireColor;\n", funcDeclare: "", funcDefine: "", body: "vec2 p = v_texCoord * 8.0;\n	float q = fbm(p - u_time * 0.1);\n	vec2 r = vec2(fbm(p + q + u_time * u_speed.x - p.x - p.y), fbm(p + q - u_time * u_speed.y));\n	vec3 c = mix(u_fireColor.c1, u_fireColor.c2, fbm(p + r)) + mix(u_fireColor.c3, u_fireColor.c4, r.x) - mix(u_fireColor.c5, u_fireColor.c6, r.y);\n	vec3 color = c * cos(u_shift * v_texCoord.y);\n	float luminance = dot(color.rgb, vec3(0.3, 0.59, 0.11));\n\n	gl_FragColor = vec4(color, luminance * u_alphaThreshold + (1.0 - u_alphaThreshold));\n\n", };
        ShaderChunk.grass_proceduralTexture_fragment = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\n", funcDeclare: "", funcDefine: "", body: "vec3 color = mix(u_groundColor, u_herb1Color, rand(gl_FragCoord.xy * 4.0));\n	color = mix(color, u_herb2Color, rand(gl_FragCoord.xy * 8.0));\n	color = mix(color, u_herb3Color, rand(gl_FragCoord.xy));\n	color = mix(color, u_herb1Color, fbm(gl_FragCoord.xy * 16.0));\n\n	gl_FragColor = vec4(color, 1.0);\n", };
        ShaderChunk.marble_proceduralTexture_fragment = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\nconst vec3 TILE_SIZE = vec3(1.1, 1.0, 1.1);\n//const vec3 TILE_PCT = vec3(0.98, 1.0, 0.98);\n", funcDeclare: "", funcDefine: "vec3 marble_color(float x)\n{\n	vec3 col;\n	x = 0.5*(x + 1.);\n	x = sqrt(x);\n	x = sqrt(x);\n	x = sqrt(x);\n	col = vec3(.2 + .75*x);\n	col.b *= 0.95;\n	return col;\n}\n", body: "vec3 color;\n	float brickW = 1.0 / u_tilesHeightNumber;\n	float brickH = 1.0 / u_tilesWidthNumber;\n	float jointWPercentage = 0.01;\n	float jointHPercentage = 0.01;\n	float yi = v_texCoord.y / brickH;\n	float nyi = round(yi);\n	float xi = v_texCoord.x / brickW;\n\n	if (mod(floor(yi), 2.0) == 0.0){\n		xi = xi - 0.5;\n	}\n\n	float nxi = round(xi);\n	vec2 brickv_texCoord = vec2((xi - floor(xi)) / brickH, (yi - floor(yi)) / brickW);\n\n	if (yi < nyi + jointHPercentage && yi > nyi - jointHPercentage){\n		color = mix(u_jointColor, vec3(0.37, 0.25, 0.25), (yi - nyi) / jointHPercentage + 0.2);\n	}\n	else if (xi < nxi + jointWPercentage && xi > nxi - jointWPercentage){\n		color = mix(u_jointColor, vec3(0.44, 0.44, 0.44), (xi - nxi) / jointWPercentage + 0.2);\n	}\n	else {\n		float t = 6.28 * brickv_texCoord.x / (TILE_SIZE.x + noise(vec2(v_texCoord)*6.0));\n		t += u_amplitude * turbulence(brickv_texCoord.xy);\n		t = sin(t);\n		color = marble_color(t);\n	}\n\n	gl_FragColor = vec4(color, 1.0);\n", };
        ShaderChunk.wood_proceduralTexture_fragment = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\n", funcDeclare: "", funcDefine: "", body: "float ratioy = mod(v_texCoord.x * u_ampScale, 2.0 + fbm(v_texCoord * 0.8));\n	vec3 wood = u_woodColor * ratioy;\n\n	gl_FragColor = vec4(wood, 1.0);\n", };
        ShaderChunk.road_proceduralTexture_fragment = { top: "", define: "", varDeclare: "varying vec2 v_texCoord;\n", funcDeclare: "", funcDefine: "", body: "float ratioy = mod(gl_FragCoord.y * 100.0 , fbm(v_texCoord * 2.0));\n	vec3 color = u_roadColor * ratioy;\n\n	gl_FragColor = vec4(color, 1.0);\n", };
        ShaderChunk.basic_bitmapFont_fragment = { top: "", define: "", varDeclare: "varying vec2 v_bitmapCoord;\n", funcDeclare: "", funcDefine: "", body: "totalColor *= texture2D(u_bitmapSampler, v_bitmapCoord);\n", };
        ShaderChunk.grass_batch_instance_vertex = { top: "", define: "", varDeclare: "uniform vec4 a_offset; // {x:x, y:y, z:z, w:rot} (blade's position & rotation)\n	uniform vec4 a_shape; // {x:width, y:height, z:lean, w:curve} (blade's a_shape properties)\n", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.grass_common_instance_fragment = { top: "", define: "", varDeclare: "//	uniform vec3 fogColor;\n//	uniform float fogNear;\n//	uniform float fogFar;\n//	uniform vec3 grassFogColor;\n//	uniform float grassFogFar;\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n", funcDeclare: "", funcDefine: "", body: "vec4 color = v_color * texture2D(u_grassMapSampler, vec2(v_texCoord.s, v_texCoord.t));\n\n\n//		float depth = gl_FragCoord.z / gl_FragCoord.w;\n//		// apply 'grass fog' first\n//		float fogFactor = smoothstep(fogNear, grassFogFar, depth);\n//		color.rgb = mix(color.rgb, grassFogColor, fogFactor);\n//		// then apply atmosphere fog\n//		fogFactor = smoothstep(fogNear, fogFar, depth);\n//		color.rgb = mix(color.rgb, fogColor, fogFactor);\n		// output\n		gl_FragColor = color;\n", };
        ShaderChunk.grass_common_instance_vertex = { top: "", define: "", varDeclare: "varying vec4 v_color;\n    varying vec2 v_texCoord;\n", funcDeclare: "", funcDefine: "// Rotate by an angle\nvec2 rotate (float x, float y, float r) {\n    float c = cos(r);\n    float s = sin(r);\n    return vec2(x * c - y * s, x * s + y * c);\n}\n\n// Rotate by a vector\nvec2 rotate (float x, float y, vec2 r) {\n    return vec2(x * r.x - y * r.y, x * r.y + y * r.x);\n}\n\nvec3 _getLightDir(){\n/*!\nregard any light as direction light\n*/\n    return getDirectionLightDir(u_lightPos);\n}\n\nvec4 computeLightColor(vec3 normal, float hpct){\n/*!\nonly consider one light\n\nnot consider ambient light\n*/\n    float c = max(-dot(normal, _getLightDir()), 0.0);\n\n    c = max(c - (1.0 - hpct) * 0.75, 0.0);\n    c = 0.3 + 0.7 * c;\n\n    vec4 color = vec4(\n        c * 0.85 + cos(a_offset.x * 80.0) * 0.05,\n        c * 0.95 + sin(a_offset.z * 140.0) * 0.05,\n        c * 0.95 + sin(a_offset.x * 99.0) * 0.05,\n        1.0\n    );\n\n    color.rgb = color.rgb * u_lightColor;\n\n    return color;\n}\n\n", body: "float vi = mod(a_vertexIndex, BLADE_VERTS); // vertex index for this side of the blade\n    float di = floor(vi / 2.0);  // div index (0 .. BLADE_DIVS)\n    float hpct = di / BLADE_SEGS;  // percent of height of blade this vertex is at\n    float bside = floor(a_vertexIndex / BLADE_VERTS);  // front/back side of blade\n    float bedge = mod(vi, 2.0);  // left/right edge (x=0 or x=1)\n    // Vertex position - start with 2D a_shape, no bend applied\n    vec4 pos = vec4(\n        a_shape.x * (bedge - 0.5) * (1.0 - pow(hpct, 3.0)), // taper blade edges as approach tip\n        a_shape.y * di / BLADE_SEGS, // height of vtx, unbent\n        0.0, // flat z, unbent\n        1.0\n    );\n\n\n    // Start computing a normal for this vertex\n    vec3 normal = vec3(rotate(0.0, bside * 2.0 - 1.0, a_offset.w), 0.0);\n\n//vec3 normal = vec3(0.0);\n//\n//if(bside == 0.0){\n//normal.x = -1.0;\n//}\n//else{\n//normal.x = 1.0;\n//}\n\n    // Apply blade's natural curve amount\n    float curve = a_shape.w;\n    // Then add animated curve amount by u_time using this blade's\n    // unique properties to randomize its oscillation\n    curve += a_shape.w + 0.125 * (sin(u_time * 4.0 + a_offset.w * 0.2 * a_shape.y + a_offset.x + a_offset.z));\n    // put lean and curve together\n    float rot = a_shape.z + curve * hpct;\n    vec2 rotv = vec2(cos(rot), sin(rot));\n    pos.zy = rotate(pos.z, pos.y, rotv);\n    normal.zy = rotate(normal.z, normal.y, rotv);\n//    normal.yx = rotate(normal.y, normal.x, rotv);\n\n    // rotation of this blade as a vector\n    rotv = vec2(cos(a_offset.w), sin(a_offset.w));\n    pos.xz = rotate(pos.x, pos.z, rotv);\n    normal.xz = rotate(normal.x, normal.z, rotv);\n\n    pos.x += u_grassRangeWidth / 2.0 - a_offset.x;\n    pos.z += u_grassRangeHeight / 2.0 - a_offset.z;\n\n    pos = u_mMatrix * pos;\n\n\n    pos.y += getHeightFromHeightMap(pos.x, pos.z) * u_terrainScaleY + u_terrainPositionY;\n\n\n\n\n    //todo add wind\n    //todo pass wind direction uniform\n\n    // Compute wind effect\n//    float wind = getHeightFromHeightMap(vec2(heightMapSampleTexCoord.x - u_time / 100.0, heightMapSampleTexCoord.y - u_time / 50.0));\n\n//    wind = (clamp(wind, 0.35, 0.85) - 0.35) * 2.0;\n//    wind = wind * wind * 1.5;\n\n//    wind *= hpct; // min(hpct * a_shape.y / BLADE_HEIGHT_TALL, 1.0); // scale wind by height of blade\n//    wind = -wind;\n//    rotv = vec2(cos(wind), sin(wind));\n    // Wind blows in axis-aligned direction to make things simpler\n//    pos.zy = rotate(pos.z, pos.y, rotv);\n//    normal.yz = rotate(normal.y, normal.z, rotv);\n\n    // Sample the data texture to get altitude for this blade position\n//    float altitude = texture2D(heightMap, heightMapSampleTexCoord).r;\n//    float altclr = (clamp(altitude, 0.45, 0.75) - 0.45) * 3.3333333;\n//    vec3 grassColor = mix(grassColorLow, grassColorHigh, altclr);\n    // Vertex color must be brighter because it is multiplied with blade texture\n//    grassColor = min(vec3(grassColor.r * 1.5, grassColor.g * 1.5, grassColor.b * 0.95), 1.0);\n//    altitude *= heightMapScale.z;\n\n    v_color = computeLightColor(normal, hpct);\n//    v_color.rgb = v_color.rgb * LIGHT_COLOR * grassColor;\n\n\n    // grass texture coordinate for this vertex\n    v_texCoord = vec2(bedge, di * 2.0);\n\n    gl_Position = u_vpMatrix * pos;\n", };
        ShaderChunk.grass_hardware_instance_vertex = { top: "", define: "", varDeclare: "attribute vec4 a_offset; // {x:x, y:y, z:z, w:rot} (blade's position & rotation)\n	attribute vec4 a_shape; // {x:width, y:height, z:lean, w:curve} (blade's a_shape properties)\n", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.grass_map_fragment = { top: "", define: "", varDeclare: "struct GrassMapData {\n    vec4 sourceRegion;\n};\nuniform GrassMapData u_grassMapDatas[3];\n\n\nvarying vec2 v_grassTexCoord;\nvarying float v_quadIndex;\n", funcDeclare: "", funcDefine: "vec4 getGrassMapColor(in sampler2D grassMapSampler, in GrassMapData grassMapDatas[3]){\n    vec4 sourceRegion;\n\n    if(v_quadIndex == 0.0){\n        sourceRegion = grassMapDatas[0].sourceRegion;\n    }\n    else if(v_quadIndex == 1.0){\n        sourceRegion = grassMapDatas[1].sourceRegion;\n    }\n    else if(v_quadIndex == 2.0){\n        sourceRegion = grassMapDatas[2].sourceRegion;\n    }\n\n    return texture2D(grassMapSampler, v_grassTexCoord * sourceRegion.zw + sourceRegion.xy);\n}\n", body: "totalColor *= getGrassMapColor(u_grassMapSampler, u_grassMapDatas);\n", };
        ShaderChunk.grass_map_setWorldPosition_vertex = { top: "", define: "", varDeclare: "struct GrassWindData {\n    vec2 direction;\n    float time;\n    float strength;\n};\nuniform GrassWindData u_windData;\n", funcDeclare: "", funcDefine: "bool isTopPartOfGrass(){\n    return a_texCoord.y >= 0.9;\n}\n\nfloat getWindPower(){\n    float windPower = sin(u_windData.time) * u_windData.strength;\n\n    return windPower;\n}\n\nvec3 computeVertexPositionForAnimation(vec3 position, float time, vec2 windDirection){\n    vec2 windData = windDirection * getWindPower();\n    vec3 translation = vec3(windData.x, 0, windData.y);\n\n    return position + translation;\n}\n", body: "vec3 position;\n\n    if(isTopPartOfGrass()){\n        position = computeVertexPositionForAnimation(a_position, u_windData.time, u_windData.direction);\n    }\n    else{\n        position = a_position;\n    }\n\n    v_worldPosition = vec3(mMatrix * vec4(position, 1.0));\n", };
        ShaderChunk.grass_map_vertex = { top: "", define: "", varDeclare: "varying vec2 v_grassTexCoord;\nvarying float v_quadIndex;\n", funcDeclare: "", funcDefine: "", body: "v_grassTexCoord = a_texCoord;\nv_quadIndex = a_quadIndex;\n", };
        ShaderChunk.terrain_layer_fragment = { top: "", define: "", varDeclare: "struct LayerHeightData {\n    float minHeight;\n    float maxHeight;\n    vec4 repeatRegion;\n};\nuniform LayerHeightData u_layerHeightDatas[LAYER_COUNT];\n//sampler2D can't be contained in struct\nuniform sampler2D u_layerSampler2Ds[LAYER_COUNT];\n\n\nvarying vec2 v_layerTexCoord;\n", funcDeclare: "", funcDefine: "vec4 getLayerMapColor(in sampler2D layerSampler2Ds[LAYER_COUNT], in LayerHeightData layerHeightDatas[LAYER_COUNT]){\n    vec4 color = vec4(0.0);\n    bool isInLayer = false;\n\n    float height = v_worldPosition.y;\n\n    for(int i = 0; i < LAYER_COUNT; i++){\n        if(height >= layerHeightDatas[i].minHeight && height < layerHeightDatas[i].maxHeight){\n            vec4 repeatRegion = layerHeightDatas[i].repeatRegion;\n\n            //todo blend color\n            //todo optimize:move 'v_layerTexCoord * repeatRegion.zw + repeatRegion.xy' to vertex shader?\n            color += texture2D(layerSampler2Ds[i], v_layerTexCoord * repeatRegion.zw + repeatRegion.xy);\n\n            isInLayer = true;\n\n            break;\n        }\n    }\n\n    return isInLayer ? color : vec4(1.0);\n}\n", body: "\ntotalColor *= getLayerMapColor(u_layerSampler2Ds, u_layerHeightDatas);\n", };
        ShaderChunk.terrain_layer_vertex = { top: "", define: "", varDeclare: "varying vec2 v_layerTexCoord;\n", funcDeclare: "", funcDefine: "", body: "v_layerTexCoord = a_texCoord;\n", };
        ShaderChunk.terrain_mix_bump_cotangentFrame_fallback = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "mat3 cotangentFrame(vec3 normal,vec3 p,vec2 uv)\n{\n    //todo how to implement dFdx,dFdy?\n    vec3 dp1=p;\n    vec3 dp2=p;\n    vec2 duv1=uv;\n    vec2 duv2=uv;\n    vec3 dp2perp=cross(dp2,normal);\n    vec3 dp1perp=cross(normal,dp1);\n    vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\n    vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\n\n    float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\n    return mat3(tangent*invmax,binormal*invmax,normal);\n}\n", body: "", };
        ShaderChunk.terrain_mix_bump_cotangentFrame_standardDerivatives = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "mat3 cotangentFrame(vec3 normal,vec3 p,vec2 uv)\n{\n    vec3 dp1=dFdx(p);\n    vec3 dp2=dFdy(p);\n    vec2 duv1=dFdx(uv);\n    vec2 duv2=dFdy(uv);\n    vec3 dp2perp=cross(dp2,normal);\n    vec3 dp1perp=cross(normal,dp1);\n    vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\n    vec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\n\n    float invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\n    return mat3(tangent*invmax,binormal*invmax,normal);\n}\n", body: "", };
        ShaderChunk.terrain_mix_bump_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "vec3 getNormal();\n", funcDefine: "vec3 getNormal(){\n    vec3 viewDir = getViewDir();\n    vec3 mixColor = baseColor.rgb;\n\n    vec3 bump1Color=texture2D(u_bumpMap1Sampler,v_diffuseMap1TexCoord).xyz;\n    vec3 bump2Color=texture2D(u_bumpMap2Sampler,v_diffuseMap2TexCoord).xyz;\n    vec3 bump3Color=texture2D(u_bumpMap3Sampler,v_diffuseMap3TexCoord).xyz;\n    bump1Color.rgb*=mixColor.r;\n    bump2Color.rgb=mix(bump1Color.rgb,bump2Color.rgb,mixColor.g);\n    vec3 map=mix(bump2Color.rgb,bump3Color.rgb,mixColor.b);\n    map=map*255./127.-128./127.;\n\n    mat3 TBN=cotangentFrame(v_normal,-viewDir,v_mixMapTexCoord);\n\n    return normalize(TBN*map);\n}\n", body: "", };
        ShaderChunk.terrain_mix_bump_vertex = { top: "", define: "", varDeclare: "//varying vec3 v_normal;\n//\n//", funcDeclare: "", funcDefine: "", body: "//    v_normal = normalize(normalMatrix * a_normal);\n//", };
        ShaderChunk.terrain_mix_common_fragment = { top: "", define: "", varDeclare: "vec4 baseColor;\n", funcDeclare: "", funcDefine: "", body: "baseColor = texture2D(u_mixMapSampler,v_mixMapTexCoord);\n", };
        ShaderChunk.terrain_mix_fragment = { top: "", define: "", varDeclare: "varying vec2 v_mixMapTexCoord;\nvarying vec2 v_diffuseMap1TexCoord;\nvarying vec2 v_diffuseMap2TexCoord;\nvarying vec2 v_diffuseMap3TexCoord;\n", funcDeclare: "", funcDefine: "vec4 getMixMapColor(){\n    vec4 diffuse1Color=texture2D(u_diffuseMap1Sampler,v_diffuseMap1TexCoord);\n    vec4 diffuse2Color=texture2D(u_diffuseMap2Sampler,v_diffuseMap2TexCoord);\n    vec4 diffuse3Color=texture2D(u_diffuseMap3Sampler,v_diffuseMap3TexCoord);\n\n    diffuse1Color.rgb*=baseColor.r;\n    diffuse2Color.rgb=mix(diffuse1Color.rgb,diffuse2Color.rgb,baseColor.g);\n    baseColor.rgb=mix(diffuse2Color.rgb,diffuse3Color.rgb,baseColor.b);\n\n    return baseColor;\n}\n", body: "totalColor *= getMixMapColor();\n", };
        ShaderChunk.terrain_mix_vertex = { top: "", define: "", varDeclare: "varying vec2 v_mixMapTexCoord;\nvarying vec2 v_diffuseMap1TexCoord;\nvarying vec2 v_diffuseMap2TexCoord;\nvarying vec2 v_diffuseMap3TexCoord;\n", funcDeclare: "", funcDefine: "", body: "v_mixMapTexCoord = a_texCoord;\n\nv_diffuseMap1TexCoord = a_texCoord * u_diffuseMap1RepeatRegion.zw + u_diffuseMap1RepeatRegion.xy;\n\n\nv_diffuseMap2TexCoord = a_texCoord * u_diffuseMap2RepeatRegion.zw + u_diffuseMap2RepeatRegion.xy;\n\n\nv_diffuseMap3TexCoord = a_texCoord * u_diffuseMap3RepeatRegion.zw + u_diffuseMap3RepeatRegion.xy;\n", };
        ShaderChunk.common_bitmapFont_vertex = { top: "", define: "", varDeclare: "varying vec2 v_bitmapCoord;\n", funcDeclare: "", funcDefine: "", body: "v_bitmapCoord = a_texCoord;\n", };
        ShaderChunk.buildCubemapShadowMap_fragment = { top: "", define: "", varDeclare: "varying vec3 v_worldPosition;\n", funcDeclare: "", funcDefine: "", body: "\n// get distance between fragment and light source\n    float lightDistance = length(v_worldPosition - u_lightPos);\n\n    // map to [0,1] range by dividing by farPlane\n    lightDistance = lightDistance / u_farPlane;\n\n\ngl_FragData[0] = packDepth(lightDistance);\n\n\n//gl_FragColor = vec4(0.5, 0.0, 1.0, 1.0);\n//gl_FragData[0] = vec4(lightDistance, 1.0, 1.0, 1.0);\n", };
        ShaderChunk.buildCubemapShadowMap_vertex = { top: "", define: "", varDeclare: "varying vec3 v_worldPosition;\n", funcDeclare: "", funcDefine: "", body: "v_worldPosition = vec3(mMatrix * vec4(a_position, 1.0));\n    gl_Position = u_pMatrix * u_vMatrix * vec4(v_worldPosition, 1.0);\n", };
        ShaderChunk.buildTwoDShadowMap_depthMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.buildTwoDShadowMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "", };
        ShaderChunk.buildTwoDShadowMap_packDepth_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_FragData[0] = packDepth(gl_FragCoord.z);\n", };
        ShaderChunk.buildTwoDShadowMap_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_Position = u_vpMatrixFromLight * mMatrix * vec4(a_position, 1.0);\n", };
        ShaderChunk.commonBuildShadowMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "// Packing a float in GLSL with multiplication and mod\nvec4 packDepth(in float depth) {\n    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n    const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n    // combination of mod and multiplication and division works better\n    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n    res -= res.xxyz * bit_mask;\n\n    return res;\n}\n", body: "", };
        ShaderChunk.cubemapShadowMap_fragment = { top: "", define: "", varDeclare: "uniform samplerCube u_cubemapShadowMapSampler[ CUBEMAP_SHADOWMAP_COUNT ];\n\n    uniform int u_isCubemapRenderListEmpty[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform float u_cubemapShadowDarkness[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform float u_cubemapShadowBias[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform float u_farPlane[ CUBEMAP_SHADOWMAP_COUNT ];\n	uniform vec3 u_cubemapLightPos[ CUBEMAP_SHADOWMAP_COUNT ];\n", funcDeclare: "", funcDefine: "// PCF\nfloat getCubemapShadowVisibilityByPCF(float currentDepth, vec3 fragToLight, samplerCube cubemapShadowMapSampler, float shadowBias, float farPlane, float shadowDarkness){\n    //only support in opengl es 3.0+\n    //vec3 sampleOffsetDirections[20] = vec3[]\n    //(\n       //vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1),\n       //vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1),\n       //vec3( 1,  1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1,  1,  0),\n       //vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),\n       //vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1)\n    //);\n\n    vec3 sampleOffsetDirections[20];\n\n    sampleOffsetDirections[0] = vec3( 1,  1,  1);\n    sampleOffsetDirections[1] = vec3( 1,  -1,  1);\n    sampleOffsetDirections[2] = vec3( -1,  -1,  1);\n    sampleOffsetDirections[3] = vec3( -1,  1,  1);\n\n    sampleOffsetDirections[4] = vec3( 1,  1,  -1);\n    sampleOffsetDirections[5] = vec3( 1,  -1,  -1);\n    sampleOffsetDirections[6] = vec3( -1,  -1,  -1);\n    sampleOffsetDirections[7] = vec3( -1,  1,  -1);\n\n    sampleOffsetDirections[8] = vec3( 1,  1,  0);\n    sampleOffsetDirections[9] = vec3( 1,  -1,  0);\n    sampleOffsetDirections[10] = vec3( -1,  -1,  0);\n    sampleOffsetDirections[11] = vec3( -1,  1,  0);\n\n    sampleOffsetDirections[12] = vec3( 1,  0,  1);\n    sampleOffsetDirections[13] = vec3( -1,  0,  1);\n    sampleOffsetDirections[14] = vec3( 1,  0,  -1);\n    sampleOffsetDirections[15] = vec3( -1,  0,  -1);\n\n    sampleOffsetDirections[16] = vec3( 0,  1,  1);\n    sampleOffsetDirections[17] = vec3( 0,  -1,  1);\n    sampleOffsetDirections[18] = vec3( 0,  -1,  -1);\n    sampleOffsetDirections[19] = vec3( 0,  1,  -1);\n\n    float shadow = 0.0;\n    int samples = 20;\n\n    //float diskRadius = 0.00000;\n    //Another interesting trick we can apply here is that we can change the diskRadius based on how far the viewer is away from a fragment; this way we can increase the offset radius by the distance to the viewer, making the shadows softer when far away and sharper when close by.\n    float viewDistance = length(u_cameraPos - v_worldPosition);\n    float diskRadius = (1.0 + (viewDistance / farPlane)) / 25.0;\n\n    //for(int i = 0; i < samples; ++i)\n    for(int i = 0; i < 20; ++i)\n    {\n        float pcfDepth = unpackDepth(textureCube(cubemapShadowMapSampler, fragToLight + sampleOffsetDirections[i] * diskRadius));\n        pcfDepth *= farPlane;   // Undo mapping [0;1]\n        shadow += currentDepth - shadowBias > pcfDepth  ? shadowDarkness : 1.0;\n    }\n    shadow /= float(samples);\n\n    return shadow;\n}\n\n\nfloat getCubemapShadowVisibility(vec3 lightDir, samplerCube cubemapShadowMapSampler, vec3 lightPos, float farPlane, float shadowBias, float  shadowDarkness) {\n// Get vector between fragment position and light position\n    vec3 fragToLight= v_worldPosition - lightPos;\n    // Use the light to fragment vector to sample from the depth map\n    // Now get current linear depth as the length between the fragment and light position\n    float currentDepth = length(fragToLight);\n\n    #if defined(SHADOWMAP_TYPE_PCF)\n    return getCubemapShadowVisibilityByPCF(currentDepth, fragToLight, cubemapShadowMapSampler, getShadowBias(lightDir, shadowBias), farPlane, shadowDarkness);\n    #endif\n\n    float closestDepth = unpackDepth(textureCube(cubemapShadowMapSampler, fragToLight));\n\n    // It is currently in linear range between [0,1]. Re-transform back to original value\n    closestDepth *= farPlane;\n\n\n    return float(currentDepth > closestDepth + getShadowBias(lightDir, shadowBias) ? shadowDarkness : 1.0);\n}\n", body: "", };
        ShaderChunk.totalShadowMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "float getShadowBias(vec3 lightDir, float shadowBias);\nfloat unpackDepth(vec4 rgbaDepth);\n", funcDefine: "float getShadowBias(vec3 lightDir, float shadowBias){\n    float bias = shadowBias;\n\n    if(shadowBias == NULL){\n        bias = 0.005;\n    }\n\n\n     /*!\n     A shadow bias of 0.005 solves the issues of our scene by a large extent, but some surfaces that have a steep angle to the light source might still produce shadow acne. A more solid approach would be to change the amount of bias based on the surface angle towards the light: something we can solve with the dot product:\n     */\n\n     return max(bias * (1.0 - dot(normalize(getNormal()), lightDir)), bias);\n\n    //return bias;\n}\n\nvec3 getShadowVisibility() {\n    vec3 shadowColor = vec3(1.0);\n    vec3 twoDLightDir = vec3(0.0);\n    vec3 cubemapLightDir = vec3(0.0);\n\n\n\n    //to normalMap, the lightDir use the origin one instead of normalMap's lightDir here(the lightDir is used for computing shadowBias, the origin one is enough for it)\n\n    #if TWOD_SHADOWMAP_COUNT > 0\n	for( int i = 0; i < TWOD_SHADOWMAP_COUNT; i ++ ) {\n        if(isRenderListEmpty(u_isTwoDRenderListEmpty[i])){\n            continue;\n        }\n\n        twoDLightDir = getDirectionLightDirByLightPos(u_twoDLightPos[i]);\n\n	////if is opposite to direction of light rays, no shadow\n\n        shadowColor *= getTwoDShadowVisibility(twoDLightDir, u_twoDShadowMapSampler[i], v_positionFromLight[i], u_twoDShadowBias[i], u_twoDShadowDarkness[i], u_twoDShadowSize[i]);\n	}\n	#endif\n\n\n	#if CUBEMAP_SHADOWMAP_COUNT > 0\n\n	for( int i = 0; i < CUBEMAP_SHADOWMAP_COUNT; i ++ ) {\n        if(isRenderListEmpty(u_isCubemapRenderListEmpty[i])){\n            continue;\n        }\n\n	////if is opposite to direction of light rays, no shadow\n\n        shadowColor *= getCubemapShadowVisibility(cubemapLightDir, u_cubemapShadowMapSampler[i], u_cubemapLightPos[i], u_farPlane[i], u_cubemapShadowBias[i], u_cubemapShadowDarkness[i]);\n	}\n	#endif\n\n	return shadowColor;\n}\n\nfloat unpackDepth(vec4 rgbaDepth) {\n    /*! make sure that the visibility from the shadow map which is not builded is always be 1.0 */\n    if(rgbaDepth == vec4(0.0)){\n        return 100000.0;\n    }\n\n    const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n    return dot(rgbaDepth, bitShift);\n}\n\n", body: "", };
        ShaderChunk.twoDShadowMap_depthMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "float handleDepthMap(vec4 rgbaDepth);\n", funcDefine: "float handleDepthMap(vec4 rgbaDepth) {\n    return rgbaDepth.r;\n}\n", body: "", };
        ShaderChunk.twoDShadowMap_fragment = { top: "", define: "", varDeclare: "varying vec4 v_positionFromLight[ TWOD_SHADOWMAP_COUNT ];\n    uniform int u_isTwoDRenderListEmpty[ TWOD_SHADOWMAP_COUNT ];\n	uniform sampler2D u_twoDShadowMapSampler[ TWOD_SHADOWMAP_COUNT ];\n	uniform float u_twoDShadowDarkness[ TWOD_SHADOWMAP_COUNT ];\n	uniform float u_twoDShadowBias[ TWOD_SHADOWMAP_COUNT ];\n	uniform vec2 u_twoDShadowSize[ TWOD_SHADOWMAP_COUNT ];\n	uniform vec3 u_twoDLightPos[ TWOD_SHADOWMAP_COUNT ];\n", funcDeclare: "", funcDefine: "// PCF\nfloat getTwoDShadowVisibilityByPCF(float currentDepth, vec2 shadowCoord, sampler2D twoDShadowMapSampler, float shadowBias, float shadowDarkness, vec2 shadowMapSize){\n\n    float shadow = 0.0;\n    vec2 texelSize = vec2(1.0 / shadowMapSize[0], 1.0 / shadowMapSize[1]);\n\n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            float pcfDepth = handleDepthMap(texture2D(twoDShadowMapSampler, shadowCoord + vec2(x, y) * texelSize));\n            shadow += currentDepth - shadowBias > pcfDepth  ? shadowDarkness : 1.0;\n        }\n    }\n    shadow /= 9.0;\n\n    return shadow;\n}\n\n\n\nfloat getTwoDShadowVisibility(vec3 lightDir, sampler2D twoDShadowMapSampler, vec4 v_positionFromLight, float shadowBias, float shadowDarkness, vec2 shadowSize) {\n    //project texture\n    vec3 shadowCoord = (v_positionFromLight.xyz / v_positionFromLight.w) / 2.0 + 0.5;\n    //vec3 shadowCoord = vec3(0.5, 0.5, 0.5);\n\n    #ifdef SHADOWMAP_TYPE_PCF\n    // Percentage-close filtering\n    // (9 pixel kernel)\n    return getTwoDShadowVisibilityByPCF(shadowCoord.z, shadowCoord.xy, twoDShadowMapSampler, getShadowBias(lightDir, shadowBias), shadowDarkness, shadowSize);\n\n    #else\n    return shadowCoord.z > handleDepthMap(texture2D(twoDShadowMapSampler, shadowCoord.xy)) + getShadowBias(lightDir, shadowBias) ? shadowDarkness : 1.0;\n    #endif\n}\n", body: "", };
        ShaderChunk.twoDShadowMap_unpackDepth_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "float handleDepthMap(vec4 rgbaDepth);\n", funcDefine: "float handleDepthMap(vec4 rgbaDepth) {\n    return unpackDepth(rgbaDepth);\n}\n", body: "", };
        ShaderChunk.twoDShadowMap_vertex = { top: "", define: "", varDeclare: "varying vec4 v_positionFromLight[ TWOD_SHADOWMAP_COUNT ];\nuniform mat4 u_vpMatrixFromLight[ TWOD_SHADOWMAP_COUNT ];\n", funcDeclare: "", funcDefine: "", body: "for( int i = 0; i < TWOD_SHADOWMAP_COUNT; i ++ ) {\n    v_positionFromLight[i] = u_vpMatrixFromLight[i] * vec4(v_worldPosition, 1.0);\n	}\n", };
        return ShaderChunk;
    }());
    wd.ShaderChunk = ShaderChunk;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShaderSnippet = (function () {
        function ShaderSnippet() {
        }
        ShaderSnippet.main_begin = "void main(void){\n";
        ShaderSnippet.main_end = "}\n";
        ShaderSnippet.setPos_mvp = "gl_Position = u_pMatrix * u_vMatrix * mMatrix * vec4(a_position, 1.0);\n";
        return ShaderSnippet;
    }());
    wd.ShaderSnippet = ShaderSnippet;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Material = (function () {
        function Material() {
            this._blendType = null;
            this._blendSrc = wd.EBlendFunc.ONE;
            this._blendDst = wd.EBlendFunc.ZERO;
            this._blendEquation = wd.EBlendEquation.ADD;
            this._alphaToCoverage = false;
            this._color = wd.Color.create("#ffffff");
            this.redWrite = true;
            this.greenWrite = true;
            this.blueWrite = true;
            this.alphaWrite = true;
            this.polygonOffsetMode = wd.EPolygonOffsetMode.NONE;
            this.side = wd.ESide.FRONT;
            this.blend = false;
            this.blendFuncSeparate = null;
            this.blendEquationSeparate = [wd.EBlendEquation.ADD, wd.EBlendEquation.ADD];
            this.geometry = null;
            this._shaderManager = wd.ShaderManager.create(this);
        }
        Object.defineProperty(Material.prototype, "program", {
            get: function () {
                return this.shader.program;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "blendType", {
            get: function () {
                return this._blendType;
            },
            set: function (blendType) {
                if (blendType === null) {
                    return;
                }
                switch (blendType) {
                    case wd.EBlendType.NONE:
                        this.blend = false;
                        this.blendSrc = wd.EBlendFunc.ONE;
                        this.blendDst = wd.EBlendFunc.ZERO;
                        this.blendEquation = wd.EBlendEquation.ADD;
                        break;
                    case wd.EBlendType.NORMAL:
                        this.blend = true;
                        this.blendSrc = wd.EBlendFunc.SRC_ALPHA;
                        this.blendDst = wd.EBlendFunc.ONE_MINUS_SRC_ALPHA;
                        this.blendEquation = wd.EBlendEquation.ADD;
                        break;
                    case wd.EBlendType.PREMULTIPLIED:
                        this.blend = true;
                        this.blendSrc = wd.EBlendFunc.ONE;
                        this.blendDst = wd.EBlendFunc.ONE_MINUS_SRC_ALPHA;
                        this.blendEquation = wd.EBlendEquation.ADD;
                        break;
                    case wd.EBlendType.ADDITIVE:
                        this.blend = true;
                        this.blendSrc = wd.EBlendFunc.ONE;
                        this.blendDst = wd.EBlendFunc.ONE;
                        this.blendEquation = wd.EBlendEquation.ADD;
                        break;
                    case wd.EBlendType.ADDITIVEALPHA:
                        this.blend = true;
                        this.blendSrc = wd.EBlendFunc.SRC_ALPHA;
                        this.blendDst = wd.EBlendFunc.ONE;
                        this.blendEquation = wd.EBlendEquation.ADD;
                        break;
                    case wd.EBlendType.MULTIPLICATIVE:
                        this.blend = true;
                        this.blendSrc = wd.EBlendFunc.DST_COLOR;
                        this.blendDst = wd.EBlendFunc.ZERO;
                        this.blendEquation = wd.EBlendEquation.ADD;
                        break;
                    default:
                        wd.Log.error(true, wd.Log.info.FUNC_INVALID("blendType"));
                        break;
                }
                this._blendType = blendType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "envMap", {
            get: function () {
                return this.mapManager.getEnvMap();
            },
            set: function (envMap) {
                this.mapManager.setEnvMap(envMap);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "blendSrc", {
            get: function () {
                return this._blendSrc;
            },
            set: function (blendSrc) {
                if (this._blendSrc === blendSrc) {
                    return;
                }
                this._blendSrc = blendSrc;
                this.blendFuncSeparate = null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "blendDst", {
            get: function () {
                return this._blendDst;
            },
            set: function (blendDst) {
                if (this._blendDst === blendDst) {
                    return;
                }
                this._blendDst = blendDst;
                this.blendFuncSeparate = null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "blendEquation", {
            get: function () {
                return this._blendEquation;
            },
            set: function (blendEquation) {
                if (this._blendEquation === blendEquation) {
                    return;
                }
                this._blendEquation = blendEquation;
                this.blendEquationSeparate = null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "alphaToCoverage", {
            get: function () {
                return this._alphaToCoverage;
            },
            set: function (alphaToCoverage) {
                this._alphaToCoverage = alphaToCoverage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color.isEqual(color)) {
                    return;
                }
                this._color = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "mapManager", {
            get: function () {
                return this._shaderManager.mapManager;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shader", {
            get: function () {
                return this._shaderManager.shader;
            },
            enumerable: true,
            configurable: true
        });
        Material.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Material.prototype.initWhenCreate = function () {
            this._shaderManager.setShader(this.createShader());
        };
        Material.prototype.init = function () {
            this._shaderManager.init();
        };
        Material.prototype.dispose = function () {
            this._shaderManager.dispose();
        };
        Material.prototype.updateShader = function (quadCmd) {
            this._shaderManager.update(quadCmd);
        };
        Material.prototype.addShader = function (shaderKey, shader) {
            this._shaderManager.addShader(shaderKey, shader);
        };
        Material.prototype.hasShader = function (shaderKey) {
            return this._shaderManager.hasShader(shaderKey);
        };
        Material.prototype.getShader = function (shaderKey) {
            return this._shaderManager.getShader(shaderKey);
        };
        Material.prototype.hasMap = function (map) {
            return this.mapManager.hasMap(map);
        };
        __decorate([
            wd.cloneAttributeAsBasicType({
                order: 1
            })
        ], Material.prototype, "blendType", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Material.prototype, "envMap", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "blendSrc", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "blendDst", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "blendEquation", null);
        __decorate([
            wd.cloneAttributeAsBasicType(),
            wd.ensureGetter(function (alphaToCoverage) {
                wd.it("if enable alphaToCoverage, multiSample should be enabled", function () {
                    if (alphaToCoverage) {
                        wd.expect(wd.DeviceManager.getInstance().contextConfig.options.antialias).true;
                    }
                });
            })
        ], Material.prototype, "alphaToCoverage", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Material.prototype, "color", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "redWrite", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "greenWrite", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "blueWrite", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "alphaWrite", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "polygonOffsetMode", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "side", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "blend", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType({
                order: -1
            })
        ], Material.prototype, "blendFuncSeparate", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "blendEquationSeparate", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Material.prototype, "geometry", void 0);
        return Material;
    }());
    wd.Material = Material;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var EngineMaterial = (function (_super) {
        __extends(EngineMaterial, _super);
        function EngineMaterial() {
            _super.apply(this, arguments);
            this.refractionRatio = 0;
            this.reflectivity = null;
            this.mapCombineMode = wd.ETextureCombineMode.MIX;
            this.mapMixRatio = 0.5;
        }
        EngineMaterial.prototype.init = function () {
            this._addTopShaderLib();
            this.addShaderLib();
            this._addEndShaderLib();
            _super.prototype.init.call(this);
        };
        EngineMaterial.prototype.addShaderLib = function () {
        };
        EngineMaterial.prototype.addNormalShaderLib = function () {
            var NormalMorphShaderLib = wd.ClassUtils.getClass("NormalMorphShaderLib");
            if (wd.GlobalGeometryUtils.hasMorphAnimation(this.geometry)
                && NormalMorphShaderLib !== void 0 && !this.shader.hasLib(NormalMorphShaderLib)) {
                this._addShaderLibToTop(NormalMorphShaderLib.create());
            }
            else if (!this.shader.hasLib(wd.NormalCommonShaderLib)) {
                this._addShaderLibToTop(wd.NormalCommonShaderLib.create());
            }
        };
        EngineMaterial.prototype.createShader = function () {
            return wd.CommonShader.create();
        };
        EngineMaterial.prototype._addTopShaderLib = function () {
            this.shader.addLib(wd.CommonShaderLib.create());
            wd.InstanceUtils.addModelMatrixShaderLib(this.shader, this.geometry.entityObject);
            wd.ShaderLibUtils.addVerticeShaderLib(this.geometry, this.shader);
        };
        EngineMaterial.prototype._addShaderLibToTop = function (lib) {
            this.shader.addShaderLibToTop(lib);
        };
        EngineMaterial.prototype._addEndShaderLib = function () {
            this.shader.addLib(wd.EndShaderLib.create());
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], EngineMaterial.prototype, "refractionRatio", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], EngineMaterial.prototype, "reflectivity", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], EngineMaterial.prototype, "mapCombineMode", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], EngineMaterial.prototype, "mapMixRatio", void 0);
        __decorate([
            wd.virtual
        ], EngineMaterial.prototype, "addShaderLib", null);
        return EngineMaterial;
    }(wd.Material));
    wd.EngineMaterial = EngineMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var StandardLightMaterial = (function (_super) {
        __extends(StandardLightMaterial, _super);
        function StandardLightMaterial() {
            _super.apply(this, arguments);
            this._lightMap = null;
            this._diffuseMap = null;
            this._specularMap = null;
            this._emissionMap = null;
            this._normalMap = null;
            this._shininess = 32;
            this.shading = wd.EShading.FLAT;
            this.opacity = 1.0;
            this.lightModel = wd.ELightModel.PHONG;
            this.specularColor = wd.Color.create("#ffffff");
            this.emissionColor = wd.Color.create("rgba(0,0,0,0)");
            this.lightMapIntensity = 1;
            this.alphaTest = null;
        }
        Object.defineProperty(StandardLightMaterial.prototype, "lightMap", {
            get: function () {
                return this._lightMap;
            },
            set: function (lightMap) {
                this._lightMap = lightMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StandardLightMaterial.prototype, "diffuseMap", {
            get: function () {
                return this._diffuseMap;
            },
            set: function (diffuseMap) {
                this._diffuseMap = diffuseMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StandardLightMaterial.prototype, "specularMap", {
            get: function () {
                return this._specularMap;
            },
            set: function (specularMap) {
                this._specularMap = specularMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StandardLightMaterial.prototype, "emissionMap", {
            get: function () {
                return this._emissionMap;
            },
            set: function (emissionMap) {
                this._emissionMap = emissionMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StandardLightMaterial.prototype, "normalMap", {
            get: function () {
                return this._normalMap;
            },
            set: function (normalMap) {
                this._normalMap = normalMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StandardLightMaterial.prototype, "shininess", {
            get: function () {
                if (Number(this._shininess) <= 0) {
                    return 32;
                }
                return this._shininess;
            },
            set: function (shininess) {
                this._shininess = shininess;
            },
            enumerable: true,
            configurable: true
        });
        StandardLightMaterial.prototype.init = function () {
            this._addMap();
            _super.prototype.init.call(this);
        };
        StandardLightMaterial.prototype.addTopExtendShaderLib = function () {
        };
        StandardLightMaterial.prototype.addExtendShaderLib = function () {
        };
        StandardLightMaterial.prototype.addEndShaderLib = function () {
        };
        StandardLightMaterial.prototype.addNormalRelatedShaderLib = function () {
            if (this._normalMap) {
                this.shader.addLib(wd.NormalMapShaderLib.create());
            }
            else {
                this.shader.addLib(wd.NoNormalMapShaderLib.create());
            }
        };
        StandardLightMaterial.prototype.addLightSetWorldPositionShaderLib = function () {
            this.shader.addLib(wd.LightSetWorldPositionShaderLib.create());
        };
        StandardLightMaterial.prototype.addShaderLib = function () {
            var envMap = null;
            this.addTopExtendShaderLib();
            wd.InstanceUtils.addNormalModelMatrixShaderLib(this.shader, this.geometry.entityObject);
            this.addNormalShaderLib();
            this.shader.addLib(wd.LightCommonShaderLib.create());
            this.addLightSetWorldPositionShaderLib();
            this._setLightMapShaderLib();
            this.shader.addLib(wd.LightShaderLib.create());
            envMap = this.envMap;
            if (envMap) {
                this._setEnvMapShaderLib(envMap);
            }
            this.addExtendShaderLib();
            this.shader.addLib(wd.LightEndShaderLib.create());
            this.addEndShaderLib();
        };
        StandardLightMaterial.prototype._setLightMapShaderLib = function () {
            var scene = wd.Director.getInstance().scene;
            this.shader.addLib(wd.CommonLightMapShaderLib.create());
            if (this._lightMap) {
                this.shader.addLib(wd.LightMapShaderLib.create());
            }
            else {
                this.shader.addLib(wd.NoLightMapShaderLib.create());
            }
            if (this._diffuseMap) {
                this.shader.addLib(wd.DiffuseMapShaderLib.create());
            }
            else {
                this.shader.addLib(wd.NoDiffuseMapShaderLib.create());
            }
            if (this._specularMap) {
                this.shader.addLib(wd.SpecularMapShaderLib.create());
            }
            else {
                this.shader.addLib(wd.NoSpecularMapShaderLib.create());
            }
            if (this._emissionMap) {
                this.shader.addLib(wd.EmissionMapShaderLib.create());
            }
            else {
                this.shader.addLib(wd.NoEmissionMapShaderLib.create());
            }
            this.addNormalRelatedShaderLib();
            if (scene.shadowMap.enable) {
                var hasTwoD = false, hasCubemap = false;
                if (this._hasTwoDShadowMap()) {
                    hasTwoD = true;
                    this.shader.addLib(wd.ClassUtils.getClass("TwoDShadowMapShaderLib").create());
                }
                if (this._hasCubemapShadowMap()) {
                    hasCubemap = true;
                    this.shader.addLib(wd.ClassUtils.getClass("CubemapShadowMapShaderLib").create());
                }
                if (hasTwoD || hasCubemap) {
                    this.shader.addLib(wd.ClassUtils.getClass("TotalShadowMapShaderLib").create());
                }
                else {
                    this.shader.addLib(wd.NoShadowMapShaderLib.create());
                }
            }
            else {
                this.shader.addLib(wd.NoShadowMapShaderLib.create());
            }
        };
        StandardLightMaterial.prototype._setEnvMapShaderLib = function (envMap) {
            this.shader.addLib(wd.CommonEnvMapShaderLib.create());
            switch (envMap.mode) {
                case wd.EEnvMapMode.BASIC:
                    this.shader.addLib(wd.BasicForLightEnvMapShaderLib.create());
                    break;
                case wd.EEnvMapMode.REFLECTION:
                    this.shader.addLib(wd.ReflectionForLightEnvMapShaderLib.create());
                    break;
                case wd.EEnvMapMode.REFRACTION:
                    this.shader.addLib(wd.RefractionForLightEnvMapShaderLib.create());
                    break;
                case wd.EEnvMapMode.FRESNEL:
                    this.shader.addLib(wd.FresnelForLightEnvMapShaderLib.create());
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("EEnvMapMode"));
                    break;
            }
        };
        StandardLightMaterial.prototype._hasTwoDShadowMap = function () {
            var ShadowUtils = wd.ClassUtils.getClass("ShadowUtils");
            if (ShadowUtils === void 0) {
                return false;
            }
            return ShadowUtils.isReceive(this.geometry.entityObject) && this.mapManager.getTwoDShadowMapList().getCount() > 0;
        };
        StandardLightMaterial.prototype._hasCubemapShadowMap = function () {
            var ShadowUtils = wd.ClassUtils.getClass("ShadowUtils");
            if (ShadowUtils === void 0) {
                return false;
            }
            return ShadowUtils.isReceive(this.geometry.entityObject) && this.mapManager.getCubemapShadowMapList().getCount() > 0;
        };
        StandardLightMaterial.prototype._addMap = function () {
            if (this._lightMap !== null) {
                this.mapManager.addMap(this._lightMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("lightMap")
                });
            }
            if (this._diffuseMap !== null) {
                this.mapManager.addMap(this._diffuseMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("diffuseMap")
                });
            }
            if (this._specularMap !== null) {
                this.mapManager.addMap(this._specularMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("specularMap")
                });
            }
            if (this._emissionMap !== null) {
                this.mapManager.addMap(this._emissionMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("emissionMap")
                });
            }
            if (this._normalMap !== null) {
                this.mapManager.addMap(this._normalMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("normalMap")
                });
            }
        };
        __decorate([
            wd.requireSetter(function (lightMap) {
                wd.assert(lightMap instanceof wd.ImageTexture || lightMap instanceof wd.ProceduralTexture, wd.Log.info.FUNC_SHOULD("lightMap", "be ImageTexture or ProceduralTexture"));
            }),
            wd.cloneAttributeAsCloneable()
        ], StandardLightMaterial.prototype, "lightMap", null);
        __decorate([
            wd.requireSetter(function (diffuseMap) {
                wd.assert(diffuseMap instanceof wd.ImageTexture || diffuseMap instanceof wd.ProceduralTexture, wd.Log.info.FUNC_SHOULD("diffuseMap", "be ImageTexture or ProceduralTexture"));
            }),
            wd.cloneAttributeAsCloneable()
        ], StandardLightMaterial.prototype, "diffuseMap", null);
        __decorate([
            wd.requireSetter(function (specularMap) {
                wd.assert(specularMap instanceof wd.ImageTexture || specularMap instanceof wd.ProceduralTexture, wd.Log.info.FUNC_SHOULD("specularMap", "be ImageTexture or ProceduralTexture"));
            }),
            wd.cloneAttributeAsCloneable()
        ], StandardLightMaterial.prototype, "specularMap", null);
        __decorate([
            wd.requireSetter(function (emissionMap) {
                wd.assert(emissionMap instanceof wd.ImageTexture || emissionMap instanceof wd.ProceduralTexture, wd.Log.info.FUNC_SHOULD("emissionMap", "be ImageTexture or ProceduralTexture"));
            }),
            wd.cloneAttributeAsCloneable()
        ], StandardLightMaterial.prototype, "emissionMap", null);
        __decorate([
            wd.requireSetter(function (normalMap) {
                wd.assert(normalMap instanceof wd.ImageTexture, wd.Log.info.FUNC_SHOULD("normalMap", "be ImageTexture"));
            }),
            wd.cloneAttributeAsCloneable()
        ], StandardLightMaterial.prototype, "normalMap", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardLightMaterial.prototype, "shininess", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardLightMaterial.prototype, "shading", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardLightMaterial.prototype, "opacity", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardLightMaterial.prototype, "lightModel", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], StandardLightMaterial.prototype, "specularColor", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], StandardLightMaterial.prototype, "emissionColor", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardLightMaterial.prototype, "lightMapIntensity", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardLightMaterial.prototype, "alphaTest", void 0);
        __decorate([
            wd.virtual
        ], StandardLightMaterial.prototype, "addTopExtendShaderLib", null);
        __decorate([
            wd.virtual
        ], StandardLightMaterial.prototype, "addExtendShaderLib", null);
        __decorate([
            wd.virtual
        ], StandardLightMaterial.prototype, "addEndShaderLib", null);
        __decorate([
            wd.virtual
        ], StandardLightMaterial.prototype, "addNormalRelatedShaderLib", null);
        __decorate([
            wd.virtual
        ], StandardLightMaterial.prototype, "addLightSetWorldPositionShaderLib", null);
        return StandardLightMaterial;
    }(wd.EngineMaterial));
    wd.StandardLightMaterial = StandardLightMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var StandardBasicMaterial = (function (_super) {
        __extends(StandardBasicMaterial, _super);
        function StandardBasicMaterial() {
            _super.apply(this, arguments);
            this._map = null;
            this.opacity = 1.0;
            this.alphaTest = null;
        }
        Object.defineProperty(StandardBasicMaterial.prototype, "mapList", {
            get: function () {
                return this.mapManager.getMapList();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(StandardBasicMaterial.prototype, "map", {
            get: function () {
                return this.mapList.getChild(0);
            },
            set: function (map) {
                this._map = map;
                this._addMap();
            },
            enumerable: true,
            configurable: true
        });
        StandardBasicMaterial.prototype.addExtendShaderLib = function () {
        };
        StandardBasicMaterial.prototype.addShaderLib = function () {
            var envMap = null;
            if (this.geometry.hasColors()) {
                this.shader.addLib(wd.BasicVertexColorShaderLib.create());
            }
            else {
                this.shader.addLib(wd.BasicMaterialColorShaderLib.create());
            }
            this.shader.addLib(wd.BasicShaderLib.create());
            this._setMapShaderLib();
            envMap = this.envMap;
            if (envMap) {
                wd.InstanceUtils.addNormalModelMatrixShaderLib(this.shader, this.geometry.entityObject);
                this._setEnvMapShaderLib(envMap);
            }
            this.addExtendShaderLib();
            this.shader.addLib(wd.EndBasicShaderLib.create());
        };
        StandardBasicMaterial.prototype._setMapShaderLib = function () {
            var mapManager = this.mapManager, mapCount = mapManager.getMapCount();
            if (mapCount > 0) {
                if (mapCount > 1) {
                    this.shader.addLib(wd.MultiMapShaderLib.create());
                }
                else {
                    this.shader.addLib(wd.BasicMapShaderLib.create());
                }
            }
        };
        StandardBasicMaterial.prototype._setEnvMapShaderLib = function (envMap) {
            this.addNormalShaderLib();
            this.shader.addLib(wd.CommonEnvMapShaderLib.create());
            switch (envMap.mode) {
                case wd.EEnvMapMode.BASIC:
                    this.shader.addLib(wd.BasicForBasicEnvMapShaderLib.create());
                    break;
                case wd.EEnvMapMode.REFLECTION:
                    this.shader.addLib(wd.ReflectionForBasicEnvMapShaderLib.create());
                    break;
                case wd.EEnvMapMode.REFRACTION:
                    this.shader.addLib(wd.RefractionForBasicEnvMapShaderLib.create());
                    break;
                case wd.EEnvMapMode.FRESNEL:
                    this.shader.addLib(wd.FresnelForBasicEnvMapShaderLib.create());
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_INVALID("EEnvMapMode"));
                    break;
            }
        };
        StandardBasicMaterial.prototype._addMap = function () {
            var map = this._map;
            if (map === null) {
                return;
            }
            if (map instanceof wd.Texture || map instanceof wd.TextureAsset) {
                this.mapManager.addMap(map);
            }
            else {
                for (var _i = 0, map_1 = map; _i < map_1.length; _i++) {
                    var m = map_1[_i];
                    this.mapManager.addMap(m);
                }
            }
        };
        __decorate([
            wd.ensureGetter(function (mapList) {
                wd.assert(mapList.getCount() <= 2, wdCb.Log.info.FUNC_SUPPORT("only", "map.count <= 2"));
            }),
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                source[memberName].forEach(function (map) {
                    target.mapManager.addMap(map.clone());
                });
            })
        ], StandardBasicMaterial.prototype, "mapList", null);
        __decorate([
            wd.requireSetter(function (map) {
                if (map instanceof wd.Texture || map instanceof wd.TextureAsset) {
                }
                else {
                    var mapArr_3 = map;
                    wd.it("map should be array", function () {
                        wd.expect(mapArr_3).be.a("array");
                    });
                    wd.it("map.count should < 3", function () {
                        wd.expect(mapArr_3.length).lessThan(3);
                    });
                }
            })
        ], StandardBasicMaterial.prototype, "map", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardBasicMaterial.prototype, "opacity", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], StandardBasicMaterial.prototype, "alphaTest", void 0);
        __decorate([
            wd.virtual
        ], StandardBasicMaterial.prototype, "addExtendShaderLib", null);
        return StandardBasicMaterial;
    }(wd.EngineMaterial));
    wd.StandardBasicMaterial = StandardBasicMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LineMaterial = (function (_super) {
        __extends(LineMaterial, _super);
        function LineMaterial() {
            _super.apply(this, arguments);
            this._lineWidth = 1.0;
        }
        LineMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(LineMaterial.prototype, "lineWidth", {
            get: function () {
                return this._lineWidth;
            },
            set: function (lineWidth) {
                this._lineWidth = lineWidth;
            },
            enumerable: true,
            configurable: true
        });
        LineMaterial.prototype.getTextureForRenderSort = function () {
            return this.mapList.getChild(0);
        };
        __decorate([
            wd.cloneAttributeAsBasicType(),
            wd.requireSetter(function (lineWidth) {
                wd.it("lineWidth should <= 1", function () {
                    wd.expect(lineWidth).not.to.greaterThan(1);
                });
            }),
            wd.ensureGetter(function (lineWidth) {
                wd.it("lineWidth should <= 1", function () {
                    wd.expect(lineWidth).not.to.greaterThan(1);
                });
            })
        ], LineMaterial.prototype, "lineWidth", null);
        return LineMaterial;
    }(wd.StandardBasicMaterial));
    wd.LineMaterial = LineMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicMaterial = (function (_super) {
        __extends(BasicMaterial, _super);
        function BasicMaterial() {
            _super.apply(this, arguments);
        }
        BasicMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        BasicMaterial.prototype.getTextureForRenderSort = function () {
            return this.mapList.getChild(0);
        };
        return BasicMaterial;
    }(wd.StandardBasicMaterial));
    wd.BasicMaterial = BasicMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SkyboxMaterial = (function (_super) {
        __extends(SkyboxMaterial, _super);
        function SkyboxMaterial() {
            _super.apply(this, arguments);
        }
        SkyboxMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        SkyboxMaterial.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.side = wd.ESide.BACK;
        };
        SkyboxMaterial.prototype.getTextureForRenderSort = function () {
            return null;
        };
        SkyboxMaterial.prototype.addShaderLib = function () {
            this.shader.addLib(wd.SkyboxShaderLib.create());
        };
        return SkyboxMaterial;
    }(wd.EngineMaterial));
    wd.SkyboxMaterial = SkyboxMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightMaterial = (function (_super) {
        __extends(LightMaterial, _super);
        function LightMaterial() {
            _super.apply(this, arguments);
        }
        LightMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        LightMaterial.prototype.getTextureForRenderSort = function () {
            return this.diffuseMap;
        };
        return LightMaterial;
    }(wd.StandardLightMaterial));
    wd.LightMaterial = LightMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShaderMaterial = (function (_super) {
        __extends(ShaderMaterial, _super);
        function ShaderMaterial() {
            _super.apply(this, arguments);
            this.definitionData = null;
        }
        ShaderMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        ShaderMaterial.prototype.init = function () {
            var _this = this;
            this.shader.read(this.definitionData);
            this.shader.getSampler2DUniformsAfterRead().forEach(function (uniform, name) {
                _this.mapManager.addMap(wd.LoaderManager.getInstance().get(uniform.textureId), {
                    samplerVariableName: name
                });
            });
            this.shader.addLib(wd.CustomShaderLib.create());
            this.shader.addLib(wd.EndShaderLib.create());
            _super.prototype.init.call(this);
        };
        ShaderMaterial.prototype.getTextureForRenderSort = function () {
            return null;
        };
        ShaderMaterial.prototype.read = function (definitionDataId) {
            this.definitionData = wd.LoaderManager.getInstance().get(definitionDataId);
        };
        ShaderMaterial.prototype.createShader = function () {
            return wd.CustomShader.create();
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ShaderMaterial.prototype, "definitionData", void 0);
        __decorate([
            wd.ensure(function () {
                var _this = this;
                wd.it("should only has CustomShaderLib and EndShaderLib, not has other shader libs", function () {
                    wd.expect(_this.shader.getLibs().getCount() === 2 && _this.shader.hasLib(wd.CustomShaderLib)).true;
                });
            })
        ], ShaderMaterial.prototype, "init", null);
        return ShaderMaterial;
    }(wd.Material));
    wd.ShaderMaterial = ShaderMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EShading) {
        EShading[EShading["FLAT"] = 0] = "FLAT";
        EShading[EShading["SMOOTH"] = 1] = "SMOOTH";
    })(wd.EShading || (wd.EShading = {}));
    var EShading = wd.EShading;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShaderManager = (function () {
        function ShaderManager(material) {
            this._material = null;
            this._otherShaderMap = wdCb.Hash.create();
            this._mainShader = null;
            this._material = material;
        }
        ShaderManager.create = function (material) {
            var obj = new this(material);
            return obj;
        };
        Object.defineProperty(ShaderManager.prototype, "shader", {
            get: function () {
                var scene = wd.Director.getInstance().scene;
                return scene.isUseShader ? this._otherShaderMap.getChild(scene.currentShaderType) : this._mainShader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ShaderManager.prototype, "mapManager", {
            get: function () {
                return this.shader.mapManager;
            },
            enumerable: true,
            configurable: true
        });
        ShaderManager.prototype.setShader = function (shader) {
            this._mainShader = shader;
            this._mainShader.mapManager.material = this._material;
        };
        ShaderManager.prototype.init = function () {
            var material = this._material;
            this._otherShaderMap.forEach(function (shader) {
                shader.init(material);
            });
            this._mainShader.init(material);
        };
        ShaderManager.prototype.dispose = function () {
            this._otherShaderMap.forEach(function (shader) {
                shader.dispose();
            });
            this._mainShader.dispose();
        };
        ShaderManager.prototype.update = function (quadCmd) {
            this.shader.update(quadCmd, this._material);
        };
        ShaderManager.prototype.addShader = function (shaderKey, shader) {
            this._otherShaderMap.addChild(shaderKey, shader);
        };
        ShaderManager.prototype.hasShader = function (shaderKey) {
            return this._otherShaderMap.hasChild(shaderKey);
        };
        ShaderManager.prototype.getShader = function (shaderKey) {
            return this._otherShaderMap.getChild(shaderKey);
        };
        __decorate([
            wd.ensureGetter(function (shader) {
                wd.assert(!!shader, wd.Log.info.FUNC_NOT_EXIST("shader"));
            })
        ], ShaderManager.prototype, "shader", null);
        return ShaderManager;
    }());
    wd.ShaderManager = ShaderManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EAssetType) {
        EAssetType[EAssetType["UNKNOW"] = 0] = "UNKNOW";
        EAssetType[EAssetType["FONT"] = 1] = "FONT";
        EAssetType[EAssetType["SCRIPT"] = 2] = "SCRIPT";
    })(wd.EAssetType || (wd.EAssetType = {}));
    var EAssetType = wd.EAssetType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Loader = (function () {
        function Loader() {
            this._container = wdCb.Hash.create();
        }
        Loader.prototype.load = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var url = args[0], id = null, config = null, self = this, data = null, stream = null;
            id = args[1];
            config = args[2];
            data = this._container.getChild(id);
            if (data) {
                stream = wdFrp.just(data);
            }
            else {
                stream = this.loadAsset(url, id, config)
                    .do(function (data) {
                    self._container.addChild(id, data);
                    wd.LoaderManager.getInstance().add(id, self);
                }, function (err) {
                    self._errorHandle(url, err);
                }, null);
            }
            return stream;
        };
        Loader.prototype.get = function (id) {
            return this._container.getChild(id);
        };
        Loader.prototype.has = function (id) {
            return this._container.hasChild(id);
        };
        Loader.prototype.dispose = function () {
            this._container.removeAllChildren();
        };
        Loader.prototype._errorHandle = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var path = null, err = null;
            if (wd.JudgeUtils.isArrayExactly(args[0])) {
                path = args[0].join(",");
            }
            else {
                path = args[0];
            }
            err = args[1];
            wd.Log.log("load " + path + " asset fail:" + err);
        };
        return Loader;
    }());
    wd.Loader = Loader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GLSLLoader = (function (_super) {
        __extends(GLSLLoader, _super);
        function GLSLLoader() {
            _super.call(this);
        }
        GLSLLoader.getInstance = function () { };
        GLSLLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var url = args[0];
            return wd.AjaxLoader.load(url, "text");
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.assert(!wd.JudgeUtils.isArrayExactly(args[0]), wd.Log.info.FUNC_MUST_BE("url", "string"));
            })
        ], GLSLLoader.prototype, "loadAsset", null);
        GLSLLoader = __decorate([
            wd.singleton()
        ], GLSLLoader);
        return GLSLLoader;
    }(wd.Loader));
    wd.GLSLLoader = GLSLLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var JsLoader = (function (_super) {
        __extends(JsLoader, _super);
        function JsLoader() {
            _super.call(this);
        }
        JsLoader.getInstance = function () { };
        JsLoader.prototype.loadAsset = function () {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var self = this, url = args[0];
            return wdFrp.fromPromise(new wd.RSVP.Promise(function (resolve, reject) {
                var script = self._createScript();
                script.async = false;
                script.addEventListener("error", function (e) {
                    reject("load js file error. url:" + url);
                });
                if (script.readyState) {
                    script.onreadystatechange = function () {
                        if (script.readyState === "loaded" || script.readyState === "complete") {
                            script.onreadystatechange = null;
                            resolve(url);
                        }
                    };
                }
                else {
                    script.onload = function () {
                        resolve(url);
                    };
                }
                script.src = url;
                _this._appendScript(script);
            }));
        };
        JsLoader.prototype._createScript = function () {
            var script = document.createElement("script");
            script.type = "text/javascript";
            return script;
        };
        JsLoader.prototype._appendScript = function (script) {
            document.getElementsByTagName("head")[0].appendChild(script);
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.assert(!wd.JudgeUtils.isArrayExactly(args[0]), wd.Log.info.FUNC_MUST_BE("url", "string"));
            })
        ], JsLoader.prototype, "loadAsset", null);
        JsLoader = __decorate([
            wd.singleton()
        ], JsLoader);
        return JsLoader;
    }(wd.Loader));
    wd.JsLoader = JsLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ScriptLoader = (function (_super) {
        __extends(ScriptLoader, _super);
        function ScriptLoader() {
            _super.call(this);
        }
        ScriptLoader.getInstance = function () { };
        ScriptLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var self = this, url = args[0], id = args[1];
            return wd.JsLoader.getInstance().load(url, id)
                .map(function () {
                return wd.Script.scriptList.pop();
            });
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.assert(!wd.JudgeUtils.isArrayExactly(args[0]), wd.Log.info.FUNC_MUST_BE("url", "string"));
            })
        ], ScriptLoader.prototype, "loadAsset", null);
        ScriptLoader = __decorate([
            wd.singleton()
        ], ScriptLoader);
        return ScriptLoader;
    }(wd.Loader));
    wd.ScriptLoader = ScriptLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var JSONLoader = (function (_super) {
        __extends(JSONLoader, _super);
        function JSONLoader() {
            _super.call(this);
        }
        JSONLoader.getInstance = function () { };
        JSONLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var url = args[0];
            return wd.AjaxLoader.load(url, "json");
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.assert(!wd.JudgeUtils.isArrayExactly(args[0]), wd.Log.info.FUNC_MUST_BE("url", "string"));
            })
        ], JSONLoader.prototype, "loadAsset", null);
        JSONLoader = __decorate([
            wd.singleton()
        ], JSONLoader);
        return JSONLoader;
    }(wd.Loader));
    wd.JSONLoader = JSONLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VideoLoader = (function (_super) {
        __extends(VideoLoader, _super);
        function VideoLoader() {
            _super.call(this);
        }
        VideoLoader.getInstance = function () { };
        VideoLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var urlArr = null;
            if (wd.JudgeUtils.isString(args[0])) {
                urlArr = [args[0]];
            }
            else {
                urlArr = args[0];
            }
            return wdFrp.fromPromise(new wd.RSVP.Promise(function (resolve, reject) {
                wd.Video.create({
                    urlArr: urlArr,
                    onLoad: function (video) {
                        resolve(wd.VideoTextureAsset.create(video));
                    },
                    onError: function (err) {
                        reject(err);
                    }
                });
            }));
        };
        VideoLoader = __decorate([
            wd.singleton()
        ], VideoLoader);
        return VideoLoader;
    }(wd.Loader));
    wd.VideoLoader = VideoLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SoundLoader = (function (_super) {
        __extends(SoundLoader, _super);
        function SoundLoader() {
            _super.call(this);
        }
        SoundLoader.getInstance = function () { };
        SoundLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var urlArr = null;
            if (wd.JudgeUtils.isString(args[0])) {
                urlArr = [args[0]];
            }
            else {
                urlArr = args[0];
            }
            return wdFrp.fromPromise(new wd.RSVP.Promise(function (resolve, reject) {
                wd.Sound.create({
                    urlArr: urlArr,
                    onLoad: function (sound) {
                        resolve(sound);
                    },
                    onError: function (err) {
                        reject(err);
                    }
                });
            }));
        };
        SoundLoader = __decorate([
            wd.singleton()
        ], SoundLoader);
        return SoundLoader;
    }(wd.Loader));
    wd.SoundLoader = SoundLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TextureLoader = (function (_super) {
        __extends(TextureLoader, _super);
        function TextureLoader() {
            _super.call(this);
        }
        TextureLoader.getInstance = function () { };
        TextureLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var extname = null, stream = null, url = args[0], config = args[2];
            extname = wdCb.PathUtils.extname(url).toLowerCase();
            switch (extname) {
                case ".jpg":
                case ".jpeg":
                case ".gif":
                case ".bmp":
                    stream = wd.ImageLoader.load(url, config)
                        .map(function (image) {
                        var asset = wd.ImageTextureAsset.create(image);
                        asset.format = wd.ETextureFormat.RGB;
                        return asset;
                    });
                    break;
                case ".png":
                    stream = wd.ImageLoader.load(url, config)
                        .map(function (image) {
                        return wd.ImageTextureAsset.create(image);
                    });
                    break;
                case ".dds":
                    stream = wd.CompressedTextureLoader.load(url);
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT(extname));
                    break;
            }
            return stream;
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.assert(!wd.JudgeUtils.isArrayExactly(args[0]), wd.Log.info.FUNC_MUST_BE("url", "string"));
            })
        ], TextureLoader.prototype, "loadAsset", null);
        TextureLoader = __decorate([
            wd.singleton()
        ], TextureLoader);
        return TextureLoader;
    }(wd.Loader));
    wd.TextureLoader = TextureLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var AjaxLoader = (function () {
        function AjaxLoader() {
        }
        AjaxLoader.load = function (url, dataType) {
            return wdFrp.fromPromise(new wd.RSVP.Promise(function (resolve, reject) {
                wdCb.AjaxUtils.ajax({
                    type: "get",
                    url: url,
                    contentType: "text/plain; charset=utf-8",
                    dataType: dataType,
                    success: function (data) {
                        resolve(data);
                    },
                    error: function (XMLHttpRequest, errorThrown) {
                        reject("url:" + url + "\nreadyState:" + XMLHttpRequest.readyState + "\nstatus:" + XMLHttpRequest.status + "\nmessage:" + errorThrown.message + "\nresponseText:" + XMLHttpRequest.responseText);
                    }
                });
            }));
        };
        return AjaxLoader;
    }());
    wd.AjaxLoader = AjaxLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Base64Utils = (function () {
        function Base64Utils() {
        }
        Base64Utils.createImageFromBase64 = function (base64) {
            var image = new Image();
            image.src = base64;
            return image;
        };
        __decorate([
            wd.require(function (base64) {
                wd.it("base64 should define 'data:image' field", function () {
                    wd.expect(base64.indexOf("data:image")).gt(-1);
                });
            })
        ], Base64Utils, "createImageFromBase64", null);
        return Base64Utils;
    }());
    wd.Base64Utils = Base64Utils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BufferReader = (function () {
        function BufferReader() {
            this._dataView = null;
            this._offset = 0;
        }
        BufferReader.create = function (arraybuffer, byteOffset, byteLength) {
            var obj = new this();
            obj.initWhenCreate(arraybuffer, byteOffset, byteLength);
            return obj;
        };
        Object.defineProperty(BufferReader.prototype, "arraybuffer", {
            get: function () {
                return this._dataView.buffer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BufferReader.prototype, "byteLength", {
            get: function () {
                return this._dataView.byteLength;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BufferReader.prototype, "byteOffset", {
            get: function () {
                return this._dataView.byteOffset;
            },
            enumerable: true,
            configurable: true
        });
        BufferReader.prototype.initWhenCreate = function (arraybuffer, byteOffset, byteLength) {
            this._dataView = new DataView(arraybuffer, byteOffset, byteLength);
        };
        BufferReader.prototype.readInt8 = function () {
            var result = this._dataView.getInt8(this._offset);
            this._offset++;
            return result;
        };
        BufferReader.prototype.readUInt8 = function () {
            var result = this._dataView.getUint8(this._offset);
            this._offset++;
            return result;
        };
        BufferReader.prototype.readInt16 = function () {
            var result = this._dataView.getInt16(this._offset, true);
            this._offset += 2;
            return result;
        };
        BufferReader.prototype.readUInt16 = function () {
            var result = this._dataView.getUint16(this._offset, true);
            this._offset += 2;
            return result;
        };
        BufferReader.prototype.readInt32 = function () {
            var result = this._dataView.getInt32(this._offset, true);
            this._offset += 4;
            return result;
        };
        BufferReader.prototype.readUInt32 = function () {
            var result = this._dataView.getUint32(this._offset, true);
            this._offset += 4;
            return result;
        };
        BufferReader.prototype.readFloat = function () {
            var result = this._dataView.getFloat32(this._offset, true);
            this._offset += 4;
            return result;
        };
        BufferReader.prototype.seek = function (pos) {
            this._offset = pos;
        };
        return BufferReader;
    }());
    wd.BufferReader = BufferReader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ImageLoader = (function () {
        function ImageLoader() {
        }
        ImageLoader.load = function (url, config) {
            return wdFrp.fromPromise(new wd.RSVP.Promise(function (resolve, reject) {
                var img = null;
                img = new wd.root.Image();
                if (config.isCrossOrigin) {
                    img.crossOrigin = "anonymous";
                }
                img.onload = function () {
                    this.onload = null;
                    resolve(img);
                };
                img.onerror = function () {
                    reject("error");
                };
                img.src = url;
            }));
        };
        return ImageLoader;
    }());
    wd.ImageLoader = ImageLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ModelLoaderUtils = (function () {
        function ModelLoaderUtils() {
        }
        ModelLoaderUtils.getPath = function (filePath, mapUrl) {
            return wdCb.PathUtils.dirname(filePath) + "/" + mapUrl;
        };
        return ModelLoaderUtils;
    }());
    wd.ModelLoaderUtils = ModelLoaderUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CompressedTextureLoader = (function () {
        function CompressedTextureLoader() {
        }
        CompressedTextureLoader.load = function (url) {
            var _this = this;
            return wd.AjaxLoader.load(url, "arraybuffer")
                .map(function (data) {
                var texDatas = wd.DDSParser.parse(data, true), asset = wd.CompressedTextureAsset.create();
                asset.width = texDatas.width;
                asset.height = texDatas.height;
                asset.mipmaps = texDatas.mipmaps;
                if (texDatas.mipmapCount == 1) {
                    asset.minFilter = wd.ETextureFilterMode.LINEAR;
                }
                asset.format = _this._getCompressedFormat(texDatas.format);
                return asset;
            });
        };
        CompressedTextureLoader._getCompressedFormat = function (format) {
            var extension = wd.GPUDetector.getInstance().extensionCompressedTextureS3TC;
            if (format === wd.ETextureFormat.RGBA) {
                return format;
            }
            if (!extension) {
                return null;
            }
            switch (format) {
                case wd.ETextureFormat.RGB_S3TC_DXT1:
                    format = extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    break;
                case wd.ETextureFormat.RGBA_S3TC_DXT1:
                    format = extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    break;
                case wd.ETextureFormat.RGBA_S3TC_DXT3:
                    format = extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    break;
                case wd.ETextureFormat.RGBA_S3TC_DXT5:
                    format = extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    break;
            }
            return format;
        };
        return CompressedTextureLoader;
    }());
    wd.CompressedTextureLoader = CompressedTextureLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DDS_MAGIC = 0x20534444, DDSD_CAPS = 0x1, DDSD_HEIGHT = 0x2, DDSD_WIDTH = 0x4, DDSD_PITCH = 0x8, DDSD_PIXELFORMAT = 0x1000, DDSD_MIPMAPCOUNT = 0x20000, DDSD_LINEARSIZE = 0x80000, DDSD_DEPTH = 0x800000, DDSCAPS_COMPLEX = 0x8, DDSCAPS_MIPMAP = 0x400000, DDSCAPS_TEXTURE = 0x1000, DDSCAPS2_CUBEMAP = 0x200, DDSCAPS2_CUBEMAP_POSITIVEX = 0x400, DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800, DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000, DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000, DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000, DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000, DDSCAPS2_VOLUME = 0x200000, DDPF_ALPHAPIXELS = 0x1, DDPF_ALPHA = 0x2, DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, DDPF_YUV = 0x200, DDPF_LUMINANCE = 0x20000;
    var DDSParser = (function () {
        function DDSParser() {
        }
        DDSParser.parse = function (buffer, loadMipmaps) {
            if (loadMipmaps === void 0) { loadMipmaps = true; }
            var dds = new DDSData(), FOURCC_DXT1 = this._fourCCToInt32("DXT1"), FOURCC_DXT3 = this._fourCCToInt32("DXT3"), FOURCC_DXT5 = this._fourCCToInt32("DXT5"), headerLengthInt = 31, off_magic = 0, off_size = 1, off_flags = 2, off_height = 3, off_width = 4, off_mipmapCount = 7, off_pfFlags = 20, off_pfFourCC = 21, off_RGBBitCount = 22, off_RBitMask = 23, off_GBitMask = 24, off_BBitMask = 25, off_ABitMask = 26, off_caps = 27, off_caps2 = 28, off_caps3 = 29, off_caps4 = 30, header = new Int32Array(buffer, 0, headerLengthInt), blockBytes = null, fourCC = null, isRGBAUncompressed = null, dataOffset = null, width = null, height = null, faces = null;
            if (header[off_magic] !== DDS_MAGIC) {
                wd.Log.error(true, "Invalid magic number in DDS header.");
                return dds;
            }
            if ((!header[off_pfFlags]) & DDPF_FOURCC) {
                wd.Log.error(true, "Unsupported format, must contain a FourCC code.");
                return dds;
            }
            fourCC = header[off_pfFourCC];
            isRGBAUncompressed = false;
            switch (fourCC) {
                case FOURCC_DXT1:
                    blockBytes = 8;
                    dds.format = wd.ETextureFormat.RGB_S3TC_DXT1;
                    break;
                case FOURCC_DXT3:
                    blockBytes = 16;
                    dds.format = wd.ETextureFormat.RGBA_S3TC_DXT3;
                    break;
                case FOURCC_DXT5:
                    blockBytes = 16;
                    dds.format = wd.ETextureFormat.RGBA_S3TC_DXT5;
                    break;
                default:
                    if (header[off_RGBBitCount] == 32
                        && header[off_RBitMask] & 0xff0000
                        && header[off_GBitMask] & 0xff00
                        && header[off_BBitMask] & 0xff
                        && header[off_ABitMask] & 0xff000000) {
                        isRGBAUncompressed = true;
                        blockBytes = 64;
                        dds.format = wd.ETextureFormat.RGBA;
                    }
                    else {
                        wd.Log.error(true, "Unsupported FourCC code " + this._int32ToFourCC(fourCC));
                        return dds;
                    }
            }
            dds.mipmapCount = 1;
            if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
                dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
            }
            dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
            dds.width = header[off_width];
            dds.height = header[off_height];
            dataOffset = header[off_size] + 4;
            width = dds.width;
            height = dds.height;
            faces = dds.isCubemap ? 6 : 1;
            for (var face = 0; face < faces; face++) {
                for (var i = 0; i < dds.mipmapCount; i++) {
                    var mipmap = null, byteArray = null, dataLength = null;
                    if (isRGBAUncompressed) {
                        byteArray = this._loadARGBMip(buffer, dataOffset, width, height);
                        dataLength = byteArray.length;
                    }
                    else {
                        dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                        byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                    }
                    mipmap = { "data": byteArray, "width": width, "height": height };
                    dds.mipmaps.addChild(mipmap);
                    dataOffset += dataLength;
                    width = Math.max(width * 0.5, 1);
                    height = Math.max(height * 0.5, 1);
                }
                width = dds.width;
                height = dds.height;
            }
            return dds;
        };
        DDSParser._fourCCToInt32 = function (value) {
            return value.charCodeAt(0) +
                (value.charCodeAt(1) << 8) +
                (value.charCodeAt(2) << 16) +
                (value.charCodeAt(3) << 24);
        };
        DDSParser._int32ToFourCC = function (value) {
            return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
        };
        DDSParser._loadARGBMip = function (buffer, dataOffset, width, height) {
            var dataLength = width * height * 4, srcBuffer = new Uint8Array(buffer, dataOffset, dataLength), byteArray = new Uint8Array(dataLength), dst = 0, src = 0;
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var b = null, g = null, r = null, a = null;
                    b = srcBuffer[src];
                    src++;
                    g = srcBuffer[src];
                    src++;
                    r = srcBuffer[src];
                    src++;
                    a = srcBuffer[src];
                    src++;
                    byteArray[dst] = r;
                    dst++;
                    byteArray[dst] = g;
                    dst++;
                    byteArray[dst] = b;
                    dst++;
                    byteArray[dst] = a;
                    dst++;
                }
            }
            return byteArray;
        };
        return DDSParser;
    }());
    wd.DDSParser = DDSParser;
    var DDSData = (function () {
        function DDSData() {
            this.mipmaps = wdCb.Collection.create();
            this.width = 0;
            this.height = 0;
            this.format = null;
            this.mipmapCount = 1;
            this.isCubemap = false;
        }
        return DDSData;
    }());
    wd.DDSData = DDSData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TextureAsset = (function () {
        function TextureAsset() {
            this._width = null;
            this._height = null;
            this.generateMipmaps = true;
            this.sourceRegionMethod = wd.ETextureSourceRegionMethod.CHANGE_TEXCOORDS_IN_GLSL;
            this.format = wd.ETextureFormat.RGBA;
            this.source = TextureAsset.defaultTexture;
            this.repeatRegion = wd.RectRegion.create(0, 0, 1, 1);
            this.sourceRegion = null;
            this.sourceRegionMapping = wd.ETextureSourceRegionMapping.CANVAS;
            this.packAlignment = 4;
            this.unpackAlignment = 4;
            this.flipY = true;
            this.premultiplyAlpha = false;
            this.isPremultipliedAlpha = null;
            this.colorspaceConversion = wd.DeviceManager.getInstance().gl.BROWSER_DEFAULT_WEBGL;
            this.wrapS = wd.ETextureWrapMode.CLAMP_TO_EDGE;
            this.wrapT = wd.ETextureWrapMode.CLAMP_TO_EDGE;
            this.magFilter = wd.ETextureFilterMode.LINEAR;
            this.minFilter = wd.ETextureFilterMode.LINEAR_MIPMAP_LINEAR;
            this.type = wd.ETextureType.UNSIGNED_BYTE;
            this.mipmaps = wdCb.Collection.create();
            this.anisotropy = 0;
            this.needUpdate = true;
        }
        Object.defineProperty(TextureAsset.prototype, "width", {
            get: function () {
                return this._width === null ? (this.source ? this.source.width : null) : this._width;
            },
            set: function (width) {
                this._width = width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextureAsset.prototype, "height", {
            get: function () {
                return this._height === null ? (this.source ? this.source.height : null) : this._height;
            },
            set: function (height) {
                this._height = height;
            },
            enumerable: true,
            configurable: true
        });
        TextureAsset.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        TextureAsset.prototype.cloneToCubemapTexture = function (cubemapTexture) {
            cubemapTexture.generateMipmaps = this.generateMipmaps;
            cubemapTexture.minFilter = this.minFilter;
            cubemapTexture.magFilter = this.magFilter;
            cubemapTexture.width = this.width;
            cubemapTexture.height = this.height;
            cubemapTexture.wrapS = this.wrapS;
            cubemapTexture.wrapT = this.wrapT;
            cubemapTexture.anisotropy = this.anisotropy;
            cubemapTexture.premultiplyAlpha = this.premultiplyAlpha;
            cubemapTexture.isPremultipliedAlpha = this.isPremultipliedAlpha;
            cubemapTexture.flipY = false;
            cubemapTexture.unpackAlignment = this.unpackAlignment;
            cubemapTexture.packAlignment = this.packAlignment;
            cubemapTexture.colorspaceConversion = this.colorspaceConversion;
            cubemapTexture.needUpdate = this.needUpdate;
            cubemapTexture.mode = wd.EEnvMapMode.BASIC;
        };
        TextureAsset.prototype.cloneTo = function (texture) {
            wd.Log.error(!texture, wd.Log.info.FUNC_MUST_DEFINE("texture"));
            texture.source = this.source;
            texture.width = this.width;
            texture.height = this.height;
            texture.mipmaps = this.mipmaps.clone();
            texture.wrapS = this.wrapS;
            texture.wrapT = this.wrapT;
            texture.magFilter = this.magFilter;
            texture.minFilter = this.minFilter;
            texture.anisotropy = this.anisotropy;
            texture.format = this.format;
            texture.type = this.type;
            texture.repeatRegion = this.repeatRegion.clone();
            texture.sourceRegion = this.sourceRegion && this.sourceRegion.clone();
            texture.sourceRegionMapping = this.sourceRegionMapping;
            texture.sourceRegionMethod = this.sourceRegionMethod;
            texture.generateMipmaps = this.generateMipmaps;
            texture.premultiplyAlpha = this.premultiplyAlpha;
            texture.isPremultipliedAlpha = this.isPremultipliedAlpha;
            texture.flipY = this.flipY;
            texture.unpackAlignment = this.unpackAlignment;
            texture.packAlignment = this.packAlignment;
            texture.colorspaceConversion = this.colorspaceConversion;
            texture.needUpdate = this.needUpdate;
            return texture;
        };
        TextureAsset.defaultTexture = null;
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TextureAsset.prototype, "source", void 0);
        return TextureAsset;
    }());
    wd.TextureAsset = TextureAsset;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ImageTextureAsset = (function (_super) {
        __extends(ImageTextureAsset, _super);
        function ImageTextureAsset(source) {
            _super.call(this);
            this.source = source;
        }
        ImageTextureAsset.create = function (source) {
            var obj = new this(source);
            return obj;
        };
        ImageTextureAsset.prototype.toTexture = function () {
            return wd.ImageTexture.create(this);
        };
        ImageTextureAsset.prototype.toCubemapFaceTexture = function () {
            return wd.CubemapFaceImageTexture.create(this);
        };
        ImageTextureAsset.prototype.cloneToCubemapFaceTexture = function (cubemapFaceTexture) {
            cubemapFaceTexture.source = this.source;
            cubemapFaceTexture.type = this.type;
            cubemapFaceTexture.format = this.format;
            cubemapFaceTexture.width = this.width;
            cubemapFaceTexture.height = this.height;
            cubemapFaceTexture.sourceRegion = this.sourceRegion;
            cubemapFaceTexture.sourceRegionMethod = wd.ETextureSourceRegionMethod.DRAW_IN_CANVAS;
        };
        return ImageTextureAsset;
    }(wd.TextureAsset));
    wd.ImageTextureAsset = ImageTextureAsset;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VideoTextureAsset = (function (_super) {
        __extends(VideoTextureAsset, _super);
        function VideoTextureAsset(video) {
            _super.call(this);
            this.video = null;
            this.video = video;
            this.source = this.video.source;
        }
        VideoTextureAsset.create = function (video) {
            var obj = new this(video);
            obj.initWhenCreate();
            return obj;
        };
        VideoTextureAsset.prototype.initWhenCreate = function () {
            this.width = 0;
            this.height = 0;
            this.generateMipmaps = false;
            this.minFilter = null;
            this.magFilter = null;
            this.sourceRegion = null;
            this.sourceRegionMethod = null;
        };
        VideoTextureAsset.prototype.toTexture = function () {
            return wd.VideoTexture.create(this);
        };
        VideoTextureAsset.prototype.toCubemapFaceTexture = function () {
            return wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("video texture", "cubemap"));
        };
        VideoTextureAsset.prototype.cloneToCubemapFaceTexture = function (cubemapFaceTexture) {
            wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("video texture", "cubemap"));
        };
        return VideoTextureAsset;
    }(wd.TextureAsset));
    wd.VideoTextureAsset = VideoTextureAsset;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CompressedTextureAsset = (function (_super) {
        __extends(CompressedTextureAsset, _super);
        function CompressedTextureAsset() {
            _super.apply(this, arguments);
        }
        CompressedTextureAsset.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        CompressedTextureAsset.prototype.initWhenCreate = function () {
            this.generateMipmaps = false;
            this.flipY = false;
        };
        CompressedTextureAsset.prototype.toTexture = function () {
            return wd.CompressedTexture.create(this);
        };
        CompressedTextureAsset.prototype.toCubemapFaceTexture = function () {
            return wd.CubemapFaceCompressedTexture.create(this);
        };
        CompressedTextureAsset.prototype.cloneToCubemapFaceTexture = function (cubemapFaceTexture) {
            cubemapFaceTexture.type = this.type;
            cubemapFaceTexture.format = this.format;
            cubemapFaceTexture.width = this.width;
            cubemapFaceTexture.height = this.height;
            cubemapFaceTexture.mipmaps = this.mipmaps;
            cubemapFaceTexture.minFilter = this.minFilter;
        };
        return CompressedTextureAsset;
    }(wd.TextureAsset));
    wd.CompressedTextureAsset = CompressedTextureAsset;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureFilterMode) {
        ETextureFilterMode[ETextureFilterMode["NEAREST"] = "NEAREST"] = "NEAREST";
        ETextureFilterMode[ETextureFilterMode["NEAREST_MIPMAP_MEAREST"] = "NEAREST_MIPMAP_MEAREST"] = "NEAREST_MIPMAP_MEAREST";
        ETextureFilterMode[ETextureFilterMode["NEAREST_MIPMAP_LINEAR"] = "NEAREST_MIPMAP_LINEAR"] = "NEAREST_MIPMAP_LINEAR";
        ETextureFilterMode[ETextureFilterMode["LINEAR"] = "LINEAR"] = "LINEAR";
        ETextureFilterMode[ETextureFilterMode["LINEAR_MIPMAP_NEAREST"] = "LINEAR_MIPMAP_NEAREST"] = "LINEAR_MIPMAP_NEAREST";
        ETextureFilterMode[ETextureFilterMode["LINEAR_MIPMAP_LINEAR"] = "LINEAR_MIPMAP_LINEAR"] = "LINEAR_MIPMAP_LINEAR";
    })(wd.ETextureFilterMode || (wd.ETextureFilterMode = {}));
    var ETextureFilterMode = wd.ETextureFilterMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureWrapMode) {
        ETextureWrapMode[ETextureWrapMode["REPEAT"] = "REPEAT"] = "REPEAT";
        ETextureWrapMode[ETextureWrapMode["MIRRORED_REPEAT"] = "MIRRORED_REPEAT"] = "MIRRORED_REPEAT";
        ETextureWrapMode[ETextureWrapMode["CLAMP_TO_EDGE"] = "CLAMP_TO_EDGE"] = "CLAMP_TO_EDGE";
    })(wd.ETextureWrapMode || (wd.ETextureWrapMode = {}));
    var ETextureWrapMode = wd.ETextureWrapMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureFormat) {
        ETextureFormat[ETextureFormat["RGB"] = "RGB"] = "RGB";
        ETextureFormat[ETextureFormat["RGBA"] = "RGBA"] = "RGBA";
        ETextureFormat[ETextureFormat["ALPHA"] = "ALPHA"] = "ALPHA";
        ETextureFormat[ETextureFormat["LUMINANCE"] = "LUMINANCE"] = "LUMINANCE";
        ETextureFormat[ETextureFormat["LUMINANCE_ALPHA"] = "LUMINANCE_ALPHA"] = "LUMINANCE_ALPHA";
        ETextureFormat[ETextureFormat["RGB_S3TC_DXT1"] = "RGB_S3TC_DXT1"] = "RGB_S3TC_DXT1";
        ETextureFormat[ETextureFormat["RGBA_S3TC_DXT1"] = "RGBA_S3TC_DXT1"] = "RGBA_S3TC_DXT1";
        ETextureFormat[ETextureFormat["RGBA_S3TC_DXT3"] = "RGBA_S3TC_DXT3"] = "RGBA_S3TC_DXT3";
        ETextureFormat[ETextureFormat["RGBA_S3TC_DXT5"] = "RGBA_S3TC_DXT5"] = "RGBA_S3TC_DXT5";
    })(wd.ETextureFormat || (wd.ETextureFormat = {}));
    var ETextureFormat = wd.ETextureFormat;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureType) {
        ETextureType[ETextureType["UNSIGNED_BYTE"] = "UNSIGNED_BYTE"] = "UNSIGNED_BYTE";
        ETextureType[ETextureType["UNSIGNED_SHORT_5_6_5"] = "UNSIGNED_SHORT_5_6_5"] = "UNSIGNED_SHORT_5_6_5";
        ETextureType[ETextureType["UNSIGNED_SHORT_4_4_4_4"] = "UNSIGNED_SHORT_4_4_4_4"] = "UNSIGNED_SHORT_4_4_4_4";
        ETextureType[ETextureType["UNSIGNED_SHORT_5_5_5_1"] = "UNSIGNED_SHORT_5_5_5_1"] = "UNSIGNED_SHORT_5_5_5_1";
    })(wd.ETextureType || (wd.ETextureType = {}));
    var ETextureType = wd.ETextureType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EEnvMapMode) {
        EEnvMapMode[EEnvMapMode["BASIC"] = 0] = "BASIC";
        EEnvMapMode[EEnvMapMode["REFLECTION"] = 1] = "REFLECTION";
        EEnvMapMode[EEnvMapMode["REFRACTION"] = 2] = "REFRACTION";
        EEnvMapMode[EEnvMapMode["FRESNEL"] = 3] = "FRESNEL";
    })(wd.EEnvMapMode || (wd.EEnvMapMode = {}));
    var EEnvMapMode = wd.EEnvMapMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureCombineMode) {
        ETextureCombineMode[ETextureCombineMode["MIX"] = 0] = "MIX";
        ETextureCombineMode[ETextureCombineMode["MULTIPLY"] = 1] = "MULTIPLY";
        ETextureCombineMode[ETextureCombineMode["ADD"] = 2] = "ADD";
    })(wd.ETextureCombineMode || (wd.ETextureCombineMode = {}));
    var ETextureCombineMode = wd.ETextureCombineMode;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureSourceRegionMapping) {
        ETextureSourceRegionMapping[ETextureSourceRegionMapping["CANVAS"] = 0] = "CANVAS";
        ETextureSourceRegionMapping[ETextureSourceRegionMapping["UV"] = 1] = "UV";
    })(wd.ETextureSourceRegionMapping || (wd.ETextureSourceRegionMapping = {}));
    var ETextureSourceRegionMapping = wd.ETextureSourceRegionMapping;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureSourceRegionMethod) {
        ETextureSourceRegionMethod[ETextureSourceRegionMethod["CHANGE_TEXCOORDS_IN_GLSL"] = 0] = "CHANGE_TEXCOORDS_IN_GLSL";
        ETextureSourceRegionMethod[ETextureSourceRegionMethod["DRAW_IN_CANVAS"] = 1] = "DRAW_IN_CANVAS";
    })(wd.ETextureSourceRegionMethod || (wd.ETextureSourceRegionMethod = {}));
    var ETextureSourceRegionMethod = wd.ETextureSourceRegionMethod;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ETextureTarget) {
        ETextureTarget[ETextureTarget["TEXTURE_2D"] = "TEXTURE_2D"] = "TEXTURE_2D";
        ETextureTarget[ETextureTarget["TEXTURE_CUBE_MAP"] = "TEXTURE_CUBE_MAP"] = "TEXTURE_CUBE_MAP";
    })(wd.ETextureTarget || (wd.ETextureTarget = {}));
    var ETextureTarget = wd.ETextureTarget;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LoaderManager = (function () {
        function LoaderManager() {
            this.assetCount = 0;
            this.currentLoadedCount = 0;
            this._assetTable = wdCb.Hash.create();
        }
        LoaderManager.getInstance = function () { };
        LoaderManager.prototype.load = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var self = this;
            if (wd.JudgeUtils.isString(args[0])) {
                var url = args[0], id = url;
                return this._createLoadSingleAssetStream(url, id, self._getConfig(null));
            }
            else {
                var self_7 = this, assetArr = args[0];
                return wdFrp.fromArray(assetArr).concatMap(function (asset) {
                    return self_7._createLoadMultiAssetStream(asset.type || wd.EAssetType.UNKNOW, asset.url, asset.id, self_7._getConfig(asset.config));
                });
            }
        };
        LoaderManager.prototype.reset = function () {
            this.assetCount = 0;
            this.currentLoadedCount = 0;
        };
        LoaderManager.prototype.dispose = function () {
            this.reset();
            wd.LoaderFactory.createAllLoader().forEach(function (loader) {
                loader.dispose();
            });
        };
        LoaderManager.prototype.get = function (id) {
            var loader = this._assetTable.getChild(id);
            return loader ? loader.get(id) : null;
        };
        LoaderManager.prototype.add = function (id, loader) {
            this._assetTable.addChild(id, loader);
        };
        LoaderManager.prototype._createLoadMultiAssetStream = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var type = args[0], url = args[1], id = args[2], config = args[3], loader = this._getLoader(type, url), stream = null, self = this;
            if (!loader.has(id)) {
                self.assetCount++;
            }
            return loader.load(url, id, config)
                .map(function () {
                self.currentLoadedCount++;
                return {
                    currentLoadedCount: self.currentLoadedCount,
                    assetCount: self.assetCount
                };
            });
        };
        LoaderManager.prototype._createLoadSingleAssetStream = function (url, id, config) {
            var loader = this._getLoader(wd.EAssetType.UNKNOW, url);
            return loader.load(url, id, config);
        };
        LoaderManager.prototype._getLoader = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var type = args[0], extname = null;
            if (wd.JudgeUtils.isArrayExactly(args[1])) {
                extname = wdCb.PathUtils.extname(args[1][0]);
            }
            else {
                extname = wdCb.PathUtils.extname(args[1]);
            }
            return wd.LoaderFactory.create(type, extname.toLowerCase());
        };
        LoaderManager.prototype._getConfig = function (config) {
            var defaultConfig = {
                isCrossOrigin: false
            };
            if (config === null) {
                return defaultConfig;
            }
            return wdCb.ExtendUtils.extend(defaultConfig, config);
        };
        LoaderManager = __decorate([
            wd.singleton()
        ], LoaderManager);
        return LoaderManager;
    }());
    wd.LoaderManager = LoaderManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LoaderFactory = (function () {
        function LoaderFactory() {
        }
        LoaderFactory.create = function (type, extname) {
            var loader = null;
            switch (type) {
                case wd.EAssetType.SCRIPT:
                    loader = wd.ScriptLoader.getInstance();
                    break;
                case wd.EAssetType.FONT:
                    loader = wd.FontLoader.getInstance();
                    break;
                case wd.EAssetType.UNKNOW:
                    loader = this._getLoaderByExtname(extname);
                    break;
                default:
                    wdCb.Log.error(true, wdCb.Log.info.FUNC_UNKNOW("asset type:" + type));
                    break;
            }
            return loader;
        };
        LoaderFactory.createAllLoader = function () {
            var loaderList = wdCb.Collection.create([wd.JsLoader.getInstance(), wd.GLSLLoader.getInstance(), wd.WDLoader.getInstance(), wd.TextureLoader.getInstance(), wd.FontLoader.getInstance(), wd.FntLoader.getInstance()]), soundLoader = this._getLoader("SoundLoader"), videoLoader = this._getLoader("VideoLoader");
            if (soundLoader !== null) {
                loaderList.addChild(soundLoader);
            }
            if (videoLoader !== null) {
                loaderList.addChild(videoLoader);
            }
            return loaderList;
        };
        LoaderFactory._getLoaderByExtname = function (extname) {
            var loader = null;
            switch (extname) {
                case ".json":
                    loader = wd.JSONLoader.getInstance();
                    break;
                case ".js":
                    loader = wd.JsLoader.getInstance();
                    break;
                case ".glsl":
                    loader = wd.GLSLLoader.getInstance();
                    break;
                case ".jpg":
                case ".jpeg":
                case ".png":
                case ".dds":
                case ".gif":
                case ".bmp":
                    loader = wd.TextureLoader.getInstance();
                    break;
                case ".mp4":
                case ".ogv":
                case ".webm":
                    loader = this._getLoader("VideoLoader", extname);
                    break;
                case ".ogg":
                case ".mp3":
                case ".wav":
                    loader = this._getLoader("SoundLoader", extname);
                    break;
                case ".wd":
                    loader = wd.WDLoader.getInstance();
                    break;
                case ".eot":
                case ".ttf":
                case ".woff":
                case ".svg":
                    loader = wd.FontLoader.getInstance();
                    break;
                case ".fnt":
                    loader = wd.FntLoader.getInstance();
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNKNOW("extname:" + extname));
                    break;
            }
            return loader;
        };
        LoaderFactory._getLoader = function (className, extname) {
            var _class = wd.ClassUtils.getClass(className);
            if (_class === void 0) {
                if (!!extname) {
                    wd.Log.error(true, wd.Log.info.FUNC_UNKNOW("extname:" + extname));
                }
                return null;
            }
            return _class.getInstance();
        };
        return LoaderFactory;
    }());
    wd.LoaderFactory = LoaderFactory;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EKeyFrameInterpolation) {
        EKeyFrameInterpolation[EKeyFrameInterpolation["LINEAR"] = "LINEAR"] = "LINEAR";
        EKeyFrameInterpolation[EKeyFrameInterpolation["SWITCH"] = "SWITCH"] = "SWITCH";
    })(wd.EKeyFrameInterpolation || (wd.EKeyFrameInterpolation = {}));
    var EKeyFrameInterpolation = wd.EKeyFrameInterpolation;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EKeyFrameAnimationTarget) {
        EKeyFrameAnimationTarget[EKeyFrameAnimationTarget["TRANSLATION"] = "position"] = "TRANSLATION";
        EKeyFrameAnimationTarget[EKeyFrameAnimationTarget["ROTATION"] = "rotation"] = "ROTATION";
        EKeyFrameAnimationTarget[EKeyFrameAnimationTarget["SCALE"] = "scale"] = "SCALE";
        EKeyFrameAnimationTarget[EKeyFrameAnimationTarget["TEXTURE_OFFSET"] = "TEXTURE_OFFSET"] = "TEXTURE_OFFSET";
    })(wd.EKeyFrameAnimationTarget || (wd.EKeyFrameAnimationTarget = {}));
    var EKeyFrameAnimationTarget = wd.EKeyFrameAnimationTarget;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EWDTag) {
        EWDTag[EWDTag["CONTAINER"] = "CONTAINER"] = "CONTAINER";
    })(wd.EWDTag || (wd.EWDTag = {}));
    var EWDTag = wd.EWDTag;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EWDKeyFrameAnimationPath) {
        EWDKeyFrameAnimationPath[EWDKeyFrameAnimationPath["TRANSLATION"] = "translation"] = "TRANSLATION";
        EWDKeyFrameAnimationPath[EWDKeyFrameAnimationPath["ROTATION"] = "rotation"] = "ROTATION";
        EWDKeyFrameAnimationPath[EWDKeyFrameAnimationPath["SCALE"] = "scale"] = "SCALE";
    })(wd.EWDKeyFrameAnimationPath || (wd.EWDKeyFrameAnimationPath = {}));
    var EWDKeyFrameAnimationPath = wd.EWDKeyFrameAnimationPath;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDLoader = (function (_super) {
        __extends(WDLoader, _super);
        function WDLoader() {
            _super.call(this);
            this._arrayBufferMap = wdCb.Hash.create();
            this._imageMap = wdCb.Hash.create();
        }
        WDLoader.getInstance = function () { };
        WDLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var url = args[0], config = args[2], self = this, jsonData = null;
            return wd.AjaxLoader.load(url, "json")
                .flatMap(function (json) {
                jsonData = json;
                return self._createLoadAllAssetsStream(url, config, json);
            })
                .lastOrDefault()
                .map(function () {
                return wd.WDAssembler.create().build(wd.WDParser.create().parse(jsonData, self._arrayBufferMap, self._imageMap));
            });
        };
        WDLoader.prototype._createLoadAllAssetsStream = function (url, config, json) {
            return wdFrp.fromArray([
                this._createLoadBuffersStream(url, json),
                this._createLoadImageAssetStream(url, config, json)
            ])
                .mergeAll();
        };
        WDLoader.prototype._createLoadBuffersStream = function (filePath, json) {
            var arrayBufferMap = this._arrayBufferMap;
            return this._createLoadAssetStream(filePath, json, json.buffers, function (id, uri) {
                arrayBufferMap.addChild(id, wd.WDUtils.decodeArrayBuffer(uri));
            }, function (id, url) {
                return wd.AjaxLoader.load(url, "arraybuffer")
                    .do(function (buffer) {
                    wd.Log.error(!(buffer instanceof ArrayBuffer), wd.Log.info.FUNC_SHOULD("Buffer:" + id, "be an array buffer"));
                    wd.Log.error(buffer.byteLength !== buffer.byteLength, wd.Log.info.FUNC_SHOULD("Buffer:" + id + "'s length is " + buffer.byteLength + ", but it", "be " + buffer.byteLength));
                    arrayBufferMap.addChild(id, buffer);
                });
            });
        };
        WDLoader.prototype._createLoadImageAssetStream = function (filePath, config, json) {
            var imageMap = this._imageMap;
            return this._createLoadAssetStream(filePath, json, json.images, function (id, uri) {
                imageMap.addChild(id, wd.Base64Utils.createImageFromBase64(uri));
            }, function (id, url) {
                return wd.TextureLoader.getInstance().load(url, id, config)
                    .do(function (asset) {
                    imageMap.addChild(id, asset.source);
                });
            });
        };
        WDLoader.prototype._createLoadAssetStream = function (filePath, json, datas, addBase64AssetFunc, loadStreamFunc) {
            var streamArr = [];
            if (datas) {
                var id = null;
                for (id in datas) {
                    if (datas.hasOwnProperty(id)) {
                        var data = datas[id];
                        if (wd.WDUtils.isBase64(data.uri)) {
                            addBase64AssetFunc(id, data.uri);
                        }
                        else {
                            var url = wd.ModelLoaderUtils.getPath(filePath, data.uri);
                            streamArr.push(loadStreamFunc(id, url));
                        }
                    }
                }
            }
            return wdFrp.fromArray(streamArr).mergeAll();
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.assert(!wd.JudgeUtils.isArrayExactly(args[0]), wd.Log.info.FUNC_MUST_BE("url", "string"));
            })
        ], WDLoader.prototype, "loadAsset", null);
        WDLoader = __decorate([
            wd.singleton()
        ], WDLoader);
        return WDLoader;
    }(wd.Loader));
    wd.WDLoader = WDLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDParser = (function () {
        function WDParser() {
            this._data = {};
            this._arrayBufferMap = null;
            this._imageMap = null;
            this._json = null;
            this._geometryParser = wd.WDGeometryParser.create();
            this._keyFrameAnimationParser = wd.WDKeyFrameAnimationParser.create();
            this._skinSkeletonAnimationAnimationParser = wd.WDSkinSkeletonAnimationParser.create();
            this._articulatedAnimationParser = wd.WDArticulatedAnimationParser.create();
            this._transformParser = wd.WDTransformParser.create();
            this._skinSkeletonAnimationParser = wd.WDSkinSkeletonParser.create();
            this._cameraParser = wd.WDCameraParser.create();
            this._lightParser = wd.WDLightParser.create();
            this._skinSkeletonAnimationMap = wdCb.Hash.create();
        }
        WDParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDParser.prototype.parse = function (json, arrayBufferMap, imageMap) {
            var _this = this;
            this._json = json;
            this._arrayBufferMap = arrayBufferMap;
            this._imageMap = imageMap;
            if (json.asset) {
                this._parseMetadata();
            }
            this._parseObjects();
            if (json.animations) {
                var _a = this._keyFrameAnimationParser.parse(json, this._data.objects, this._arrayBufferMap), nodeWithAnimationMap_1 = _a.nodeWithAnimationMap, objectWithAnimationMap = _a.objectWithAnimationMap;
                this._skinSkeletonAnimationMap.forEach(function (skinSkeletonAnimation) {
                    skinSkeletonAnimation.jointTransformData = _this._skinSkeletonAnimationAnimationParser.parse(json, nodeWithAnimationMap_1, skinSkeletonAnimation.jointNames);
                });
                this._articulatedAnimationParser.parse(objectWithAnimationMap);
            }
            return this._data;
        };
        WDParser.prototype._parseMetadata = function () {
            var metadata = {}, json = this._json;
            for (var i in json.asset) {
                if (json.asset.hasOwnProperty(i)) {
                    metadata[i] = json.asset[i];
                }
            }
            this._data.metadata = metadata;
        };
        WDParser.prototype._parseObjects = function () {
            var _this = this;
            var self = this, json = this._json, objects = wdCb.Collection.create();
            var parse = function (nodeId, node) {
                var object = null;
                if (_this._isJointNode(json, node)) {
                    return null;
                }
                object = wd.WDUtils.createObjectData();
                object.id = nodeId;
                if (node.name) {
                    object.name = node.name;
                }
                if (node.mesh) {
                    var mesh = null;
                    mesh = json.meshes[node.mesh];
                    if (!node.name && mesh.name) {
                        object.name = mesh.name;
                    }
                    self._geometryParser.parse(json, object, mesh, self._arrayBufferMap, self._imageMap);
                }
                if (node.light) {
                    object.components.addChild(self._lightParser.parse(json, node.light));
                }
                if (node.camera) {
                    object.components.addChild((self._cameraParser.parse(json, node.camera)));
                }
                if (node.matrix) {
                    object.components.addChild(self._transformParser.parse(node.matrix));
                }
                else if (node.rotation && node.scale && node.translation) {
                    object.components.addChild(self._transformParser.parse(node.translation, node.rotation, node.scale));
                }
                if (node.skin && node.skeletons) {
                    var skinSkeletonAnimation = self._skinSkeletonAnimationParser.parse(json, node.skin, node.skeletons, object.name, self._arrayBufferMap);
                    self._skinSkeletonAnimationMap.addChild(nodeId, skinSkeletonAnimation);
                    object.components.addChild(skinSkeletonAnimation);
                }
                if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var childId = _a[_i];
                        var child = parse(childId, json.nodes[childId]);
                        if (child !== null) {
                            object.children.addChild(child);
                        }
                    }
                }
                return object;
            };
            if (!json.scenes[json.scene]) {
                this._data.objects = objects;
                return;
            }
            for (var _i = 0, _a = json.scenes[json.scene].nodes; _i < _a.length; _i++) {
                var nodeId = _a[_i];
                var child = parse(nodeId, json.nodes[nodeId]);
                if (child !== null) {
                    objects.addChild(child);
                }
            }
            this._data.objects = objects;
        };
        WDParser.prototype._isJointNode = function (json, node) {
            return !!node.jointName
                || (!!node.children && node.children.length > 0 && !!json.nodes[node.children[0]].jointName);
        };
        return WDParser;
    }());
    wd.WDParser = WDParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDComponentParser = (function () {
        function WDComponentParser() {
        }
        return WDComponentParser;
    }());
    wd.WDComponentParser = WDComponentParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDGeometryParser = (function (_super) {
        __extends(WDGeometryParser, _super);
        function WDGeometryParser() {
            _super.apply(this, arguments);
            this._isGeneratedFromGLTF = false;
            this._arrayBufferMap = null;
            this._imageMap = null;
            this._json = null;
            this._materialParser = wd.WDMaterialParser.create();
        }
        WDGeometryParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDGeometryParser.prototype.parse = function (json, object, mesh, arrayBufferMap, imageMap) {
            this._json = json;
            this._arrayBufferMap = arrayBufferMap;
            this._imageMap = imageMap;
            if (json.asset && json.asset.generator && json.asset.generator.indexOf("GLTF") > -1) {
                this._isGeneratedFromGLTF = true;
            }
            if (mesh.primitives.length > 1) {
                for (var _i = 0, _a = mesh.primitives; _i < _a.length; _i++) {
                    var primitive = _a[_i];
                    var childObject = wd.WDUtils.createObjectData();
                    this._setChildObjectNameWithMultiPrimitives(childObject, primitive);
                    childObject.components.addChild(this._parseGeometry(primitive));
                    object.children.addChild(childObject);
                }
                object.isContainer = true;
            }
            else if (mesh.primitives.length === 1) {
                object.components.addChild(this._parseGeometry(mesh.primitives[0]));
            }
            else {
            }
        };
        WDGeometryParser.prototype._setChildObjectNameWithMultiPrimitives = function (object, primitive) {
            if (!!primitive.name) {
                object.name = primitive.name;
            }
            else if (!!primitive.material) {
                object.name = primitive.material;
            }
        };
        WDGeometryParser.prototype._parseGeometry = function (primitive) {
            var json = this._json, arrayBufferMap = this._arrayBufferMap, bufferReader = null, geometry = {}, vertices = null, texCoords = null, colors = null, joints = null, weights = null, normals = null, faces = null, morphVertices = null, morphNormals = null;
            for (var semantic in primitive.attributes) {
                if (primitive.attributes.hasOwnProperty(semantic)) {
                    var attribute = primitive.attributes[semantic], accessor = json.accessors[attribute], _a = wd.WDUtils.getBufferReaderFromAccessor(json, accessor, arrayBufferMap), bufferReader_1 = _a.bufferReader, count = _a.count;
                    if (semantic === "POSITION") {
                        vertices = [];
                        this._addAttributeData(vertices, bufferReader_1, count);
                    }
                    else if (semantic === "TEXCOORD") {
                        texCoords = [];
                        this._addAttributeData(texCoords, bufferReader_1, count);
                        if (this._isGeneratedFromGLTF) {
                            this._normalizeTexCoords(texCoords);
                        }
                    }
                    else if (semantic === "NORMAL") {
                        normals = [];
                        this._addAttributeData(normals, bufferReader_1, count);
                    }
                    else if (semantic === "COLOR") {
                        colors = [];
                        this._addAttributeData(colors, bufferReader_1, count);
                    }
                    else if (semantic === "JOINT") {
                        joints = [];
                        this._addAttributeData(joints, bufferReader_1, count);
                    }
                    else if (semantic === "WEIGHT") {
                        weights = [];
                        this._addWeightAttributeData(weights, bufferReader_1, count);
                    }
                }
            }
            faces = this._getFaces(json, primitive.indices, normals);
            if (primitive.morphTargets !== void 0) {
                var data = wd.WDMorphDataParseUtils.parseMorphData(json, primitive.morphTargets, this._arrayBufferMap);
                morphVertices = data.morphVertices;
                morphNormals = data.morphNormals;
            }
            wd.WDUtils.addData(geometry, "vertices", vertices);
            wd.WDUtils.addData(geometry, "colors", colors);
            wd.WDUtils.addData(geometry, "jointIndices", joints);
            wd.WDUtils.addData(geometry, "jointWeights", weights);
            wd.WDUtils.addData(geometry, "texCoords", texCoords);
            wd.WDUtils.addData(geometry, "faces", faces);
            wd.WDUtils.addData(geometry, "morphVertices", morphVertices);
            wd.WDUtils.addData(geometry, "morphNormals", morphNormals);
            wd.WDUtils.addData(geometry, "drawMode", this._parseDrawMode(primitive.mode));
            geometry.material = this._materialParser.parse(json, primitive.material, this._imageMap);
            return geometry;
        };
        WDGeometryParser.prototype._addAttributeData = function (geometryData, bufferReader, count) {
            for (var i = 0; i < count; i++) {
                geometryData.push(bufferReader.readFloat());
            }
        };
        WDGeometryParser.prototype._addWeightAttributeData = function (geometryData, bufferReader, count) {
            for (var i = 0; i < count; i += 4) {
                var vec4 = wd.Vector4.create(bufferReader.readFloat(), bufferReader.readFloat(), bufferReader.readFloat(), bufferReader.readFloat()), scale = 1.0 / vec4.lengthManhattan();
                if (scale !== Infinity) {
                    vec4.multiplyScalar(scale);
                }
                else {
                    vec4.set(1, 0, 0, 0);
                }
                geometryData.push(vec4.x, vec4.y, vec4.z, vec4.w);
            }
        };
        WDGeometryParser.prototype._getFaces = function (json, indices, normals) {
            var accessor = null, face = null, faces = [];
            if (!indices) {
                return [];
            }
            accessor = json.accessors[indices];
            var _a = wd.WDUtils.getBufferReaderFromAccessor(json, accessor, this._arrayBufferMap), bufferReader = _a.bufferReader, count = _a.count;
            for (var i = 0, len = count; i < len; i += 3) {
                var aIndex = bufferReader.readUInt16(), bIndex = bufferReader.readUInt16(), cIndex = bufferReader.readUInt16(), verticeIndiceArr = [aIndex, bIndex, cIndex];
                face = wd.Face3.create(aIndex, bIndex, cIndex);
                if (wd.GeometryUtils.hasData(normals)) {
                    this._addNormalData(face.vertexNormals, normals, verticeIndiceArr);
                }
                faces.push(face);
            }
            return faces;
        };
        WDGeometryParser.prototype._addNormalData = function (targetNormals, sourceNormals, normalIndiceArr) {
            var aIndex = normalIndiceArr[0], bIndex = normalIndiceArr[1], cIndex = normalIndiceArr[2];
            targetNormals.addChildren([
                this._getThreeComponentData(sourceNormals, aIndex),
                this._getThreeComponentData(sourceNormals, bIndex),
                this._getThreeComponentData(sourceNormals, cIndex)
            ]);
        };
        WDGeometryParser.prototype._getThreeComponentData = function (sourceData, index) {
            var startIndex = 3 * index;
            return wd.Vector3.create(sourceData[startIndex], sourceData[startIndex + 1], sourceData[startIndex + 2]);
        };
        WDGeometryParser.prototype._parseDrawMode = function (mode) {
            var drawMode = null;
            if (!mode) {
                return wd.EDrawMode.TRIANGLES;
            }
            switch (mode) {
                case 0:
                    drawMode = wd.EDrawMode.POINTS;
                    break;
                case 1:
                    drawMode = wd.EDrawMode.LINES;
                    break;
                case 2:
                    drawMode = wd.EDrawMode.LINE_LOOP;
                    break;
                case 3:
                    drawMode = wd.EDrawMode.LINE_STRIP;
                    break;
                case 4:
                    drawMode = wd.EDrawMode.TRIANGLES;
                    break;
                case 5:
                    drawMode = wd.EDrawMode.TRIANGLE_STRIP;
                    break;
                case 6:
                    drawMode = wd.EDrawMode.TRANGLE_FAN;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("mode:" + mode));
                    break;
            }
            return drawMode;
        };
        WDGeometryParser.prototype._normalizeTexCoords = function (texCoords) {
            if (!texCoords) {
                return;
            }
            for (var i = 0, len = texCoords.length / 2; i < len; i++) {
                texCoords[i * 2 + 1] = 1.0 - texCoords[i * 2 + 1];
            }
        };
        __decorate([
            wd.require(function (geometryData, bufferReader, count) {
                wd.it("count should 4 times", function () {
                    wd.expect(count % 4).equals(0);
                });
            })
        ], WDGeometryParser.prototype, "_addWeightAttributeData", null);
        __decorate([
            wd.require(function (json, indices, normals) {
                var _this = this;
                if (indices) {
                    wd.it("indices' count should be 3 times", function () {
                        var accessor = json.accessors[indices], _a = wd.WDUtils.getBufferReaderFromAccessor(json, accessor, _this._arrayBufferMap), bufferReader = _a.bufferReader, count = _a.count;
                        wd.expect(count % 3).equal(0);
                    }, this);
                }
            })
        ], WDGeometryParser.prototype, "_getFaces", null);
        return WDGeometryParser;
    }(wd.WDComponentParser));
    wd.WDGeometryParser = WDGeometryParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDTransformParser = (function (_super) {
        __extends(WDTransformParser, _super);
        function WDTransformParser() {
            _super.apply(this, arguments);
        }
        WDTransformParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDTransformParser.prototype.parse = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var transform = {};
            if (args.length === 1) {
                var matrix = args[0];
                transform.matrix = wd.Matrix4.create(new Float32Array(matrix));
            }
            else if (args.length === 3) {
                var translation = args[0], rotation = args[1], scale = args[2];
                transform.position = wd.Vector3.create(translation[0], translation[1], translation[2]);
                transform.rotation = wd.Quaternion.create(rotation[0], rotation[1], rotation[2], rotation[3]);
                transform.scale = wd.Vector3.create(scale[0], scale[1], scale[2]);
            }
            return transform;
        };
        return WDTransformParser;
    }(wd.WDComponentParser));
    wd.WDTransformParser = WDTransformParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDCameraParser = (function (_super) {
        __extends(WDCameraParser, _super);
        function WDCameraParser() {
            _super.apply(this, arguments);
        }
        WDCameraParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDCameraParser.prototype.parse = function (json, cameraId) {
            var cameraData = json.cameras[cameraId], camera = {};
            this._parseCameraDataByType(camera, cameraData);
            return camera;
        };
        WDCameraParser.prototype._parseCameraDataByType = function (camera, cameraData) {
            var cameraComponent = null, type = cameraData.type, data = cameraData[type];
            switch (type) {
                case "perspective":
                    data = cameraData[type];
                    cameraComponent = wd.PerspectiveCamera.create();
                    cameraComponent.near = data.znear;
                    cameraComponent.far = data.zfar;
                    if (data.aspectRatio) {
                        cameraComponent.aspect = data.aspectRatio;
                    }
                    else {
                        var view = wd.DeviceManager.getInstance().view;
                        cameraComponent.aspect = view.width / view.height;
                    }
                    cameraComponent.fovy = wd.AngleUtils.convertRadiansToDegree(data.yfov);
                    camera.camera = cameraComponent;
                    break;
                case "orthographic":
                    cameraComponent = wd.OrthographicCamera.create();
                    cameraComponent.near = data.znear;
                    cameraComponent.far = data.zfar;
                    cameraComponent.left = -data.xmag;
                    cameraComponent.right = data.xmag;
                    cameraComponent.top = data.ymag;
                    cameraComponent.bottom = -data.ymag;
                    camera.camera = cameraComponent;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("camera type:" + type));
                    break;
            }
        };
        __decorate([
            wd.require(function (json, cameraId) {
                wd.it("should exist corresponding camera data", function () {
                    var cameras = json.cameras;
                    wd.expect(cameras).exist;
                    wd.expect(cameras[cameraId]).exist;
                }, this);
            })
        ], WDCameraParser.prototype, "parse", null);
        return WDCameraParser;
    }(wd.WDComponentParser));
    wd.WDCameraParser = WDCameraParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDLightParser = (function (_super) {
        __extends(WDLightParser, _super);
        function WDLightParser() {
            _super.apply(this, arguments);
        }
        WDLightParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDLightParser.prototype.parse = function (json, lightId) {
            var lightData = json.lights[lightId], light = {};
            wd.WDUtils.addData(light, "type", lightData.type);
            this._parseLightDataByType(light, lightData, light.type);
            return light;
        };
        WDLightParser.prototype._parseLightDataByType = function (light, lightData, type) {
            var data = lightData[type];
            wd.WDUtils.addData(light, "intensity", data.intensity);
            switch (type) {
                case "ambient":
                case "directional":
                    light.color = wd.WDUtils.getColor(data.color);
                    break;
                case "point":
                    light.color = wd.WDUtils.getColor(data.color);
                    wd.WDUtils.addData(light, "range", data.range);
                    wd.WDUtils.addData(light, "constantAttenuation", data.constantAttenuation);
                    wd.WDUtils.addData(light, "linearAttenuation", data.linearAttenuation);
                    wd.WDUtils.addData(light, "quadraticAttenuation", data.quadraticAttenuation);
                    break;
                default:
                    break;
            }
        };
        __decorate([
            wd.require(function (json, lightId) {
                wd.it("should exist corresponding light data", function () {
                    var lights = json.lights;
                    wd.expect(lights).exist;
                    wd.expect(lights[lightId]).exist;
                }, this);
            })
        ], WDLightParser.prototype, "parse", null);
        return WDLightParser;
    }(wd.WDComponentParser));
    wd.WDLightParser = WDLightParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDMaterialParser = (function () {
        function WDMaterialParser() {
            this._imageMap = null;
            this._json = null;
            this._glTextureMap = wdCb.Hash.create();
            this._textureParser = wd.WDTextureParser.create();
        }
        WDMaterialParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDMaterialParser.prototype.parse = function (json, materialId, imageMap) {
            var materialData = null;
            if (!materialId) {
                return this._getDefaultMaterialData();
            }
            this._json = json;
            this._imageMap = imageMap;
            this._textureParser.json = this._json;
            this._textureParser.imageMap = this._imageMap;
            this._textureParser.glTextureMap = this._glTextureMap;
            var material = {};
            materialData = json.materials[materialId];
            wd.WDUtils.addData(material, "doubleSided", materialData.doubleSided);
            wd.WDUtils.addData(material, "transparent", Boolean(materialData.transparent));
            material.type = this._getMaterialType(materialData.technique);
            material.lightModel = this._getLightModel(materialData.technique);
            this._addMaterialValues(material, materialData.values);
            return material;
        };
        WDMaterialParser.prototype._getDefaultMaterialData = function () {
            return {
                type: "LightMaterial",
                lightModel: wd.ELightModel.PHONG
            };
        };
        WDMaterialParser.prototype._getMaterialType = function (technique) {
            var type = null;
            switch (technique) {
                case "PHONG":
                case "BLINN":
                case "CONSTANT":
                case "LAMBERT":
                    type = "LightMaterial";
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("technique:" + technique));
                    break;
            }
            return type;
        };
        WDMaterialParser.prototype._getLightModel = function (technique) {
            var model = null;
            switch (technique) {
                case "PHONG":
                    model = wd.ELightModel.PHONG;
                    break;
                case "BLINN":
                    model = wd.ELightModel.BLINN;
                    break;
                case "CONSTANT":
                    model = wd.ELightModel.CONSTANT;
                    break;
                case "LAMBERT":
                    model = wd.ELightModel.LAMBERT;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("technique:" + technique));
                    break;
            }
            return model;
        };
        WDMaterialParser.prototype._addMaterialValues = function (material, values) {
            if (!values) {
                return;
            }
            this._addMaterialLightColor(material, "diffuse", values.diffuse);
            this._addMaterialLightColor(material, "specular", values.specular);
            this._addMaterialLightColor(material, "emission", values.emission);
            this._addMaterialLightColor(material, "reflective", values.ambient, "reflectionMap");
            this._addMaterialLightMap(material, "lightMap", values.lightMap);
            this._addMaterialLightMap(material, "normalMap", values.normalMap);
            wd.WDUtils.addData(material, "opacity", values.transparency);
            if (!!values.shininess) {
                material.shininess = values.shininess;
            }
        };
        WDMaterialParser.prototype._addMaterialLightColor = function (material, colorName, colorData, mapName) {
            if (!colorData) {
                return;
            }
            if (wd.JudgeUtils.isArrayExactly(colorData)) {
                material[(colorName + "Color")] = wd.WDUtils.getColor(colorData);
            }
            else {
                mapName = !!mapName ? mapName : colorName + "Map";
                material[mapName] = this._textureParser.getTexture(colorData);
            }
        };
        WDMaterialParser.prototype._addMaterialLightMap = function (material, mapName, mapId) {
            if (!mapId) {
                return;
            }
            material[mapName] = this._textureParser.getTexture(mapId);
        };
        return WDMaterialParser;
    }());
    wd.WDMaterialParser = WDMaterialParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDTextureParser = (function () {
        function WDTextureParser() {
            this.imageMap = null;
            this.json = null;
            this.glTextureMap = wdCb.Hash.create();
        }
        WDTextureParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDTextureParser.prototype.getTexture = function (textureDataId) {
            var textureData = null, asset = null;
            if (!this.json.textures || !this.json.textures[textureDataId]) {
                return null;
            }
            textureData = this.json.textures[textureDataId];
            asset = this._createTextureAsset(textureData.target, textureData.source);
            if (!!textureData.format) {
                asset.format = this._getTextureFormat(textureData.format);
                if (!!textureData.internalFormat) {
                    if (textureData.internalFormat !== textureData.format) {
                        wd.Log.warn("textureData.internalFormat(" + textureData.internalFormat + ") !== textureData.format(" + textureData.format + "), here take textureData.format value as their value");
                    }
                }
            }
            if (!!textureData.type) {
                asset.type = this._getTextureType(textureData.type);
            }
            this._addTextureSampler(asset, textureData.sampler);
            var glTexture = this._getGLTexture(asset, textureData.source), texture = asset.toTexture();
            if (glTexture !== null) {
                texture.glTexture = glTexture;
            }
            return texture;
        };
        WDTextureParser.prototype._getGLTexture = function (asset, sourceId) {
            var key = this._buildGLTextureMapKey(asset, sourceId), glTexture = null;
            if (this.glTextureMap.hasChild(key)) {
                return this.glTextureMap.getChild(key);
            }
            glTexture = wd.DeviceManager.getInstance().gl.createTexture();
            this.glTextureMap.addChild(key, glTexture);
            return glTexture;
        };
        WDTextureParser.prototype._buildGLTextureMapKey = function (asset, sourceId) {
            var isPremultipliedAlpha = asset.isPremultipliedAlpha !== null ? asset.isPremultipliedAlpha : false;
            return sourceId + "_" + isPremultipliedAlpha + "_" + asset.wrapS + "_" + asset.wrapT + "_" + asset.magFilter + "_" + asset.minFilter;
        };
        WDTextureParser.prototype._createTextureAsset = function (target, imageId) {
            var asset = null, source = this.imageMap.getChild(imageId);
            if (!source) {
                wd.Log.warn("no image found in loader(id:" + imageId + ")");
            }
            switch (target) {
                case 3553:
                    asset = wd.ImageTextureAsset.create(source);
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("target except TEXTURE_2D"));
                    break;
            }
            return asset;
        };
        WDTextureParser.prototype._getTextureType = function (type) {
            var textureType = null;
            switch (type) {
                case 5121:
                    textureType = wd.ETextureType.UNSIGNED_BYTE;
                    break;
                case 33635:
                    textureType = wd.ETextureType.UNSIGNED_SHORT_5_6_5;
                    break;
                case 32819:
                    textureType = wd.ETextureType.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case 32820:
                    textureType = wd.ETextureType.UNSIGNED_SHORT_5_5_5_1;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("texture->type:" + type));
                    break;
            }
            return textureType;
        };
        WDTextureParser.prototype._getTextureFormat = function (format) {
            var textureFormat = null;
            switch (format) {
                case 6406:
                    textureFormat = wd.ETextureFormat.ALPHA;
                    break;
                case 6407:
                    textureFormat = wd.ETextureFormat.RGB;
                    break;
                case 6408:
                    textureFormat = wd.ETextureFormat.RGBA;
                    break;
                case 6409:
                    textureFormat = wd.ETextureFormat.LUMINANCE;
                    break;
                case 6410:
                    textureFormat = wd.ETextureFormat.LUMINANCE_ALPHA;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("texture->format:" + format));
                    break;
            }
            return textureFormat;
        };
        WDTextureParser.prototype._addTextureSampler = function (asset, samplerId) {
            var sampler = this.json.samplers[samplerId];
            if (sampler.isPremultipliedAlpha !== void 0) {
                asset.isPremultipliedAlpha = sampler.isPremultipliedAlpha;
            }
            if (!!sampler.wrapT) {
                asset.wrapT = this._getTextureWrap(sampler.wrapT);
            }
            else {
                asset.wrapT = wd.ETextureWrapMode.REPEAT;
            }
            if (!!sampler.wrapS) {
                asset.wrapS = this._getTextureWrap(sampler.wrapS);
            }
            else {
                asset.wrapS = wd.ETextureWrapMode.REPEAT;
            }
            if (!!sampler.minFilter) {
                asset.minFilter = this._getTextureFilter(sampler.minFilter);
            }
            else {
                asset.minFilter = wd.ETextureFilterMode.LINEAR;
            }
            if (!!sampler.magFilter) {
                asset.magFilter = this._getTextureFilter(sampler.magFilter);
            }
            else {
                asset.magFilter = wd.ETextureFilterMode.LINEAR;
            }
            if (!!sampler.repeatRegion) {
                asset.repeatRegion = this._getTextureRepeatRegion(sampler.repeatRegion);
            }
        };
        WDTextureParser.prototype._getTextureRepeatRegion = function (repeatRegion) {
            return wd.RectRegion.create(repeatRegion[0], repeatRegion[1], repeatRegion[2], repeatRegion[3]);
        };
        WDTextureParser.prototype._getTextureFilter = function (filter) {
            var textureFilter = null;
            switch (filter) {
                case 9728:
                    textureFilter = wd.ETextureFilterMode.NEAREST;
                    break;
                case 9729:
                    textureFilter = wd.ETextureFilterMode.LINEAR;
                    break;
                case 9984:
                    textureFilter = wd.ETextureFilterMode.NEAREST_MIPMAP_MEAREST;
                    break;
                case 9985:
                    textureFilter = wd.ETextureFilterMode.LINEAR_MIPMAP_NEAREST;
                    break;
                case 9986:
                    textureFilter = wd.ETextureFilterMode.NEAREST_MIPMAP_LINEAR;
                    break;
                case 9987:
                    textureFilter = wd.ETextureFilterMode.LINEAR_MIPMAP_LINEAR;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("texture filter:" + filter));
                    break;
            }
            return textureFilter;
        };
        WDTextureParser.prototype._getTextureWrap = function (wrap) {
            var textureWrap = null;
            switch (wrap) {
                case 33071:
                    textureWrap = wd.ETextureWrapMode.CLAMP_TO_EDGE;
                    break;
                case 33648:
                    textureWrap = wd.ETextureWrapMode.MIRRORED_REPEAT;
                    break;
                case 10497:
                    textureWrap = wd.ETextureWrapMode.REPEAT;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("texture wrap:" + wrap));
                    break;
            }
            return textureWrap;
        };
        __decorate([
            wd.require(function (asset, samplerId) {
                wd.assert(!!this.json.samplers[samplerId], wd.Log.info.FUNC_NOT_EXIST("samplerId:" + samplerId));
            })
        ], WDTextureParser.prototype, "_addTextureSampler", null);
        return WDTextureParser;
    }());
    wd.WDTextureParser = WDTextureParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDSkinSkeletonParser = (function () {
        function WDSkinSkeletonParser() {
            this._json = null;
            this._arrayBufferMap = null;
        }
        WDSkinSkeletonParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDSkinSkeletonParser.prototype.parse = function (json, skinId, skeletonsIdArr, objectName, arrayBufferMap) {
            var skinSkeleton = {}, skinData = json.skins[skinId];
            this._json = json;
            this._arrayBufferMap = arrayBufferMap;
            if (!skinData.bindShapeMatrix || this._isIdentiyMatrixValues(skinData.bindShapeMatrix)) {
                skinSkeleton.bindShapeMatrix = null;
            }
            else {
                skinSkeleton.bindShapeMatrix = wd.Matrix4.create(new Float32Array(skinData.bindShapeMatrix));
            }
            skinSkeleton.jointNames = skinData.jointNames;
            skinSkeleton.inverseBindMatrices = this._getInverseBindMatrices(skinData.inverseBindMatrices);
            skinSkeleton.boneMatrixMap = this._getBoneMatrixMap(skeletonsIdArr[0]);
            skinSkeleton.jointTransformData = null;
            return skinSkeleton;
        };
        WDSkinSkeletonParser.prototype._isIdentiyMatrixValues = function (bindShapeMatrix) {
            var identityValues = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            for (var i = 0, len = identityValues.length; i < len; i++) {
                if (bindShapeMatrix[i] !== identityValues[i]) {
                    return false;
                }
            }
            return true;
        };
        WDSkinSkeletonParser.prototype._getInverseBindMatrices = function (inverseBindMatricesAccessorId) {
            var json = this._json, inverseBindMatrices = [], values = null, mat = null, _a = wd.WDUtils.getBufferReaderFromAccessor(json, json.accessors[inverseBindMatricesAccessorId], this._arrayBufferMap), bufferReader = _a.bufferReader, count = _a.count;
            for (var i = 0, len = count; i < len; i += 16) {
                values = new Float32Array(16);
                for (var j = 0; j < 16; j++) {
                    values[j] = bufferReader.readFloat();
                }
                inverseBindMatrices.push(wd.Matrix4.create(values));
            }
            return inverseBindMatrices;
        };
        WDSkinSkeletonParser.prototype._getBoneMatrixMap = function (rootSkeletonId) {
            var self = this, nodes = this._json.nodes, boneMatrixMap = wdCb.Hash.create();
            var find = function (nodeId, parentBoneMatrix) {
                var node = nodes[nodeId], matrix = self._composeBoneMatrix(node), boneMatrix = wd.BoneMatrix.create(matrix);
                if (parentBoneMatrix !== null) {
                    boneMatrix.parent = parentBoneMatrix;
                }
                if (!node.jointName) {
                    boneMatrixMap.addChild(nodeId, boneMatrix);
                }
                else {
                    boneMatrixMap.addChild(node.jointName, boneMatrix);
                }
                if (!!node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var childNodeId = _a[_i];
                        find(childNodeId, boneMatrix);
                    }
                }
            };
            find(this._findRootNodeIdContainRootSkeleton(rootSkeletonId), null);
            return boneMatrixMap;
        };
        WDSkinSkeletonParser.prototype._findRootNodeIdContainRootSkeleton = function (rootSkeletonId) {
            var self = this, nodes = this._json.nodes, rootNodeId = null;
            var find = function (targetNodeId) {
                rootNodeId = targetNodeId;
                for (var nodeId in nodes) {
                    if (nodes.hasOwnProperty(nodeId)) {
                        var node = nodes[nodeId];
                        if (!!node.children && node.children.indexOf(targetNodeId) > -1) {
                            find(nodeId);
                            break;
                        }
                    }
                }
            };
            find(rootSkeletonId);
            return rootNodeId;
        };
        WDSkinSkeletonParser.prototype._composeBoneMatrix = function (node) {
            var mat = null;
            if (node.translation && node.rotation && node.scale) {
                var translation = node.translation, rotation = node.rotation, scale = node.scale;
                mat = wd.Matrix4.create().setTRS(wd.Vector3.create(translation[0], translation[1], translation[2]), wd.Quaternion.create(rotation[0], rotation[1], rotation[2], rotation[3]), wd.Vector3.create(scale[0], scale[1], scale[2]));
            }
            else if (node.matrix) {
                mat = wd.Matrix4.create(new Float32Array(node.matrix));
            }
            return mat;
        };
        __decorate([
            wd.require(function (json, skinId, skeletonsIdArr, objectName) {
                wd.it("if has multi root skeletons, warn that only use the first skeleton", function () {
                    if (skeletonsIdArr.length > 1) {
                        wd.Log.warn(objectName + " has multi root skeletons:" + skeletonsIdArr + ", only use the first skeleton:" + skeletonsIdArr[0]);
                    }
                });
                wd.it("skin and skeleton should both exist", function () {
                    wd.expect(skinId).exist;
                    wd.expect(json.skins).exist;
                    wd.expect(json.skins[skinId]).exist;
                    wd.expect(skeletonsIdArr).exist;
                    wd.expect(skeletonsIdArr.length).gt(0);
                });
            })
        ], WDSkinSkeletonParser.prototype, "parse", null);
        __decorate([
            wd.require(function (node) {
                wd.it("should define matrix data", function () {
                    wd.expect((!!node.translation && !!node.rotation && !!node.scale)
                        || !!node.matrix).true;
                });
            })
        ], WDSkinSkeletonParser.prototype, "_composeBoneMatrix", null);
        return WDSkinSkeletonParser;
    }());
    wd.WDSkinSkeletonParser = WDSkinSkeletonParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDKeyFrameAnimationParser = (function (_super) {
        __extends(WDKeyFrameAnimationParser, _super);
        function WDKeyFrameAnimationParser() {
            _super.apply(this, arguments);
            this._arrayBufferMap = null;
            this._json = null;
        }
        WDKeyFrameAnimationParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDKeyFrameAnimationParser.prototype.parse = function (json, objects, arrayBufferMap) {
            var _this = this;
            var objectWithAnimationMap = wdCb.Hash.create(), nodeWithAnimationMap = wdCb.Hash.create(), nodes = json.nodes, self = this;
            this._json = json;
            this._arrayBufferMap = arrayBufferMap;
            var _loop_5 = function(animId) {
                if (json.animations.hasOwnProperty(animId)) {
                    var animation_1 = json.animations[animId], nodeWithChannelMap = wdCb.Hash.create();
                    for (var i = 0, len = animation_1.channels.length; i < len; i++) {
                        var channel = animation_1.channels[i], targetId = channel.target.id;
                        nodeWithChannelMap.appendChild(targetId, channel);
                    }
                    nodeWithChannelMap.forEach(function (channelList, targetId) {
                        var keyFrameDataList = wdCb.Collection.create(), targetNode = null, targetObject = null, inputData = null;
                        targetObject = _this._findObject(objects, targetId);
                        if (targetObject === null) {
                            targetNode = self._findNode(nodes, targetId);
                        }
                        if (targetNode === null && targetObject === null) {
                            wd.Log.warn("can't find node or object whose id is " + targetId + " to attach to animation named " + animId);
                            return;
                        }
                        var animName = self._getAnimName(animation_1, animId);
                        if (targetObject !== null) {
                            self._addAnimationToNode(objectWithAnimationMap, targetId, targetObject, animName, keyFrameDataList);
                        }
                        else {
                            self._addAnimationToNode(nodeWithAnimationMap, targetId, targetNode, animName, keyFrameDataList);
                        }
                        inputData = self._getInputData(animation_1, channelList);
                        var _a = wd.WDUtils.getBufferReaderFromAccessor(json, json.accessors[inputData], arrayBufferMap), bufferReader = _a.bufferReader, count = _a.count, channelBufferReaderArr = _this._getChannelBufferReaderArr(animation_1, channelList);
                        for (var i = 0; i < count; i++) {
                            var data = bufferReader.readFloat();
                            var keyFrameData = {};
                            keyFrameData.time = _this._convertSecondToMillisecond(data);
                            keyFrameData.targets = _this._getKeyFrameDataTargets(animation_1, channelList, channelBufferReaderArr);
                            keyFrameDataList.addChild(keyFrameData);
                        }
                    });
                }
            };
            for (var animId in json.animations) {
                _loop_5(animId);
            }
            return {
                nodeWithAnimationMap: nodeWithAnimationMap,
                objectWithAnimationMap: objectWithAnimationMap
            };
        };
        WDKeyFrameAnimationParser.prototype._getChannelBufferReaderArr = function (animation, channelList) {
            var _this = this;
            var bufferReaderArr = [];
            channelList.forEach(function (channel) {
                var sampler = animation.samplers[channel.sampler], outputData = null, targetPath = null;
                if (!sampler) {
                    return;
                }
                targetPath = channel.target.path;
                outputData = animation.parameters[sampler.output];
                var _a = wd.WDUtils.getBufferReaderFromAccessor(_this._json, _this._json.accessors[outputData], _this._arrayBufferMap), bufferReader = _a.bufferReader, count = _a.count;
                bufferReaderArr.push(bufferReader);
            });
            return bufferReaderArr;
        };
        WDKeyFrameAnimationParser.prototype._getAnimName = function (animation, animId) {
            return animation.name ? animation.name : animId;
        };
        WDKeyFrameAnimationParser.prototype._getInputData = function (animation, channelList) {
            var result = null;
            channelList.forEach(function (channel) {
                var sampler = animation.samplers[channel.sampler];
                if (sampler) {
                    result = animation.parameters[sampler.input];
                    return wdCb.$BREAK;
                }
            });
            return result;
        };
        WDKeyFrameAnimationParser.prototype._addAnimationToNode = function (entityWithAnimationMap, targetId, targetEntity, animName, keyFrameDataList) {
            if (!entityWithAnimationMap.hasChild(targetId)) {
                entityWithAnimationMap.addChild(targetId, {
                    entity: targetEntity,
                    animationData: {}
                });
            }
            entityWithAnimationMap.getChild(targetId).animationData[animName] = keyFrameDataList;
        };
        WDKeyFrameAnimationParser.prototype._getKeyFrameDataTargets = function (animation, channelList, channelBufferReaderArr) {
            var _this = this;
            var targets = wdCb.Collection.create();
            channelList.forEach(function (channel, index) {
                var sampler = animation.samplers[channel.sampler], outputData = null, targetPath = null, targetData = {}, bufferReader = null;
                if (!sampler) {
                    return;
                }
                targetPath = channel.target.path;
                outputData = animation.parameters[sampler.output];
                bufferReader = channelBufferReaderArr[index];
                targetData.interpolationMethod = _this._convertTointerpolationMethod(sampler.interpolation);
                switch (targetPath) {
                    case wd.EWDKeyFrameAnimationPath.TRANSLATION:
                        targetData.target = wd.EKeyFrameAnimationTarget.TRANSLATION;
                        targetData.data = wd.Vector3.create(bufferReader.readFloat(), bufferReader.readFloat(), bufferReader.readFloat());
                        break;
                    case wd.EWDKeyFrameAnimationPath.ROTATION:
                        targetData.target = wd.EKeyFrameAnimationTarget.ROTATION;
                        targetData.data = wd.Quaternion.create(bufferReader.readFloat(), bufferReader.readFloat(), bufferReader.readFloat(), bufferReader.readFloat());
                        break;
                    case wd.EWDKeyFrameAnimationPath.SCALE:
                        targetData.target = wd.EKeyFrameAnimationTarget.SCALE;
                        targetData.data = wd.Vector3.create(bufferReader.readFloat(), bufferReader.readFloat(), bufferReader.readFloat());
                        break;
                    default:
                        wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("path:" + targetPath));
                        break;
                }
                targets.addChild(targetData);
            }, this);
            return targets;
        };
        WDKeyFrameAnimationParser.prototype._findNode = function (nodes, targetId) {
            return nodes[targetId];
        };
        WDKeyFrameAnimationParser.prototype._findObject = function (objects, targetId) {
            var find = function (objects) {
                var result = objects.findOne(function (object) {
                    return object.id === targetId;
                });
                if (result) {
                    return result;
                }
                objects.forEach(function (object) {
                    result = find(object.children);
                    if (result) {
                        return wdCb.$BREAK;
                    }
                });
                return result;
            };
            return find(objects);
        };
        WDKeyFrameAnimationParser.prototype._convertSecondToMillisecond = function (time) {
            return 1000 * time;
        };
        WDKeyFrameAnimationParser.prototype._convertTointerpolationMethod = function (jsonInterpolation) {
            switch (jsonInterpolation) {
                case wd.EKeyFrameInterpolation.LINEAR:
                    return wd.EKeyFrameInterpolation.LINEAR;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_NOT_SUPPORT("interpolation:" + jsonInterpolation));
                    break;
            }
        };
        return WDKeyFrameAnimationParser;
    }(wd.WDComponentParser));
    wd.WDKeyFrameAnimationParser = WDKeyFrameAnimationParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDSkinSkeletonAnimationParser = (function (_super) {
        __extends(WDSkinSkeletonAnimationParser, _super);
        function WDSkinSkeletonAnimationParser() {
            _super.apply(this, arguments);
        }
        WDSkinSkeletonAnimationParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDSkinSkeletonAnimationParser.prototype.parse = function (json, nodeWithAnimationMap, jointNames) {
            var jointTransformData = wdCb.Hash.create();
            for (var _i = 0, jointNames_1 = jointNames; _i < jointNames_1.length; _i++) {
                var jointName = jointNames_1[_i];
                var data = nodeWithAnimationMap.getChild(jointName), animationData = null;
                if (!data) {
                    continue;
                }
                for (var animName in data.animationData) {
                    if (data.animationData.hasOwnProperty(animName)) {
                        var oneAnimData = data.animationData[animName];
                        if (jointTransformData.hasChild(animName)) {
                            animationData = jointTransformData.getChild(animName);
                        }
                        else {
                            animationData = wdCb.Hash.create();
                            jointTransformData.addChild(animName, animationData);
                        }
                        animationData.addChild(jointName, oneAnimData);
                    }
                }
            }
            return jointTransformData;
        };
        return WDSkinSkeletonAnimationParser;
    }(wd.WDComponentParser));
    wd.WDSkinSkeletonAnimationParser = WDSkinSkeletonAnimationParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDArticulatedAnimationParser = (function (_super) {
        __extends(WDArticulatedAnimationParser, _super);
        function WDArticulatedAnimationParser() {
            _super.apply(this, arguments);
        }
        WDArticulatedAnimationParser.create = function () {
            var obj = new this();
            return obj;
        };
        WDArticulatedAnimationParser.prototype.parse = function (objectWithAnimationMap) {
            this._addAnimationComponent(objectWithAnimationMap);
        };
        WDArticulatedAnimationParser.prototype._addAnimationComponent = function (objectWithAnimationMap) {
            objectWithAnimationMap.forEach(function (data) {
                var node = data.entity, animationData = data.animationData;
                node.components.addChild(animationData);
                delete data.animationData;
            });
        };
        __decorate([
            wd.ensure(function (returnVal, objectWithAnimationMap) {
                wd.it("node should only has 1 IWDKeyFrameAnimation component", function () {
                    objectWithAnimationMap.forEach(function (_a) {
                        var entity = _a.entity, animationData = _a.animationData;
                        wd.expect(entity.components.filter(function (component) {
                            return wd.WDUtils.isIWDKeyFrameAnimationAssembler(component);
                        }).getCount()).most(1);
                    });
                });
            })
        ], WDArticulatedAnimationParser.prototype, "_addAnimationComponent", null);
        return WDArticulatedAnimationParser;
    }(wd.WDComponentParser));
    wd.WDArticulatedAnimationParser = WDArticulatedAnimationParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDUtils = (function () {
        function WDUtils() {
        }
        WDUtils.addData = function (target, sourceName, sourceData) {
            if (sourceData !== undefined && sourceData !== null) {
                target[sourceName] = sourceData;
            }
        };
        WDUtils.isBase64 = function (uri) {
            return /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{4}|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)$/.test(uri)
                || uri.substr(0, 5) === "data:";
        };
        WDUtils.decodeArrayBuffer = function (base64Str) {
            var arr = base64Str.split(','), base64 = arr.length > 1 ? arr[1] : arr[0], decodedString = atob(base64), bufferLength = decodedString.length, arraybuffer = new Uint8Array(new ArrayBuffer(bufferLength));
            for (var i = 0; i < bufferLength; i++) {
                arraybuffer[i] = decodedString.charCodeAt(i);
            }
            return arraybuffer.buffer;
        };
        WDUtils.createObjectData = function () {
            return {
                id: null,
                isContainer: false,
                components: wdCb.Collection.create(),
                children: wdCb.Collection.create()
            };
        };
        WDUtils.getColor = function (value) {
            var color = wd.Color.create();
            color.r = Number(value[0]);
            color.g = Number(value[1]);
            color.b = Number(value[2]);
            if (value.length === 4) {
                color.a = Number(value[3]);
            }
            return color;
        };
        WDUtils.getBufferReaderFromAccessor = function (json, accessor, arrayBufferMap) {
            var bufferView = json.bufferViews[accessor.bufferView], arrayBuffer = arrayBufferMap.getChild(bufferView.buffer), byteOffset = accessor.byteOffset + bufferView.byteOffset, count = accessor.count * this.getAccessorTypeSize(accessor), byteSize = null;
            switch (accessor.componentType) {
                case 5120:
                    byteSize = 1;
                    break;
                case 5121:
                    byteSize = 1;
                    break;
                case 5122:
                    byteSize = 2;
                    break;
                case 5123:
                    byteSize = 2;
                    break;
                case 5126:
                    byteSize = 4;
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("componentType:" + accessor.componentType));
                    break;
            }
            return {
                bufferReader: wd.BufferReader.create(arrayBuffer, byteOffset, count * byteSize),
                count: count
            };
        };
        WDUtils.getAccessorTypeSize = function (accessor) {
            var type = accessor.type;
            switch (type) {
                case "VEC2":
                    return 2;
                case "VEC3":
                    return 3;
                case "VEC4":
                    return 4;
                case "MAT2":
                    return 4;
                case "MAT3":
                    return 9;
                case "MAT4":
                    return 16;
                default:
                    return 1;
            }
        };
        WDUtils.isIWDKeyFrameAnimationAssembler = function (component) {
            if (!wd.JudgeUtils.isDirectObject(component)) {
                return false;
            }
            for (var animName in component) {
                return component[animName] instanceof wdCb.Collection && component[animName].getCount() > 0 && component[animName].getChild(0).time !== void 0;
            }
        };
        return WDUtils;
    }());
    wd.WDUtils = WDUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDMorphDataParseUtils = (function () {
        function WDMorphDataParseUtils() {
        }
        WDMorphDataParseUtils.parseMorphData = function (json, sourceMorphTargets, arrayBufferMap) {
            var morphVertices = wdCb.Hash.create(), morphNormals = wdCb.Hash.create(), accessor = null;
            for (var _i = 0, sourceMorphTargets_1 = sourceMorphTargets; _i < sourceMorphTargets_1.length; _i++) {
                var frame = sourceMorphTargets_1[_i];
                var animName = this._getAnimName(frame.name);
                morphVertices.appendChild(animName, this._getMorphDatas(json, frame.vertices, arrayBufferMap));
                if (!!frame.normals) {
                    morphNormals.appendChild(animName, this._getMorphDatas(json, frame.normals, arrayBufferMap));
                }
            }
            if (morphNormals.getCount() === 0) {
                morphNormals = null;
            }
            return {
                morphVertices: morphVertices,
                morphNormals: morphNormals
            };
        };
        WDMorphDataParseUtils._getMorphDatas = function (json, frameDataAccessorId, arrayBufferMap) {
            var accessor = json.accessors[frameDataAccessorId], _a = wd.WDUtils.getBufferReaderFromAccessor(json, accessor, arrayBufferMap), bufferReader = _a.bufferReader, count = _a.count, dataArr = [];
            for (var i = 0; i < count; i++) {
                dataArr.push(bufferReader.readFloat());
            }
            return dataArr;
        };
        WDMorphDataParseUtils._getAnimName = function (frameName) {
            var PATTERN = /([a-z]+)_?(\d+)/, DEFAULT_ANIM_NAME = "defaultMorphAnimation";
            var parts = frameName.match(PATTERN);
            return parts && parts.length > 1 ? parts[1] : DEFAULT_ANIM_NAME;
        };
        return WDMorphDataParseUtils;
    }());
    wd.WDMorphDataParseUtils = WDMorphDataParseUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDAssembler = (function () {
        function WDAssembler() {
            this._result = wdCb.Hash.create();
            this._geometryAssembler = wd.WDGeometryAssembler.create();
            this._transformAssembler = wd.WDTransformAssembler.create();
            this._lightAssembler = wd.WDLightAssembler.create();
        }
        WDAssembler.create = function () {
            var obj = new this();
            return obj;
        };
        WDAssembler.prototype.build = function (parseData) {
            this._buildMetadata(parseData);
            this._buildModels(parseData);
            wd.EventManager.trigger(wd.CustomEvent.create(wd.EEngineEvent.AFTER_SCENEGRAPH_BUILD));
            return this._result;
        };
        WDAssembler.prototype._buildMetadata = function (parseData) {
            var metadata = {};
            for (var i in parseData.metadata) {
                if (parseData.metadata.hasOwnProperty(i)) {
                    metadata[i] = parseData.metadata[i];
                }
            }
            this._result.addChild("metadata", metadata);
        };
        WDAssembler.prototype._buildModels = function (parseData) {
            var models = wdCb.Collection.create(), self = this;
            var build = function (object) {
                var model = wd.GameObject.create();
                if (object.name) {
                    model.name = object.name;
                }
                if (self._isModelContainer(object)) {
                    model.addTag(wd.EWDTag.CONTAINER);
                }
                self._addComponentsFromwd(model, object.components);
                model.addComponent(wd.MeshRenderer.create());
                if (object.children) {
                    object.children.forEach(function (child) {
                        model.addChild(build(child));
                    });
                }
                return model;
            };
            if (!parseData.objects) {
                return;
            }
            parseData.objects.forEach(function (object) {
                models.addChild(build(object));
            });
            this._result.addChild("models", models);
        };
        WDAssembler.prototype._isModelContainer = function (object) {
            return object.isContainer;
        };
        WDAssembler.prototype._addComponentsFromwd = function (model, components) {
            var self = this;
            components.forEach(function (component) {
                if (self._isTransform(component)) {
                    model.addComponent(self._transformAssembler.createComponent(component));
                }
                else if (self._isCamera(component)) {
                    model.addComponent(self._createCamera(component));
                }
                else if (self._isLight(component)) {
                    model.addComponent(self._lightAssembler.createComponent(component));
                }
                else if (self._isGeometry(component)) {
                    var geometry = self._geometryAssembler.createComponent(component);
                    model.addComponent(geometry);
                    if (!!geometry.morphVertices && geometry.morphVertices.getCount() > 0) {
                        var MorphAnimation_2 = wd.ClassUtils.getClass("MorphAnimation");
                        if (MorphAnimation_2 !== void 0) {
                            model.addComponent(MorphAnimation_2.create());
                        }
                    }
                }
                else if (self._isKeyFrameAnimation(component)) {
                    var TransformArticulatedAnimation_1 = wd.ClassUtils.getClass("TransformArticulatedAnimation");
                    if (TransformArticulatedAnimation_1 !== void 0) {
                        model.addComponent(self._createKeyFrameAnimation(component, TransformArticulatedAnimation_1));
                    }
                }
                else if (self._isSkinSkeleton(component)) {
                    var SkinSkeletonAnimation_2 = wd.ClassUtils.getClass("SkinSkeletonAnimation");
                    if (SkinSkeletonAnimation_2 !== void 0) {
                        model.addComponent(self._createSkinSkeletonAnimation(component, SkinSkeletonAnimation_2));
                    }
                }
            });
        };
        WDAssembler.prototype._isTransform = function (component) {
            return !!component.matrix || !!component.position;
        };
        WDAssembler.prototype._isCamera = function (component) {
            return !!component.camera;
        };
        WDAssembler.prototype._isLight = function (component) {
            return !!component.color && !!component.type;
        };
        WDAssembler.prototype._isGeometry = function (component) {
            return !!component.material;
        };
        WDAssembler.prototype._isKeyFrameAnimation = function (component) {
            return wd.WDUtils.isIWDKeyFrameAnimationAssembler(component);
        };
        WDAssembler.prototype._isSkinSkeleton = function (component) {
            return !!component.jointNames;
        };
        WDAssembler.prototype._createCamera = function (component) {
            return wd.BasicCameraController.create(component.camera);
        };
        WDAssembler.prototype._createKeyFrameAnimation = function (component, TransformArticulatedAnimation) {
            var anim = TransformArticulatedAnimation.create();
            anim.data = wdCb.Hash.create(component);
            return anim;
        };
        WDAssembler.prototype._createSkinSkeletonAnimation = function (component, SkinSkeletonAnimation) {
            var anim = SkinSkeletonAnimation.create();
            anim.bindShapeMatrix = component.bindShapeMatrix;
            anim.inverseBindMatrices = component.inverseBindMatrices;
            anim.boneMatrixMap = component.boneMatrixMap;
            anim.jointNames = component.jointNames;
            anim.jointTransformData = component.jointTransformData;
            return anim;
        };
        return WDAssembler;
    }());
    wd.WDAssembler = WDAssembler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDComponentAssembler = (function () {
        function WDComponentAssembler() {
        }
        return WDComponentAssembler;
    }());
    wd.WDComponentAssembler = WDComponentAssembler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDGeometryAssembler = (function (_super) {
        __extends(WDGeometryAssembler, _super);
        function WDGeometryAssembler() {
            _super.apply(this, arguments);
        }
        WDGeometryAssembler.create = function () {
            var obj = new this();
            return obj;
        };
        WDGeometryAssembler.prototype.createComponent = function (component) {
            var geometry = wd.ModelGeometry.create();
            geometry.vertices = component.vertices;
            geometry.faces = component.faces;
            wd.WDUtils.addData(geometry, "colors", component.colors);
            wd.WDUtils.addData(geometry, "texCoords", component.texCoords);
            wd.WDUtils.addData(geometry, "jointIndices", component.jointIndices);
            wd.WDUtils.addData(geometry, "jointWeights", component.jointWeights);
            wd.WDUtils.addData(geometry, "morphVertices", component.morphVertices);
            wd.WDUtils.addData(geometry, "morphNormals", component.morphNormals);
            geometry.drawMode = component.drawMode;
            geometry.material = this._createMaterial(component.material);
            return geometry;
        };
        WDGeometryAssembler.prototype._createMaterial = function (materialData) {
            var material = null;
            switch (materialData.type) {
                case "LightMaterial":
                    material = this._createLightMaterial(materialData);
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("material type:" + materialData.type));
                    break;
            }
            return material;
        };
        WDGeometryAssembler.prototype._createLightMaterial = function (materialData) {
            return this._createStandardLightMaterial(wd.LightMaterial.create(), materialData);
        };
        WDGeometryAssembler.prototype._createStandardLightMaterial = function (material, materialData) {
            this._setBasicDataOfMaterial(material, materialData);
            if (materialData.transparent === true && materialData.opacity !== void 0) {
                material.opacity = materialData.opacity;
                material.blendType = wd.EBlendType.NORMAL;
            }
            if (materialData.lightModel === wd.ELightModel.LAMBERT) {
                wd.Log.log(wd.Log.info.FUNC_NOT_SUPPORT("LAMBERT light model, use PHONG light model instead"));
                material.lightModel = wd.ELightModel.PHONG;
            }
            else {
                material.lightModel = materialData.lightModel;
            }
            wd.WDUtils.addData(material, "color", materialData.diffuseColor);
            wd.WDUtils.addData(material, "specularColor", materialData.specularColor);
            wd.WDUtils.addData(material, "emissionColor", materialData.emissionColor);
            wd.WDUtils.addData(material, "diffuseMap", materialData.diffuseMap);
            wd.WDUtils.addData(material, "specularMap", materialData.specularMap);
            wd.WDUtils.addData(material, "emissionMap", materialData.emissionMap);
            wd.WDUtils.addData(material, "lightMap", materialData.lightMap);
            wd.WDUtils.addData(material, "normalMap", materialData.normalMap);
            wd.WDUtils.addData(material, "shininess", materialData.shininess);
            return material;
        };
        WDGeometryAssembler.prototype._setBasicDataOfMaterial = function (material, materialData) {
            if (!!materialData.doubleSided && materialData.doubleSided === true) {
                material.side = wd.ESide.BOTH;
            }
            else {
                material.side = wd.ESide.FRONT;
            }
        };
        __decorate([
            wd.require(function (materialData) {
                wd.it("material type should always be LightMaterial", function () {
                    wd.expect(materialData.type).equals("LightMaterial");
                });
            })
        ], WDGeometryAssembler.prototype, "_createMaterial", null);
        return WDGeometryAssembler;
    }(wd.WDComponentAssembler));
    wd.WDGeometryAssembler = WDGeometryAssembler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDTransformAssembler = (function (_super) {
        __extends(WDTransformAssembler, _super);
        function WDTransformAssembler() {
            _super.apply(this, arguments);
        }
        WDTransformAssembler.create = function () {
            var obj = new this();
            return obj;
        };
        WDTransformAssembler.prototype.createComponent = function (component) {
            var transform = wd.ThreeDTransform.create();
            if (component.matrix) {
                transform.localPosition = component.matrix.getTranslation();
                transform.localRotation = component.matrix.getRotation();
                transform.localScale = component.matrix.getScale();
            }
            else {
                transform.localPosition = component.position;
                transform.localRotation = component.rotation;
                transform.localScale = component.scale;
            }
            return transform;
        };
        return WDTransformAssembler;
    }(wd.WDComponentAssembler));
    wd.WDTransformAssembler = WDTransformAssembler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WDLightAssembler = (function (_super) {
        __extends(WDLightAssembler, _super);
        function WDLightAssembler() {
            _super.apply(this, arguments);
        }
        WDLightAssembler.create = function () {
            var obj = new this();
            return obj;
        };
        WDLightAssembler.prototype.createComponent = function (component) {
            var light = null;
            switch (component.type) {
                case "ambient":
                    light = wd.AmbientLight.create();
                    light.color = component.color;
                    break;
                case "directional":
                    light = wd.DirectionLight.create();
                    light.color = component.color;
                    break;
                case "point":
                    light = wd.PointLight.create();
                    light.color = component.color;
                    wd.WDUtils.addData(light, "constant", component.constantAttenuation);
                    wd.WDUtils.addData(light, "linear", component.linearAttenuation);
                    wd.WDUtils.addData(light, "quadratic", component.quadraticAttenuation);
                    wd.WDUtils.addData(light, "range", component.range);
                    break;
                default:
                    break;
            }
            wd.WDUtils.addData(light, "intensity", component.intensity);
            return light;
        };
        return WDLightAssembler;
    }(wd.WDComponentAssembler));
    wd.WDLightAssembler = WDLightAssembler;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TYPE = {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    };
    var FontLoader = (function (_super) {
        __extends(FontLoader, _super);
        function FontLoader() {
            _super.call(this);
            this._familyName = null;
        }
        FontLoader.getInstance = function () { };
        FontLoader.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            wdCb.DomQuery.create("#" + this._familyName).remove();
        };
        FontLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var familyName = args[1], self = this;
            this._familyName = familyName;
            return wdFrp.fromPromise(new wd.RSVP.Promise(function (resolve, reject) {
                self._addStyleElement(args, familyName);
                if (document.fonts) {
                    document.fonts.load("1em " + familyName).then(function () {
                        resolve();
                    }, function (e) {
                        reject(e);
                    });
                }
                else {
                    wd.Log.warn("your browser not support document.fonts api, so it can't ensure that the font is loaded");
                    resolve();
                }
            }));
        };
        FontLoader.prototype._getType = function (url) {
            return TYPE[wdCb.PathUtils.extname(url).toLowerCase()];
        };
        FontLoader.prototype._addStyleElement = function (args, familyName) {
            var fontStyleEle = wdCb.DomQuery.create("<style id=\"" + familyName + "\"></style>"), fontStr = null;
            fontStyleEle.prependTo("body");
            fontStr = "@font-face { font-family:" + familyName + "; src:";
            if (wd.JudgeUtils.isArrayExactly(args[0])) {
                var urlArr = args[0];
                for (var _i = 0, urlArr_1 = urlArr; _i < urlArr_1.length; _i++) {
                    var url = urlArr_1[_i];
                    fontStr += "url('" + url + "') format('" + this._getType(url) + "'),";
                }
                fontStr = fontStr.replace(/,$/, ";");
            }
            else {
                var url = args[0];
                fontStr += "url('" + url + "') format('" + this._getType(url) + "');";
            }
            fontStyleEle.get(0).textContent += fontStr + "};";
        };
        __decorate([
            wd.require(function (url) {
                var extname = wdCb.PathUtils.extname(url).toLowerCase();
                wd.assert(!!TYPE[extname], wd.Log.info.FUNC_UNKNOW("type:" + extname));
            })
        ], FontLoader.prototype, "_getType", null);
        FontLoader = __decorate([
            wd.singleton()
        ], FontLoader);
        return FontLoader;
    }(wd.Loader));
    wd.FontLoader = FontLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var COMMON_EXP = /common [^\n]*(\n|$)/gi, PAGE_EXP = /page [^\n]*(\n|$)/gi, CHAR_EXP = /char [^\n]*(\n|$)/gi, KERNING_EXP = /kerning [^\n]*(\n|$)/gi, ITEM_EXP = /\w+=[^ \r\n]+/gi, INT_EXP = /^[\-]?\d+$/;
    var FntParser = (function () {
        function FntParser() {
        }
        FntParser.create = function () {
            var obj = new this();
            return obj;
        };
        FntParser.prototype.parseFnt = function (fntStr, url) {
            var fnt = {}, commonObj = null, pageObj = null;
            commonObj = this._parseStrToObj(fntStr.match(COMMON_EXP)[0]);
            fnt.commonHeight = commonObj["lineHeight"];
            fnt.commonBase = commonObj["base"];
            fnt.scaleW = commonObj["scaleW"];
            fnt.scaleH = commonObj["scaleH"];
            if (commonObj["pages"] !== 1) {
                fnt.isMultiPages = true;
            }
            else {
                fnt.isMultiPages = false;
            }
            pageObj = this._parseStrToObj(fntStr.match(PAGE_EXP)[0]);
            if (pageObj["id"] !== 0) {
                wd.Log.log("file could not be found");
            }
            fnt.atlasName = wdCb.PathUtils.changeBasename(url, pageObj["file"]);
            this._parseChar(fntStr, fnt);
            this._parseKerning(fntStr, fnt);
            return fnt;
        };
        FntParser.prototype._parseStrToObj = function (str) {
            var arr = str.match(ITEM_EXP), obj = {};
            if (arr) {
                for (var _i = 0, arr_6 = arr; _i < arr_6.length; _i++) {
                    var tempStr = arr_6[_i];
                    var index = tempStr.indexOf("="), key = tempStr.substring(0, index), value = tempStr.substring(index + 1);
                    if (value.match(INT_EXP)) {
                        value = parseInt(value);
                    }
                    else if (value[0] == '"') {
                        value = value.substring(1, value.length - 1);
                    }
                    obj[key] = value;
                }
            }
            return obj;
        };
        FntParser.prototype._parseChar = function (fntStr, fnt) {
            var charLines = fntStr.match(CHAR_EXP), fontDefDictionary = {};
            for (var _i = 0, charLines_1 = charLines; _i < charLines_1.length; _i++) {
                var char = charLines_1[_i];
                var charObj = this._parseStrToObj(char), charId = charObj["id"];
                fontDefDictionary[charId] = {
                    id: charId,
                    rect: { x: charObj["x"], y: charObj["y"], width: charObj["width"], height: charObj["height"] },
                    xOffset: charObj["xoffset"],
                    yOffset: charObj["yoffset"],
                    xAdvance: charObj["xadvance"],
                    page: charObj["page"]
                };
            }
            fnt.fontDefDictionary = fontDefDictionary;
        };
        FntParser.prototype._parseKerning = function (fntStr, fnt) {
            var kerningLines = fntStr.match(KERNING_EXP), kerningArray = [];
            if (kerningLines === null) {
                fnt.kerningArray = [];
                return;
            }
            for (var _i = 0, kerningLines_1 = kerningLines; _i < kerningLines_1.length; _i++) {
                var kerning = kerningLines_1[_i];
                var kerningObj = this._parseStrToObj(kerning);
                kerningArray.push({
                    first: kerningObj["first"],
                    second: kerningObj["second"],
                    amount: kerningObj["amount"]
                });
            }
            fnt.kerningArray = kerningArray;
        };
        return FntParser;
    }());
    wd.FntParser = FntParser;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FntLoader = (function (_super) {
        __extends(FntLoader, _super);
        function FntLoader() {
            _super.call(this);
            this._parser = wd.FntParser.create();
        }
        FntLoader.getInstance = function () { };
        FntLoader.prototype.loadAsset = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var url = args[0], self = this;
            return wd.AjaxLoader.load(url, "text")
                .map(function (fntStr) {
                return self._parser.parseFnt(fntStr, url);
            });
        };
        __decorate([
            wd.require(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                wd.assert(!wd.JudgeUtils.isArrayExactly(args[0]), wd.Log.info.FUNC_MUST_BE("url", "string"));
            })
        ], FntLoader.prototype, "loadAsset", null);
        FntLoader = __decorate([
            wd.singleton()
        ], FntLoader);
        return FntLoader;
    }(wd.Loader));
    wd.FntLoader = FntLoader;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DeviceManager = (function () {
        function DeviceManager() {
            this._scissorTest = false;
            this._depthTest = null;
            this._depthFunc = null;
            this._side = null;
            this.polygonOffset = null;
            this._polygonOffsetMode = null;
            this._depthWrite = null;
            this._blend = null;
            this._alphaToCoverage = null;
            this.view = null;
            this.gl = null;
            this.contextConfig = null;
            this._writeRed = null;
            this._writeGreen = null;
            this._writeBlue = null;
            this._writeAlpha = null;
            this._blendSrc = null;
            this._blendDst = null;
            this._blendEquation = null;
            this._blendFuncSeparate = null;
            this._blendEquationSeparate = null;
            this._scissorRegion = wd.RectRegion.create();
            this._viewport = wd.RectRegion.create();
            this._clearColor = null;
            this._pixelRatio = null;
        }
        DeviceManager.getInstance = function () { };
        Object.defineProperty(DeviceManager.prototype, "scissorTest", {
            get: function () {
                return this._scissorTest;
            },
            set: function (scissorTest) {
                var gl = this.gl;
                if (this._scissorTest === scissorTest) {
                    return;
                }
                if (scissorTest) {
                    gl.enable(gl.SCISSOR_TEST);
                }
                else {
                    gl.disable(gl.SCISSOR_TEST);
                }
                this._scissorTest = scissorTest;
            },
            enumerable: true,
            configurable: true
        });
        DeviceManager.prototype.setScissor = function (x, y, width, height) {
            if (this._scissorRegion.y === y && this._scissorRegion.width === width && this._scissorRegion.height === height) {
                return;
            }
            this.gl.scissor(x, y, width, height);
            this._scissorRegion.set(x, y, width, height);
            this.scissorTest = true;
        };
        DeviceManager.prototype.setViewport = function (x, y, width, height) {
            if (this._viewport.x === x && this._viewport.y === y && this._viewport.width === width && this._viewport.height === height) {
                return;
            }
            this._viewport.set(x, y, width, height);
            this.gl.viewport(x, y, width, height);
        };
        DeviceManager.prototype.getViewport = function () {
            return this._viewport;
        };
        Object.defineProperty(DeviceManager.prototype, "depthTest", {
            get: function () {
                return this._depthTest;
            },
            set: function (depthTest) {
                var gl = this.gl;
                if (this._depthTest !== depthTest) {
                    if (depthTest) {
                        gl.enable(gl.DEPTH_TEST);
                    }
                    else {
                        gl.disable(gl.DEPTH_TEST);
                    }
                    this._depthTest = depthTest;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceManager.prototype, "depthFunc", {
            get: function () {
                return this._depthFunc;
            },
            set: function (depthFunc) {
                var gl = this.gl;
                if (this._depthFunc !== depthFunc) {
                    gl.depthFunc(gl[depthFunc]);
                    this._depthFunc = depthFunc;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceManager.prototype, "side", {
            get: function () {
                return this._side;
            },
            set: function (side) {
                var gl = this.gl;
                if (this._side !== side) {
                    switch (side) {
                        case ESide.NONE:
                            gl.enable(gl.CULL_FACE);
                            gl.cullFace(gl.FRONT_AND_BACK);
                            break;
                        case ESide.BOTH:
                            gl.disable(gl.CULL_FACE);
                            break;
                        case ESide.FRONT:
                            gl.enable(gl.CULL_FACE);
                            gl.cullFace(gl.BACK);
                            break;
                        case ESide.BACK:
                            gl.enable(gl.CULL_FACE);
                            gl.cullFace(gl.FRONT);
                            break;
                        default:
                            wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("side", side));
                            break;
                    }
                    this._side = side;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceManager.prototype, "polygonOffsetMode", {
            get: function () {
                return this._polygonOffsetMode;
            },
            set: function (polygonOffsetMode) {
                var gl = this.gl;
                if (this._polygonOffsetMode !== polygonOffsetMode) {
                    switch (polygonOffsetMode) {
                        case EPolygonOffsetMode.NONE:
                            gl.polygonOffset(0.0, 0.0);
                            gl.disable(gl.POLYGON_OFFSET_FILL);
                            break;
                        case EPolygonOffsetMode.IN:
                            gl.enable(gl.POLYGON_OFFSET_FILL);
                            gl.polygonOffset(1.0, 1.0);
                            break;
                        case EPolygonOffsetMode.OUT:
                            gl.enable(gl.POLYGON_OFFSET_FILL);
                            gl.polygonOffset(-1.0, -1.0);
                            break;
                        case EPolygonOffsetMode.CUSTOM:
                            gl.enable(gl.POLYGON_OFFSET_FILL);
                            wd.Log.error(!this.polygonOffset, wd.Log.info.FUNC_MUST_DEFINE("polygonOffset"));
                            gl.polygonOffset(this.polygonOffset.x, this.polygonOffset.y);
                            break;
                        default:
                            break;
                    }
                    this._polygonOffsetMode = polygonOffsetMode;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceManager.prototype, "depthWrite", {
            get: function () {
                return this._depthWrite;
            },
            set: function (depthWrite) {
                if (this._depthWrite !== depthWrite) {
                    this.gl.depthMask(depthWrite);
                    this._depthWrite = depthWrite;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceManager.prototype, "blend", {
            get: function () {
                return this._blend;
            },
            set: function (blend) {
                var gl = this.gl;
                if (this._blend !== blend) {
                    if (blend) {
                        gl.enable(gl.BLEND);
                    }
                    else {
                        gl.disable(gl.BLEND);
                    }
                    this._blend = blend;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeviceManager.prototype, "alphaToCoverage", {
            get: function () {
                return this._alphaToCoverage;
            },
            set: function (alphaToCoverage) {
                var gl = this.gl;
                if (this._alphaToCoverage !== alphaToCoverage) {
                    if (alphaToCoverage) {
                        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }
                    else {
                        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }
                    this._alphaToCoverage = alphaToCoverage;
                }
            },
            enumerable: true,
            configurable: true
        });
        DeviceManager.prototype.setBlendFunc = function (blendSrc, blendDst) {
            if ((this._blendSrc !== blendSrc) || (this._blendDst !== blendDst)) {
                this._blend && this.gl.blendFunc(this.gl[blendSrc], this.gl[blendDst]);
                this._blendSrc = blendSrc;
                this._blendDst = blendDst;
            }
        };
        DeviceManager.prototype.setBlendEquation = function (blendEquation) {
            if (this._blendEquation !== blendEquation) {
                this._blend && this.gl.blendEquation(this.gl[blendEquation]);
                this._blendEquation = blendEquation;
            }
        };
        DeviceManager.prototype.setBlendFuncSeparate = function (blendFuncSeparate) {
            var gl = this.gl;
            if (!this._blendFuncSeparate || this._blendFuncSeparate[0] !== blendFuncSeparate[0] || this._blendFuncSeparate[1] !== blendFuncSeparate[1]) {
                this._blend && gl.blendFuncSeparate(gl[blendFuncSeparate[0]], gl[blendFuncSeparate[1]], gl[blendFuncSeparate[2]], gl[blendFuncSeparate[3]]);
                this._blendFuncSeparate = blendFuncSeparate;
            }
        };
        DeviceManager.prototype.setBlendEquationSeparate = function (blendEquationSeparate) {
            var gl = this.gl;
            if (!this._blendEquationSeparate || this._blendEquationSeparate[0] !== blendEquationSeparate[0] || this._blendEquationSeparate[1] !== blendEquationSeparate[1]) {
                this._blend && gl.blendEquationSeparate(gl[blendEquationSeparate[0]], gl[blendEquationSeparate[1]]);
                this._blendEquationSeparate = blendEquationSeparate;
            }
        };
        DeviceManager.prototype.setColorWrite = function (writeRed, writeGreen, writeBlue, writeAlpha) {
            if (this._writeRed !== writeRed
                || this._writeGreen !== writeGreen
                || this._writeBlue !== writeBlue
                || this._writeAlpha !== writeAlpha) {
                this.gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
                this._writeRed = writeRed;
                this._writeGreen = writeGreen;
                this._writeBlue = writeBlue;
                this._writeAlpha = writeAlpha;
            }
        };
        DeviceManager.prototype.clear = function (options) {
            var gl = this.gl, color = options.color;
            this._setClearColor(color);
            this.setColorWrite(true, true, true, true);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        };
        DeviceManager.prototype.createGL = function (canvasId, contextConfig, useDevicePixelRatio) {
            var canvas = null;
            this.contextConfig = contextConfig;
            if (!!canvasId) {
                canvas = wdCb.DomQuery.create(this._getCanvasId(canvasId)).get(0);
            }
            else {
                canvas = wdCb.DomQuery.create("<canvas></canvas>").prependTo("body").get(0);
            }
            this.view = wd.ViewWebGL.create(canvas);
            if (useDevicePixelRatio) {
                this.setPixelRatio(wd.root.devicePixelRatio);
            }
            this.gl = this.view.getContext(contextConfig);
            if (!this.gl) {
                wdCb.DomQuery.create("<p class='not-support-webgl'></p>").prependTo("body").text("Your device doesn't support WebGL");
            }
        };
        DeviceManager.prototype.setScreen = function () {
            var screenSize = wd.Main.screenSize, x = null, y = null, width = null, height = null, styleWidth = null, styleHeight = null;
            if (screenSize === wd.EScreenSize.FULL) {
                x = 0;
                y = 0;
                width = wd.root.innerWidth;
                height = wd.root.innerHeight;
                styleWidth = "100%";
                styleHeight = "100%";
                wdCb.DomQuery.create("body").css("margin", "0");
            }
            else {
                x = screenSize.x || 0;
                y = screenSize.y || 0;
                width = screenSize.width || wd.root.innerWidth;
                height = screenSize.height || wd.root.innerHeight;
                styleWidth = width + "px";
                styleHeight = height + "px";
            }
            this.view.initCanvas();
            this.view.x = x;
            this.view.y = y;
            this.view.width = width;
            this.view.height = height;
            this.view.styleWidth = styleWidth;
            this.view.styleHeight = styleHeight;
            this.setViewport(0, 0, width, height);
        };
        DeviceManager.prototype.setHardwareScaling = function (level) {
            var width = this.view.width / level, height = this.view.height / level;
            this.view.width = width;
            this.view.height = height;
            this.setViewport(0, 0, width, height);
        };
        DeviceManager.prototype.setPixelRatio = function (pixelRatio) {
            this.view.width = Math.round(this.view.width * pixelRatio);
            this.view.height = Math.round(this.view.height * pixelRatio);
            this._pixelRatio = pixelRatio;
        };
        DeviceManager.prototype.getPixelRatio = function () {
            return this._pixelRatio;
        };
        DeviceManager.prototype._setClearColor = function (color) {
            if (this._clearColor && this._clearColor.isEqual(color)) {
                return;
            }
            this.gl.clearColor(color.r, color.g, color.b, color.a);
            this._clearColor = color;
        };
        DeviceManager.prototype._getCanvasId = function (canvasId) {
            if (canvasId.indexOf('#') > -1) {
                return canvasId;
            }
            return "#" + canvasId;
        };
        __decorate([
            wd.require(function () {
                wd.it("should exist Main.screenSize", function () {
                    wd.expect(wd.Main.screenSize).exist;
                });
            })
        ], DeviceManager.prototype, "setScreen", null);
        __decorate([
            wd.require(function (level) {
                wd.it("level should > 0, but actual is " + level, function () {
                    wd.expect(level).greaterThan(0);
                });
            })
        ], DeviceManager.prototype, "setHardwareScaling", null);
        __decorate([
            wd.ensure(function (id) {
                wd.it("canvas id should be #xxx", function () {
                    wd.expect(/#[^#]+/.test(id)).true;
                });
            })
        ], DeviceManager.prototype, "_getCanvasId", null);
        DeviceManager = __decorate([
            wd.singleton()
        ], DeviceManager);
        return DeviceManager;
    }());
    wd.DeviceManager = DeviceManager;
    (function (EDepthFunction) {
        EDepthFunction[EDepthFunction["NEVER"] = "NEVER"] = "NEVER";
        EDepthFunction[EDepthFunction["ALWAYS"] = "ALWAYS"] = "ALWAYS";
        EDepthFunction[EDepthFunction["LESS"] = "LESS"] = "LESS";
        EDepthFunction[EDepthFunction["LEQUAL"] = "LEQUAL"] = "LEQUAL";
        EDepthFunction[EDepthFunction["EQUAL"] = "EQUAL"] = "EQUAL";
        EDepthFunction[EDepthFunction["GEQUAL"] = "GEQUAL"] = "GEQUAL";
        EDepthFunction[EDepthFunction["GREATER"] = "GREATER"] = "GREATER";
        EDepthFunction[EDepthFunction["NOTEQUAL"] = "NOTEQUAL"] = "NOTEQUAL";
    })(wd.EDepthFunction || (wd.EDepthFunction = {}));
    var EDepthFunction = wd.EDepthFunction;
    (function (ESide) {
        ESide[ESide["NONE"] = 0] = "NONE";
        ESide[ESide["BOTH"] = 1] = "BOTH";
        ESide[ESide["BACK"] = 2] = "BACK";
        ESide[ESide["FRONT"] = 3] = "FRONT";
    })(wd.ESide || (wd.ESide = {}));
    var ESide = wd.ESide;
    (function (EPolygonOffsetMode) {
        EPolygonOffsetMode[EPolygonOffsetMode["NONE"] = 0] = "NONE";
        EPolygonOffsetMode[EPolygonOffsetMode["IN"] = 1] = "IN";
        EPolygonOffsetMode[EPolygonOffsetMode["OUT"] = 2] = "OUT";
        EPolygonOffsetMode[EPolygonOffsetMode["CUSTOM"] = 3] = "CUSTOM";
    })(wd.EPolygonOffsetMode || (wd.EPolygonOffsetMode = {}));
    var EPolygonOffsetMode = wd.EPolygonOffsetMode;
    (function (EBlendFunc) {
        EBlendFunc[EBlendFunc["ZERO"] = "ZEOR"] = "ZERO";
        EBlendFunc[EBlendFunc["ONE"] = "ONE"] = "ONE";
        EBlendFunc[EBlendFunc["SRC_COLOR"] = "SRC_COLOR"] = "SRC_COLOR";
        EBlendFunc[EBlendFunc["ONE_MINUS_SRC_COLOR"] = "ONE_MINUS_SRC_COLOR"] = "ONE_MINUS_SRC_COLOR";
        EBlendFunc[EBlendFunc["DST_COLOR"] = "DST_COLOR"] = "DST_COLOR";
        EBlendFunc[EBlendFunc["ONE_MINUS_DST_COLOR"] = "ONE_MINUS_DST_COLOR"] = "ONE_MINUS_DST_COLOR";
        EBlendFunc[EBlendFunc["SRC_ALPHA"] = "SRC_ALPHA"] = "SRC_ALPHA";
        EBlendFunc[EBlendFunc["SRC_ALPHA_SATURATE"] = "SRC_ALPHA_SATURATE"] = "SRC_ALPHA_SATURATE";
        EBlendFunc[EBlendFunc["ONE_MINUS_SRC_ALPHA"] = "ONE_MINUS_SRC_ALPHA"] = "ONE_MINUS_SRC_ALPHA";
        EBlendFunc[EBlendFunc["DST_ALPHA"] = "DST_ALPHA"] = "DST_ALPHA";
        EBlendFunc[EBlendFunc["ONE_MINUS_DST_ALPH"] = "ONE_MINUS_DST_ALPHA"] = "ONE_MINUS_DST_ALPH";
    })(wd.EBlendFunc || (wd.EBlendFunc = {}));
    var EBlendFunc = wd.EBlendFunc;
    (function (EBlendEquation) {
        EBlendEquation[EBlendEquation["ADD"] = "FUNC_ADD"] = "ADD";
        EBlendEquation[EBlendEquation["SUBTRACT"] = "FUNC_SUBTRACT"] = "SUBTRACT";
        EBlendEquation[EBlendEquation["REVERSE_SUBTRAC"] = "FUNC_REVERSE_SUBTRACT"] = "REVERSE_SUBTRAC";
    })(wd.EBlendEquation || (wd.EBlendEquation = {}));
    var EBlendEquation = wd.EBlendEquation;
    (function (EBlendType) {
        EBlendType[EBlendType["NONE"] = 0] = "NONE";
        EBlendType[EBlendType["NORMAL"] = 1] = "NORMAL";
        EBlendType[EBlendType["ADDITIVE"] = 2] = "ADDITIVE";
        EBlendType[EBlendType["ADDITIVEALPHA"] = 3] = "ADDITIVEALPHA";
        EBlendType[EBlendType["MULTIPLICATIVE"] = 4] = "MULTIPLICATIVE";
        EBlendType[EBlendType["PREMULTIPLIED"] = 5] = "PREMULTIPLIED";
    })(wd.EBlendType || (wd.EBlendType = {}));
    var EBlendType = wd.EBlendType;
    (function (ECanvasType) {
        ECanvasType[ECanvasType["TwoDUI"] = "TwoDUI"] = "TwoDUI";
    })(wd.ECanvasType || (wd.ECanvasType = {}));
    var ECanvasType = wd.ECanvasType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GPUDetector = (function () {
        function GPUDetector() {
            this.maxTextureUnit = null;
            this.maxTextureSize = null;
            this.maxCubemapTextureSize = null;
            this.maxAnisotropy = null;
            this.maxBoneCount = null;
            this.extensionCompressedTextureS3TC = null;
            this.extensionTextureFilterAnisotropic = null;
            this.extensionInstancedArrays = null;
            this.extensionUintIndices = null;
            this.extensionDepthTexture = null;
            this.extensionVAO = null;
            this.extensionStandardDerivatives = null;
            this.precision = null;
            this._isDetected = false;
        }
        GPUDetector.getInstance = function () { };
        Object.defineProperty(GPUDetector.prototype, "gl", {
            get: function () {
                return wd.DeviceManager.getInstance().gl;
            },
            enumerable: true,
            configurable: true
        });
        GPUDetector.prototype.detect = function () {
            this._isDetected = true;
            this._detectExtension();
            this._detectCapabilty();
        };
        GPUDetector.prototype._detectExtension = function () {
            this.extensionCompressedTextureS3TC = this._getExtension("WEBGL_compressed_texture_s3tc");
            this.extensionTextureFilterAnisotropic = this._getExtension("EXT_texture_filter_anisotropic");
            this.extensionInstancedArrays = this._getExtension("ANGLE_instanced_arrays");
            this.extensionUintIndices = this._getExtension("element_index_uint");
            this.extensionDepthTexture = this._getExtension("depth_texture");
            this.extensionVAO = this._getExtension("vao");
            this.extensionStandardDerivatives = this._getExtension("standard_derivatives");
        };
        GPUDetector.prototype._detectCapabilty = function () {
            var gl = this.gl;
            this.maxTextureUnit = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubemapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxAnisotropy = this._getMaxAnisotropy();
            this.maxBoneCount = this._getMaxBoneCount();
            this._detectPrecision();
        };
        GPUDetector.prototype._getExtension = function (name) {
            var extension, gl = this.gl;
            switch (name) {
                case "EXT_texture_filter_anisotropic":
                    extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                case "ANGLE_instanced_arrays":
                    extension = gl.getExtension("ANGLE_instanced_arrays");
                    break;
                case "element_index_uint":
                    extension = gl.getExtension("OES_element_index_uint") !== null;
                    break;
                case "depth_texture":
                    extension = gl.getExtension("WEBKIT_WEBGL_depth_texture") !== null || gl.getExtension("WEBGL_depth_texture") !== null;
                    break;
                case "vao":
                    extension = gl.getExtension("OES_vertex_array_object");
                    break;
                case "standard_derivatives":
                    extension = gl.getExtension("OES_standard_derivatives");
                    break;
                default:
                    extension = gl.getExtension(name);
                    break;
            }
            return extension;
        };
        GPUDetector.prototype._getMaxBoneCount = function () {
            var gl = this.gl, numUniforms = null, maxBoneCount = null;
            numUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            numUniforms -= 4 * 4;
            numUniforms -= 1;
            numUniforms -= 4 * 4;
            maxBoneCount = Math.floor(numUniforms / 4);
            return Math.min(maxBoneCount, 128);
        };
        GPUDetector.prototype._getMaxAnisotropy = function () {
            var extension = this.extensionTextureFilterAnisotropic, gl = this.gl;
            return extension !== null ? gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        };
        GPUDetector.prototype._detectPrecision = function () {
            var gl = this.gl;
            if (!gl.getShaderPrecisionFormat) {
                this.precision = EGPUPrecision.HIGHP;
                return;
            }
            var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT), vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT), fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT), fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT), highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0, mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
            if (!highpAvailable) {
                if (mediumpAvailable) {
                    this.precision = EGPUPrecision.MEDIUMP;
                    wd.Log.warn(wd.Log.info.FUNC_NOT_SUPPORT("gpu", "highp, using mediump"));
                }
                else {
                    this.precision = EGPUPrecision.LOWP;
                    wd.Log.warn(wd.Log.info.FUNC_NOT_SUPPORT("gpu", "highp and mediump, using lowp"));
                }
            }
            else {
                this.precision = EGPUPrecision.HIGHP;
            }
        };
        GPUDetector = __decorate([
            wd.singleton()
        ], GPUDetector);
        return GPUDetector;
    }());
    wd.GPUDetector = GPUDetector;
    (function (EGPUPrecision) {
        EGPUPrecision[EGPUPrecision["HIGHP"] = 0] = "HIGHP";
        EGPUPrecision[EGPUPrecision["MEDIUMP"] = 1] = "MEDIUMP";
        EGPUPrecision[EGPUPrecision["LOWP"] = 2] = "LOWP";
    })(wd.EGPUPrecision || (wd.EGPUPrecision = {}));
    var EGPUPrecision = wd.EGPUPrecision;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EScreenSize) {
        EScreenSize[EScreenSize["FULL"] = 0] = "FULL";
    })(wd.EScreenSize || (wd.EScreenSize = {}));
    var EScreenSize = wd.EScreenSize;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Point = (function () {
        function Point(x, y) {
            if (x === void 0) { x = null; }
            if (y === void 0) { y = null; }
            this.x = null;
            this.y = null;
            this.x = x;
            this.y = y;
        }
        Point.create = function (x, y) {
            if (x === void 0) { x = null; }
            if (y === void 0) { y = null; }
            var obj = new this(x, y);
            return obj;
        };
        return Point;
    }());
    wd.Point = Point;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Face3 = (function () {
        function Face3(aIndex, bIndex, cIndex, faceNormal, vertexNormals) {
            this._faceNormal = null;
            this.aIndex = null;
            this.bIndex = null;
            this.cIndex = null;
            this.vertexNormals = null;
            this.aIndex = aIndex;
            this.bIndex = bIndex;
            this.cIndex = cIndex;
            this._faceNormal = faceNormal;
            this.vertexNormals = vertexNormals;
        }
        Face3.create = function (aIndex, bIndex, cIndex, faceNormal, vertexNormals) {
            if (faceNormal === void 0) { faceNormal = null; }
            if (vertexNormals === void 0) { vertexNormals = wdCb.Collection.create(); }
            var obj = new this(aIndex, bIndex, cIndex, faceNormal, vertexNormals);
            return obj;
        };
        Object.defineProperty(Face3.prototype, "faceNormal", {
            get: function () {
                return this._faceNormal !== null ? this._faceNormal : wd.Vector3.create(0, 0, 0);
            },
            set: function (faceNormal) {
                this._faceNormal = faceNormal;
            },
            enumerable: true,
            configurable: true
        });
        Face3.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Face3.prototype.hasFaceNormal = function () {
            return this._faceNormal !== null;
        };
        Face3.prototype.hasVertexNormal = function () {
            return this.vertexNormals.getCount() > 0;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], Face3.prototype, "_faceNormal", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Face3.prototype, "aIndex", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Face3.prototype, "bIndex", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Face3.prototype, "cIndex", void 0);
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = source[memberName].clone(true);
            })
        ], Face3.prototype, "vertexNormals", void 0);
        return Face3;
    }());
    wd.Face3 = Face3;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RectRegion = (function (_super) {
        __extends(RectRegion, _super);
        function RectRegion() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(RectRegion.prototype, "width", {
            get: function () {
                return this.z;
            },
            set: function (width) {
                this.z = width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RectRegion.prototype, "height", {
            get: function () {
                return this.w;
            },
            set: function (height) {
                this.w = height;
            },
            enumerable: true,
            configurable: true
        });
        RectRegion.prototype.clone = function () {
            return this.copyHelper(RectRegion.create());
        };
        RectRegion.prototype.isNotEmpty = function () {
            return this.x !== 0
                || this.y !== 0
                || this.width !== 0
                || this.height !== 0;
        };
        return RectRegion;
    }(wd.Vector4));
    wd.RectRegion = RectRegion;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ViewWebGL = (function () {
        function ViewWebGL(dom) {
            this._dom = null;
            this._dom = dom;
        }
        ViewWebGL.create = function (view) {
            var obj = new this(view);
            return obj;
        };
        Object.defineProperty(ViewWebGL.prototype, "offset", {
            get: function () {
                var view = this._dom, offset = { x: view.offsetLeft, y: view.offsetTop };
                while (view = view.offsetParent) {
                    offset.x += view.offsetLeft;
                    offset.y += view.offsetTop;
                }
                return offset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewWebGL.prototype, "dom", {
            get: function () {
                return this._dom;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewWebGL.prototype, "width", {
            get: function () {
                return this._dom.clientWidth;
            },
            set: function (width) {
                this._dom.width = width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewWebGL.prototype, "height", {
            get: function () {
                return this._dom.clientHeight;
            },
            set: function (height) {
                this._dom.height = height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewWebGL.prototype, "styleWidth", {
            get: function () {
                return this._dom.style.width;
            },
            set: function (styleWidth) {
                this._dom.style.width = styleWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewWebGL.prototype, "styleHeight", {
            get: function () {
                return this._dom.style.height;
            },
            set: function (styleHeight) {
                this._dom.style.height = styleHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewWebGL.prototype, "x", {
            get: function () {
                return Number(this._dom.style.left.slice(0, -2));
            },
            set: function (x) {
                this._dom.style.left = x + "px";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewWebGL.prototype, "y", {
            get: function () {
                return Number(this._dom.style.top.slice(0, -2));
            },
            set: function (y) {
                this._dom.style.top = y + "px";
            },
            enumerable: true,
            configurable: true
        });
        ViewWebGL.prototype.initCanvas = function () {
            this._dom.style.cssText = "position:absolute;left:0;top:0;";
        };
        ViewWebGL.prototype.getContext = function (contextConfig) {
            return this._dom.getContext("webgl", contextConfig.options) || this._dom.getContext("experimental-webgl", contextConfig.options);
        };
        return ViewWebGL;
    }());
    wd.ViewWebGL = ViewWebGL;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Color = (function () {
        function Color() {
            this._r = null;
            this._g = null;
            this._b = null;
            this._a = null;
            this._colorString = null;
            this._colorVec3Cache = null;
            this._colorVec4Cache = null;
        }
        Color.create = function (colorVal) {
            var obj = new this();
            obj.initWhenCreate(colorVal);
            return obj;
        };
        Object.defineProperty(Color.prototype, "dirty", {
            set: function (dirty) {
                if (dirty) {
                    this._clearCache();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "r", {
            get: function () {
                return this._r;
            },
            set: function (r) {
                if (this._r !== r) {
                    this.dirty = true;
                    this._r = r;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "g", {
            get: function () {
                return this._g;
            },
            set: function (g) {
                if (this._g !== g) {
                    this.dirty = true;
                    this._g = g;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "b", {
            get: function () {
                return this._b;
            },
            set: function (b) {
                if (this._b !== b) {
                    this.dirty = true;
                    this._b = b;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "a", {
            get: function () {
                return this._a;
            },
            set: function (a) {
                if (this._a !== a) {
                    this.dirty = true;
                    this._a = a;
                }
            },
            enumerable: true,
            configurable: true
        });
        Color.prototype.initWhenCreate = function (colorVal) {
            if (!colorVal) {
                return;
            }
            this._colorString = colorVal;
            this._setColor(colorVal);
        };
        Color.prototype.toVector3 = function () {
            return wd.Vector3.create(this.r, this.g, this.b);
        };
        Color.prototype.toVector4 = function () {
            return wd.Vector4.create(this.r, this.g, this.b, this.a);
        };
        Color.prototype.toString = function () {
            return this._colorString;
        };
        Color.prototype.clone = function () {
            return Color.create(this._colorString);
        };
        Color.prototype.isEqual = function (color) {
            return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
        };
        Color.prototype._setColor = function (colorVal) {
            var REGEX_RGBA = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([^\)]+)\)$/i, REGEX_RGBA_2 = /^rgba\((\d+\.\d+),\s*(\d+\.\d+),\s*(\d+\.\d+),\s*([^\)]+)\)$/i, REGEX_RGB = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i, REGEX_RGB_2 = /^rgb\((\d+\.\d+),\s*(\d+\.\d+),\s*(\d+\.\d+)\)$/i, REGEX_NUM = /^\#([0-9a-f]{6})$/i;
            var color = null;
            if (REGEX_RGBA.test(colorVal)) {
                color = REGEX_RGBA.exec(colorVal);
                this.r = this._getColorValue(color, 1);
                this.g = this._getColorValue(color, 2);
                this.b = this._getColorValue(color, 3);
                this.a = Number(color[4]);
                return this;
            }
            if (REGEX_RGBA_2.test(colorVal)) {
                color = REGEX_RGBA_2.exec(colorVal);
                this.r = parseFloat(color[1]);
                this.g = parseFloat(color[2]);
                this.b = parseFloat(color[3]);
                this.a = Number(color[4]);
                return this;
            }
            if (REGEX_RGB.test(colorVal)) {
                color = REGEX_RGB.exec(colorVal);
                this.r = this._getColorValue(color, 1);
                this.g = this._getColorValue(color, 2);
                this.b = this._getColorValue(color, 3);
                this.a = 1;
                return this;
            }
            if (REGEX_RGB_2.test(colorVal)) {
                color = REGEX_RGB_2.exec(colorVal);
                this.r = parseFloat(color[1]);
                this.g = parseFloat(color[2]);
                this.b = parseFloat(color[3]);
                this.a = 1;
                return this;
            }
            if (REGEX_NUM.test(colorVal)) {
                color = REGEX_NUM.exec(colorVal);
                this._setHex(parseInt(color[1], 16));
                return this;
            }
        };
        Color.prototype._getColorValue = function (color, index, num) {
            if (num === void 0) { num = 255; }
            return Math.min(num, parseInt(color[index], 10)) / num;
        };
        Color.prototype._setHex = function (hex) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            this.a = 1;
            return this;
        };
        Color.prototype._clearCache = function () {
            this._colorVec3Cache = null;
            this._colorVec4Cache = null;
        };
        __decorate([
            wd.ensureGetter(function (r) {
                wd.assert(r >= 0, wd.Log.info.FUNC_SHOULD("r", ">= 0, but actual is " + r));
            })
        ], Color.prototype, "r", null);
        __decorate([
            wd.ensureGetter(function (g) {
                wd.assert(g >= 0, wd.Log.info.FUNC_SHOULD("g", ">= 0, but actual is " + g));
            })
        ], Color.prototype, "g", null);
        __decorate([
            wd.ensureGetter(function (b) {
                wd.assert(b >= 0, wd.Log.info.FUNC_SHOULD("b", ">= 0, but actual is " + b));
            })
        ], Color.prototype, "b", null);
        __decorate([
            wd.ensureGetter(function (a) {
                wd.assert(a >= 0, wd.Log.info.FUNC_SHOULD("a", ">= 0, but actual is " + a));
            })
        ], Color.prototype, "a", null);
        __decorate([
            wd.cache(function () {
                return this._colorVec3Cache !== null;
            }, function () {
                return this._colorVec3Cache;
            }, function (result) {
                this._colorVec3Cache = result;
            })
        ], Color.prototype, "toVector3", null);
        __decorate([
            wd.cache(function () {
                return this._colorVec4Cache !== null;
            }, function () {
                return this._colorVec4Cache;
            }, function (result) {
                this._colorVec4Cache = result;
            })
        ], Color.prototype, "toVector4", null);
        return Color;
    }());
    wd.Color = Color;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            _super.apply(this, arguments);
            this.name = "";
            this.material = null;
            this.width = null;
            this.height = null;
            this.variableData = null;
            this.wrapS = null;
            this.wrapT = null;
            this.magFilter = null;
            this.minFilter = null;
            this.glTexture = null;
            this.needUpdate = null;
            this.target = wd.ETextureTarget.TEXTURE_2D;
        }
        Object.defineProperty(Texture.prototype, "geometry", {
            get: function () {
                return this.material.geometry;
            },
            enumerable: true,
            configurable: true
        });
        Texture.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        Texture.prototype.bindToUnit = function (unit) {
            var gl = wd.DeviceManager.getInstance().gl;
            if (wd.TextureCache.isCached(unit, this)) {
                return;
            }
            wd.TextureCache.addActiveTexture(unit, this);
            gl.activeTexture(gl["TEXTURE" + String(unit)]);
            gl.bindTexture(gl[this.target], this.glTexture);
            return this;
        };
        Texture.prototype.sendData = function (program, name, unit) {
            program.sendUniformData(name, this.getSamplerType(), unit);
        };
        Texture.prototype.dispose = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.deleteTexture(this.glTexture);
            delete this.glTexture;
            this._unBindAllUnit();
        };
        Texture.prototype.filterFallback = function (filter) {
            if (filter === wd.ETextureFilterMode.NEAREST || filter === wd.ETextureFilterMode.NEAREST_MIPMAP_MEAREST || filter === wd.ETextureFilterMode.NEAREST_MIPMAP_LINEAR) {
                return wd.ETextureFilterMode.NEAREST;
            }
            return wd.ETextureFilterMode.LINEAR;
        };
        Texture.prototype.getSamplerNameByVariableData = function (unit, type) {
            var samplerName = null;
            if (this.variableData) {
                if (this.variableData.samplerVariableName) {
                    samplerName = this.variableData.samplerVariableName;
                }
            }
            else {
                samplerName = type === wd.EVariableType.SAMPLER_2D ? "u_sampler2D" + unit : "u_samplerCube" + unit;
            }
            return samplerName;
        };
        Texture.prototype.getSamplerType = function () {
            var type = null;
            switch (this.target) {
                case wd.ETextureTarget.TEXTURE_2D:
                    type = wd.EVariableType.SAMPLER_2D;
                    break;
                case wd.ETextureTarget.TEXTURE_CUBE_MAP:
                    type = wd.EVariableType.SAMPLER_CUBE;
                    break;
                default:
                    break;
            }
            return type;
        };
        Texture.prototype.isSourcePowerOfTwo = function () {
            return wd.TextureUtils.isPowerOfTwo(this.width, this.height);
        };
        Texture.prototype.setTextureParameters = function (textureType, isSourcePowerOfTwo) {
            var gl = wd.DeviceManager.getInstance().gl;
            if (isSourcePowerOfTwo) {
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, gl[this.wrapS]);
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, gl[this.wrapT]);
                gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, gl[this.magFilter]);
                gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, gl[this.minFilter]);
            }
            else {
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, gl[this.filterFallback(this.magFilter)]);
                gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, gl[this.filterFallback(this.minFilter)]);
            }
        };
        Texture.prototype._unBindAllUnit = function () {
            var gl = wd.DeviceManager.getInstance().gl, maxTextureUnit = wd.GPUDetector.getInstance().maxTextureUnit;
            for (var channel = 0; channel < maxTextureUnit; channel++) {
                gl.activeTexture(gl["TEXTURE" + channel]);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            }
            wd.TextureCache.clearAllBindTextureUnitCache();
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "name", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "material", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "width", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "height", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "variableData", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "wrapS", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "wrapT", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "magFilter", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "minFilter", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], Texture.prototype, "needUpdate", void 0);
        __decorate([
            wd.require(function (unit, texture) {
                var maxTextureUnit = wd.GPUDetector.getInstance().maxTextureUnit;
                wd.assert(unit >= 0, wd.Log.info.FUNC_SHOULD("texture unit", ">= 0, but actual is " + unit));
                wd.assert(unit < maxTextureUnit, "trying to cache " + unit + " texture units, but GPU only supports " + maxTextureUnit + " units");
            })
        ], Texture.prototype, "bindToUnit", null);
        __decorate([
            wd.virtual
        ], Texture.prototype, "isSourcePowerOfTwo", null);
        return Texture;
    }(wd.Entity));
    wd.Texture = Texture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TextureUtils = (function () {
        function TextureUtils() {
        }
        TextureUtils.isPowerOfTwo = function (width, height) {
            return wd.JudgeUtils.isPowerOfTwo(width) && wd.JudgeUtils.isPowerOfTwo(height);
        };
        return TextureUtils;
    }());
    wd.TextureUtils = TextureUtils;
})(wd || (wd = {}));
var wd;
(function (wd_1) {
    var BasicTextureUtils = (function (_super) {
        __extends(BasicTextureUtils, _super);
        function BasicTextureUtils() {
            _super.apply(this, arguments);
        }
        BasicTextureUtils.isDrawPartOfTexture = function (sourceRegion, sourceRegionMethod) {
            return sourceRegion && sourceRegion.isNotEmpty() && sourceRegionMethod === wd_1.ETextureSourceRegionMethod.DRAW_IN_CANVAS;
        };
        BasicTextureUtils.drawPartOfTextureByCanvas = function (source, canvasWidth, canvasHeight, sx, sy, sWidth, sHeight, dx, wd, dWidth, dHeight) {
            var canvas = wdCb.DomQuery.create("<canvas></canvas>").get(0), ctx = null;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            ctx = canvas.getContext("2d");
            ctx.drawImage(source, sx, sy, sWidth, sHeight, dx, wd, dWidth, dHeight);
            return canvas;
        };
        BasicTextureUtils.isSourcePowerOfTwo = function (sourceRegion, sourceRegionMethod, width, height) {
            if (this.isDrawPartOfTexture(sourceRegion, sourceRegionMethod)) {
                return this.isPowerOfTwo(sourceRegion.width, sourceRegion.height);
            }
            return this.isPowerOfTwo(width, height);
        };
        BasicTextureUtils.needClampMaxSize = function (maxSize, width, height) {
            return width > maxSize || height > maxSize;
        };
        BasicTextureUtils.clampToMaxSize = function (source, maxSize) {
            var maxDimension = null, newWidth = null, newHeight = null, canvas = null;
            maxDimension = Math.max(source.width, source.height);
            newWidth = Math.floor(source.width * maxSize / maxDimension);
            newHeight = Math.floor(source.height * maxSize / maxDimension);
            canvas = this.drawPartOfTextureByCanvas(source, newWidth, newHeight, 0, 0, source.width, source.height, 0, 0, newWidth, newHeight);
            wd_1.Log.log("source is too big (width:" + source.width + ", height:" + source.height + "), resize it to be width:" + canvas.width + ", height:" + canvas.height + ".");
            return canvas;
        };
        return BasicTextureUtils;
    }(wd_1.TextureUtils));
    wd_1.BasicTextureUtils = BasicTextureUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RenderTargetTexture = (function (_super) {
        __extends(RenderTargetTexture, _super);
        function RenderTargetTexture() {
            _super.apply(this, arguments);
            this._renderRate = 1;
        }
        Object.defineProperty(RenderTargetTexture.prototype, "renderRate", {
            get: function () {
                return this._renderRate;
            },
            set: function (renderRate) {
                this._renderRate = renderRate;
            },
            enumerable: true,
            configurable: true
        });
        RenderTargetTexture.prototype.initWhenCreate = function () {
            this.needUpdate = false;
            this.minFilter = wd.ETextureFilterMode.LINEAR;
            this.magFilter = wd.ETextureFilterMode.LINEAR;
            this.wrapS = wd.ETextureWrapMode.CLAMP_TO_EDGE;
            this.wrapT = wd.ETextureWrapMode.CLAMP_TO_EDGE;
        };
        RenderTargetTexture.prototype.init = function () {
        };
        RenderTargetTexture.prototype.update = function () {
        };
        RenderTargetTexture.prototype.getPosition = function () {
            return this.geometry.entityObject.transform.position;
        };
        RenderTargetTexture.prototype.setEmptyTexture = function (texture) {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.bindTexture(gl[this.target], texture);
            this.setTextureParameters(gl[this.target], this.isSourcePowerOfTwo());
        };
        __decorate([
            wd.require(function (texture) {
                wd.assert(!!texture, wd.Log.info.FUNC_NOT_EXIST("texture object"));
            })
        ], RenderTargetTexture.prototype, "setEmptyTexture", null);
        return RenderTargetTexture;
    }(wd.Texture));
    wd.RenderTargetTexture = RenderTargetTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDRenderTargetTexture = (function (_super) {
        __extends(TwoDRenderTargetTexture, _super);
        function TwoDRenderTargetTexture() {
            _super.apply(this, arguments);
            this._renderList = null;
        }
        Object.defineProperty(TwoDRenderTargetTexture.prototype, "renderList", {
            get: function () {
                return this._renderList;
            },
            set: function (renderList) {
                if (wd.JudgeUtils.isArrayExactly(renderList)) {
                    this._renderList = wdCb.Collection.create(renderList);
                }
                else {
                    this._renderList = renderList;
                }
            },
            enumerable: true,
            configurable: true
        });
        TwoDRenderTargetTexture.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.width = 256;
            this.height = 256;
        };
        TwoDRenderTargetTexture.prototype.createEmptyTexture = function () {
            var gl = wd.DeviceManager.getInstance().gl, texture = gl.createTexture();
            this.setEmptyTexture(texture);
            this.texImageEmpty();
            this.glTexture = texture;
        };
        TwoDRenderTargetTexture.prototype.texImageEmpty = function () {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.texImage2D(gl[this.target], 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        };
        __decorate([
            wd.requireSetter(function (renderList) {
                wd.assert(wd.JudgeUtils.isArrayExactly(renderList) || wd.JudgeUtils.isCollection(renderList), wd.Log.info.FUNC_MUST_BE("renderList", "array or collection"));
            }),
            wd.cloneAttributeAsCloneable()
        ], TwoDRenderTargetTexture.prototype, "renderList", null);
        __decorate([
            wd.virtual
        ], TwoDRenderTargetTexture.prototype, "texImageEmpty", null);
        return TwoDRenderTargetTexture;
    }(wd.RenderTargetTexture));
    wd.TwoDRenderTargetTexture = TwoDRenderTargetTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowMapTextureUtils = (function () {
        function ShadowMapTextureUtils() {
        }
        ShadowMapTextureUtils.setTextureParameters = function (textureType) {
            var gl = wd.DeviceManager.getInstance().gl, scene = wd.Director.getInstance().scene;
            if (scene.shadowMap.softType === wd.EShadowMapSoftType.PCF) {
                gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            }
        };
        return ShadowMapTextureUtils;
    }());
    wd.ShadowMapTextureUtils = ShadowMapTextureUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ProceduralTexture = (function (_super) {
        __extends(ProceduralTexture, _super);
        function ProceduralTexture() {
            _super.apply(this, arguments);
            this.repeatRegion = wd.RectRegion.create(0, 0, 1, 1);
        }
        Object.defineProperty(ProceduralTexture.prototype, "sourceRegionForGLSL", {
            get: function () {
                return wd.RectRegion.create(0, 0, 1, 1);
            },
            enumerable: true,
            configurable: true
        });
        ProceduralTexture.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.renderRate = 0;
        };
        ProceduralTexture.prototype.getSamplerName = function (unit) {
            return this.getSamplerNameByVariableData(unit, wd.EVariableType.SAMPLER_2D);
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], ProceduralTexture.prototype, "repeatRegion", void 0);
        return ProceduralTexture;
    }(wd.TwoDRenderTargetTexture));
    wd.ProceduralTexture = ProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CustomProceduralTexture = (function (_super) {
        __extends(CustomProceduralTexture, _super);
        function CustomProceduralTexture() {
            _super.apply(this, arguments);
            this.mapManager = wd.MapManager.create();
            this.uniformMap = wdCb.Hash.create();
            this.fsSource = null;
        }
        CustomProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        CustomProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.CustomProceduralRenderTargetRenderer.create(this));
            this.mapManager.init();
            return this;
        };
        CustomProceduralTexture.prototype.read = function (shaderConfigId) {
            var shaderConfig = wd.LoaderManager.getInstance().get(shaderConfigId), uniforms = shaderConfig.uniforms;
            this.fsSource = wd.LoaderManager.getInstance().get(shaderConfig.fsSourceId);
            this.renderRate = shaderConfig.renderRate || 0;
            for (var name_4 in uniforms) {
                if (uniforms.hasOwnProperty(name_4)) {
                    var uniform = uniforms[name_4];
                    if (uniform.type === wd.EVariableType.SAMPLER_2D) {
                        this.mapManager.addMap(wd.LoaderManager.getInstance().get(uniform.textureId), {
                            samplerVariableName: name_4
                        });
                    }
                    else {
                        this.uniformMap.addChild(name_4, uniform);
                    }
                }
            }
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                source[memberName].getMapList().forEach(function (map) {
                    target[memberName].addMap(map.clone());
                });
            })
        ], CustomProceduralTexture.prototype, "mapManager", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], CustomProceduralTexture.prototype, "uniformMap", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], CustomProceduralTexture.prototype, "fsSource", void 0);
        __decorate([
            wd.require(function (shaderConfigId) {
                var shaderConfig = wd.LoaderManager.getInstance().get(shaderConfigId), uniforms = shaderConfig.uniforms;
                for (var name_5 in uniforms) {
                    if (uniforms.hasOwnProperty(name_5)) {
                        var uniform = uniforms[name_5];
                        wd.assert(uniform.type !== wd.EVariableType.SAMPLER_CUBE, wd.Log.info.FUNC_NOT_SUPPORT("uniforms", "EVariableType.SAMPLER_CUBE type"));
                    }
                }
            }),
            wd.ensure(function () {
                wd.assert(this.fsSource !== null, wd.Log.info.FUNC_SHOULD("read fragment glsl source"));
            })
        ], CustomProceduralTexture.prototype, "read", null);
        return CustomProceduralTexture;
    }(wd.ProceduralTexture));
    wd.CustomProceduralTexture = CustomProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var LightEffectTexture = (function (_super) {
        __extends(LightEffectTexture, _super);
        function LightEffectTexture() {
            _super.apply(this, arguments);
            this._plane = null;
        }
        LightEffectTexture.prototype.getSamplerName = function (unit) {
            return this.getSamplerNameByVariableData(unit, wd.EVariableType.SAMPLER_2D);
        };
        LightEffectTexture.prototype.getPlane = function () {
            var normalData = null, normal = null, p = null;
            if (this._plane && !this.geometry.entityObject.transform.dirtyLocal) {
                return this._plane;
            }
            wd.Log.error(!(this.geometry instanceof wd.PlaneGeometry), wd.Log.info.FUNC_MUST_BE("geometry", "PlaneGeometry"));
            normalData = this.geometry.geometryData.normals;
            normal = this.geometry.entityObject.transform.localRotation.multiplyVector3(wd.Vector3.create(normalData[0], normalData[1], normalData[2])).normalize();
            p = this.getPosition();
            this._plane = wd.Plane.create(normal.x, normal.y, normal.z, -p.dot(normal));
            return this._plane;
        };
        return LightEffectTexture;
    }(wd.TwoDRenderTargetTexture));
    wd.LightEffectTexture = LightEffectTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MirrorTexture = (function (_super) {
        __extends(MirrorTexture, _super);
        function MirrorTexture() {
            _super.apply(this, arguments);
        }
        MirrorTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        MirrorTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addCommonRenderTargetRenderer(wd.MirrorRenderTargetRenderer.create(this));
            return this;
        };
        return MirrorTexture;
    }(wd.LightEffectTexture));
    wd.MirrorTexture = MirrorTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RefractionTexture = (function (_super) {
        __extends(RefractionTexture, _super);
        function RefractionTexture() {
            _super.apply(this, arguments);
        }
        RefractionTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        RefractionTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addCommonRenderTargetRenderer(wd.RefractionRenderTargetRenderer.create(this));
            return this;
        };
        return RefractionTexture;
    }(wd.LightEffectTexture));
    wd.RefractionTexture = RefractionTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDShadowMapTexture = (function (_super) {
        __extends(TwoDShadowMapTexture, _super);
        function TwoDShadowMapTexture() {
            _super.apply(this, arguments);
        }
        TwoDShadowMapTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        TwoDShadowMapTexture.prototype.getSamplerName = function (unit) {
            return "u_twoDShadowMapSampler[" + this.variableData.samplerData + "]";
        };
        TwoDShadowMapTexture.prototype.setTextureParameters = function (textureType, isSourcePowerOfTwo) {
            _super.prototype.setTextureParameters.call(this, textureType, isSourcePowerOfTwo);
            wd.ShadowMapTextureUtils.setTextureParameters(textureType);
        };
        TwoDShadowMapTexture.prototype.texImageEmpty = function () {
            if (wd.GPUDetector.getInstance().extensionDepthTexture) {
                var gl = wd.DeviceManager.getInstance().gl;
                gl.texImage2D(gl[this.target], 0, gl.DEPTH_COMPONENT, this.width, this.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
                return;
            }
            _super.prototype.texImageEmpty.call(this);
        };
        __decorate([
            wd.require(function (unit) {
                wd.assert(wd.JudgeUtils.isNumber(this.variableData.samplerData), wd.Log.info.FUNC_MUST_BE("shadowMapTexture->variableData.samplerData", "samplerIndex"));
            })
        ], TwoDShadowMapTexture.prototype, "getSamplerName", null);
        return TwoDShadowMapTexture;
    }(wd.TwoDRenderTargetTexture));
    wd.TwoDShadowMapTexture = TwoDShadowMapTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapRenderTargetTexture = (function (_super) {
        __extends(CubemapRenderTargetTexture, _super);
        function CubemapRenderTargetTexture() {
            _super.apply(this, arguments);
            this.target = wd.ETextureTarget.TEXTURE_CUBE_MAP;
        }
        CubemapRenderTargetTexture.prototype.createEmptyTexture = function () {
            var gl = wd.DeviceManager.getInstance().gl, texture = gl.createTexture(), i = null;
            this.setEmptyTexture(texture);
            for (i = 0; i < 6; i++) {
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            }
            this.glTexture = texture;
        };
        return CubemapRenderTargetTexture;
    }(wd.RenderTargetTexture));
    wd.CubemapRenderTargetTexture = CubemapRenderTargetTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapShadowMapTexture = (function (_super) {
        __extends(CubemapShadowMapTexture, _super);
        function CubemapShadowMapTexture() {
            _super.apply(this, arguments);
        }
        CubemapShadowMapTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        CubemapShadowMapTexture.prototype.getSamplerName = function (unit) {
            return "u_cubemapShadowMapSampler[" + this.variableData.samplerData + "]";
        };
        __decorate([
            wd.require(function (unit) {
                wd.assert(wd.JudgeUtils.isNumber(this.variableData.samplerData), wd.Log.info.FUNC_MUST_BE("shadowMapTexture->variableData.samplerData", "samplerIndex"));
            })
        ], CubemapShadowMapTexture.prototype, "getSamplerName", null);
        return CubemapShadowMapTexture;
    }(wd.CubemapRenderTargetTexture));
    wd.CubemapShadowMapTexture = CubemapShadowMapTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DynamicCubemapTexture = (function (_super) {
        __extends(DynamicCubemapTexture, _super);
        function DynamicCubemapTexture() {
            _super.apply(this, arguments);
            this._renderList = null;
            this.size = 256;
            this.near = 0.1;
            this.far = 100;
            this.mode = null;
        }
        DynamicCubemapTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(DynamicCubemapTexture.prototype, "renderList", {
            get: function () {
                return this._renderList;
            },
            set: function (renderList) {
                var convertedRenderList = wdCb.Hash.create();
                if (renderList instanceof wdCb.Hash) {
                }
                else if (wd.JudgeUtils.isDirectObject(renderList)) {
                    renderList = wdCb.Hash.create(renderList);
                }
                else {
                    wd.Log.error(true, wd.Log.info.FUNC_MUST_BE("renderList", "array or wdCb.Collection"));
                }
                renderList.forEach(function (faceRenderList, face) {
                    if (wd.JudgeUtils.isArrayExactly(faceRenderList)) {
                        convertedRenderList.addChild(face, wdCb.Collection.create(faceRenderList));
                    }
                    else if (wd.JudgeUtils.isCollection(faceRenderList)) {
                        convertedRenderList.addChild(face, faceRenderList);
                    }
                    else {
                        wd.Log.error(true, wd.Log.info.FUNC_MUST_BE("faceRenderList", "array or wdCb.Collection"));
                    }
                });
                this._renderList = convertedRenderList;
            },
            enumerable: true,
            configurable: true
        });
        DynamicCubemapTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            this.width = this.size;
            this.height = this.size;
            wd.Director.getInstance().scene.addCommonRenderTargetRenderer(wd.DynamicCubemapRenderTargetRenderer.create(this));
            return this;
        };
        DynamicCubemapTexture.prototype.getSamplerName = function (unit) {
            return this.getSamplerNameByVariableData(unit, wd.EVariableType.SAMPLER_CUBE);
        };
        __decorate([
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                var result = null;
                if (source[memberName] === null) {
                    return;
                }
                result = wdCb.Hash.create();
                source[memberName].forEach(function (list, key) {
                    result.addChild(key, list.clone());
                });
                target[memberName] = result;
            })
        ], DynamicCubemapTexture.prototype, "renderList", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DynamicCubemapTexture.prototype, "size", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DynamicCubemapTexture.prototype, "near", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DynamicCubemapTexture.prototype, "far", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], DynamicCubemapTexture.prototype, "mode", void 0);
        return DynamicCubemapTexture;
    }(wd.CubemapRenderTargetTexture));
    wd.DynamicCubemapTexture = DynamicCubemapTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicTexture = (function (_super) {
        __extends(BasicTexture, _super);
        function BasicTexture() {
            _super.apply(this, arguments);
            this.p_sourceRegionMethod = null;
            this._sourceRegion = null;
            this.generateMipmaps = null;
            this.format = null;
            this.source = null;
            this.repeatRegion = null;
            this.sourceRegionMapping = null;
            this.packAlignment = null;
            this.unpackAlignment = null;
            this.flipY = null;
            this.premultiplyAlpha = null;
            this.isPremultipliedAlpha = null;
            this.colorspaceConversion = null;
            this.type = null;
            this.mipmaps = null;
            this.anisotropy = null;
            this._sourceRegionDirty = false;
            this._sourceRegionForGLSLCache = null;
        }
        Object.defineProperty(BasicTexture.prototype, "sourceRegionMethod", {
            get: function () {
                return this.p_sourceRegionMethod;
            },
            set: function (sourceRegionMethod) {
                this.p_sourceRegionMethod = sourceRegionMethod;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicTexture.prototype, "sourceRegion", {
            get: function () {
                return this._sourceRegion;
            },
            set: function (sourceRegion) {
                this._sourceRegion = sourceRegion;
                this._sourceRegionDirty = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BasicTexture.prototype, "sourceRegionForGLSL", {
            get: function () {
                if (this.sourceRegion && this.sourceRegionMethod === wd.ETextureSourceRegionMethod.CHANGE_TEXCOORDS_IN_GLSL) {
                    return this._convertSourceRegionToUV(this.sourceRegion);
                }
                return wd.RectRegion.create(0, 0, 1, 1);
            },
            enumerable: true,
            configurable: true
        });
        BasicTexture.prototype.initWhenCreate = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            this.needUpdate = true;
        };
        BasicTexture.prototype.init = function () {
            if (this.glTexture === null) {
                var gl = wd.DeviceManager.getInstance().gl;
                this.glTexture = gl.createTexture();
            }
        };
        BasicTexture.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._sourceRegionForGLSLCache = null;
        };
        BasicTexture.prototype.update = function () {
            var gl = wd.DeviceManager.getInstance().gl, isSourcePowerOfTwo = this.isSourcePowerOfTwo();
            gl.pixelStorei(gl.PACK_ALIGNMENT, this.packAlignment);
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
            gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this.colorspaceConversion);
            if (this.needClampMaxSize()) {
                this.clampToMaxSize();
                isSourcePowerOfTwo = this.isSourcePowerOfTwo();
                if (!isSourcePowerOfTwo) {
                    wd.Log.warn("texture size is not power of two after clampToMaxSize()");
                }
            }
            this.setTextureParameters(gl[this.target], isSourcePowerOfTwo);
            this.allocateSourceToTexture(isSourcePowerOfTwo);
            if (this.generateMipmaps && isSourcePowerOfTwo) {
                gl.generateMipmap(gl[this.target]);
            }
            this.needUpdate = false;
            return this;
        };
        BasicTexture.prototype.getSamplerName = function (unit) {
            return this.getSamplerNameByVariableData(unit, wd.EVariableType.SAMPLER_2D);
        };
        BasicTexture.prototype.needClampMaxSize = function () {
            if (!this.source) {
                return false;
            }
            return wd.BasicTextureUtils.needClampMaxSize(wd.GPUDetector.getInstance().maxTextureSize, this.source.width, this.source.height);
        };
        BasicTexture.prototype.clampToMaxSize = function () {
            this.source = wd.BasicTextureUtils.clampToMaxSize(this.source, wd.GPUDetector.getInstance().maxTextureSize);
        };
        BasicTexture.prototype.setTextureParameters = function (textureType, isSourcePowerOfTwo) {
            _super.prototype.setTextureParameters.call(this, textureType, isSourcePowerOfTwo);
            this._setAnisotropy(textureType);
        };
        BasicTexture.prototype.isSourcePowerOfTwo = function () {
            return wd.BasicTextureUtils.isSourcePowerOfTwo(this.sourceRegion, this.sourceRegionMethod, this.width, this.height);
        };
        BasicTexture.prototype._setAnisotropy = function (textureType) {
            var gpu = wd.GPUDetector.getInstance(), gl = wd.DeviceManager.getInstance().gl;
            if (!gpu.extensionTextureFilterAnisotropic) {
                return;
            }
            if (this.anisotropy > 1) {
                gl.texParameterf(textureType, gpu.extensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this.anisotropy, gpu.maxAnisotropy));
            }
        };
        BasicTexture.prototype._convertSourceRegionToUV = function (sourceRegion) {
            if (this.sourceRegionMapping === wd.ETextureSourceRegionMapping.CANVAS) {
                return wd.GlobalTextureUtils.convertSourceRegionCanvasMapToUV(sourceRegion, this.width, this.height);
            }
            else if (this.sourceRegionMapping === wd.ETextureSourceRegionMapping.UV) {
                return sourceRegion;
            }
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "sourceRegionMethod", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BasicTexture.prototype, "sourceRegion", null);
        __decorate([
            wd.cacheGetter(function () {
                return !this._sourceRegionDirty && this._sourceRegionForGLSLCache !== null;
            }, function () {
                return this._sourceRegionForGLSLCache;
            }, function (result) {
                this._sourceRegionForGLSLCache = result;
                this._sourceRegionDirty = false;
            })
        ], BasicTexture.prototype, "sourceRegionForGLSL", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "generateMipmaps", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "format", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "source", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BasicTexture.prototype, "repeatRegion", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "sourceRegionMapping", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "packAlignment", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "unpackAlignment", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "flipY", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "premultiplyAlpha", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "isPremultipliedAlpha", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "colorspaceConversion", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "type", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BasicTexture.prototype, "mipmaps", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BasicTexture.prototype, "anisotropy", void 0);
        __decorate([
            wd.require(function (isSourcePowerOfTwo) {
                var _this = this;
                wd.it("if repeat texture and draw part of texture by changing texcoords in glsl, warn", function () {
                    if (!wd.BasicTextureUtils.isDrawPartOfTexture(_this.sourceRegion, _this.sourceRegionMethod)
                        && (_this.repeatRegion && !_this.repeatRegion.isEqual(wd.Vector4.create(0, 0, 1, 1)))) {
                        wd.Log.warn("the glsl->texCoord data may be wrong due to both repeating texture and drawing part of texture by changing texcoords in glsl");
                    }
                }, this);
            })
        ], BasicTexture.prototype, "update", null);
        __decorate([
            wd.virtual
        ], BasicTexture.prototype, "needClampMaxSize", null);
        return BasicTexture;
    }(wd.Texture));
    wd.BasicTexture = BasicTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDTexture = (function (_super) {
        __extends(TwoDTexture, _super);
        function TwoDTexture(asset) {
            _super.call(this);
            this.asset = null;
            this.asset = asset;
        }
        TwoDTexture.prototype.clone = function () {
            return wd.CloneUtils.clone(this, null, [this.asset]);
        };
        TwoDTexture.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.asset.cloneTo(this);
        };
        return TwoDTexture;
    }(wd.BasicTexture));
    wd.TwoDTexture = TwoDTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonTexture = (function (_super) {
        __extends(CommonTexture, _super);
        function CommonTexture() {
            _super.apply(this, arguments);
        }
        CommonTexture.prototype.allocateSourceToTexture = function (isSourcePowerOfTwo) {
            var mipmapCmd = null, noMipmapCmd = null, gl = wd.DeviceManager.getInstance().gl;
            if (isSourcePowerOfTwo && this.mipmaps.getCount() > 0) {
                mipmapCmd = wd.DrawMipmapTwoDTextureCommand.create();
                mipmapCmd.mipmaps = this.mipmaps;
                mipmapCmd.format = this.format;
                mipmapCmd.type = this.type;
                mipmapCmd.sourceRegion = this.sourceRegion;
                mipmapCmd.sourceRegionMethod = this.sourceRegionMethod;
                mipmapCmd.glTarget = gl.TEXTURE_2D;
                mipmapCmd.execute();
                this.generateMipmaps = false;
            }
            else {
                noMipmapCmd = wd.DrawNoMipmapTwoDTextureCommand.create();
                noMipmapCmd.source = this.source;
                noMipmapCmd.format = this.format;
                noMipmapCmd.type = this.type;
                noMipmapCmd.sourceRegion = this.sourceRegion;
                noMipmapCmd.sourceRegionMethod = this.sourceRegionMethod;
                noMipmapCmd.glTarget = gl.TEXTURE_2D;
                noMipmapCmd.execute();
            }
        };
        return CommonTexture;
    }(wd.TwoDTexture));
    wd.CommonTexture = CommonTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ImageTexture = (function (_super) {
        __extends(ImageTexture, _super);
        function ImageTexture(arg) {
            if (arg instanceof wd.ImageTextureAsset) {
                var asset = arg;
                _super.call(this, asset);
            }
            else {
                var canvas = arg;
                _super.call(this, wd.ImageTextureAsset.create(canvas));
            }
        }
        ImageTexture.create = function (arg) {
            var obj = new this(arg);
            obj.initWhenCreate();
            return obj;
        };
        return ImageTexture;
    }(wd.CommonTexture));
    wd.ImageTexture = ImageTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VideoTexture = (function (_super) {
        __extends(VideoTexture, _super);
        function VideoTexture() {
            _super.apply(this, arguments);
            this._video = null;
            this._startLoopSubscription = null;
        }
        VideoTexture.create = function (asset) {
            var obj = new this(asset);
            obj.initWhenCreate();
            return obj;
        };
        VideoTexture.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this._video = this.asset.video;
        };
        VideoTexture.prototype.init = function () {
            var self = this;
            _super.prototype.init.call(this);
            this._startLoopSubscription = wd.EventManager.fromEvent(wd.EEngineEvent.STARTLOOP)
                .subscribe(function () {
                if (self._video.isStop) {
                    self.needUpdate = false;
                }
                else {
                    self.needUpdate = true;
                }
            });
            return this;
        };
        VideoTexture.prototype.dispose = function () {
            this._startLoopSubscription && this._startLoopSubscription.dispose();
        };
        VideoTexture.prototype.needClampMaxSize = function () {
            return false;
        };
        return VideoTexture;
    }(wd.CommonTexture));
    wd.VideoTexture = VideoTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapTexture = (function (_super) {
        __extends(CubemapTexture, _super);
        function CubemapTexture(assets) {
            _super.call(this);
            this.assets = null;
            this.textures = wdCb.Collection.create();
            this.mode = null;
            this.target = wd.ETextureTarget.TEXTURE_CUBE_MAP;
            this._areAllCompressedAsset = false;
            this.assets = assets;
        }
        CubemapTexture.create = function (assets) {
            var obj = new this(assets);
            obj.initWhenCreate(assets);
            return obj;
        };
        CubemapTexture.prototype.clone = function () {
            var resultAssets = null;
            if (this.assets !== null) {
                resultAssets = [].concat(this.assets);
            }
            else {
                resultAssets = null;
            }
            return wd.CloneUtils.clone(this, null, [resultAssets]);
        };
        CubemapTexture.prototype.initWhenCreate = function (assets) {
            _super.prototype.initWhenCreate.call(this);
            if (this._areAssetsAllCompressedAsset(assets)) {
                this._areAllCompressedAsset = true;
            }
            else {
                this._areAllCompressedAsset = false;
            }
            this._createTextures(assets);
            this._getRepresentAsset(assets).cloneToCubemapTexture(this);
            if (this._areAllCompressedAsset) {
                this.generateMipmaps = false;
                if (this._hasNoMipmapCompressedAsset()) {
                    this.minFilter = this.filterFallback(this.minFilter);
                }
            }
            else {
                this.generateMipmaps = true;
            }
            this.flipY = false;
        };
        CubemapTexture.prototype.getSamplerName = function (unit) {
            return this.getSamplerNameByVariableData(unit, wd.EVariableType.SAMPLER_CUBE);
        };
        CubemapTexture.prototype.allocateSourceToTexture = function (isSourcePowerOfTwo) {
            if (this._areAllCompressedAsset) {
                this.textures.forEach(function (texture, i) {
                    texture.draw(i);
                });
            }
            else {
                this.textures.forEach(function (texture, i) {
                    texture.draw(i);
                });
            }
        };
        CubemapTexture.prototype.needClampMaxSize = function () {
            var needAllClampMaxSize = false;
            this.textures.forEach(function (texture) {
                if (texture.needClampMaxSize()) {
                    needAllClampMaxSize = true;
                    return wdCb.$BREAK;
                }
            });
            return needAllClampMaxSize;
        };
        CubemapTexture.prototype.isSourcePowerOfTwo = function () {
            var areAllSourcePowerOfTwo = true;
            this.textures.forEach(function (texture) {
                if (!texture.isSourcePowerOfTwo()) {
                    areAllSourcePowerOfTwo = false;
                    return wdCb.$BREAK;
                }
            });
            return areAllSourcePowerOfTwo;
        };
        CubemapTexture.prototype.clampToMaxSize = function () {
            this.textures.forEach(function (texture) {
                texture.clampToMaxSize();
            });
        };
        CubemapTexture.prototype._hasNoMipmapCompressedAsset = function () {
            var self = this;
            if (!this._areAllCompressedAsset) {
                return false;
            }
            return this.textures.filter(function (texture) {
                return !self._isMipmapFilter(texture.minFilter);
            }).getCount() > 0;
        };
        CubemapTexture.prototype._isMipmapFilter = function (filter) {
            return filter === wd.ETextureFilterMode.LINEAR_MIPMAP_LINEAR || filter === wd.ETextureFilterMode.LINEAR_MIPMAP_NEAREST || filter === wd.ETextureFilterMode.NEAREST_MIPMAP_LINEAR || filter === wd.ETextureFilterMode.NEAREST_MIPMAP_MEAREST;
        };
        CubemapTexture.prototype._getRepresentAsset = function (assets) {
            return assets[0].asset;
        };
        CubemapTexture.prototype._areAssetsAllImageAssets = function (assets) {
            var areImageAssets = [];
            for (var _i = 0, assets_1 = assets; _i < assets_1.length; _i++) {
                var data = assets_1[_i];
                if (data.asset instanceof wd.ImageTextureAsset) {
                    areImageAssets.push(data);
                }
            }
            return areImageAssets.length === 6;
        };
        CubemapTexture.prototype._areAssetsAllCompressedAsset = function (assets) {
            var areCompressedAssets = [];
            for (var _i = 0, assets_2 = assets; _i < assets_2.length; _i++) {
                var data = assets_2[_i];
                if (data.asset instanceof wd.CompressedTextureAsset) {
                    areCompressedAssets.push(data);
                }
            }
            return areCompressedAssets.length === 6;
        };
        CubemapTexture.prototype._createTextures = function (assets) {
            var self = this;
            for (var _i = 0, assets_3 = assets; _i < assets_3.length; _i++) {
                var data = assets_3[_i];
                var face = data.asset.toCubemapFaceTexture();
                if (data.sourceRegion && face instanceof wd.CubemapFaceImageTexture) {
                    var twoDFace = face;
                    twoDFace.sourceRegion = data.sourceRegion;
                }
                if (data.type) {
                    face.type = data.type;
                }
                self.textures.addChild(face);
            }
        };
        CubemapTexture.prototype._areTextureSizOfAllFaceseEqual = function (assets) {
            var textureWidthSizeArr = [], textureHeightSizeArr = [];
            for (var _i = 0, assets_4 = assets; _i < assets_4.length; _i++) {
                var data = assets_4[_i];
                if (data.sourceRegion) {
                    textureWidthSizeArr.push(data.sourceRegion.width);
                    textureHeightSizeArr.push(data.sourceRegion.height);
                }
                else {
                    textureWidthSizeArr.push(data.asset.width);
                    textureHeightSizeArr.push(data.asset.height);
                }
            }
            return this._areAllElementsEqual(textureWidthSizeArr) && this._areAllElementsEqual(textureHeightSizeArr);
        };
        CubemapTexture.prototype._hasSourceRegion = function (assets) {
            for (var _i = 0, assets_5 = assets; _i < assets_5.length; _i++) {
                var data = assets_5[_i];
                if (data.sourceRegion) {
                    return true;
                }
            }
            return false;
        };
        CubemapTexture.prototype._areAllElementsEqual = function (arr) {
            var lastEle = arr[0];
            for (var _i = 0, arr_7 = arr; _i < arr_7.length; _i++) {
                var ele = arr_7[_i];
                if (ele !== lastEle) {
                    return false;
                }
            }
            return true;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], CubemapTexture.prototype, "mode", void 0);
        __decorate([
            wd.require(function (assets) {
                wd.assert(assets.length === 6, wd.Log.info.FUNC_MUST("cubemap", "has 6 assets"));
                wd.assert(this._areAssetsAllImageAssets(assets) || this._areAssetsAllCompressedAsset(assets), wd.Log.info.FUNC_MUST_BE("cubemap six face's assets", "all ImageTextureAsset or all CompressedTextureAsset"));
                if (this._areAssetsAllCompressedAsset(assets)) {
                    wd.assert(!this._hasSourceRegion(assets), wd.Log.info.FUNC_SHOULD_NOT("compressed face", "contain sourceRegion data"));
                }
                wd.assert(this._areTextureSizOfAllFaceseEqual(assets), wd.Log.info.FUNC_MUST_BE("all cubemap faces' texture size", "equal"));
            })
        ], CubemapTexture.prototype, "initWhenCreate", null);
        return CubemapTexture;
    }(wd.BasicTexture));
    wd.CubemapTexture = CubemapTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapFaceTexture = (function () {
        function CubemapFaceTexture() {
            this.type = wd.ETextureType.UNSIGNED_BYTE;
            this.format = null;
            this.width = null;
            this.height = null;
        }
        return CubemapFaceTexture;
    }());
    wd.CubemapFaceTexture = CubemapFaceTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapFaceImageTexture = (function (_super) {
        __extends(CubemapFaceImageTexture, _super);
        function CubemapFaceImageTexture() {
            _super.apply(this, arguments);
            this.sourceRegion = null;
            this.source = null;
        }
        CubemapFaceImageTexture.create = function (asset) {
            var obj = new this();
            obj.initWhenCreate(asset);
            return obj;
        };
        Object.defineProperty(CubemapFaceImageTexture.prototype, "sourceRegionMethod", {
            get: function () {
                return wd.ETextureSourceRegionMethod.DRAW_IN_CANVAS;
            },
            set: function (sourceRegionMethod) {
            },
            enumerable: true,
            configurable: true
        });
        CubemapFaceImageTexture.prototype.initWhenCreate = function (asset) {
            asset.cloneToCubemapFaceTexture(this);
        };
        CubemapFaceImageTexture.prototype.isSourcePowerOfTwo = function () {
            return wd.BasicTextureUtils.isSourcePowerOfTwo(this.sourceRegion, this.sourceRegionMethod, this.width, this.height);
        };
        CubemapFaceImageTexture.prototype.needClampMaxSize = function () {
            if (!this.source) {
                return false;
            }
            return wd.BasicTextureUtils.needClampMaxSize(wd.GPUDetector.getInstance().maxCubemapTextureSize, this.source.width, this.source.height);
        };
        CubemapFaceImageTexture.prototype.clampToMaxSize = function () {
            var maxSize = wd.GPUDetector.getInstance().maxCubemapTextureSize;
            this.source = wd.BasicTextureUtils.clampToMaxSize(this.source, maxSize);
        };
        CubemapFaceImageTexture.prototype.draw = function (index) {
            var noMipmapCmd = wd.DrawNoMipmapTwoDTextureCommand.create(), gl = wd.DeviceManager.getInstance().gl;
            noMipmapCmd.source = this.source;
            noMipmapCmd.sourceRegion = this.sourceRegion;
            noMipmapCmd.sourceRegionMethod = this.sourceRegionMethod;
            noMipmapCmd.glTarget = gl.TEXTURE_CUBE_MAP_POSITIVE_X + index;
            noMipmapCmd.format = this.format;
            noMipmapCmd.type = this.type;
            noMipmapCmd.execute();
        };
        __decorate([
            wd.requireSetter(function (sourceRegionMethod) {
                wd.assert(sourceRegionMethod === wd.ETextureSourceRegionMethod.DRAW_IN_CANVAS, wd.Log.info.FUNC_SUPPORT("cubemap twoD face texture->sourceRegionMethod only", "DRAW_IN_CANVAS"));
            })
        ], CubemapFaceImageTexture.prototype, "sourceRegionMethod", null);
        return CubemapFaceImageTexture;
    }(wd.CubemapFaceTexture));
    wd.CubemapFaceImageTexture = CubemapFaceImageTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapFaceCompressedTexture = (function (_super) {
        __extends(CubemapFaceCompressedTexture, _super);
        function CubemapFaceCompressedTexture() {
            _super.apply(this, arguments);
            this.mipmaps = null;
            this.minFilter = null;
        }
        CubemapFaceCompressedTexture.create = function (asset) {
            var obj = new this();
            obj.initWhenCreate(asset);
            return obj;
        };
        CubemapFaceCompressedTexture.prototype.initWhenCreate = function (asset) {
            asset.cloneToCubemapFaceTexture(this);
        };
        CubemapFaceCompressedTexture.prototype.isSourcePowerOfTwo = function () {
            return wd.BasicTextureUtils.isSourcePowerOfTwo(null, null, this.width, this.height);
        };
        CubemapFaceCompressedTexture.prototype.needClampMaxSize = function () {
            return wd.BasicTextureUtils.needClampMaxSize(wd.GPUDetector.getInstance().maxCubemapTextureSize, this.width, this.height);
        };
        CubemapFaceCompressedTexture.prototype.clampToMaxSize = function () {
            wd.Log.warn("CubemapFaceCompressedTexture's texture size is over maxCubemapTextureSize");
        };
        CubemapFaceCompressedTexture.prototype.draw = function (index) {
            var compressedCmd = wd.DrawCompressedTextureCommand.create(), gl = wd.DeviceManager.getInstance().gl;
            compressedCmd.glTarget = gl.TEXTURE_CUBE_MAP_POSITIVE_X + index;
            compressedCmd.type = this.type;
            compressedCmd.format = this.format;
            compressedCmd.mipmaps = this.mipmaps;
            compressedCmd.execute();
        };
        return CubemapFaceCompressedTexture;
    }(wd.CubemapFaceTexture));
    wd.CubemapFaceCompressedTexture = CubemapFaceCompressedTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CompressedTexture = (function (_super) {
        __extends(CompressedTexture, _super);
        function CompressedTexture() {
            _super.apply(this, arguments);
        }
        CompressedTexture.create = function (asset) {
            var obj = new this(asset);
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(CompressedTexture.prototype, "sourceRegionMethod", {
            get: function () {
                return wd.ETextureSourceRegionMethod.CHANGE_TEXCOORDS_IN_GLSL;
            },
            set: function (sourceRegionMethod) {
                this.p_sourceRegionMethod = sourceRegionMethod;
            },
            enumerable: true,
            configurable: true
        });
        CompressedTexture.prototype.allocateSourceToTexture = function (isSourcePowerOfTwo) {
            var gl = wd.DeviceManager.getInstance().gl, compressedCmd = wd.DrawCompressedTextureCommand.create();
            compressedCmd.glTarget = gl.TEXTURE_2D;
            compressedCmd.type = this.type;
            compressedCmd.format = this.format;
            compressedCmd.mipmaps = this.mipmaps;
            compressedCmd.sourceRegion = this.sourceRegion;
            compressedCmd.sourceRegionMethod = this.sourceRegionMethod;
            compressedCmd.execute();
            if (this.mipmaps.getCount() > 1) {
                this.generateMipmaps = false;
            }
        };
        CompressedTexture.prototype.needClampMaxSize = function () {
            return false;
        };
        __decorate([
            wd.ensureGetter(function (sourceRegionMethod) {
                wd.it("compressed texture not support ETextureSourceRegionMethod.DRAW_IN_CANVAS, will use ETextureSourceRegionMethod.CHANGE_TEXCOORDS_IN_GLSL instead", function () {
                    wd.expect(this.p_sourceRegionMethod).not.to.equal(wd.ETextureSourceRegionMethod.DRAW_IN_CANVAS);
                    wd.expect(sourceRegionMethod).to.equal(wd.ETextureSourceRegionMethod.CHANGE_TEXCOORDS_IN_GLSL);
                }, this);
            })
        ], CompressedTexture.prototype, "sourceRegionMethod", null);
        return CompressedTexture;
    }(wd.TwoDTexture));
    wd.CompressedTexture = CompressedTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DrawTextureCommand = (function () {
        function DrawTextureCommand() {
            this.format = null;
            this.type = null;
            this.sourceRegion = null;
            this.sourceRegionMethod = wd.ETextureSourceRegionMethod.CHANGE_TEXCOORDS_IN_GLSL;
            this.glTarget = null;
        }
        DrawTextureCommand.prototype.getDrawTarget = function (source, sourceRegion) {
            if (sourceRegion === void 0) { sourceRegion = this.sourceRegion; }
            var result = null;
            if (wd.BasicTextureUtils.isDrawPartOfTexture(sourceRegion, this.sourceRegionMethod)) {
                result = wd.BasicTextureUtils.drawPartOfTextureByCanvas(source, sourceRegion.width, sourceRegion.height, sourceRegion.x, sourceRegion.y, sourceRegion.width, sourceRegion.height, 0, 0, sourceRegion.width, sourceRegion.height);
            }
            else {
                result = source;
            }
            return result;
        };
        return DrawTextureCommand;
    }());
    wd.DrawTextureCommand = DrawTextureCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DrawCompressedTextureCommand = (function (_super) {
        __extends(DrawCompressedTextureCommand, _super);
        function DrawCompressedTextureCommand() {
            _super.apply(this, arguments);
            this.mipmaps = null;
        }
        DrawCompressedTextureCommand.create = function () {
            var obj = new this();
            return obj;
        };
        DrawCompressedTextureCommand.prototype.execute = function () {
            var gl = wd.DeviceManager.getInstance().gl, self = this;
            wd.Log.error(this.format === null, wd.Log.info.FUNC_NOT_SUPPORT(this.format));
            if (this.format !== wd.ETextureFormat.RGBA) {
                this.mipmaps.forEach(function (mipmap, index) {
                    gl.compressedTexImage2D(self.glTarget, index, self.format, mipmap.width, mipmap.height, 0, self.getDrawTarget(mipmap.data));
                });
            }
            else {
                this.mipmaps.forEach(function (mipmap, index) {
                    gl.texImage2D(self.glTarget, index, gl[self.format], mipmap.width, mipmap.height, 0, gl[self.format], gl[self.type], self.getDrawTarget(mipmap.data));
                });
            }
        };
        return DrawCompressedTextureCommand;
    }(wd.DrawTextureCommand));
    wd.DrawCompressedTextureCommand = DrawCompressedTextureCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DrawTwoDTextureCommand = (function (_super) {
        __extends(DrawTwoDTextureCommand, _super);
        function DrawTwoDTextureCommand() {
            _super.apply(this, arguments);
            this.source = null;
        }
        DrawTwoDTextureCommand.prototype.drawTexture = function (index, source) {
            var gl = wd.DeviceManager.getInstance().gl;
            gl.texImage2D(this.glTarget, index, gl[this.format], gl[this.format], gl[this.type], this.getDrawTarget(source));
        };
        return DrawTwoDTextureCommand;
    }(wd.DrawTextureCommand));
    wd.DrawTwoDTextureCommand = DrawTwoDTextureCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DrawMipmapTwoDTextureCommand = (function (_super) {
        __extends(DrawMipmapTwoDTextureCommand, _super);
        function DrawMipmapTwoDTextureCommand() {
            _super.apply(this, arguments);
            this.mipmaps = null;
        }
        DrawMipmapTwoDTextureCommand.create = function () {
            var obj = new this();
            return obj;
        };
        DrawMipmapTwoDTextureCommand.prototype.execute = function () {
            var self = this;
            this.mipmaps.forEach(function (mipmap, index) {
                self.drawTexture(index, mipmap);
            });
        };
        return DrawMipmapTwoDTextureCommand;
    }(wd.DrawTwoDTextureCommand));
    wd.DrawMipmapTwoDTextureCommand = DrawMipmapTwoDTextureCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var DrawNoMipmapTwoDTextureCommand = (function (_super) {
        __extends(DrawNoMipmapTwoDTextureCommand, _super);
        function DrawNoMipmapTwoDTextureCommand() {
            _super.apply(this, arguments);
        }
        DrawNoMipmapTwoDTextureCommand.create = function () {
            var obj = new this();
            return obj;
        };
        DrawNoMipmapTwoDTextureCommand.prototype.execute = function () {
            this.drawTexture(0, this.source);
        };
        return DrawNoMipmapTwoDTextureCommand;
    }(wd.DrawTwoDTextureCommand));
    wd.DrawNoMipmapTwoDTextureCommand = DrawNoMipmapTwoDTextureCommand;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Video = (function () {
        function Video(config) {
            this.url = null;
            this.source = null;
            this.isStop = false;
            this._urlArr = null;
            this._onLoad = null;
            this._onError = null;
            this._urlArr = wdCb.Collection.create(config.urlArr);
            this._onLoad = config.onLoad;
            this._onError = config.onError;
        }
        Video.create = function (config) {
            var obj = new this(config);
            obj.initWhenCreate();
            return obj;
        };
        Video.prototype.initWhenCreate = function () {
            this.url = this._getCanPlayUrl();
            this.source = document.createElement("video");
            this.source.src = this.url;
            this._bindEvent();
        };
        Video.prototype.play = function () {
            this.isStop = false;
            this.source.play();
        };
        Video.prototype._getCanPlayUrl = function () {
            var self = this, canPlayUrl = null, extnameArr = [];
            this._urlArr.forEach(function (url) {
                var extname = wdCb.PathUtils.extname(url);
                extnameArr.push(extname);
                if (self._canplay(extname)) {
                    canPlayUrl = url;
                    return wdCb.$BREAK;
                }
            });
            return canPlayUrl;
        };
        Video.prototype._canplay = function (extname) {
            var video = document.createElement("video"), mimeStr = null;
            switch (extname) {
                case '.mp4':
                    mimeStr = 'video/mp4; codecs="avc1.42e01e, mp4a.40.2"';
                    break;
                case ".ogv":
                    mimeStr = 'video/ogg; codecs="theora, vorbis"';
                    break;
                case ".webm":
                    mimeStr = 'video/webm; codecs="vp8, vorbis"';
                    break;
                default:
                    wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT(extname));
                    break;
            }
            return !!video.canPlayType && video.canPlayType(mimeStr) !== "";
        };
        Video.prototype._bindEvent = function () {
            var self = this;
            this.source.addEventListener("canplaythrough", function () {
                self._onLoad(self);
            }, false);
            this.source.addEventListener("error", function () {
                self._onError("errorCode " + self.source.error.code);
            }, false);
            this.source.addEventListener("ended", function () {
                self.isStop = true;
            }, false);
        };
        __decorate([
            wd.ensure(function (canPlayUrl) {
                var _this = this;
                wd.it("if browser not support video urlArr, warn", function () {
                    if (canPlayUrl === null) {
                        wd.Log.warn("browser not support video urlArr: " + _this._urlArr);
                    }
                }, this);
            })
        ], Video.prototype, "_getCanPlayUrl", null);
        return Video;
    }());
    wd.Video = Video;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var VideoManager = (function () {
        function VideoManager() {
        }
        VideoManager.getInstance = function () { };
        VideoManager.prototype.play = function (id) {
            var asset = wd.LoaderManager.getInstance().get(id), video = null;
            if (!asset) {
                wd.Log.warn("not exist video asset whose id is " + id);
                return;
            }
            video = asset.video;
            video.play();
        };
        VideoManager = __decorate([
            wd.singleton()
        ], VideoManager);
        return VideoManager;
    }());
    wd.VideoManager = VideoManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EAudioType) {
        EAudioType[EAudioType["NONE"] = 0] = "NONE";
        EAudioType[EAudioType["WEBAUDIO"] = 1] = "WEBAUDIO";
        EAudioType[EAudioType["HTML5AUDIO"] = 2] = "HTML5AUDIO";
    })(wd.EAudioType || (wd.EAudioType = {}));
    var EAudioType = wd.EAudioType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (ESoundPlayState) {
        ESoundPlayState[ESoundPlayState["NONE"] = 0] = "NONE";
        ESoundPlayState[ESoundPlayState["PLAYING"] = 1] = "PLAYING";
        ESoundPlayState[ESoundPlayState["END"] = 2] = "END";
    })(wd.ESoundPlayState || (wd.ESoundPlayState = {}));
    var ESoundPlayState = wd.ESoundPlayState;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SoundUtils = (function () {
        function SoundUtils() {
        }
        SoundUtils.getMimeStr = function (mimeType) {
            var mimeStr = null;
            switch (mimeType) {
                case "mp3":
                    return "audio/mpeg";
                case "wav":
                    return "audio/wav";
                default:
                    wd.Log.warn("unknown mimeType:" + mimeType);
                    return null;
            }
        };
        return SoundUtils;
    }());
    wd.SoundUtils = SoundUtils;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Sound = (function () {
        function Sound(config) {
            this.audioObj = null;
            this._config = null;
            this._config = config;
        }
        Sound.create = function (config) {
            var obj = new this(config);
            obj.initWhenCreate();
            return obj;
        };
        Sound.audioDetect = function () {
            try {
                var contextClass = window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.oAudioContext ||
                    window.msAudioContext;
                if (contextClass) {
                    this.ctx = new contextClass();
                    this._audioType = wd.EAudioType.WEBAUDIO;
                }
                else {
                    this._html5AudioDetect();
                }
            }
            catch (e) {
                this._html5AudioDetect();
            }
        };
        Sound._html5AudioDetect = function () {
            if (typeof window.Audio !== "undefined") {
                try {
                    new window.Audio();
                    this._audioType = wd.EAudioType.HTML5AUDIO;
                }
                catch (e) {
                    this._audioType = wd.EAudioType.NONE;
                }
            }
            else {
                this._audioType = wd.EAudioType.HTML5AUDIO;
            }
        };
        Sound.prototype.initWhenCreate = function () {
            var self = this;
            switch (Sound._audioType) {
                case wd.EAudioType.WEBAUDIO:
                    this.audioObj = wd.WebAudio.create(this._config);
                    break;
                case wd.EAudioType.HTML5AUDIO:
                    this.audioObj = wd.Html5Audio.create(this._config);
                    break;
                case wd.EAudioType.NONE:
                    wd.Log.warn("browser not support Web Audio and Html5 Audio");
                    return;
                default:
                    return;
            }
            if (this.canPlay()) {
                this.audioObj.load()
                    .subscribe(function () { }, function (e) {
                    wd.Log.log("fail to use Web Audio to loadtry use Html5 Audio to load");
                    self.audioObj = wd.Html5Audio.create(self._config);
                    self.audioObj.load();
                }, null);
            }
            else {
                this._config.onLoad(null);
            }
        };
        Sound.prototype.play = function () {
            this.audioObj.play();
        };
        Sound.prototype.canPlay = function () {
            return this.audioObj && this.audioObj.canPlay();
        };
        Sound.prototype.getPlayState = function () {
            return this.audioObj.getPlayState();
        };
        Sound.ctx = null;
        Sound._audioType = null;
        return Sound;
    }());
    wd.Sound = Sound;
    Sound.audioDetect();
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BaseAudio = (function () {
        function BaseAudio() {
            this.urlArr = null;
            this.url = null;
        }
        BaseAudio.prototype.initWhenCreate = function () {
            this.url = this._getCanPlayUrl();
        };
        BaseAudio.prototype.canPlay = function () {
            return this.url !== null;
        };
        BaseAudio.prototype._getCanPlayUrl = function () {
            var canPlayUrl = null;
            for (var _i = 0, _a = this.urlArr; _i < _a.length; _i++) {
                var url = _a[_i];
                var result = url.match(/\.(\w+)$/);
                if (this._canPlay(result[1])) {
                    canPlayUrl = url;
                    break;
                }
            }
            return canPlayUrl;
        };
        BaseAudio.prototype._canPlay = function (mimeType) {
            var audio = new window.Audio(), mimeStr = wd.SoundUtils.getMimeStr(mimeType);
            if (mimeStr === null
                || (mimeType == "mp3" && bowser.firefox)) {
                return false;
            }
            return !!audio.canPlayType && audio.canPlayType(mimeStr) !== "";
        };
        __decorate([
            wd.require(function () {
                var _this = this;
                wd.it("url should add extname", function () {
                    for (var _i = 0, _a = _this.urlArr; _i < _a.length; _i++) {
                        var url = _a[_i];
                        var result = url.match(/\.(\w+)$/);
                        wd.expect(result).not.be.a("null");
                    }
                }, this);
            }),
            wd.ensure(function (canPlayUrl) {
                var _this = this;
                wd.it("if browser not support audio urlArr, warn", function () {
                    if (canPlayUrl === null) {
                        wd.Log.warn("browser not support audio urlArr: " + _this.urlArr);
                    }
                }, this);
            })
        ], BaseAudio.prototype, "_getCanPlayUrl", null);
        return BaseAudio;
    }());
    wd.BaseAudio = BaseAudio;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WebAudio = (function (_super) {
        __extends(WebAudio, _super);
        function WebAudio(config) {
            _super.call(this);
            this._buffer = null;
            this._onLoad = null;
            this._onError = null;
            this._config = null;
            this._playState = null;
            this._config = config;
            this.urlArr = config.urlArr;
            this._onLoad = config.onLoad;
            this._onError = config.onError;
        }
        WebAudio.create = function (config) {
            var audio = new this(config);
            audio.initWhenCreate();
            return audio;
        };
        WebAudio.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this._playState = wd.ESoundPlayState.NONE;
        };
        WebAudio.prototype.load = function () {
            return this._loadBuffer(this.url);
        };
        WebAudio.prototype.play = function () {
            var source = wd.Sound.ctx.createBufferSource(), self = this;
            source.buffer = this._buffer;
            source.connect(wd.Sound.ctx.destination);
            source.start(0);
            this._playState = wd.ESoundPlayState.PLAYING;
            setTimeout(function () {
                self._playState = wd.ESoundPlayState.END;
            }, this._buffer.duration * 1000);
        };
        WebAudio.prototype.getPlayState = function () {
            return this._playState;
        };
        WebAudio.prototype._loadBuffer = function (url) {
            var self = this;
            return wd.AjaxLoader.load(url, "arraybuffer")
                .do(function (arraybuffer) {
                self._decodeAudioData(arraybuffer);
            });
        };
        WebAudio.prototype._decodeAudioData = function (arraybuffer) {
            var self = this;
            wd.Sound.ctx.decodeAudioData(arraybuffer, function (buffer) {
                if (buffer) {
                    self._buffer = buffer;
                    self._onLoad(self);
                }
            }, function (err) {
                self._onError(err.err);
            });
        };
        return WebAudio;
    }(wd.BaseAudio));
    wd.WebAudio = WebAudio;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var Html5Audio = (function (_super) {
        __extends(Html5Audio, _super);
        function Html5Audio(config) {
            _super.call(this);
            this._audio = null;
            this._onLoad = null;
            this._onError = null;
            this.urlArr = config.urlArr;
            this._onLoad = config.onLoad;
            this._onError = config.onError;
        }
        Html5Audio.create = function (config) {
            var audio = new this(config);
            audio.initWhenCreate();
            return audio;
        };
        Html5Audio.prototype.load = function () {
            var self = this;
            this._audio = new window.Audio();
            this._audio.addEventListener("canplaythrough", function () {
                self._onLoad(self);
            }, false);
            this._audio.addEventListener("error", function () {
                self._onError("errorCode " + self._audio.error.code);
            }, false);
            this._audio.addEventListener("ended", function () {
                if (bowser.chrome) {
                    self.load();
                }
                else if (bowser.firefox) {
                    this.currentTime = 0;
                }
                else {
                    wd.Log.error("audio only support chrome/firefox browser");
                }
            }, false);
            this._load();
            return wdFrp.empty();
        };
        Html5Audio.prototype.play = function () {
            this._audio.play();
        };
        Html5Audio.prototype.getPlayState = function () {
            if (this._audio.ended) {
                return wd.ESoundPlayState.END;
            }
            if (this._audio.currentTime > 0) {
                return wd.ESoundPlayState.PLAYING;
            }
            return wd.ESoundPlayState.NONE;
        };
        Html5Audio.prototype._load = function () {
            this._audio.src = this.url;
        };
        return Html5Audio;
    }(wd.BaseAudio));
    wd.Html5Audio = Html5Audio;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SoundManager = (function () {
        function SoundManager() {
        }
        SoundManager.getInstance = function () { };
        SoundManager.prototype.play = function (id) {
            var sound = wd.LoaderManager.getInstance().get(id), audioObject = null;
            if (!sound || !sound.canPlay()) {
                return;
            }
            audioObject = sound;
            this._playOnlyOneSimultaneously(audioObject);
        };
        SoundManager.prototype._playOnlyOneSimultaneously = function (audioObject) {
            if (audioObject.getPlayState() !== 1) {
                audioObject.play();
            }
        };
        SoundManager = __decorate([
            wd.singleton()
        ], SoundManager);
        return SoundManager;
    }());
    wd.SoundManager = SoundManager;
})(wd || (wd = {}));
var wd;
(function (wd) {
    wd.root = null, wd.RSVP = null, wd.expect = null;
    if (wd.JudgeUtils.isNodeJs() && typeof global != "undefined") {
        wd.root = global;
    }
    else {
        wd.root = window;
    }
    if (!!wd.root.RSVP) {
        wd.RSVP = wd.root.RSVP;
    }
    else {
        wd.RSVP = wd.root;
    }
    if (!!wd.root.chai) {
        wd.expect = wd.root.chai.expect;
    }
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (EShadowMapSoftType) {
        EShadowMapSoftType[EShadowMapSoftType["NONE"] = 0] = "NONE";
        EShadowMapSoftType[EShadowMapSoftType["PCF"] = 1] = "PCF";
    })(wd.EShadowMapSoftType || (wd.EShadowMapSoftType = {}));
    var EShadowMapSoftType = wd.EShadowMapSoftType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GlobalTempMathClass = (function () {
        function GlobalTempMathClass() {
        }
        GlobalTempMathClass.Vector3_1 = wd.Vector3.create(0, 0, 0);
        GlobalTempMathClass.Vector3_Scale_1 = wd.Vector3.create(1, 1, 1);
        GlobalTempMathClass.Quaternion_1 = wd.Quaternion.create(0, 0, 0, 1);
        return GlobalTempMathClass;
    }());
    wd.GlobalTempMathClass = GlobalTempMathClass;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FireProceduralShaderLib = (function (_super) {
        __extends(FireProceduralShaderLib, _super);
        function FireProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "fire_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        FireProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        FireProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture;
            texture.computeTime();
            this.sendUniformData(program, "u_time", texture.time);
            this.sendUniformData(program, "u_speed", texture.speed);
            this.sendUniformData(program, "u_shift", texture.shift);
            this.sendUniformData(program, "u_alphaThreshold", texture.alphaThreshold);
            texture.fireColorMap.forEach(function (color, name) {
                program.sendStructureData("u_fireColor." + name, wd.EVariableType.VECTOR_3, color.toVector3());
            });
        };
        FireProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addUniformVariable([
                "u_time", "u_speed", "u_shift", "u_alphaThreshold", "u_fireColor"
            ]);
        };
        return FireProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.FireProceduralShaderLib = FireProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FireProceduralRenderTargetRenderer = (function (_super) {
        __extends(FireProceduralRenderTargetRenderer, _super);
        function FireProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        FireProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        FireProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CommonProceduralShader.create();
            shader.addLib(wd.FireProceduralShaderLib.create(this.texture));
            return shader;
        };
        return FireProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.FireProceduralRenderTargetRenderer = FireProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var FireProceduralTexture = (function (_super) {
        __extends(FireProceduralTexture, _super);
        function FireProceduralTexture() {
            _super.apply(this, arguments);
            this._fireColorMap = null;
            this.fireColorType = EFireProceduralTextureColorType.RED;
            this.speed = wd.Vector2.create(0.5, 0.3);
            this.alphaThreshold = 0.5;
            this.shift = 1;
            this.time = 0;
        }
        FireProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(FireProceduralTexture.prototype, "fireColorMap", {
            get: function () {
                if (this._fireColorMap !== null) {
                    return this._fireColorMap;
                }
                switch (this.fireColorType) {
                    case EFireProceduralTextureColorType.CUSTOM:
                        return this._fireColorMap;
                    case EFireProceduralTextureColorType.RED:
                        return wdCb.Hash.create({
                            "c1": wd.Color.create("rgb(0.5, 0.0, 0.1)"),
                            "c2": wd.Color.create("rgb(0.9, 0.0, 0.0)"),
                            "c3": wd.Color.create("rgb(0.2, 0.0, 0.0)"),
                            "c4": wd.Color.create("rgb(1.0, 0.9, 0.0)"),
                            "c5": wd.Color.create("rgb(0.1, 0.1, 0.1)"),
                            "c6": wd.Color.create("rgb(0.9, 0.9, 0.9)")
                        });
                    case EFireProceduralTextureColorType.BLUE:
                        return wdCb.Hash.create({
                            "c1": wd.Color.create("rgb(0.1, 0.0, 0.5)"),
                            "c2": wd.Color.create("rgb(0.0, 0.0, 0.5)"),
                            "c3": wd.Color.create("rgb(0.1, 0.0, 0.2)"),
                            "c4": wd.Color.create("rgb(0.0, 0.0, 1.0)"),
                            "c5": wd.Color.create("rgb(0.1, 0.2, 0.3)"),
                            "c6": wd.Color.create("rgb(0.0, 0.2, 0.9)")
                        });
                    case EFireProceduralTextureColorType.PURPLE:
                        return wdCb.Hash.create({
                            "c1": wd.Color.create("rgb(0.5, 0.0, 1.0)"),
                            "c2": wd.Color.create("rgb(0.9, 0.0, 1.0)"),
                            "c3": wd.Color.create("rgb(0.2, 0.0, 1.0)"),
                            "c4": wd.Color.create("rgb(1.0, 0.9, 1.0)"),
                            "c5": wd.Color.create("rgb(0.1, 0.1, 1.0)"),
                            "c6": wd.Color.create("rgb(0.9, 0.9, 1.0)")
                        });
                    case EFireProceduralTextureColorType.GREEN:
                        return wdCb.Hash.create({
                            "c1": wd.Color.create("rgb(0.5, 1.0, 0.0)"),
                            "c2": wd.Color.create("rgb(0.5, 1.0, 0.0)"),
                            "c3": wd.Color.create("rgb(0.3, 0.4, 0.0)"),
                            "c4": wd.Color.create("rgb(0.5, 1.0, 0.0)"),
                            "c5": wd.Color.create("rgb(0.2, 0.0, 0.0)"),
                            "c6": wd.Color.create("rgb(0.5, 1.0, 0.0)")
                        });
                    default:
                        wd.Log.error(true, wd.Log.info.FUNC_UNEXPECT("fireColorType:" + this.fireColorType));
                        break;
                }
            },
            set: function (fireColorMap) {
                this._fireColorMap = fireColorMap;
            },
            enumerable: true,
            configurable: true
        });
        FireProceduralTexture.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.renderRate = 1;
        };
        FireProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.FireProceduralRenderTargetRenderer.create(this));
            return this;
        };
        FireProceduralTexture.prototype.computeTime = function () {
            this.time += 0.1;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], FireProceduralTexture.prototype, "_fireColorMap", void 0);
        __decorate([
            wd.requireSetter(function (fireColorMap) {
                wd.assert(fireColorMap.getCount() === 6, wd.Log.info.FUNC_SHOULD("contain 6 colors"));
            }),
            wd.ensureGetter(function (value) {
                wd.assert(value.getCount() === 6, wd.Log.info.FUNC_SHOULD("contain 6 colors"));
            })
        ], FireProceduralTexture.prototype, "fireColorMap", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], FireProceduralTexture.prototype, "fireColorType", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], FireProceduralTexture.prototype, "speed", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], FireProceduralTexture.prototype, "alphaThreshold", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], FireProceduralTexture.prototype, "shift", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], FireProceduralTexture.prototype, "time", void 0);
        return FireProceduralTexture;
    }(wd.ProceduralTexture));
    wd.FireProceduralTexture = FireProceduralTexture;
    (function (EFireProceduralTextureColorType) {
        EFireProceduralTextureColorType[EFireProceduralTextureColorType["CUSTOM"] = 0] = "CUSTOM";
        EFireProceduralTextureColorType[EFireProceduralTextureColorType["RED"] = 1] = "RED";
        EFireProceduralTextureColorType[EFireProceduralTextureColorType["PURPLE"] = 2] = "PURPLE";
        EFireProceduralTextureColorType[EFireProceduralTextureColorType["GREEN"] = 3] = "GREEN";
        EFireProceduralTextureColorType[EFireProceduralTextureColorType["BLUE"] = 4] = "BLUE";
    })(wd.EFireProceduralTextureColorType || (wd.EFireProceduralTextureColorType = {}));
    var EFireProceduralTextureColorType = wd.EFireProceduralTextureColorType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MarbleProceduralRenderTargetRenderer = (function (_super) {
        __extends(MarbleProceduralRenderTargetRenderer, _super);
        function MarbleProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        MarbleProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        MarbleProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CommonProceduralShader.create();
            shader.addLib(wd.MarbleProceduralShaderLib.create(this.texture));
            return shader;
        };
        return MarbleProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.MarbleProceduralRenderTargetRenderer = MarbleProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MarbleProceduralTexture = (function (_super) {
        __extends(MarbleProceduralTexture, _super);
        function MarbleProceduralTexture() {
            _super.apply(this, arguments);
            this.tilesHeightNumber = 3;
            this.tilesWidthNumber = 3;
            this.amplitude = 9;
            this.jointColor = wd.Color.create("rgb(0.72, 0.72, 0.72)");
        }
        MarbleProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        MarbleProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.MarbleProceduralRenderTargetRenderer.create(this));
            return this;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MarbleProceduralTexture.prototype, "tilesHeightNumber", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MarbleProceduralTexture.prototype, "tilesWidthNumber", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], MarbleProceduralTexture.prototype, "amplitude", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], MarbleProceduralTexture.prototype, "jointColor", void 0);
        return MarbleProceduralTexture;
    }(wd.ProceduralTexture));
    wd.MarbleProceduralTexture = MarbleProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MarbleProceduralShaderLib = (function (_super) {
        __extends(MarbleProceduralShaderLib, _super);
        function MarbleProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "marble_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        MarbleProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        MarbleProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture;
            this.sendUniformData(program, "u_tilesHeightNumber", texture.tilesHeightNumber);
            this.sendUniformData(program, "u_tilesWidthNumber", texture.tilesWidthNumber);
            this.sendUniformData(program, "u_amplitude", texture.amplitude);
            this.sendUniformData(program, "u_jointColor", texture.jointColor.toVector3());
        };
        MarbleProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addUniformVariable([
                "u_tilesHeightNumber", "u_tilesWidthNumber", "u_amplitude", "u_jointColor"
            ]);
        };
        return MarbleProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.MarbleProceduralShaderLib = MarbleProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassProceduralRenderTargetRenderer = (function (_super) {
        __extends(GrassProceduralRenderTargetRenderer, _super);
        function GrassProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        GrassProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        GrassProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CommonProceduralShader.create();
            shader.addLib(wd.GrassProceduralShaderLib.create(this.texture));
            return shader;
        };
        return GrassProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.GrassProceduralRenderTargetRenderer = GrassProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassProceduralTexture = (function (_super) {
        __extends(GrassProceduralTexture, _super);
        function GrassProceduralTexture() {
            _super.apply(this, arguments);
            this.herb1Color = wd.Color.create("rgb(0.29, 0.38, 0.02)");
            this.herb2Color = wd.Color.create("rgb(0.36, 0.49, 0.09)");
            this.herb3Color = wd.Color.create("rgb(0.51, 0.6, 0.28)");
            this.groundColor = wd.Color.create("rgb(1.0,1.0,1.0)");
        }
        GrassProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        GrassProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.GrassProceduralRenderTargetRenderer.create(this));
            return this;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassProceduralTexture.prototype, "herb1Color", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassProceduralTexture.prototype, "herb2Color", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassProceduralTexture.prototype, "herb3Color", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassProceduralTexture.prototype, "groundColor", void 0);
        return GrassProceduralTexture;
    }(wd.ProceduralTexture));
    wd.GrassProceduralTexture = GrassProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassProceduralShaderLib = (function (_super) {
        __extends(GrassProceduralShaderLib, _super);
        function GrassProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "grass_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        GrassProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        GrassProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture;
            this.sendUniformData(program, "u_herb1Color", texture.herb1Color.toVector3());
            this.sendUniformData(program, "u_herb2Color", texture.herb2Color.toVector3());
            this.sendUniformData(program, "u_herb3Color", texture.herb3Color.toVector3());
            this.sendUniformData(program, "u_groundColor", texture.groundColor.toVector3());
        };
        GrassProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addUniformVariable([
                "u_herb1Color", "u_herb2Color", "u_herb3Color", "u_groundColor"
            ]);
        };
        return GrassProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.GrassProceduralShaderLib = GrassProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WoodProceduralRenderTargetRenderer = (function (_super) {
        __extends(WoodProceduralRenderTargetRenderer, _super);
        function WoodProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        WoodProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        WoodProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CommonProceduralShader.create();
            shader.addLib(wd.WoodProceduralShaderLib.create(this.texture));
            return shader;
        };
        return WoodProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.WoodProceduralRenderTargetRenderer = WoodProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WoodProceduralTexture = (function (_super) {
        __extends(WoodProceduralTexture, _super);
        function WoodProceduralTexture() {
            _super.apply(this, arguments);
            this.ampScale = 100.0;
            this.woodColor = wd.Color.create("rgb(0.32, 0.17, 0.09)");
        }
        WoodProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        WoodProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.WoodProceduralRenderTargetRenderer.create(this));
            return this;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WoodProceduralTexture.prototype, "ampScale", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], WoodProceduralTexture.prototype, "woodColor", void 0);
        return WoodProceduralTexture;
    }(wd.ProceduralTexture));
    wd.WoodProceduralTexture = WoodProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WoodProceduralShaderLib = (function (_super) {
        __extends(WoodProceduralShaderLib, _super);
        function WoodProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "wood_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        WoodProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        WoodProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture;
            this.sendUniformData(program, "u_ampScale", texture.ampScale);
            this.sendUniformData(program, "u_woodColor", texture.woodColor.toVector3());
        };
        WoodProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addUniformVariable([
                "u_ampScale", "u_woodColor"
            ]);
        };
        return WoodProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.WoodProceduralShaderLib = WoodProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RoadProceduralRenderTargetRenderer = (function (_super) {
        __extends(RoadProceduralRenderTargetRenderer, _super);
        function RoadProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        RoadProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        RoadProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CommonProceduralShader.create();
            shader.addLib(wd.RoadProceduralShaderLib.create(this.texture));
            return shader;
        };
        return RoadProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.RoadProceduralRenderTargetRenderer = RoadProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RoadProceduralTexture = (function (_super) {
        __extends(RoadProceduralTexture, _super);
        function RoadProceduralTexture() {
            _super.apply(this, arguments);
            this.roadColor = wd.Color.create("rgb(0.53, 0.53, 0.53)");
        }
        RoadProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        RoadProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.RoadProceduralRenderTargetRenderer.create(this));
            return this;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], RoadProceduralTexture.prototype, "roadColor", void 0);
        return RoadProceduralTexture;
    }(wd.ProceduralTexture));
    wd.RoadProceduralTexture = RoadProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var RoadProceduralShaderLib = (function (_super) {
        __extends(RoadProceduralShaderLib, _super);
        function RoadProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "road_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        RoadProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        RoadProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture;
            this.sendUniformData(program, "u_roadColor", texture.roadColor.toVector3());
        };
        RoadProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addUniformVariable([
                "u_roadColor"
            ]);
        };
        return RoadProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.RoadProceduralShaderLib = RoadProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CloudProceduralRenderTargetRenderer = (function (_super) {
        __extends(CloudProceduralRenderTargetRenderer, _super);
        function CloudProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        CloudProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        CloudProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CommonProceduralShader.create();
            shader.addLib(wd.CloudProceduralShaderLib.create(this.texture));
            return shader;
        };
        return CloudProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.CloudProceduralRenderTargetRenderer = CloudProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CloudProceduralTexture = (function (_super) {
        __extends(CloudProceduralTexture, _super);
        function CloudProceduralTexture() {
            _super.apply(this, arguments);
            this.skyColor = wd.Color.create("rgb(0.15, 0.68, 1.0)");
            this.cloudColor = wd.Color.create("rgb(1.0, 1.0, 1.0)");
        }
        CloudProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        CloudProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.CloudProceduralRenderTargetRenderer.create(this));
            return this;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], CloudProceduralTexture.prototype, "skyColor", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], CloudProceduralTexture.prototype, "cloudColor", void 0);
        return CloudProceduralTexture;
    }(wd.ProceduralTexture));
    wd.CloudProceduralTexture = CloudProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CloudProceduralShaderLib = (function (_super) {
        __extends(CloudProceduralShaderLib, _super);
        function CloudProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "cloud_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        CloudProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        CloudProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture;
            this.sendUniformData(program, "u_skyColor", texture.skyColor.toVector4());
            this.sendUniformData(program, "u_cloudColor", texture.cloudColor.toVector4());
        };
        CloudProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addUniformVariable([
                "u_skyColor", "u_cloudColor"
            ]);
        };
        return CloudProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.CloudProceduralShaderLib = CloudProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BrickProceduralRenderTargetRenderer = (function (_super) {
        __extends(BrickProceduralRenderTargetRenderer, _super);
        function BrickProceduralRenderTargetRenderer() {
            _super.apply(this, arguments);
        }
        BrickProceduralRenderTargetRenderer.create = function (texture) {
            var obj = new this(texture);
            obj.initWhenCreate();
            return obj;
        };
        BrickProceduralRenderTargetRenderer.prototype.createShader = function () {
            var shader = wd.CommonProceduralShader.create();
            shader.addLib(wd.BrickProceduralShaderLib.create(this.texture));
            return shader;
        };
        return BrickProceduralRenderTargetRenderer;
    }(wd.ProceduralRenderTargetRenderer));
    wd.BrickProceduralRenderTargetRenderer = BrickProceduralRenderTargetRenderer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BrickProceduralTexture = (function (_super) {
        __extends(BrickProceduralTexture, _super);
        function BrickProceduralTexture() {
            _super.apply(this, arguments);
            this.tilesHeightNumber = 15;
            this.tilesWidthNumber = 5;
            this.brickColor = wd.Color.create("rgb(0.77, 0.47, 0.40)");
            this.jointColor = wd.Color.create("rgb(0.72, 0.72, 0.72)");
        }
        BrickProceduralTexture.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        BrickProceduralTexture.prototype.init = function () {
            _super.prototype.init.call(this);
            wd.Director.getInstance().scene.addProceduralRenderTargetRenderer(wd.BrickProceduralRenderTargetRenderer.create(this));
            return this;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BrickProceduralTexture.prototype, "tilesHeightNumber", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BrickProceduralTexture.prototype, "tilesWidthNumber", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BrickProceduralTexture.prototype, "brickColor", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], BrickProceduralTexture.prototype, "jointColor", void 0);
        return BrickProceduralTexture;
    }(wd.ProceduralTexture));
    wd.BrickProceduralTexture = BrickProceduralTexture;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BrickProceduralShaderLib = (function (_super) {
        __extends(BrickProceduralShaderLib, _super);
        function BrickProceduralShaderLib(proceduralTexture) {
            _super.call(this);
            this.type = "brick_proceduralTexture";
            this._proceduralTexture = null;
            this._proceduralTexture = proceduralTexture;
        }
        BrickProceduralShaderLib.create = function (proceduralTexture) {
            var obj = new this(proceduralTexture);
            return obj;
        };
        BrickProceduralShaderLib.prototype.sendShaderVariables = function (program, cmd) {
            var texture = this._proceduralTexture;
            this.sendUniformData(program, "u_tilesWidthNumber", texture.tilesWidthNumber);
            this.sendUniformData(program, "u_tilesHeightNumber", texture.tilesHeightNumber);
            this.sendUniformData(program, "u_brickColor", texture.brickColor.toVector3());
            this.sendUniformData(program, "u_jointColor", texture.jointColor.toVector3());
        };
        BrickProceduralShaderLib.prototype.setShaderDefinition = function (cmd) {
            _super.prototype.setShaderDefinition.call(this, cmd);
            this.addUniformVariable([
                "u_tilesHeightNumber", "u_tilesWidthNumber", "u_brickColor", "u_jointColor"
            ]);
        };
        return BrickProceduralShaderLib;
    }(wd.ProceduralShaderLib));
    wd.BrickProceduralShaderLib = BrickProceduralShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MirrorMaterial = (function (_super) {
        __extends(MirrorMaterial, _super);
        function MirrorMaterial() {
            _super.apply(this, arguments);
            this._reflectionMap = null;
        }
        MirrorMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(MirrorMaterial.prototype, "reflectionMap", {
            get: function () {
                return this._reflectionMap;
            },
            set: function (reflectionMap) {
                this.mapManager.addMap(reflectionMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("reflectionMap")
                });
                this._reflectionMap = reflectionMap;
            },
            enumerable: true,
            configurable: true
        });
        MirrorMaterial.prototype.getTextureForRenderSort = function () {
            return this.reflectionMap;
        };
        MirrorMaterial.prototype.addExtendShaderLib = function () {
            if (this.reflectionMap) {
                this.shader.addLib(wd.MirrorShaderLib.create());
            }
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], MirrorMaterial.prototype, "reflectionMap", null);
        return MirrorMaterial;
    }(wd.StandardLightMaterial));
    wd.MirrorMaterial = MirrorMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MirrorShaderLib = (function (_super) {
        __extends(MirrorShaderLib, _super);
        function MirrorShaderLib() {
            _super.apply(this, arguments);
            this.type = "mirror";
        }
        MirrorShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        MirrorShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            wd.RenderTargerRendererShaderLibUtils.judgeAndSendIsRenderListEmptyVariable(program, wd.EShaderGLSLData.MIRROR);
        };
        MirrorShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_isRenderListEmpty",
                wd.VariableNameTable.getVariableName("reflectionMap")
            ]);
        };
        return MirrorShaderLib;
    }(wd.EngineShaderLib));
    wd.MirrorShaderLib = MirrorShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainMaterial = (function (_super) {
        __extends(TerrainMaterial, _super);
        function TerrainMaterial() {
            _super.apply(this, arguments);
            this.layer = wd.TerrainLayer.create();
            this.mix = wd.TerrainMix.create();
        }
        TerrainMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        TerrainMaterial.prototype.init = function () {
            if (this.layer.hasData()) {
                this.layer.addMap(this.mapManager);
            }
            if (this.mix.hasData()) {
                this.mix.addMap(this.mapManager);
            }
            _super.prototype.init.call(this);
        };
        TerrainMaterial.prototype.getTextureForRenderSort = function () {
            if (this.layer.hasData()) {
                return this.layer.getTextureForRenderSort();
            }
            if (this.mix.hasData()) {
                return this.mix.getTextureForRenderSort();
            }
        };
        TerrainMaterial.prototype.addExtendShaderLib = function () {
            if (this.layer.hasData()) {
                this.shader.addLib(wd.TerrainLayerShaderLib.create());
            }
            if (this.mix.hasData()) {
                this.shader.addLib(wd.TerrainMixMapShaderLib.create());
            }
        };
        TerrainMaterial.prototype.addTopExtendShaderLib = function () {
            if (this.mix.hasData()) {
                this.shader.addLib(wd.TerrainMixCommonShaderLib.create());
            }
        };
        TerrainMaterial.prototype.addNormalRelatedShaderLib = function () {
            if (this.mix.hasBumpMap()) {
                this.shader.addLib(wd.TerrainMixBumpShaderLib.create());
            }
            else {
                _super.prototype.addNormalRelatedShaderLib.call(this);
            }
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], TerrainMaterial.prototype, "layer", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], TerrainMaterial.prototype, "mix", void 0);
        return TerrainMaterial;
    }(wd.StandardLightMaterial));
    wd.TerrainMaterial = TerrainMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainLayer = (function () {
        function TerrainLayer() {
            this._mapData = [];
        }
        TerrainLayer.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(TerrainLayer.prototype, "mapData", {
            get: function () {
                return this._mapData;
            },
            set: function (mapData) {
                this._mapData = mapData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TerrainLayer.prototype, "mapArray", {
            get: function () {
                return this._mapData.map(function (data) {
                    return data.diffuseMap;
                });
            },
            enumerable: true,
            configurable: true
        });
        TerrainLayer.prototype.addMap = function (mapManager) {
            mapManager.addMapArray("u_layerSampler2Ds", this.mapArray);
        };
        TerrainLayer.prototype.hasData = function () {
            return this.mapData.length > 0;
        };
        TerrainLayer.prototype.getMapCount = function () {
            return this.mapData.length;
        };
        TerrainLayer.prototype.getTextureForRenderSort = function () {
            return this.mapArray[0];
        };
        TerrainLayer.prototype.clone = function (layer) {
            return wd.CloneUtils.clone(this, null, null, layer);
        };
        __decorate([
            wd.requireSetter(function (mapData) {
                wd.it("mapData should be Array type", function () {
                    wd.expect(mapData).be.a("array");
                });
                wd.it("minHeight should < maxHeight", function () {
                    mapData.forEach(function (data) {
                        wd.expect(data.minHeight).lessThan(data.maxHeight);
                    });
                });
                wd.it("height range should not overlap", function () {
                    mapData.forEach(function (data1) {
                        mapData.filter(function (data2) {
                            return data2.minHeight !== data1.minHeight || data2.maxHeight !== data1.maxHeight;
                        })
                            .forEach(function (data2) {
                            wd.expect(data1.minHeight >= data2.maxHeight || data1.maxHeight <= data2.minHeight).true;
                        });
                    });
                });
            }),
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                var s = source[memberName], t = [];
                for (var _i = 0, s_1 = s; _i < s_1.length; _i++) {
                    var data = s_1[_i];
                    t.push({
                        minHeight: data.minHeight,
                        maxHeight: data.maxHeight,
                        diffuseMap: data.diffuseMap.clone()
                    });
                }
                target[memberName] = t;
            })
        ], TerrainLayer.prototype, "mapData", null);
        __decorate([
            wd.ensureGetter(function (mapArray) {
                wd.it("should return Array<Texture>", function () {
                    wd.expect(mapArray).be.a("array");
                    for (var _i = 0, mapArray_2 = mapArray; _i < mapArray_2.length; _i++) {
                        var map = mapArray_2[_i];
                        wd.expect(map).instanceOf(wd.Texture);
                    }
                });
            })
        ], TerrainLayer.prototype, "mapArray", null);
        return TerrainLayer;
    }());
    wd.TerrainLayer = TerrainLayer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainLayerShaderLib = (function (_super) {
        __extends(TerrainLayerShaderLib, _super);
        function TerrainLayerShaderLib() {
            _super.apply(this, arguments);
            this.type = "terrain_layer";
        }
        TerrainLayerShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        TerrainLayerShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            material.layer.mapData.forEach(function (mapData, index) {
                program.sendStructureData("u_layerHeightDatas[" + index + "].minHeight", wd.EVariableType.FLOAT_1, mapData.minHeight);
                program.sendStructureData("u_layerHeightDatas[" + index + "].maxHeight", wd.EVariableType.FLOAT_1, mapData.maxHeight);
                program.sendStructureData("u_layerHeightDatas[" + index + "].repeatRegion", wd.EVariableType.VECTOR_4, mapData.diffuseMap.repeatRegion);
            });
        };
        TerrainLayerShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_layerHeightDatas", "u_layerSampler2Ds"]);
            this.fsSourceDefineList.addChildren([{
                    name: "LAYER_COUNT",
                    value: material.layer.getMapCount()
                }]);
        };
        __decorate([
            wd.require(function (cmd, material) {
                wd.it("TerrainMaterial->layer->mapData->count should > 0", function () {
                    wd.expect(material).exist;
                    wd.expect(material.layer.getMapCount()).greaterThan(0);
                });
            })
        ], TerrainLayerShaderLib.prototype, "setShaderDefinition", null);
        return TerrainLayerShaderLib;
    }(wd.EngineShaderLib));
    wd.TerrainLayerShaderLib = TerrainLayerShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainMix = (function () {
        function TerrainMix() {
            this._mapData = {};
            this.alphaTest = 0.4;
        }
        TerrainMix.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(TerrainMix.prototype, "mapData", {
            get: function () {
                return this._mapData;
            },
            set: function (mapData) {
                this._mapData = mapData;
            },
            enumerable: true,
            configurable: true
        });
        TerrainMix.prototype.addMap = function (mapManager) {
            mapManager.addMap(this.mapData.mixMap, {
                samplerVariableName: wd.VariableNameTable.getVariableName("mixMap")
            });
            mapManager.addMap(this.mapData.diffuseMap1, {
                samplerVariableName: wd.VariableNameTable.getVariableName("diffuseMap1")
            });
            mapManager.addMap(this.mapData.diffuseMap2, {
                samplerVariableName: wd.VariableNameTable.getVariableName("diffuseMap2")
            });
            mapManager.addMap(this.mapData.diffuseMap3, {
                samplerVariableName: wd.VariableNameTable.getVariableName("diffuseMap3")
            });
            if (this.hasBumpMap()) {
                this._addBumpMap(mapManager, this.mapData.bumpMap1, this.mapData.diffuseMap1, "bumpMap1");
                this._addBumpMap(mapManager, this.mapData.bumpMap2, this.mapData.diffuseMap2, "bumpMap2");
                this._addBumpMap(mapManager, this.mapData.bumpMap3, this.mapData.diffuseMap3, "bumpMap3");
            }
        };
        TerrainMix.prototype.hasData = function () {
            for (var key in this.mapData) {
                if (this.mapData.hasOwnProperty(key)) {
                    return true;
                }
            }
            return false;
        };
        TerrainMix.prototype.hasBumpMap = function () {
            return !!this.mapData.bumpMap1 || !!this.mapData.bumpMap2 || !!this.mapData.bumpMap3;
        };
        TerrainMix.prototype.getTextureForRenderSort = function () {
            return this.mapData.mixMap;
        };
        TerrainMix.prototype.clone = function (mix) {
            return wd.CloneUtils.clone(this, null, null, mix);
        };
        TerrainMix.prototype._setBumpMapRepeatRegion = function (bumpMap, diffuseMap) {
            bumpMap.wrapS = diffuseMap.wrapS;
            bumpMap.wrapT = diffuseMap.wrapT;
        };
        TerrainMix.prototype._addBumpMap = function (mapManager, bumpMap, correspondDiffuseMap, samplerVariableName) {
            this._setBumpMapRepeatRegion(bumpMap, correspondDiffuseMap);
            mapManager.addMap(bumpMap, {
                samplerVariableName: wd.VariableNameTable.getVariableName(samplerVariableName)
            });
        };
        __decorate([
            wd.requireSetter(function (mapData) {
                wd.it("mapData should be Object type", function () {
                    wd.expect(mapData).be.a("object");
                    wd.expect(mapData.mixMap).exist;
                });
            }),
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                var s = source[memberName], t = target[memberName];
                for (var key in s) {
                    t[key] = s[key].clone();
                }
            })
        ], TerrainMix.prototype, "mapData", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], TerrainMix.prototype, "alphaTest", void 0);
        __decorate([
            wd.require(function (mapManager) {
                var _this = this;
                wd.it("mapData at least should has mixMap and 3 diffuseMaps", function () {
                    var mapData = _this.mapData;
                    wd.expect(mapData.mixMap).exist;
                    wd.expect(mapData.diffuseMap1).exist;
                    wd.expect(mapData.diffuseMap2).exist;
                    wd.expect(mapData.diffuseMap3).exist;
                });
                wd.describe("if has bump map", function () {
                    var _this = this;
                    wd.it("should has 3 bump maps", function () {
                        var mapData = _this.mapData;
                        wd.expect(mapData.bumpMap1).exist;
                        wd.expect(mapData.bumpMap2).exist;
                        wd.expect(mapData.bumpMap3).exist;
                    });
                    wd.it("bump map should be ImageTexture", function () {
                        var mapData = _this.mapData;
                        wd.expect(mapData.bumpMap1).instanceOf(wd.ImageTexture);
                        wd.expect(mapData.bumpMap2).instanceOf(wd.ImageTexture);
                        wd.expect(mapData.bumpMap3).instanceOf(wd.ImageTexture);
                    });
                }, function () { return _this.hasBumpMap(); }, this);
            })
        ], TerrainMix.prototype, "addMap", null);
        __decorate([
            wd.ensure(function (hasBumpMap) {
                var _this = this;
                wd.it("if has bump map, should has 3 bump maps", function () {
                    if (hasBumpMap) {
                        var mapData = _this.mapData;
                        wd.expect(mapData.bumpMap1).exist;
                        wd.expect(mapData.bumpMap2).exist;
                        wd.expect(mapData.bumpMap3).exist;
                    }
                });
            })
        ], TerrainMix.prototype, "hasBumpMap", null);
        return TerrainMix;
    }());
    wd.TerrainMix = TerrainMix;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainMixBumpShaderLib = (function (_super) {
        __extends(TerrainMixBumpShaderLib, _super);
        function TerrainMixBumpShaderLib() {
            _super.apply(this, arguments);
            this.type = "terrain_mix_bump";
        }
        TerrainMixBumpShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        TerrainMixBumpShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            var noNormalMap_light_fragment = null;
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("bumpMap1"),
                wd.VariableNameTable.getVariableName("bumpMap2"),
                wd.VariableNameTable.getVariableName("bumpMap3")
            ]);
            this.vsSourceVarDeclare = wd.ShaderChunk.noNormalMap_vertex.varDeclare;
            this.vsSourceBody = wd.ShaderChunk.noNormalMap_vertex.body;
            noNormalMap_light_fragment = wd.ShaderChunk.noNormalMap_light_fragment;
            this.fsSourceVarDeclare = noNormalMap_light_fragment.varDeclare;
            this.fsSourceFuncDefine = noNormalMap_light_fragment.funcDefine + this.fsSourceFuncDefine;
            if (wd.GPUDetector.getInstance().extensionStandardDerivatives) {
                this.fsSourceExtensionList.addChild("GL_OES_standard_derivatives");
                this.fsSourceFuncDefine = wd.ShaderChunk.terrain_mix_bump_cotangentFrame_standardDerivatives.funcDefine + this.fsSourceFuncDefine;
            }
            else {
                this.fsSourceFuncDefine = wd.ShaderChunk.terrain_mix_bump_cotangentFrame_fallback.funcDefine + this.fsSourceFuncDefine;
            }
        };
        return TerrainMixBumpShaderLib;
    }(wd.EngineShaderLib));
    wd.TerrainMixBumpShaderLib = TerrainMixBumpShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainMixCommonShaderLib = (function (_super) {
        __extends(TerrainMixCommonShaderLib, _super);
        function TerrainMixCommonShaderLib() {
            _super.apply(this, arguments);
            this.type = "terrain_mix_common";
        }
        TerrainMixCommonShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return TerrainMixCommonShaderLib;
    }(wd.EngineShaderLib));
    wd.TerrainMixCommonShaderLib = TerrainMixCommonShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TerrainMixMapShaderLib = (function (_super) {
        __extends(TerrainMixMapShaderLib, _super);
        function TerrainMixMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "terrain_mix";
        }
        TerrainMixMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        TerrainMixMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var mapData = material.mix.mapData;
            this.sendUniformData(program, "u_diffuseMap1RepeatRegion", mapData.diffuseMap1.repeatRegion);
            this.sendUniformData(program, "u_diffuseMap2RepeatRegion", mapData.diffuseMap2.repeatRegion);
            this.sendUniformData(program, "u_diffuseMap3RepeatRegion", mapData.diffuseMap3.repeatRegion);
        };
        TerrainMixMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("mixMap"),
                wd.VariableNameTable.getVariableName("diffuseMap1"),
                wd.VariableNameTable.getVariableName("diffuseMap2"),
                wd.VariableNameTable.getVariableName("diffuseMap3"),
                "u_diffuseMap1RepeatRegion",
                "u_diffuseMap2RepeatRegion",
                "u_diffuseMap3RepeatRegion"
            ]);
            this.fsSourceBody = "if (baseColor.a < " + material.mix.alphaTest + "){\n            discard;\n            }\n            " + this.fsSourceBody;
        };
        return TerrainMixMapShaderLib;
    }(wd.EngineShaderLib));
    wd.TerrainMixMapShaderLib = TerrainMixMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassMapBufferContainer = (function (_super) {
        __extends(GrassMapBufferContainer, _super);
        function GrassMapBufferContainer() {
            _super.apply(this, arguments);
            this._quadIndexBuffer = null;
        }
        GrassMapBufferContainer.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        GrassMapBufferContainer.prototype.createBuffersFromGeometryData = function () {
            _super.prototype.createBuffersFromGeometryData.call(this);
            this.getChild(wd.EBufferDataType.CUSTOM, "quadIndices");
        };
        GrassMapBufferContainer.prototype.getBufferForRenderSort = function () {
            var buffer = this.getChild(wd.EBufferDataType.VERTICE);
            if (!buffer) {
                return null;
            }
            return buffer;
        };
        GrassMapBufferContainer.prototype.getCustomData = function (dataName) {
            var geometryData = this.geometryData[dataName];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_quadIndexBuffer", geometryData, 1);
            return this._quadIndexBuffer;
        };
        __decorate([
            wd.cacheBufferForBufferContainer()
        ], GrassMapBufferContainer.prototype, "getCustomData", null);
        return GrassMapBufferContainer;
    }(wd.CommonBufferContainer));
    wd.GrassMapBufferContainer = GrassMapBufferContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassMapGeometry = (function (_super) {
        __extends(GrassMapGeometry, _super);
        function GrassMapGeometry() {
            _super.apply(this, arguments);
            this.width = null;
            this.height = null;
            this._vertices = [];
            this._texCoords = [];
            this._indices = [];
            this._normals = [];
            this._quadIndices = [];
        }
        GrassMapGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        GrassMapGeometry.prototype.computeData = function () {
            this._generateFirstRect();
            this._generateSecondRect();
            this._generateThirdRect();
            this._generateQuadIndices();
            return {
                vertices: this._vertices,
                faces: wd.GeometryUtils.convertToFaces(this._indices, this._normals),
                texCoords: this._texCoords
            };
        };
        GrassMapGeometry.prototype.createBufferContainer = function () {
            return wd.GrassMapBufferContainer.create(this.entityObject);
        };
        GrassMapGeometry.prototype.createGeometryData = function (computedData) {
            var vertices = computedData.vertices, _a = computedData.faces, faces = _a === void 0 ? [] : _a, texCoords = computedData.texCoords, colors = computedData.colors, geometryData = wd.GrassMapGeometryData.create(this);
            geometryData.vertices = vertices;
            geometryData.faces = faces;
            geometryData.texCoords = texCoords;
            geometryData.colors = colors;
            geometryData.quadIndices = this._quadIndices;
            return geometryData;
        };
        GrassMapGeometry.prototype._generateFirstRect = function () {
            this._generateRect(null, 0);
        };
        GrassMapGeometry.prototype._generateSecondRect = function () {
            this._generateRect(wd.Matrix4.create().rotate(45, wd.Vector3.up), 1);
        };
        GrassMapGeometry.prototype._generateThirdRect = function () {
            this._generateRect(wd.Matrix4.create().rotate(-45, wd.Vector3.up), 2);
        };
        GrassMapGeometry.prototype._generateRect = function (rotationMatrix, index) {
            var width = this.width, height = this.height, left = -width / 2, right = width / 2, up = height / 2, down = -height / 2;
            if (rotationMatrix === null) {
                this._vertices = this._vertices.concat([
                    right, up, 0,
                    left, up, 0,
                    left, down, 0,
                    right, down, 0
                ]);
            }
            else {
                this._vertices = this._vertices.concat(rotationMatrix.multiplyVector3(wd.Vector3.create(right, up, 0)).toArray(), rotationMatrix.multiplyVector3(wd.Vector3.create(left, up, 0)).toArray(), rotationMatrix.multiplyVector3(wd.Vector3.create(left, down, 0)).toArray(), rotationMatrix.multiplyVector3(wd.Vector3.create(right, down, 0)).toArray());
            }
            this._indices = this._indices.concat([
                0 + 4 * index, 1 + 4 * index, 2 + 4 * index,
                0 + 4 * index, 2 + 4 * index, 3 + 4 * index
            ]);
            this._texCoords = this._texCoords.concat([
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0,
                1.0, 0.0
            ]);
            this._normals = this._normals.concat([
                0, 1, 0,
                0, 1, 0,
                0, 1, 0,
                0, 1, 0
            ]);
        };
        GrassMapGeometry.prototype._generateQuadIndices = function () {
            this._quadIndices = [
                0, 0, 0, 0,
                1, 1, 1, 1,
                2, 2, 2, 2
            ];
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassMapGeometry.prototype, "width", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassMapGeometry.prototype, "height", void 0);
        return GrassMapGeometry;
    }(wd.Geometry));
    wd.GrassMapGeometry = GrassMapGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassMapGeometryData = (function (_super) {
        __extends(GrassMapGeometryData, _super);
        function GrassMapGeometryData() {
            _super.apply(this, arguments);
            this._quadIndices = null;
        }
        GrassMapGeometryData.create = function (geometry) {
            var obj = new this(geometry);
            return obj;
        };
        Object.defineProperty(GrassMapGeometryData.prototype, "quadIndices", {
            get: function () {
                return this._quadIndices;
            },
            set: function (quadIndices) {
                this._quadIndices = quadIndices;
                this.geometry.buffers.removeCache("quadIndices");
            },
            enumerable: true,
            configurable: true
        });
        return GrassMapGeometryData;
    }(wd.GeometryData));
    wd.GrassMapGeometryData = GrassMapGeometryData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassMapMaterial = (function (_super) {
        __extends(GrassMapMaterial, _super);
        function GrassMapMaterial() {
            _super.apply(this, arguments);
            this._mapData = [];
            this.grassMap = null;
            this.alphaTest = 0.0001;
            this.wind = GrassWindModel.create();
        }
        GrassMapMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(GrassMapMaterial.prototype, "mapData", {
            get: function () {
                return this._mapData;
            },
            set: function (mapData) {
                this._mapData = mapData;
            },
            enumerable: true,
            configurable: true
        });
        GrassMapMaterial.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.side = wd.ESide.BOTH;
        };
        GrassMapMaterial.prototype.init = function () {
            this.mapManager.addMap(this.grassMap, {
                samplerVariableName: wd.VariableNameTable.getVariableName("grassMap")
            });
            _super.prototype.init.call(this);
        };
        GrassMapMaterial.prototype.getTextureForRenderSort = function () {
            return this.grassMap;
        };
        GrassMapMaterial.prototype.updateShader = function (cmd) {
            this.wind.computeTime();
            _super.prototype.updateShader.call(this, cmd);
        };
        GrassMapMaterial.prototype.addExtendShaderLib = function () {
            this.shader.addLib(wd.GrassMapShaderLib.create());
        };
        GrassMapMaterial.prototype.addLightSetWorldPositionShaderLib = function () {
            this.shader.addLib(wd.GrassMapSetWorldPositionShaderLib.create());
        };
        __decorate([
            wd.requireSetter(function (mapData) {
                wd.it("should contain 3 sourceRegion data", function () {
                    wd.expect(mapData.length).equal(3);
                    for (var _i = 0, mapData_1 = mapData; _i < mapData_1.length; _i++) {
                        var data = mapData_1[_i];
                        wd.expect(data.sourceRegion).exist;
                    }
                });
            }),
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                var s = source[memberName], t = [];
                for (var _i = 0, s_2 = s; _i < s_2.length; _i++) {
                    var data = s_2[_i];
                    t.push({
                        sourceRegion: data.sourceRegion.clone()
                    });
                }
                target[memberName] = t;
            })
        ], GrassMapMaterial.prototype, "mapData", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassMapMaterial.prototype, "grassMap", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassMapMaterial.prototype, "alphaTest", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassMapMaterial.prototype, "wind", void 0);
        return GrassMapMaterial;
    }(wd.StandardLightMaterial));
    wd.GrassMapMaterial = GrassMapMaterial;
    var GrassWindModel = (function () {
        function GrassWindModel() {
            this.time = 0;
            this.speed = 0.1;
            this.direction = wd.Vector2.create(1, 1);
            this.strength = 0.5;
        }
        GrassWindModel.create = function () {
            var obj = new this();
            return obj;
        };
        GrassWindModel.prototype.clone = function () {
            return wd.CloneUtils.clone(this);
        };
        GrassWindModel.prototype.computeTime = function () {
            this.time += this.speed;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassWindModel.prototype, "time", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassWindModel.prototype, "speed", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassWindModel.prototype, "direction", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassWindModel.prototype, "strength", void 0);
        return GrassWindModel;
    }());
    wd.GrassWindModel = GrassWindModel;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassMapSetWorldPositionShaderLib = (function (_super) {
        __extends(GrassMapSetWorldPositionShaderLib, _super);
        function GrassMapSetWorldPositionShaderLib() {
            _super.apply(this, arguments);
            this.type = "grass_map_setWorldPosition";
        }
        GrassMapSetWorldPositionShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        GrassMapSetWorldPositionShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            program.sendStructureData("u_windData.direction", wd.EVariableType.VECTOR_2, material.wind.direction);
            program.sendStructureData("u_windData.time", wd.EVariableType.FLOAT_1, material.wind.time);
            program.sendStructureData("u_windData.strength", wd.EVariableType.FLOAT_1, material.wind.strength);
        };
        GrassMapSetWorldPositionShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_windData"
            ]);
        };
        return GrassMapSetWorldPositionShaderLib;
    }(wd.EngineShaderLib));
    wd.GrassMapSetWorldPositionShaderLib = GrassMapSetWorldPositionShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassMapShaderLib = (function (_super) {
        __extends(GrassMapShaderLib, _super);
        function GrassMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "grass_map";
        }
        GrassMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        GrassMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var quadIndexBuffer = cmd.buffers.getChild(wd.EBufferDataType.CUSTOM, "quadIndices");
            if (!quadIndexBuffer) {
                return;
            }
            var grassMap = material.grassMap;
            this.sendAttributeBuffer(program, "a_quadIndex", quadIndexBuffer);
            program.sendStructureData("u_windData.direction", wd.EVariableType.VECTOR_2, material.wind.direction);
            program.sendStructureData("u_windData.time", wd.EVariableType.FLOAT_1, material.wind.time);
            program.sendStructureData("u_windData.strength", wd.EVariableType.FLOAT_1, material.wind.strength);
            material.mapData.forEach(function (mapData, index) {
                program.sendStructureData("u_grassMapDatas[" + index + "].sourceRegion", wd.EVariableType.VECTOR_4, wd.GlobalTextureUtils.convertSourceRegionCanvasMapToUV(mapData.sourceRegion, grassMap.width, grassMap.height));
            });
        };
        GrassMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_quadIndex"]);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("grassMap"),
                "u_grassMapDatas",
                "u_windData"
            ]);
            this.fsSourceBody += "if (totalColor.a < " + material.alphaTest + "){\n    discard;\n}\n";
        };
        return GrassMapShaderLib;
    }(wd.EngineShaderLib));
    wd.GrassMapShaderLib = GrassMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassInstanceGeometry = (function (_super) {
        __extends(GrassInstanceGeometry, _super);
        function GrassInstanceGeometry() {
            _super.apply(this, arguments);
            this.bladeCount = 10;
            this.bladeSegments = 4;
            this.bladeWidth = 0.15;
            this.bladeMinHeight = 2;
            this.bladeMaxHeight = 4;
            this.rangeWidth = 5;
            this.rangeHeight = 5;
            this.vertexIndexBuffer = null;
        }
        GrassInstanceGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        Object.defineProperty(GrassInstanceGeometry.prototype, "bladeVerts", {
            get: function () {
                return this.bladeDivs * 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GrassInstanceGeometry.prototype, "bladeDivs", {
            get: function () {
                return this.bladeSegments + 1;
            },
            enumerable: true,
            configurable: true
        });
        GrassInstanceGeometry.prototype.computeData = function () {
            for (var i = 0; i < this.bladeCount; i++) {
                this.addInstanceAttributes([
                    { attributeName: "a_shape", data: this._generateShapes(), meshPerAttribute: 1 },
                    { attributeName: "a_offset", data: this._generateOffsets(), meshPerAttribute: 1 }
                ]);
            }
            this.vertexIndexBuffer = wd.BufferUtils.convertArrayToArrayBuffer(wd.EVariableType.FLOAT_1, this._generateVertexIndex());
            this.indices = this._generateIndices();
            this.vertices = this._generateVerticesForCollisionCheck();
            return _super.prototype.computeData.call(this);
        };
        GrassInstanceGeometry.prototype._generateVertexIndex = function () {
            var vertices = [], vIndexLength = this.bladeVerts * 2 * 1;
            for (var i = 0; i < vIndexLength; i++) {
                vertices[i] = i;
            }
            return vertices;
        };
        GrassInstanceGeometry.prototype._generateVerticesForCollisionCheck = function () {
            var halfWidth = this.rangeWidth / 2, height = this.bladeMaxHeight, halfDepth = this.rangeHeight / 2;
            return [
                -halfWidth, height, halfDepth,
                halfWidth, height, halfDepth,
                halfWidth, 0, halfDepth,
                -halfWidth, 0, halfDepth,
                -halfWidth, height, -halfDepth,
                halfWidth, height, -halfDepth,
                halfWidth, 0, -halfDepth,
                -halfWidth, 0, -halfDepth
            ];
        };
        GrassInstanceGeometry.prototype._generateShapes = function () {
            var shape = [], width = this.bladeWidth + Math.random() * this.bladeWidth * 0.5, height = this.bladeMinHeight + Math.pow(Math.random(), 4.0) * (this.bladeMaxHeight - this.bladeMinHeight), lean = 0.0 + Math.random() * 0.2, curve = 0.2 + Math.random() * 0.2;
            shape[0] = width;
            shape[1] = height;
            shape[2] = lean;
            shape[3] = curve;
            return shape;
        };
        GrassInstanceGeometry.prototype._generateOffsets = function () {
            var offset = [], x = wd.MathUtils.generateMinToMax(-1, 1) * this.rangeWidth, y = 0.0, z = wd.MathUtils.generateMinToMax(-1, 1) * this.rangeHeight, rot = Math.PI * 2.0 * Math.random();
            offset[0] = x;
            offset[1] = y;
            offset[2] = z;
            offset[3] = rot;
            return offset;
        };
        GrassInstanceGeometry.prototype._generateIndices = function () {
            var seg = null, i = 0, vc1 = 0, vc2 = this.bladeVerts, indices = [];
            for (seg = 0; seg < this.bladeSegments; seg++) {
                indices[i++] = vc1 + 0;
                indices[i++] = vc1 + 1;
                indices[i++] = vc1 + 2;
                indices[i++] = vc1 + 2;
                indices[i++] = vc1 + 1;
                indices[i++] = vc1 + 3;
                vc1 += 2;
            }
            for (seg = 0; seg < this.bladeSegments; seg++) {
                indices[i++] = vc2 + 2;
                indices[i++] = vc2 + 1;
                indices[i++] = vc2 + 0;
                indices[i++] = vc2 + 3;
                indices[i++] = vc2 + 1;
                indices[i++] = vc2 + 2;
                vc2 += 2;
            }
            return indices;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceGeometry.prototype, "bladeCount", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceGeometry.prototype, "bladeSegments", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceGeometry.prototype, "bladeWidth", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceGeometry.prototype, "bladeMinHeight", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceGeometry.prototype, "bladeMaxHeight", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceGeometry.prototype, "rangeWidth", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceGeometry.prototype, "rangeHeight", void 0);
        return GrassInstanceGeometry;
    }(wd.InstanceGeometry));
    wd.GrassInstanceGeometry = GrassInstanceGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassInstanceMaterial = (function (_super) {
        __extends(GrassInstanceMaterial, _super);
        function GrassInstanceMaterial() {
            _super.apply(this, arguments);
            this.map = null;
            this.time = 0;
            this.speed = 0.01;
            this.terrainGeometry = null;
        }
        GrassInstanceMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        GrassInstanceMaterial.prototype.init = function () {
            this.mapManager.addMap(this.map, {
                samplerVariableName: wd.VariableNameTable.getVariableName("grassMap")
            });
            if (this.terrainGeometry && this.terrainGeometry.heightMapAsset) {
                this.mapManager.addMap(this.terrainGeometry.heightMapAsset.toTexture(), {
                    samplerVariableName: wd.VariableNameTable.getVariableName("heightMap")
                });
            }
            this._addShaderLib();
            _super.prototype.init.call(this);
        };
        GrassInstanceMaterial.prototype.getTextureForRenderSort = function () {
            return this.map;
        };
        GrassInstanceMaterial.prototype.updateShader = function (cmd) {
            this._computeTime();
            _super.prototype.updateShader.call(this, cmd);
        };
        GrassInstanceMaterial.prototype.createShader = function () {
            return wd.CommonShader.create();
        };
        GrassInstanceMaterial.prototype._addShaderLib = function () {
            this.shader.addLib(wd.GrassCommonInstanceShaderLib.create());
            if (wd.InstanceUtils.isHardwareSupport()) {
                this.shader.addLib(wd.GrassHardwareInstanceShaderLib.create());
            }
            else {
                this.shader.addLib(wd.GrassBatchInstanceShaderLib.create());
            }
            this.shader.addLib(wd.EndShaderLib.create());
        };
        GrassInstanceMaterial.prototype._computeTime = function () {
            this.time += this.speed;
        };
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], GrassInstanceMaterial.prototype, "map", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceMaterial.prototype, "time", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceMaterial.prototype, "speed", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], GrassInstanceMaterial.prototype, "terrainGeometry", void 0);
        return GrassInstanceMaterial;
    }(wd.Material));
    wd.GrassInstanceMaterial = GrassInstanceMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassInstanceShaderLib = (function (_super) {
        __extends(GrassInstanceShaderLib, _super);
        function GrassInstanceShaderLib() {
            _super.apply(this, arguments);
        }
        return GrassInstanceShaderLib;
    }(wd.EngineShaderLib));
    wd.GrassInstanceShaderLib = GrassInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassBatchInstanceShaderLib = (function (_super) {
        __extends(GrassBatchInstanceShaderLib, _super);
        function GrassBatchInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "grass_batch_instance";
        }
        GrassBatchInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return GrassBatchInstanceShaderLib;
    }(wd.GrassInstanceShaderLib));
    wd.GrassBatchInstanceShaderLib = GrassBatchInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassCommonInstanceShaderLib = (function (_super) {
        __extends(GrassCommonInstanceShaderLib, _super);
        function GrassCommonInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "grass_common_instance";
        }
        GrassCommonInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        GrassCommonInstanceShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var geometry = material.geometry;
            this.sendAttributeBuffer(program, "a_vertexIndex", material.geometry.vertexIndexBuffer);
            this.sendUniformData(program, "u_mMatrix", cmd.mMatrix);
            this.sendUniformData(program, "u_vpMatrix", cmd.vpMatrix);
            this.sendUniformData(program, "u_grassRangeWidth", geometry.rangeWidth);
            this.sendUniformData(program, "u_grassRangeHeight", geometry.rangeHeight);
            this.sendUniformData(program, "u_time", material.time);
            this._sendTerrainData(material, program);
            this._sendLightData(program);
        };
        GrassCommonInstanceShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_vertexIndex"]);
            this.addUniformVariable([
                "u_grassMapSampler",
                "u_mMatrix",
                "u_vpMatrix",
                "u_grassRangeWidth",
                "u_grassRangeHeight",
                "u_time",
                "u_terrainRangeWidth",
                "u_terrainRangeHeight",
                "u_terrainMinHeight",
                "u_terrainMaxHeight",
                "u_terrainSubdivisions",
                "u_terrainScaleY",
                "u_terrainPositionY",
                "u_heightMapSampler",
                "u_lightPos",
                "u_lightColor"
            ]);
            this.vsSourceFuncDefine = wd.ShaderChunk.common_heightMap.funcDefine + wd.ShaderChunk.common_light.funcDefine + this.vsSourceFuncDefine;
            var geometry = material.geometry;
            this.vsSourceDefineList.addChildren([
                {
                    name: "BLADE_SEGS",
                    value: geometry.bladeSegments + ".0"
                },
                {
                    name: "BLADE_DIVS",
                    value: geometry.bladeDivs + ".0"
                },
                {
                    name: "BLADE_VERTS",
                    value: geometry.bladeVerts + ".0"
                }
            ]);
        };
        GrassCommonInstanceShaderLib.prototype._sendTerrainData = function (material, program) {
            var terrainGeo = material.terrainGeometry;
            this.sendUniformData(program, "u_terrainRangeWidth", terrainGeo.rangeWidth);
            this.sendUniformData(program, "u_terrainRangeHeight", terrainGeo.rangeHeight);
            this.sendUniformData(program, "u_terrainMinHeight", terrainGeo.minHeight);
            this.sendUniformData(program, "u_terrainMaxHeight", terrainGeo.maxHeight);
            this.sendUniformData(program, "u_terrainSubdivisions", terrainGeo.subdivisions);
            var terrainGameObjectTransform = terrainGeo.entityObject.transform;
            this.sendUniformData(program, "u_terrainScaleY", terrainGameObjectTransform.scale.y);
            this.sendUniformData(program, "u_terrainPositionY", terrainGameObjectTransform.position.y);
        };
        GrassCommonInstanceShaderLib.prototype._sendLightData = function (program) {
            var scene = wd.Director.getInstance().scene, directionLights = scene.directionLights, pointLights = scene.pointLights;
            if (directionLights) {
                var lightComponent = directionLights.getChild(0).getComponent(wd.DirectionLight);
                this.sendUniformData(program, "u_lightPos", wd.LightUtils.getDirectionLightPosition(lightComponent));
                this.sendUniformData(program, "u_lightColor", lightComponent.color.toVector3());
            }
            else if (pointLights) {
                var lightComponent = pointLights.getChild(0).getComponent(wd.PointLight);
                this.sendUniformData(program, "u_lightPos", wd.LightUtils.getPointLightPosition(lightComponent));
                this.sendUniformData(program, "u_lightColor", lightComponent.color.toVector3());
            }
        };
        __decorate([
            wd.require(function (program, cmd, material) {
                wd.it("geometry should be GrassInstanceGeometry", function () {
                    wd.expect(material.geometry).instanceOf(wd.GrassInstanceGeometry);
                });
            })
        ], GrassCommonInstanceShaderLib.prototype, "sendShaderVariables", null);
        __decorate([
            wd.require(function (material, program) {
                var geo = material.terrainGeometry;
                wd.it("material.terrainGeometry should exist ", function () {
                    wd.expect(geo).exist;
                });
                wd.it("subdivisions should >= 2", function () {
                    wd.expect(geo.subdivisions).greaterThan(1);
                });
                wd.it("rangeWidth,rangeHeight should > 0", function () {
                    wd.expect(geo.rangeWidth).greaterThan(0);
                    wd.expect(geo.rangeHeight).greaterThan(0);
                });
                wd.it("min height should < max height", function () {
                    wd.expect(geo.minHeight).lessThan(geo.maxHeight);
                });
            })
        ], GrassCommonInstanceShaderLib.prototype, "_sendTerrainData", null);
        __decorate([
            wd.require(function () {
                var scene = wd.Director.getInstance().scene, directionLights = scene.directionLights, pointLights = scene.pointLights;
                wd.it("should exist light", function () {
                    wd.expect(!directionLights && !pointLights).false;
                    if (directionLights) {
                        wd.expect(directionLights).not.empty;
                    }
                    if (pointLights) {
                        wd.expect(pointLights).not.empty;
                    }
                });
            })
        ], GrassCommonInstanceShaderLib.prototype, "_sendLightData", null);
        return GrassCommonInstanceShaderLib;
    }(wd.EngineShaderLib));
    wd.GrassCommonInstanceShaderLib = GrassCommonInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var GrassHardwareInstanceShaderLib = (function (_super) {
        __extends(GrassHardwareInstanceShaderLib, _super);
        function GrassHardwareInstanceShaderLib() {
            _super.apply(this, arguments);
            this.type = "grass_hardware_instance";
        }
        GrassHardwareInstanceShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return GrassHardwareInstanceShaderLib;
    }(wd.GrassInstanceShaderLib));
    wd.GrassHardwareInstanceShaderLib = GrassHardwareInstanceShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterBumpMapShaderLib = (function (_super) {
        __extends(WaterBumpMapShaderLib, _super);
        function WaterBumpMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "water_bump";
        }
        WaterBumpMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        WaterBumpMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            this.sendUniformData(program, "u_windMatrix", material.wind.matrix);
        };
        WaterBumpMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                wd.VariableNameTable.getVariableName("bumpMap"),
                "u_windMatrix"
            ]);
        };
        return WaterBumpMapShaderLib;
    }(wd.EngineShaderLib));
    wd.WaterBumpMapShaderLib = WaterBumpMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterFresnelShaderLib = (function (_super) {
        __extends(WaterFresnelShaderLib, _super);
        function WaterFresnelShaderLib() {
            _super.apply(this, arguments);
            this.type = "water_fresnel";
        }
        WaterFresnelShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        WaterFresnelShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            wd.RenderTargerRendererShaderLibUtils.judgeAndSendIsRenderListEmptyVariable(program, wd.EShaderGLSLData.MIRROR, "u_isReflectionRenderListEmpty");
            wd.RenderTargerRendererShaderLibUtils.judgeAndSendIsRenderListEmptyVariable(program, wd.EShaderGLSLData.REFRACTION, "u_isRefractionRenderListEmpty");
            program.sendStructureData("u_levelData.fresnelLevel", wd.EVariableType.FLOAT_1, material.fresnelLevel);
            program.sendStructureData("u_levelData.refractionLevel", wd.EVariableType.FLOAT_1, material.refractionLevel);
            program.sendStructureData("u_levelData.reflectionLevel", wd.EVariableType.FLOAT_1, material.reflectionLevel);
        };
        WaterFresnelShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_levelData",
                "u_isReflectionRenderListEmpty",
                "u_isRefractionRenderListEmpty",
                wd.VariableNameTable.getVariableName("reflectionMap"),
                wd.VariableNameTable.getVariableName("refractionMap"),
            ]);
        };
        return WaterFresnelShaderLib;
    }(wd.EngineShaderLib));
    wd.WaterFresnelShaderLib = WaterFresnelShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterMaterial = (function (_super) {
        __extends(WaterMaterial, _super);
        function WaterMaterial() {
            _super.apply(this, arguments);
            this._bumpMap = null;
            this._reflectionMap = null;
            this._refractionMap = null;
            this.wind = WaterWindModel.create();
            this.wave = WaterWaveModel.create();
            this.fresnelLevel = 1.0;
            this.reflectionLevel = 0.6;
            this.refractionLevel = 0.8;
        }
        WaterMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(WaterMaterial.prototype, "bumpMap", {
            get: function () {
                return this._bumpMap;
            },
            set: function (bumpMap) {
                bumpMap.wrapS = wd.ETextureWrapMode.REPEAT;
                bumpMap.wrapT = wd.ETextureWrapMode.REPEAT;
                this.mapManager.addMap(bumpMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("bumpMap")
                });
                this._bumpMap = bumpMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterMaterial.prototype, "reflectionMap", {
            get: function () {
                return this._reflectionMap;
            },
            set: function (reflectionMap) {
                this.mapManager.addMap(reflectionMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("reflectionMap")
                });
                this._reflectionMap = reflectionMap;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WaterMaterial.prototype, "refractionMap", {
            get: function () {
                return this._refractionMap;
            },
            set: function (refractionMap) {
                this.mapManager.addMap(refractionMap, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("refractionMap")
                });
                this._refractionMap = refractionMap;
            },
            enumerable: true,
            configurable: true
        });
        WaterMaterial.prototype.updateShader = function (cmd) {
            this.wind.computeTime();
            _super.prototype.updateShader.call(this, cmd);
        };
        WaterMaterial.prototype.getTextureForRenderSort = function () {
            return this.reflectionMap;
        };
        WaterMaterial.prototype.addExtendShaderLib = function () {
            if (this.bumpMap) {
                this.shader.addLib(wd.WaterBumpMapShaderLib.create());
            }
            else {
                this.shader.addLib(wd.WaterNoBumpMapShaderLib.create());
            }
            this.shader.addLib(wd.WaterShaderLib.create());
            if (this.reflectionMap && this.refractionMap) {
                this.shader.addLib(wd.WaterFresnelShaderLib.create());
            }
            else if (this.reflectionMap) {
                this.shader.addLib(wd.WaterReflectionMapShaderLib.create());
            }
            else if (this.refractionMap) {
                this.shader.addLib(wd.WaterRefractionMapShaderLib.create());
            }
            else {
                this.shader.addLib(wd.WaterNoLightEffectShaderLib.create());
            }
        };
        __decorate([
            wd.requireSetter(function (bumpMap) {
                wd.assert(bumpMap instanceof wd.ImageTexture);
            }),
            wd.cloneAttributeAsCloneable()
        ], WaterMaterial.prototype, "bumpMap", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], WaterMaterial.prototype, "reflectionMap", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], WaterMaterial.prototype, "refractionMap", null);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], WaterMaterial.prototype, "wind", void 0);
        __decorate([
            wd.cloneAttributeAsCloneable()
        ], WaterMaterial.prototype, "wave", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterMaterial.prototype, "fresnelLevel", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterMaterial.prototype, "reflectionLevel", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterMaterial.prototype, "refractionLevel", void 0);
        return WaterMaterial;
    }(wd.StandardLightMaterial));
    wd.WaterMaterial = WaterMaterial;
    var WaterWindModel = (function () {
        function WaterWindModel() {
            this.time = 0;
            this.direction = wd.Vector2.create(0, 1);
            this.speed = 0.0001;
        }
        WaterWindModel.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(WaterWindModel.prototype, "matrix", {
            get: function () {
                return wd.Matrix4.create().translate(this.direction.x * this.time, this.direction.y * this.time, 0);
            },
            enumerable: true,
            configurable: true
        });
        WaterWindModel.prototype.clone = function (model) {
            return wd.CloneUtils.clone(this, null, null, model);
        };
        WaterWindModel.prototype.computeTime = function () {
            this.time += this.speed;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterWindModel.prototype, "time", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterWindModel.prototype, "direction", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterWindModel.prototype, "speed", void 0);
        return WaterWindModel;
    }());
    wd.WaterWindModel = WaterWindModel;
    var WaterWaveModel = (function () {
        function WaterWaveModel() {
            this.height = 0.15;
            this.length = 0.1;
        }
        WaterWaveModel.create = function () {
            var obj = new this();
            return obj;
        };
        WaterWaveModel.prototype.clone = function (model) {
            return wd.CloneUtils.clone(this, null, null, model);
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterWaveModel.prototype, "height", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], WaterWaveModel.prototype, "length", void 0);
        return WaterWaveModel;
    }());
    wd.WaterWaveModel = WaterWaveModel;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterNoBumpMapShaderLib = (function (_super) {
        __extends(WaterNoBumpMapShaderLib, _super);
        function WaterNoBumpMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "water_noBump";
        }
        WaterNoBumpMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        WaterNoBumpMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        return WaterNoBumpMapShaderLib;
    }(wd.EngineShaderLib));
    wd.WaterNoBumpMapShaderLib = WaterNoBumpMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterNoLightEffectShaderLib = (function (_super) {
        __extends(WaterNoLightEffectShaderLib, _super);
        function WaterNoLightEffectShaderLib() {
            _super.apply(this, arguments);
            this.type = "water_noLightEffect";
        }
        WaterNoLightEffectShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        WaterNoLightEffectShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        return WaterNoLightEffectShaderLib;
    }(wd.EngineShaderLib));
    wd.WaterNoLightEffectShaderLib = WaterNoLightEffectShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterReflectionMapShaderLib = (function (_super) {
        __extends(WaterReflectionMapShaderLib, _super);
        function WaterReflectionMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "water_reflection";
        }
        WaterReflectionMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        WaterReflectionMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            wd.RenderTargerRendererShaderLibUtils.judgeAndSendIsRenderListEmptyVariable(program, wd.EShaderGLSLData.MIRROR, "u_isReflectionRenderListEmpty");
            program.sendStructureData("u_levelData.reflectionLevel", wd.EVariableType.FLOAT_1, material.reflectionLevel);
        };
        WaterReflectionMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_levelData",
                "u_isReflectionRenderListEmpty",
                wd.VariableNameTable.getVariableName("reflectionMap")
            ]);
        };
        return WaterReflectionMapShaderLib;
    }(wd.EngineShaderLib));
    wd.WaterReflectionMapShaderLib = WaterReflectionMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterRefractionMapShaderLib = (function (_super) {
        __extends(WaterRefractionMapShaderLib, _super);
        function WaterRefractionMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "water_refraction";
        }
        WaterRefractionMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        WaterRefractionMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            wd.RenderTargerRendererShaderLibUtils.judgeAndSendIsRenderListEmptyVariable(program, wd.EShaderGLSLData.REFRACTION, "u_isRefractionRenderListEmpty");
            program.sendStructureData("u_levelData.refractionLevel", wd.EVariableType.FLOAT_1, material.refractionLevel);
        };
        WaterRefractionMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_levelData",
                "u_isRefractionRenderListEmpty",
                wd.VariableNameTable.getVariableName("refractionMap")
            ]);
        };
        return WaterRefractionMapShaderLib;
    }(wd.EngineShaderLib));
    wd.WaterRefractionMapShaderLib = WaterRefractionMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var WaterShaderLib = (function (_super) {
        __extends(WaterShaderLib, _super);
        function WaterShaderLib() {
            _super.apply(this, arguments);
            this.type = "water";
        }
        WaterShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        WaterShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            program.sendStructureData("u_waveData.length", wd.EVariableType.FLOAT_1, material.wave.length);
            program.sendStructureData("u_waveData.height", wd.EVariableType.FLOAT_1, material.wave.height);
        };
        WaterShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_waveData"
            ]);
        };
        return WaterShaderLib;
    }(wd.EngineShaderLib));
    wd.WaterShaderLib = WaterShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BitmapFontBufferContainer = (function (_super) {
        __extends(BitmapFontBufferContainer, _super);
        function BitmapFontBufferContainer() {
            _super.apply(this, arguments);
            this._pageBuffer = null;
        }
        BitmapFontBufferContainer.create = function (entityObject) {
            var obj = new this(entityObject);
            return obj;
        };
        BitmapFontBufferContainer.prototype.createBuffersFromGeometryData = function () {
            _super.prototype.createBuffersFromGeometryData.call(this);
            this.getChild(wd.EBufferDataType.CUSTOM, "pages");
        };
        BitmapFontBufferContainer.prototype.getBufferForRenderSort = function () {
            var buffer = this.getChild(wd.EBufferDataType.VERTICE);
            if (!buffer) {
                return null;
            }
            return buffer;
        };
        BitmapFontBufferContainer.prototype.getCustomData = function (dataName) {
            var geometryData = this.geometryData[dataName];
            if (!this.hasData(geometryData)) {
                return null;
            }
            this.createOnlyOnceAndUpdateArrayBuffer("_pageBuffer", geometryData, 1);
            return this._pageBuffer;
        };
        __decorate([
            wd.cacheBufferForBufferContainer()
        ], BitmapFontBufferContainer.prototype, "getCustomData", null);
        return BitmapFontBufferContainer;
    }(wd.CommonBufferContainer));
    wd.BitmapFontBufferContainer = BitmapFontBufferContainer;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BitmapFontGeometry = (function (_super) {
        __extends(BitmapFontGeometry, _super);
        function BitmapFontGeometry() {
            _super.apply(this, arguments);
            this._pages = null;
        }
        BitmapFontGeometry.create = function () {
            var geom = new this();
            return geom;
        };
        BitmapFontGeometry.prototype.computeData = function () {
            var bitmapFont = this.entityObject.getComponent(wd.ThreeDBitmapFont), layoutDataList = bitmapFont.layoutDataList, vertices = null, texCoords = null, indices = null, fntData = wd.LoaderManager.getInstance().get(bitmapFont.fntId);
            if (layoutDataList) {
                vertices = this._generateVertices(layoutDataList, bitmapFont.width, bitmapFont.height);
                texCoords = this._generateTexCoords(layoutDataList, fntData.scaleW, fntData.scaleH, this.material.isMapFlipY());
                indices = this._generateIndices(layoutDataList);
                if (fntData.isMultiPages) {
                    this._pages = this._generatePages(layoutDataList);
                }
            }
            else {
                vertices = [];
                texCoords = [];
                indices = [];
                this._pages = [];
            }
            return {
                vertices: vertices,
                faces: wd.GeometryUtils.convertToFaces(indices, null),
                texCoords: texCoords
            };
        };
        BitmapFontGeometry.prototype.updateBuffers = function () {
            if (this.buffers === null) {
                return;
            }
            var geometryData = null, _a = this.computeData(), vertices = _a.vertices, faces = _a.faces, texCoords = _a.texCoords;
            this.buffers.geometryData.vertices = vertices;
            this.buffers.geometryData.faces = faces;
            this.buffers.geometryData.texCoords = texCoords;
            if (this.hasMultiPages()) {
                this.buffers.geometryData.pages = this._pages;
            }
        };
        BitmapFontGeometry.prototype.hasMultiPages = function () {
            return this._pages !== null && this._pages.length > 0;
        };
        BitmapFontGeometry.prototype.createBufferContainer = function () {
            if (this.hasMultiPages()) {
                return wd.BitmapFontBufferContainer.create(this.entityObject);
            }
            return wd.BasicBufferContainer.create(this.entityObject);
        };
        BitmapFontGeometry.prototype.createGeometryData = function (computedData) {
            if (this.hasMultiPages()) {
                var vertices = computedData.vertices, _a = computedData.faces, faces = _a === void 0 ? [] : _a, texCoords = computedData.texCoords, colors = computedData.colors, geometryData = wd.BitmapFontGeometryData.create(this);
                geometryData.vertices = vertices;
                geometryData.faces = faces;
                geometryData.texCoords = texCoords;
                geometryData.colors = colors;
                geometryData.pages = this._pages;
                return geometryData;
            }
            return this.createBasicGeometryData(computedData);
        };
        BitmapFontGeometry.prototype._generatePages = function (layoutDataList) {
            var pages = [], i = 0;
            layoutDataList.forEach(function (layoutCharData) {
                var page = layoutCharData.data.page || 0;
                pages[i++] = page;
                pages[i++] = page;
                pages[i++] = page;
                pages[i++] = page;
            });
            return pages;
        };
        BitmapFontGeometry.prototype._generateVertices = function (layoutDataList, bitmapFontWidth, bitmapFontHeight) {
            var vertices = [], i = 0;
            layoutDataList.forEach(function (layoutCharData) {
                var rect = layoutCharData.data.rect, z = 0, w = rect.width, h = rect.height, position = wd.CoordinateUtils.convertLeftCornerPositionToCenterPositionInWebGL(wd.Vector2.create(layoutCharData.position[0], layoutCharData.position[1]), bitmapFontWidth, bitmapFontHeight), x = position.x, y = position.y;
                vertices[i++] = x;
                vertices[i++] = -y;
                vertices[i++] = z;
                vertices[i++] = x;
                vertices[i++] = -(y + h);
                vertices[i++] = z;
                vertices[i++] = x + w;
                vertices[i++] = -(y + h);
                vertices[i++] = z;
                vertices[i++] = x + w;
                vertices[i++] = -y;
                vertices[i++] = z;
            });
            return vertices;
        };
        BitmapFontGeometry.prototype._generateTexCoords = function (layoutDataList, textureWidth, textureHeight, flipY) {
            var texCoords = [], i = 0;
            layoutDataList.forEach(function (layoutDataList) {
                var rect = layoutDataList.data.rect, bw = (rect.x + rect.width), bh = (rect.y + rect.height), u0 = rect.x / textureWidth, v0 = rect.y / textureHeight, u1 = bw / textureWidth, v1 = bh / textureHeight;
                if (flipY) {
                    v0 = (textureHeight - rect.y) / textureHeight;
                    v1 = (textureHeight - bh) / textureHeight;
                }
                texCoords[i++] = u0;
                texCoords[i++] = v0;
                texCoords[i++] = u0;
                texCoords[i++] = v1;
                texCoords[i++] = u1;
                texCoords[i++] = v1;
                texCoords[i++] = u1;
                texCoords[i++] = v0;
            });
            return texCoords;
        };
        BitmapFontGeometry.prototype._generateIndices = function (layoutDataList) {
            var numIndices = layoutDataList.getCount() * 6, indices = [];
            for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
                indices[i] = j;
                indices[i + 1] = j + 1;
                indices[i + 2] = j + 2;
                indices[i + 3] = j;
                indices[i + 4] = j + 2;
                indices[i + 5] = j + 3;
            }
            return indices;
        };
        return BitmapFontGeometry;
    }(wd.Geometry));
    wd.BitmapFontGeometry = BitmapFontGeometry;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BitmapFontGeometryData = (function (_super) {
        __extends(BitmapFontGeometryData, _super);
        function BitmapFontGeometryData() {
            _super.apply(this, arguments);
            this._pages = null;
        }
        BitmapFontGeometryData.create = function (geometry) {
            var obj = new this(geometry);
            return obj;
        };
        Object.defineProperty(BitmapFontGeometryData.prototype, "pages", {
            get: function () {
                return this._pages;
            },
            set: function (pages) {
                this._pages = pages;
                this.geometry.buffers.removeCache("pages");
            },
            enumerable: true,
            configurable: true
        });
        return BitmapFontGeometryData;
    }(wd.GeometryData));
    wd.BitmapFontGeometryData = BitmapFontGeometryData;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BitmapFontMaterial = (function (_super) {
        __extends(BitmapFontMaterial, _super);
        function BitmapFontMaterial() {
            _super.apply(this, arguments);
            this.enableSdf = false;
            this.sdfType = wd.SdfBitmapFontType.SMOOTH;
            this.alphaTest = 0.0001;
            this._bitmap = null;
            this._pageMapData = null;
        }
        BitmapFontMaterial.create = function () {
            var obj = new this();
            obj.initWhenCreate();
            return obj;
        };
        Object.defineProperty(BitmapFontMaterial.prototype, "bitmap", {
            get: function () {
                return this._bitmap;
            },
            set: function (map) {
                this.mapManager.addMap(map, {
                    samplerVariableName: wd.VariableNameTable.getVariableName("bitmap")
                });
                this._bitmap = map;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BitmapFontMaterial.prototype, "pageMapData", {
            get: function () {
                return this._pageMapData;
            },
            set: function (pageMapData) {
                this._pageMapData = pageMapData;
            },
            enumerable: true,
            configurable: true
        });
        BitmapFontMaterial.prototype.isMapFlipY = function () {
            if (this.pageMapData !== null && this.pageMapData.length > 0) {
                return this.pageMapData[0].flipY;
            }
            return this.bitmap.flipY;
        };
        BitmapFontMaterial.prototype.initWhenCreate = function () {
            _super.prototype.initWhenCreate.call(this);
            this.blend = true;
        };
        BitmapFontMaterial.prototype.init = function () {
            if (this._hasMultiPages()) {
                this.mapManager.addMapArray("u_pageSampler2Ds", this.pageMapData);
            }
            _super.prototype.init.call(this);
        };
        BitmapFontMaterial.prototype.getTextureForRenderSort = function () {
            if (this.bitmap) {
                return this.bitmap;
            }
            if (this.pageMapData) {
                return this.pageMapData[0];
            }
            return null;
        };
        BitmapFontMaterial.prototype.addExtendShaderLib = function () {
            if (this._hasMultiPages()) {
                this.shader.addLib(wd.MultiPagesBitmapFontShaderLib.create());
            }
            else if (!this._isSdfFont()) {
                this.shader.addLib(wd.BasicBitmapFontShaderLib.create());
            }
        };
        BitmapFontMaterial.prototype.addEndShaderLib = function () {
            this.shader.addLib(wd.CommonBitmapFontShaderLib.create());
            if (this._isSdfFont()) {
                switch (this.sdfType) {
                    case wd.SdfBitmapFontType.SMOOTH:
                        this.shader.addLib(wd.SdfBitmapFontSmoothShaderLib.create());
                        break;
                    default:
                        wd.Log.error(true, wd.Log.info.FUNC_UNKNOW("sdfType:" + this.sdfType));
                }
            }
        };
        BitmapFontMaterial.prototype._hasMultiPages = function () {
            return this.geometry.hasMultiPages();
        };
        BitmapFontMaterial.prototype._isSdfFont = function () {
            return this.enableSdf;
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BitmapFontMaterial.prototype, "enableSdf", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BitmapFontMaterial.prototype, "sdfType", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], BitmapFontMaterial.prototype, "alphaTest", void 0);
        __decorate([
            wd.requireSetter(function (map) {
                wd.it("should add ImageTexture", function () {
                    wd.expect(map).instanceOf(wd.ImageTexture);
                });
            }),
            wd.cloneAttributeAsCloneable()
        ], BitmapFontMaterial.prototype, "bitmap", null);
        __decorate([
            wd.requireSetter(function (pageMapData) {
                wd.it("pageMapData should be Array type", function () {
                    wd.expect(pageMapData).be.a("array");
                });
            }),
            wd.cloneAttributeAsCustomType(function (source, target, memberName) {
                target[memberName] = wd.CloneUtils.cloneArray(source[memberName], true);
            })
        ], BitmapFontMaterial.prototype, "pageMapData", null);
        __decorate([
            wd.virtual,
            wd.require(function () {
                wd.it("should only set pageMap or bitmap ", function () {
                    wd.expect((this.pageMapData !== null && this.bitmap === null)
                        || (this.pageMapData === null && this.bitmap !== null)).true;
                }, this);
                wd.describe("if has multi pages", function () {
                    wd.it("each map in pageMapData should be all flipY or all not", function () {
                        var count = this.pageMapData.filter(function (map) {
                            return map.flipY === true;
                        }).length;
                        wd.expect(count === 0 || count === this.pageMapData.length).true;
                    });
                }, function () {
                    return this.pageMapData !== null && this.pageMapData.length > 0;
                }, this);
            })
        ], BitmapFontMaterial.prototype, "isMapFlipY", null);
        __decorate([
            wd.ensure(function (hasMultiPages) {
                if (hasMultiPages) {
                    wd.it("should has one page map at least", function () {
                        wd.expect(this.pageMapData.length).greaterThan(0);
                    }, this);
                }
            })
        ], BitmapFontMaterial.prototype, "_hasMultiPages", null);
        return BitmapFontMaterial;
    }(wd.StandardLightMaterial));
    wd.BitmapFontMaterial = BitmapFontMaterial;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ThreeDBitmapFont = (function (_super) {
        __extends(ThreeDBitmapFont, _super);
        function ThreeDBitmapFont() {
            _super.apply(this, arguments);
            this._text = "";
            this._xAlignment = wd.EFontXAlignment.LEFT;
            this.fntId = null;
            this._width = null;
            this.height = 0;
            this.layoutDataList = null;
            this._layout = wd.BitmapFontLayout.create();
        }
        ThreeDBitmapFont.create = function () {
            var obj = new this();
            return obj;
        };
        Object.defineProperty(ThreeDBitmapFont.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                if (this._text !== text) {
                    this._text = text;
                    this.needFormat = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDBitmapFont.prototype, "xAlignment", {
            get: function () {
                return this._xAlignment;
            },
            set: function (xAlignment) {
                if (this._xAlignment !== xAlignment) {
                    this._xAlignment = xAlignment;
                    this.needFormat = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ThreeDBitmapFont.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this.needFormat = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        ThreeDBitmapFont.prototype.init = function () {
            _super.prototype.init.call(this);
            this.layoutDataList = this._layout.getLayoutData(this.text, this.fntId, {
                width: this.width,
                align: this.xAlignment
            });
        };
        ThreeDBitmapFont.prototype.reFormat = function () {
            this.layoutDataList = this._layout.getLayoutData(this.text, this.fntId, {
                width: this.width,
                align: this.xAlignment
            });
            this.entityObject.getComponent(wd.BitmapFontGeometry).updateBuffers();
        };
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ThreeDBitmapFont.prototype, "text", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ThreeDBitmapFont.prototype, "xAlignment", null);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ThreeDBitmapFont.prototype, "fntId", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ThreeDBitmapFont.prototype, "_width", void 0);
        __decorate([
            wd.cloneAttributeAsBasicType()
        ], ThreeDBitmapFont.prototype, "height", void 0);
        return ThreeDBitmapFont;
    }(wd.ThreeDFont));
    wd.ThreeDBitmapFont = ThreeDBitmapFont;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BasicBitmapFontShaderLib = (function (_super) {
        __extends(BasicBitmapFontShaderLib, _super);
        function BasicBitmapFontShaderLib() {
            _super.apply(this, arguments);
            this.type = "basic_bitmapFont";
        }
        BasicBitmapFontShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        return BasicBitmapFontShaderLib;
    }(wd.EngineShaderLib));
    wd.BasicBitmapFontShaderLib = BasicBitmapFontShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CommonBitmapFontShaderLib = (function (_super) {
        __extends(CommonBitmapFontShaderLib, _super);
        function CommonBitmapFontShaderLib() {
            _super.apply(this, arguments);
            this.type = "common_bitmapFont";
        }
        CommonBitmapFontShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CommonBitmapFontShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable(["u_bitmapSampler"]);
        };
        return CommonBitmapFontShaderLib;
    }(wd.EngineShaderLib));
    wd.CommonBitmapFontShaderLib = CommonBitmapFontShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var MultiPagesBitmapFontShaderLib = (function (_super) {
        __extends(MultiPagesBitmapFontShaderLib, _super);
        function MultiPagesBitmapFontShaderLib() {
            _super.apply(this, arguments);
            this.type = "multiPages_bitmapFont";
        }
        MultiPagesBitmapFontShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        MultiPagesBitmapFontShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var pageBuffer = cmd.buffers.getChild(wd.EBufferDataType.CUSTOM, "pages");
            if (!pageBuffer) {
                return;
            }
            this.sendAttributeBuffer(program, "a_page", pageBuffer);
        };
        MultiPagesBitmapFontShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addAttributeVariable(["a_page"]);
            this.addUniformVariable(["u_pageSampler2Ds"]);
            this.fsSourceBody += material.pageMapData.map(function (map, index) {
                var cond = index === 0 ? 'if' : 'else if';
                return cond + "(v_page == " + index + ".0) {\n                    totalColor *= texture2D(u_pageSampler2Ds[" + index + "], v_bitmapCoord);\n                    }";
            }).join('\n')
                + "\n";
            this.fsSourceDefineList.addChildren([{
                    name: "PAGE_COUNT",
                    value: material.pageMapData.length
                }]);
        };
        __decorate([
            wd.require(function (program, cmd, material) {
                wd.it("should exist page buffer", function () {
                    wd.expect(cmd.buffers.getChild(wd.EBufferDataType.CUSTOM, "pages")).exist;
                });
            })
        ], MultiPagesBitmapFontShaderLib.prototype, "sendShaderVariables", null);
        return MultiPagesBitmapFontShaderLib;
    }(wd.EngineShaderLib));
    wd.MultiPagesBitmapFontShaderLib = MultiPagesBitmapFontShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var SdfBitmapFontSmoothShaderLib = (function (_super) {
        __extends(SdfBitmapFontSmoothShaderLib, _super);
        function SdfBitmapFontSmoothShaderLib() {
            _super.apply(this, arguments);
            this.type = "sdf_bitmapFont_smooth";
        }
        SdfBitmapFontSmoothShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        SdfBitmapFontSmoothShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            if (wd.GPUDetector.getInstance().extensionStandardDerivatives) {
                this.fsSourceExtensionList.addChild("GL_OES_standard_derivatives");
                this.fsSourceFuncDefine = wd.ShaderChunk.sdf_bitmapFont_smoothStep_standardDerivatives.funcDefine;
            }
            else {
                this.fsSourceFuncDefine = wd.ShaderChunk.sdf_bitmapFont_smoothStep_fallback.funcDefine;
            }
            this.fsSourceBody += "if (gl_FragColor.a < " + material.alphaTest + "){\n    discard;\n}";
        };
        return SdfBitmapFontSmoothShaderLib;
    }(wd.EngineShaderLib));
    wd.SdfBitmapFontSmoothShaderLib = SdfBitmapFontSmoothShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    (function (SdfBitmapFontType) {
        SdfBitmapFontType[SdfBitmapFontType["SMOOTH"] = 0] = "SMOOTH";
    })(wd.SdfBitmapFontType || (wd.SdfBitmapFontType = {}));
    var SdfBitmapFontType = wd.SdfBitmapFontType;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BuildShadowMapShaderLib = (function (_super) {
        __extends(BuildShadowMapShaderLib, _super);
        function BuildShadowMapShaderLib() {
            _super.apply(this, arguments);
        }
        BuildShadowMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.setFsSource(this.getFsChunk("commonBuildShadowMap_fragment.glsl"));
            this.setFsSource(this.getFsChunk(), "+");
        };
        return BuildShadowMapShaderLib;
    }(wd.EngineShaderLib));
    wd.BuildShadowMapShaderLib = BuildShadowMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BuildTwoDShadowMapShaderLib = (function (_super) {
        __extends(BuildTwoDShadowMapShaderLib, _super);
        function BuildTwoDShadowMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "buildTwoDShadowMap";
        }
        BuildTwoDShadowMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        BuildTwoDShadowMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            program.sendMatrix4("u_vpMatrixFromLight", cmd.vMatrix.applyMatrix(cmd.pMatrix, true));
        };
        BuildTwoDShadowMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            var fs = null;
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_vpMatrixFromLight"
            ]);
            if (wd.GPUDetector.getInstance().extensionDepthTexture) {
                fs = this.getFsChunk("buildTwoDShadowMap_depthMap");
            }
            else {
                fs = this.getFsChunk("buildTwoDShadowMap_packDepth");
            }
            this.fsSourceBody = fs.body;
        };
        return BuildTwoDShadowMapShaderLib;
    }(wd.BuildShadowMapShaderLib));
    wd.BuildTwoDShadowMapShaderLib = BuildTwoDShadowMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var BuildCubemapShadowMapShaderLib = (function (_super) {
        __extends(BuildCubemapShadowMapShaderLib, _super);
        function BuildCubemapShadowMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "buildCubemapShadowMap";
        }
        BuildCubemapShadowMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        BuildCubemapShadowMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            wd.Director.getInstance().scene.glslData.getChild(wd.EShaderGLSLData.BUILD_CUBEMAP_SHADOWMAP).forEach(function (data, index) {
                var light = data.light;
                program.sendVector3("u_lightPos", light.position);
                program.sendFloat1("u_farPlane", light.shadowCameraFar);
            });
        };
        BuildCubemapShadowMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this.addUniformVariable([
                "u_lightPos", "u_farPlane"
            ]);
        };
        return BuildCubemapShadowMapShaderLib;
    }(wd.BuildShadowMapShaderLib));
    wd.BuildCubemapShadowMapShaderLib = BuildCubemapShadowMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TotalShadowMapShaderLib = (function (_super) {
        __extends(TotalShadowMapShaderLib, _super);
        function TotalShadowMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "totalShadowMap";
        }
        TotalShadowMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        TotalShadowMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
        };
        return TotalShadowMapShaderLib;
    }(wd.EngineShaderLib));
    wd.TotalShadowMapShaderLib = TotalShadowMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var ShadowMapShaderLib = (function (_super) {
        __extends(ShadowMapShaderLib, _super);
        function ShadowMapShaderLib() {
            _super.apply(this, arguments);
            this._softTypeChangeSubscription = null;
        }
        ShadowMapShaderLib.prototype.init = function () {
            var shader = this.shader;
            this._softTypeChangeSubscription = wd.EventManager.fromEvent(wd.Director.getInstance().scene.gameObjectScene, wd.EEngineEvent.SHADOWMAP_SOFTTYPE_CHANGE)
                .subscribe(function () {
                shader.libDirty = true;
            });
        };
        ShadowMapShaderLib.prototype.dispose = function () {
            this._softTypeChangeSubscription && this._softTypeChangeSubscription.dispose();
        };
        ShadowMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            this._setShadowMapSource();
        };
        ShadowMapShaderLib.prototype._setShadowMapSource = function () {
            var scene = wd.Director.getInstance().scene, shadowManager = scene.gameObjectScene.shadowManager, twoDShadowMapCountForGLSL = shadowManager.twoDShadowMapCountForGLSL, cubemapShadowMapCountForGLSL = shadowManager.cubemapShadowMapCountForGLSL;
            if (scene.shadowMap.softType === wd.EShadowMapSoftType.PCF) {
                this.fsSourceDefineList.addChildren([{
                        name: "SHADOWMAP_TYPE_PCF"
                    }]);
            }
            this.vsSourceDefineList.addChild({
                name: "TWOD_SHADOWMAP_COUNT",
                value: twoDShadowMapCountForGLSL
            });
            this.fsSourceDefineList.addChildren([
                {
                    name: "TWOD_SHADOWMAP_COUNT",
                    value: twoDShadowMapCountForGLSL
                },
                {
                    name: "CUBEMAP_SHADOWMAP_COUNT",
                    value: cubemapShadowMapCountForGLSL
                }
            ]);
        };
        return ShadowMapShaderLib;
    }(wd.EngineShaderLib));
    wd.ShadowMapShaderLib = ShadowMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var TwoDShadowMapShaderLib = (function (_super) {
        __extends(TwoDShadowMapShaderLib, _super);
        function TwoDShadowMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "twoDShadowMap";
        }
        TwoDShadowMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        TwoDShadowMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var glslData = null;
            glslData = wd.Director.getInstance().scene.glslData.getChild(wd.EShaderGLSLData.TWOD_SHADOWMAP);
            if (!glslData) {
                return;
            }
            glslData.forEach(function (data, index) {
                var camera = data.camera, light = data.light;
                if (data.isRenderListEmpty) {
                    program.sendNum1("u_isTwoDRenderListEmpty[" + index + "]", 1);
                    return;
                }
                program.sendNum1("u_isTwoDRenderListEmpty[" + index + "]", 0);
                program.sendMatrix4("u_vpMatrixFromLight[" + index + "]", camera.worldToCameraMatrix.applyMatrix(camera.pMatrix, true));
                program.sendFloat2("u_twoDShadowSize[" + index + "]", [light.shadowMapWidth, light.shadowMapHeight]);
                program.sendFloat1("u_twoDShadowBias[" + index + "]", light.shadowBias);
                program.sendFloat1("u_twoDShadowDarkness[" + index + "]", light.shadowDarkness);
                program.sendVector3("u_twoDLightPos[" + index + "]", light.position);
            });
        };
        TwoDShadowMapShaderLib.prototype.setShaderDefinition = function (cmd, material) {
            var fs = null;
            _super.prototype.setShaderDefinition.call(this, cmd, material);
            if (wd.GPUDetector.getInstance().extensionDepthTexture) {
                fs = this.getFsChunk("twoDShadowMap_depthMap");
            }
            else {
                fs = this.getFsChunk("twoDShadowMap_unpackDepth");
            }
            this.fsSourceFuncDeclare += fs.funcDeclare;
            this.fsSourceFuncDefine += fs.funcDefine;
        };
        return TwoDShadowMapShaderLib;
    }(wd.ShadowMapShaderLib));
    wd.TwoDShadowMapShaderLib = TwoDShadowMapShaderLib;
})(wd || (wd = {}));
var wd;
(function (wd) {
    var CubemapShadowMapShaderLib = (function (_super) {
        __extends(CubemapShadowMapShaderLib, _super);
        function CubemapShadowMapShaderLib() {
            _super.apply(this, arguments);
            this.type = "cubemapShadowMap";
        }
        CubemapShadowMapShaderLib.create = function () {
            var obj = new this();
            return obj;
        };
        CubemapShadowMapShaderLib.prototype.sendShaderVariables = function (program, cmd, material) {
            var glslData = wd.Director.getInstance().scene.glslData.getChild(wd.EShaderGLSLData.CUBEMAP_SHADOWMAP);
            if (!glslData) {
                return;
            }
            glslData.forEach(function (data, index) {
                var light = data.light;
                if (data.isRenderListEmpty) {
                    program.sendNum1("u_isCubemapRenderListEmpty[" + index + "]", 1);
                }
                else {
                    program.sendNum1("u_isCubemapRenderListEmpty[" + index + "]", 0);
                }
                program.sendVector3("u_cubemapLightPos[" + index + "]", light.position);
                program.sendFloat1("u_farPlane[" + index + "]", light.shadowCameraFar);
                program.sendFloat1("u_cubemapShadowBias[" + index + "]", light.shadowBias);
                program.sendFloat1("u_cubemapShadowDarkness[" + index + "]", light.shadowDarkness);
            });
        };
        return CubemapShadowMapShaderLib;
    }(wd.ShadowMapShaderLib));
    wd.CubemapShadowMapShaderLib = CubemapShadowMapShaderLib;
})(wd || (wd = {}));
