/*!
 * wonder.js - 3d webgl engine
 * @version v1.0.0-alpha.6
 * @author DreamForest
 * @link https://github.com/DreamForeast/Wonder.js
 * @license MIT
 */


function __extends(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var SPLITPATH_REGEX = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var PathUtils = (function () {
    function PathUtils() {
    }
    PathUtils.basename = function (path, ext) {
        var f = this._splitPath(path)[2];
        if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
        }
        return f;
    };
    PathUtils.changeExtname = function (pathStr, extname) {
        var extname = extname || "", index = pathStr.indexOf("?"), tempStr = "";
        if (index > 0) {
            tempStr = pathStr.substring(index);
            pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf(".");
        if (index < 0) {
            return pathStr + extname + tempStr;
        }
        return pathStr.substring(0, index) + extname + tempStr;
    };
    PathUtils.changeBasename = function (pathStr, basename, isSameExt) {
        if (isSameExt === void 0) { isSameExt = false; }
        var index = null, tempStr = null, ext = null;
        if (basename.indexOf(".") == 0) {
            return this.changeExtname(pathStr, basename);
        }
        index = pathStr.indexOf("?");
        tempStr = "";
        ext = isSameExt ? this.extname(pathStr) : "";
        if (index > 0) {
            tempStr = pathStr.substring(index);
            pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf("/");
        index = index <= 0 ? 0 : index + 1;
        return pathStr.substring(0, index) + basename + ext + tempStr;
    };
    PathUtils.extname = function (path) {
        return this._splitPath(path)[3];
    };
    PathUtils.dirname = function (path) {
        var result = this._splitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
            return '.';
        }
        if (dir) {
            dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
    };
    PathUtils._splitPath = function (fileName) {
        return SPLITPATH_REGEX.exec(fileName).slice(1);
    };
    return PathUtils;
}());

var JudgeUtils$1 = (function () {
    function JudgeUtils() {
    }
    JudgeUtils.isArray = function (arr) {
        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
        var length = arr && arr.length;
        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };
    JudgeUtils.isArrayExactly = function (arr) {
        return Object.prototype.toString.call(arr) === "[object Array]";
    };
    JudgeUtils.isNumber = function (num) {
        return typeof num == "number";
    };
    JudgeUtils.isNumberExactly = function (num) {
        return Object.prototype.toString.call(num) === "[object Number]";
    };
    JudgeUtils.isString = function (str) {
        return typeof str == "string";
    };
    JudgeUtils.isStringExactly = function (str) {
        return Object.prototype.toString.call(str) === "[object String]";
    };
    JudgeUtils.isBoolean = function (bool) {
        return bool === true || bool === false || toString.call(bool) === '[boolect Boolean]';
    };
    JudgeUtils.isDom = function (obj) {
        return !!(obj && obj.nodeType === 1);
    };
    JudgeUtils.isObject = function (obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };
    JudgeUtils.isDirectObject = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
    };
    JudgeUtils.isHostMethod = function (object, property) {
        var type = typeof object[property];
        return type === "function" ||
            (type === "object" && !!object[property]);
    };
    JudgeUtils.isNodeJs = function () {
        return ((typeof global != "undefined" && global.module) || (typeof module != "undefined")) && typeof module.exports != "undefined";
    };
    JudgeUtils.isFunction = function (func) {
        return true;
    };
    return JudgeUtils;
}());
if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    JudgeUtils$1.isFunction = function (func) {
        return typeof func == 'function';
    };
}
else {
    JudgeUtils$1.isFunction = function (func) {
        return Object.prototype.toString.call(func) === "[object Function]";
    };
}

var root;
if (JudgeUtils$1.isNodeJs() && typeof global != "undefined") {
    root = global;
}
else if (typeof window != "undefined") {
    root = window;
}
else if (typeof self != "undefined") {
    root = self;
}
else {
    Log$1.error("no avaliable root!");
}

var Log$1 = (function () {
    function Log() {
    }
    Log.log = function () {
        var messages = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            messages[_i] = arguments[_i];
        }
        if (!this._exec("log", messages)) {
            root.alert(messages.join(","));
        }
        this._exec("trace", messages);
    };
    Log.assert = function (cond) {
        if (cond) {
            if (!this._exec("assert", arguments, 1)) {
                this.log.apply(this, Array.prototype.slice.call(arguments, 1));
            }
        }
    };
    Log.error = function (cond) {
        if (cond) {
            throw new Error(Array.prototype.slice.call(arguments, 1).join("\n"));
        }
    };
    Log.warn = function () {
        var result = this._exec("warn", arguments);
        if (!result) {
            this.log.apply(this, arguments);
        }
        else {
            this._exec("trace", ["warn trace"]);
        }
    };
    Log._exec = function (consoleMethod, args, sliceBegin) {
        if (sliceBegin === void 0) { sliceBegin = 0; }
        if (root.console && root.console[consoleMethod]) {
            root.console[consoleMethod].apply(root.console, Array.prototype.slice.call(args, sliceBegin));
            return true;
        }
        return false;
    };
    Log.info = {
        INVALID_PARAM: "invalid parameter",
        helperFunc: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var result = "";
            args.forEach(function (val) {
                result += String(val) + " ";
            });
            return result.slice(0, -1);
        },
        assertion: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 2) {
                return this.helperFunc(args[0], args[1]);
            }
            else if (args.length === 3) {
                return this.helperFunc(args[1], args[0], args[2]);
            }
            else {
                throw new Error("args.length must <= 3");
            }
        },
        FUNC_INVALID: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("invalid");
            return this.assertion.apply(this, args);
        },
        FUNC_MUST: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("must");
            return this.assertion.apply(this, args);
        },
        FUNC_MUST_BE: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("must be");
            return this.assertion.apply(this, args);
        },
        FUNC_MUST_NOT_BE: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("must not be");
            return this.assertion.apply(this, args);
        },
        FUNC_SHOULD: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("should");
            return this.assertion.apply(this, args);
        },
        FUNC_SHOULD_NOT: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("should not");
            return this.assertion.apply(this, args);
        },
        FUNC_SUPPORT: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("support");
            return this.assertion.apply(this, args);
        },
        FUNC_NOT_SUPPORT: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("not support");
            return this.assertion.apply(this, args);
        },
        FUNC_MUST_DEFINE: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("must define");
            return this.assertion.apply(this, args);
        },
        FUNC_MUST_NOT_DEFINE: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("must not define");
            return this.assertion.apply(this, args);
        },
        FUNC_UNKNOW: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("unknow");
            return this.assertion.apply(this, args);
        },
        FUNC_EXPECT: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("expect");
            return this.assertion.apply(this, args);
        },
        FUNC_UNEXPECT: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("unexpect");
            return this.assertion.apply(this, args);
        },
        FUNC_EXIST: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("exist");
            return this.assertion.apply(this, args);
        },
        FUNC_NOT_EXIST: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("not exist");
            return this.assertion.apply(this, args);
        },
        FUNC_ONLY: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("only");
            return this.assertion.apply(this, args);
        },
        FUNC_CAN_NOT: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            args.unshift("can't");
            return this.assertion.apply(this, args);
        }
    };
    return Log;
}());

var Log$$1 = (function (_super) {
    __extends(Log$$1, _super);
    function Log$$1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Log$$1;
}(Log$1));

var $BREAK = {
    break: true
};
var $REMOVE = void 0;

var List = (function () {
    function List() {
        this.children = null;
    }
    List.prototype.getCount = function () {
        return this.children.length;
    };
    List.prototype.hasChild = function (child) {
        var c = null, children = this.children;
        for (var i = 0, len = children.length; i < len; i++) {
            c = children[i];
            if (child.uid && c.uid && child.uid == c.uid) {
                return true;
            }
            else if (child === c) {
                return true;
            }
        }
        return false;
    };
    List.prototype.hasChildWithFunc = function (func) {
        for (var i = 0, len = this.children.length; i < len; i++) {
            if (func(this.children[i], i)) {
                return true;
            }
        }
        return false;
    };
    List.prototype.getChildren = function () {
        return this.children;
    };
    List.prototype.getChild = function (index) {
        return this.children[index];
    };
    List.prototype.addChild = function (child) {
        this.children.push(child);
        return this;
    };
    List.prototype.addChildren = function (arg) {
        if (JudgeUtils$1.isArray(arg)) {
            var children = arg;
            this.children = this.children.concat(children);
        }
        else if (arg instanceof List) {
            var children = arg;
            this.children = this.children.concat(children.getChildren());
        }
        else {
            var child = arg;
            this.addChild(child);
        }
        return this;
    };
    List.prototype.setChildren = function (children) {
        this.children = children;
        return this;
    };
    List.prototype.unShiftChild = function (child) {
        this.children.unshift(child);
    };
    List.prototype.removeAllChildren = function () {
        this.children = [];
        return this;
    };
    List.prototype.forEach = function (func, context) {
        this._forEach(this.children, func, context);
        return this;
    };
    List.prototype.toArray = function () {
        return this.children;
    };
    List.prototype.copyChildren = function () {
        return this.children.slice(0);
    };
    List.prototype.removeChildHelper = function (arg) {
        var result = null;
        if (JudgeUtils$1.isFunction(arg)) {
            var func = arg;
            result = this._removeChild(this.children, func);
        }
        else if (arg.uid) {
            result = this._removeChild(this.children, function (e) {
                if (!e.uid) {
                    return false;
                }
                return e.uid === arg.uid;
            });
        }
        else {
            result = this._removeChild(this.children, function (e) {
                return e === arg;
            });
        }
        return result;
    };
    List.prototype._forEach = function (arr, func, context) {
        var scope = context, i = 0, len = arr.length;
        for (i = 0; i < len; i++) {
            if (func.call(scope, arr[i], i) === $BREAK) {
                break;
            }
        }
    };
    List.prototype._removeChild = function (arr, func) {
        var self = this, removedElementArr = [], remainElementArr = [];
        this._forEach(arr, function (e, index) {
            if (!!func.call(self, e)) {
                removedElementArr.push(e);
            }
            else {
                remainElementArr.push(e);
            }
        });
        this.children = remainElementArr;
        return removedElementArr;
    };
    return List;
}());

var ExtendUtils = (function () {
    function ExtendUtils() {
    }
    ExtendUtils.extendDeep = function (parent, child, filter) {
        if (filter === void 0) { filter = function (val, i) { return true; }; }
        var i = null, len = 0, toStr = Object.prototype.toString, sArr = "[object Array]", sOb = "[object Object]", type = "", _child = null;
        if (toStr.call(parent) === sArr) {
            _child = child || [];
            for (i = 0, len = parent.length; i < len; i++) {
                var member = parent[i];
                if (!filter(member, i)) {
                    continue;
                }
                if (member.clone) {
                    _child[i] = member.clone();
                    continue;
                }
                type = toStr.call(member);
                if (type === sArr || type === sOb) {
                    _child[i] = type === sArr ? [] : {};
                    ExtendUtils.extendDeep(member, _child[i]);
                }
                else {
                    _child[i] = member;
                }
            }
        }
        else if (toStr.call(parent) === sOb) {
            _child = child || {};
            for (i in parent) {
                var member = parent[i];
                if (!filter(member, i)) {
                    continue;
                }
                if (member.clone) {
                    _child[i] = member.clone();
                    continue;
                }
                type = toStr.call(member);
                if (type === sArr || type === sOb) {
                    _child[i] = type === sArr ? [] : {};
                    ExtendUtils.extendDeep(member, _child[i]);
                }
                else {
                    _child[i] = member;
                }
            }
        }
        else {
            _child = parent;
        }
        return _child;
    };
    ExtendUtils.extend = function (destination, source) {
        var property = "";
        for (property in source) {
            if (source.hasOwnProperty(property)) {
                destination[property] = source[property];
            }
        }
        return destination;
    };
    ExtendUtils.assign = function (source, target) {
        for (var property in source) {
            if (source.hasOwnProperty(property)) {
                if (target[property] === void 0 || target[property] === null) {
                    target[property] = source[property];
                }
            }
        }
        return target;
    };
    ExtendUtils.copyPublicAttri = function (source) {
        var property = null, destination = {};
        this.extendDeep(source, destination, function (item, property) {
            return property.slice(0, 1) !== "_"
                && !JudgeUtils$1.isFunction(item);
        });
        return destination;
    };
    return ExtendUtils;
}());

var Collection = (function (_super) {
    __extends(Collection, _super);
    function Collection(children) {
        if (children === void 0) { children = []; }
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Collection.create = function (children) {
        if (children === void 0) { children = []; }
        var obj = new this(children);
        return obj;
    };
    Collection.prototype.clone = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var target = null, isDeep = null;
        if (args.length === 0) {
            isDeep = false;
            target = Collection.create();
        }
        else if (args.length === 1) {
            if (JudgeUtils$1.isBoolean(args[0])) {
                target = Collection.create();
                isDeep = args[0];
            }
            else {
                target = args[0];
                isDeep = false;
            }
        }
        else {
            target = args[0];
            isDeep = args[1];
        }
        if (isDeep === true) {
            target.setChildren(ExtendUtils.extendDeep(this.children));
        }
        else {
            target.setChildren(ExtendUtils.extend([], this.children));
        }
        return target;
    };
    Collection.prototype.filter = function (func) {
        var children = this.children, result = [], value = null;
        for (var i = 0, len = children.length; i < len; i++) {
            value = children[i];
            if (func.call(children, value, i)) {
                result.push(value);
            }
        }
        return Collection.create(result);
    };
    Collection.prototype.findOne = function (func) {
        var scope = this.children, result = null;
        this.forEach(function (value, index) {
            if (!func.call(scope, value, index)) {
                return;
            }
            result = value;
            return $BREAK;
        });
        return result;
    };
    Collection.prototype.reverse = function () {
        return Collection.create(this.copyChildren().reverse());
    };
    Collection.prototype.removeChild = function (arg) {
        return Collection.create(this.removeChildHelper(arg));
    };
    Collection.prototype.sort = function (func, isSortSelf) {
        if (isSortSelf === void 0) { isSortSelf = false; }
        if (isSortSelf) {
            this.children.sort(func);
            return this;
        }
        return Collection.create(this.copyChildren().sort(func));
    };
    Collection.prototype.map = function (func) {
        var resultArr = [];
        this.forEach(function (e, index) {
            var result = func(e, index);
            if (result !== $REMOVE) {
                resultArr.push(result);
            }
        });
        return Collection.create(resultArr);
    };
    Collection.prototype.removeRepeatItems = function () {
        var noRepeatList = Collection.create();
        this.forEach(function (item) {
            if (noRepeatList.hasChild(item)) {
                return;
            }
            noRepeatList.addChild(item);
        });
        return noRepeatList;
    };
    Collection.prototype.hasRepeatItems = function () {
        var noRepeatList = Collection.create(), hasRepeat = false;
        this.forEach(function (item) {
            if (noRepeatList.hasChild(item)) {
                hasRepeat = true;
                return $BREAK;
            }
            noRepeatList.addChild(item);
        });
        return hasRepeat;
    };
    return Collection;
}(List));

var Hash = (function () {
    function Hash(children) {
        if (children === void 0) { children = {}; }
        this._children = null;
        this._children = children;
    }
    Hash.create = function (children) {
        if (children === void 0) { children = {}; }
        var obj = new this(children);
        return obj;
    };
    Hash.prototype.getChildren = function () {
        return this._children;
    };
    Hash.prototype.getCount = function () {
        var result = 0, children = this._children, key = null;
        for (key in children) {
            if (children.hasOwnProperty(key)) {
                result++;
            }
        }
        return result;
    };
    Hash.prototype.getKeys = function () {
        var result = Collection.create(), children = this._children, key = null;
        for (key in children) {
            if (children.hasOwnProperty(key)) {
                result.addChild(key);
            }
        }
        return result;
    };
    Hash.prototype.getValues = function () {
        var result = Collection.create(), children = this._children, key = null;
        for (key in children) {
            if (children.hasOwnProperty(key)) {
                result.addChild(children[key]);
            }
        }
        return result;
    };
    Hash.prototype.getChild = function (key) {
        return this._children[key];
    };
    Hash.prototype.setValue = function (key, value) {
        this._children[key] = value;
        return this;
    };
    Hash.prototype.addChild = function (key, value) {
        this._children[key] = value;
        return this;
    };
    Hash.prototype.addChildren = function (arg) {
        var i = null, children = null;
        if (arg instanceof Hash) {
            children = arg.getChildren();
        }
        else {
            children = arg;
        }
        for (i in children) {
            if (children.hasOwnProperty(i)) {
                this.addChild(i, children[i]);
            }
        }
        return this;
    };
    Hash.prototype.appendChild = function (key, value) {
        if (this._children[key] instanceof Collection) {
            var c = (this._children[key]);
            c.addChild(value);
        }
        else {
            this._children[key] = (Collection.create().addChild(value));
        }
        return this;
    };
    Hash.prototype.setChildren = function (children) {
        this._children = children;
    };
    Hash.prototype.removeChild = function (arg) {
        var result = [];
        if (JudgeUtils$1.isString(arg)) {
            var key = arg;
            result.push(this._children[key]);
            this._children[key] = void 0;
            delete this._children[key];
        }
        else if (JudgeUtils$1.isFunction(arg)) {
            var func_1 = arg, self_1 = this;
            this.forEach(function (val, key) {
                if (func_1(val, key)) {
                    result.push(self_1._children[key]);
                    self_1._children[key] = void 0;
                    delete self_1._children[key];
                }
            });
        }
        return Collection.create(result);
    };
    Hash.prototype.removeAllChildren = function () {
        this._children = {};
    };
    Hash.prototype.hasChild = function (key) {
        return this._children[key] !== void 0;
    };
    Hash.prototype.hasChildWithFunc = function (func) {
        var result = false;
        this.forEach(function (val, key) {
            if (func(val, key)) {
                result = true;
                return $BREAK;
            }
        });
        return result;
    };
    Hash.prototype.forEach = function (func, context) {
        var children = this._children;
        for (var i in children) {
            if (children.hasOwnProperty(i)) {
                if (func.call(context, children[i], i) === $BREAK) {
                    break;
                }
            }
        }
        return this;
    };
    Hash.prototype.filter = function (func) {
        var result = {}, children = this._children, value = null;
        for (var key in children) {
            if (children.hasOwnProperty(key)) {
                value = children[key];
                if (func.call(children, value, key)) {
                    result[key] = value;
                }
            }
        }
        return Hash.create(result);
    };
    Hash.prototype.findOne = function (func) {
        var result = [], self = this, scope = this._children;
        this.forEach(function (val, key) {
            if (!func.call(scope, val, key)) {
                return;
            }
            result = [key, self.getChild(key)];
            return $BREAK;
        });
        return result;
    };
    Hash.prototype.map = function (func) {
        var resultMap = {};
        this.forEach(function (val, key) {
            var result = func(val, key);
            if (result !== $REMOVE) {
                Log$1.error(!JudgeUtils$1.isArray(result) || result.length !== 2, Log$1.info.FUNC_MUST_BE("iterator", "[key, value]"));
                resultMap[result[0]] = result[1];
            }
        });
        return Hash.create(resultMap);
    };
    Hash.prototype.toCollection = function () {
        var result = Collection.create();
        this.forEach(function (val, key) {
            if (val instanceof Collection) {
                result.addChildren(val);
            }
            else {
                result.addChild(val);
            }
        });
        return result;
    };
    Hash.prototype.toArray = function () {
        var result = [];
        this.forEach(function (val, key) {
            if (val instanceof Collection) {
                result = result.concat(val.getChildren());
            }
            else {
                result.push(val);
            }
        });
        return result;
    };
    Hash.prototype.clone = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var target = null, isDeep = null;
        if (args.length === 0) {
            isDeep = false;
            target = Hash.create();
        }
        else if (args.length === 1) {
            if (JudgeUtils$1.isBoolean(args[0])) {
                target = Hash.create();
                isDeep = args[0];
            }
            else {
                target = args[0];
                isDeep = false;
            }
        }
        else {
            target = args[0];
            isDeep = args[1];
        }
        if (isDeep === true) {
            target.setChildren(ExtendUtils.extendDeep(this._children));
        }
        else {
            target.setChildren(ExtendUtils.extend({}, this._children));
        }
        return target;
    };
    return Hash;
}());

var JudgeUtils$2 = (function (_super) {
    __extends(JudgeUtils$$1, _super);
    function JudgeUtils$$1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JudgeUtils$$1.isCollection = function (list) {
        return list instanceof Collection;
    };
    return JudgeUtils$$1;
}(JudgeUtils$1));
var isString = JudgeUtils$2.isString;
var isArray = JudgeUtils$2.isArray;
var isUndefined = function (v) { return v === void 0; };
var isNotUndefined = function (v) { return v !== void 0; };

var Entity = (function () {
    function Entity(uidPre) {
        this._uid = null;
        this._uid = uidPre + String(Entity.UID++);
    }
    Object.defineProperty(Entity.prototype, "uid", {
        get: function () {
            return this._uid;
        },
        set: function (uid) {
            this._uid = uid;
        },
        enumerable: true,
        configurable: true
    });
    Entity.UID = 1;
    return Entity;
}());

var JudgeUtils$3 = (function (_super) {
    __extends(JudgeUtils$$1, _super);
    function JudgeUtils$$1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JudgeUtils$$1.isPromise = function (obj) {
        return !!obj
            && !_super.isFunction.call(this, obj.subscribe)
            && _super.isFunction.call(this, obj.then);
    };
    JudgeUtils$$1.isEqual = function (ob1, ob2) {
        return ob1.uid === ob2.uid;
    };
    JudgeUtils$$1.isIObserver = function (i) {
        return i.next && i.error && i.completed;
    };
    return JudgeUtils$$1;
}(JudgeUtils$1));

var SubjectObserver = (function () {
    function SubjectObserver() {
        this.observers = Collection.create();
        this._disposable = null;
    }
    SubjectObserver.prototype.isEmpty = function () {
        return this.observers.getCount() === 0;
    };
    SubjectObserver.prototype.next = function (value) {
        this.observers.forEach(function (ob) {
            ob.next(value);
        });
    };
    SubjectObserver.prototype.error = function (error) {
        this.observers.forEach(function (ob) {
            ob.error(error);
        });
    };
    SubjectObserver.prototype.completed = function () {
        this.observers.forEach(function (ob) {
            ob.completed();
        });
    };
    SubjectObserver.prototype.addChild = function (observer) {
        this.observers.addChild(observer);
        observer.setDisposable(this._disposable);
    };
    SubjectObserver.prototype.removeChild = function (observer) {
        this.observers.removeChild(function (ob) {
            return JudgeUtils$3.isEqual(ob, observer);
        });
    };
    SubjectObserver.prototype.dispose = function () {
        this.observers.forEach(function (ob) {
            ob.dispose();
        });
        this.observers.removeAllChildren();
    };
    SubjectObserver.prototype.setDisposable = function (disposable) {
        this.observers.forEach(function (observer) {
            observer.setDisposable(disposable);
        });
        this._disposable = disposable;
    };
    return SubjectObserver;
}());

var Observer = (function (_super) {
    __extends(Observer, _super);
    function Observer() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _this = _super.call(this, "Observer") || this;
        _this._isDisposed = null;
        _this.onUserNext = null;
        _this.onUserError = null;
        _this.onUserCompleted = null;
        _this._isStop = false;
        _this._disposable = null;
        if (args.length === 1) {
            var observer_1 = args[0];
            _this.onUserNext = function (v) {
                observer_1.next(v);
            };
            _this.onUserError = function (e) {
                observer_1.error(e);
            };
            _this.onUserCompleted = function () {
                observer_1.completed();
            };
        }
        else {
            var onNext = args[0], onError = args[1], onCompleted = args[2];
            _this.onUserNext = onNext || function (v) { };
            _this.onUserError = onError || function (e) {
                throw e;
            };
            _this.onUserCompleted = onCompleted || function () { };
        }
        return _this;
    }
    Object.defineProperty(Observer.prototype, "isDisposed", {
        get: function () {
            return this._isDisposed;
        },
        set: function (isDisposed) {
            this._isDisposed = isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Observer.prototype.next = function (value) {
        if (!this._isStop) {
            return this.onNext(value);
        }
    };
    Observer.prototype.error = function (error) {
        if (!this._isStop) {
            this._isStop = true;
            this.onError(error);
        }
    };
    Observer.prototype.completed = function () {
        if (!this._isStop) {
            this._isStop = true;
            this.onCompleted();
        }
    };
    Observer.prototype.dispose = function () {
        this._isStop = true;
        this._isDisposed = true;
        if (this._disposable) {
            this._disposable.dispose();
        }
    };
    Observer.prototype.setDisposable = function (disposable) {
        this._disposable = disposable;
    };
    return Observer;
}(Entity));

var Main = (function () {
    function Main() {
    }
    Main.isTest = false;
    return Main;
}());

function assert(cond, message) {
    if (message === void 0) { message = "contract error"; }
    Log$1.error(!cond, message);
}
function requireCheck(InFunc) {
    return function (target, name, descriptor) {
        var value = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (Main.isTest) {
                InFunc.apply(this, args);
            }
            return value.apply(this, args);
        };
        return descriptor;
    };
}

var AutoDetachObserver = (function (_super) {
    __extends(AutoDetachObserver, _super);
    function AutoDetachObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AutoDetachObserver.create = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            return new this(args[0]);
        }
        else {
            return new this(args[0], args[1], args[2]);
        }
    };
    AutoDetachObserver.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    AutoDetachObserver.prototype.onNext = function (value) {
        try {
            this.onUserNext(value);
        }
        catch (e) {
            this.onError(e);
        }
    };
    AutoDetachObserver.prototype.onError = function (error) {
        try {
            this.onUserError(error);
        }
        catch (e) {
            throw e;
        }
        finally {
            this.dispose();
        }
    };
    AutoDetachObserver.prototype.onCompleted = function () {
        try {
            this.onUserCompleted();
            this.dispose();
        }
        catch (e) {
            throw e;
        }
    };
    __decorate([
        requireCheck(function () {
            if (this.isDisposed) {
                Log$1.warn("only can dispose once");
            }
        })
    ], AutoDetachObserver.prototype, "dispose", null);
    return AutoDetachObserver;
}(Observer));

var InnerSubscription = (function () {
    function InnerSubscription(subject, observer) {
        this._subject = null;
        this._observer = null;
        this._subject = subject;
        this._observer = observer;
    }
    InnerSubscription.create = function (subject, observer) {
        var obj = new this(subject, observer);
        return obj;
    };
    InnerSubscription.prototype.dispose = function () {
        this._subject.remove(this._observer);
        this._observer.dispose();
    };
    return InnerSubscription;
}());

var Subject = (function () {
    function Subject() {
        this._source = null;
        this._observer = new SubjectObserver();
    }
    Subject.create = function () {
        var obj = new this();
        return obj;
    };
    Object.defineProperty(Subject.prototype, "source", {
        get: function () {
            return this._source;
        },
        set: function (source) {
            this._source = source;
        },
        enumerable: true,
        configurable: true
    });
    Subject.prototype.subscribe = function (arg1, onError, onCompleted) {
        var observer = arg1 instanceof Observer
            ? arg1
            : AutoDetachObserver.create(arg1, onError, onCompleted);
        this._observer.addChild(observer);
        return InnerSubscription.create(this, observer);
    };
    Subject.prototype.next = function (value) {
        this._observer.next(value);
    };
    Subject.prototype.error = function (error) {
        this._observer.error(error);
    };
    Subject.prototype.completed = function () {
        this._observer.completed();
    };
    Subject.prototype.start = function () {
        if (!this._source) {
            return;
        }
        this._observer.setDisposable(this._source.buildStream(this));
    };
    Subject.prototype.remove = function (observer) {
        this._observer.removeChild(observer);
    };
    Subject.prototype.dispose = function () {
        this._observer.dispose();
    };
    return Subject;
}());

var SingleDisposable = (function (_super) {
    __extends(SingleDisposable, _super);
    function SingleDisposable(dispose) {
        var _this = _super.call(this, "SingleDisposable") || this;
        _this._disposable = null;
        _this._isDisposed = false;
        _this._disposable = dispose;
        return _this;
    }
    SingleDisposable.create = function (dispose) {
        if (dispose === void 0) { dispose = null; }
        var obj = new this(dispose);
        return obj;
    };
    SingleDisposable.prototype.setDispose = function (disposable) {
        this._disposable = disposable;
    };
    SingleDisposable.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        if (!this._disposable) {
            return;
        }
        if (!!this._disposable.dispose) {
            this._disposable.dispose();
        }
        else {
            this._disposable();
        }
    };
    return SingleDisposable;
}(Entity));

var ClassMapUtils = (function () {
    function ClassMapUtils() {
    }
    ClassMapUtils.addClassMap = function (className, _class) {
        this._classMap[className] = _class;
    };
    ClassMapUtils.getClass = function (className) {
        return this._classMap[className];
    };
    ClassMapUtils._classMap = {};
    return ClassMapUtils;
}());

var FunctionUtils = (function () {
    function FunctionUtils() {
    }
    FunctionUtils.bind = function (object, func) {
        return function () {
            return func.apply(object, arguments);
        };
    };
    return FunctionUtils;
}());

var Stream = (function (_super) {
    __extends(Stream, _super);
    function Stream(subscribeFunc) {
        var _this = _super.call(this, "Stream") || this;
        _this.scheduler = null;
        _this.subscribeFunc = null;
        _this.subscribeFunc = subscribeFunc || function () { };
        return _this;
    }
    Stream.prototype.buildStream = function (observer) {
        return SingleDisposable.create((this.subscribeFunc(observer) || function () { }));
    };
    Stream.prototype.do = function (onNext, onError, onCompleted) {
        return ClassMapUtils.getClass("DoStream").create(this, onNext, onError, onCompleted);
    };
    Stream.prototype.map = function (selector) {
        return ClassMapUtils.getClass("MapStream").create(this, selector);
    };
    Stream.prototype.flatMap = function (selector) {
        return this.map(selector).mergeAll();
    };
    Stream.prototype.concatMap = function (selector) {
        return this.map(selector).concatAll();
    };
    Stream.prototype.mergeAll = function () {
        return ClassMapUtils.getClass("MergeAllStream").create(this);
    };
    Stream.prototype.concatAll = function () {
        return this.merge(1);
    };
    Stream.prototype.skipUntil = function (otherStream) {
        return ClassMapUtils.getClass("SkipUntilStream").create(this, otherStream);
    };
    Stream.prototype.takeUntil = function (otherStream) {
        return ClassMapUtils.getClass("TakeUntilStream").create(this, otherStream);
    };
    Stream.prototype.take = function (count) {
        if (count === void 0) { count = 1; }
        var self = this;
        if (count === 0) {
            return ClassMapUtils.getClass("Operator").empty();
        }
        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
            self.subscribe(function (value) {
                if (count > 0) {
                    observer.next(value);
                }
                count--;
                if (count <= 0) {
                    observer.completed();
                }
            }, function (e) {
                observer.error(e);
            }, function () {
                observer.completed();
            });
        });
    };
    Stream.prototype.takeLast = function (count) {
        if (count === void 0) { count = 1; }
        var self = this;
        if (count === 0) {
            return ClassMapUtils.getClass("Operator").empty();
        }
        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
            var queue = [];
            self.subscribe(function (value) {
                queue.push(value);
                if (queue.length > count) {
                    queue.shift();
                }
            }, function (e) {
                observer.error(e);
            }, function () {
                while (queue.length > 0) {
                    observer.next(queue.shift());
                }
                observer.completed();
            });
        });
    };
    Stream.prototype.takeWhile = function (predicate, thisArg) {
        if (thisArg === void 0) { thisArg = this; }
        var self = this, bindPredicate = null;
        bindPredicate = FunctionUtils.bind(thisArg, predicate);
        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
            var i = 0, isStart = false;
            self.subscribe(function (value) {
                if (bindPredicate(value, i++, self)) {
                    try {
                        observer.next(value);
                        isStart = true;
                    }
                    catch (e) {
                        observer.error(e);
                        return;
                    }
                }
                else {
                    if (isStart) {
                        observer.completed();
                    }
                }
            }, function (e) {
                observer.error(e);
            }, function () {
                observer.completed();
            });
        });
    };
    Stream.prototype.lastOrDefault = function (defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var self = this;
        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
            var queue = [];
            self.subscribe(function (value) {
                queue.push(value);
                if (queue.length > 1) {
                    queue.shift();
                }
            }, function (e) {
                observer.error(e);
            }, function () {
                if (queue.length === 0) {
                    observer.next(defaultValue);
                }
                else {
                    while (queue.length > 0) {
                        observer.next(queue.shift());
                    }
                }
                observer.completed();
            });
        });
    };
    Stream.prototype.filter = function (predicate, thisArg) {
        if (thisArg === void 0) { thisArg = this; }
        if (this instanceof ClassMapUtils.getClass("FilterStream")) {
            var self = this;
            return self.internalFilter(predicate, thisArg);
        }
        return ClassMapUtils.getClass("FilterStream").create(this, predicate, thisArg);
    };
    Stream.prototype.filterWithState = function (predicate, thisArg) {
        if (thisArg === void 0) { thisArg = this; }
        if (this instanceof ClassMapUtils.getClass("FilterStream")) {
            var self = this;
            return self.internalFilter(predicate, thisArg);
        }
        return ClassMapUtils.getClass("FilterWithStateStream").create(this, predicate, thisArg);
    };
    Stream.prototype.concat = function () {
        var args = null;
        if (JudgeUtils$3.isArray(arguments[0])) {
            args = arguments[0];
        }
        else {
            args = Array.prototype.slice.call(arguments, 0);
        }
        args.unshift(this);
        return ClassMapUtils.getClass("ConcatStream").create(args);
    };
    Stream.prototype.merge = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (JudgeUtils$3.isNumber(args[0])) {
            var maxConcurrent = args[0];
            return ClassMapUtils.getClass("MergeStream").create(this, maxConcurrent);
        }
        if (JudgeUtils$3.isArray(args[0])) {
            args = arguments[0];
        }
        else {
        }
        var stream = null;
        args.unshift(this);
        stream = ClassMapUtils.getClass("Operator").fromArray(args).mergeAll();
        return stream;
    };
    Stream.prototype.repeat = function (count) {
        if (count === void 0) { count = -1; }
        return ClassMapUtils.getClass("RepeatStream").create(this, count);
    };
    Stream.prototype.ignoreElements = function () {
        return ClassMapUtils.getClass("IgnoreElementsStream").create(this);
    };
    Stream.prototype.handleSubject = function (subject) {
        if (this._isSubject(subject)) {
            this._setSubject(subject);
            return true;
        }
        return false;
    };
    Stream.prototype._isSubject = function (subject) {
        return subject instanceof Subject;
    };
    Stream.prototype._setSubject = function (subject) {
        subject.source = this;
    };
    __decorate([
        requireCheck(function (count) {
            if (count === void 0) { count = 1; }
            assert(count >= 0, Log$1.info.FUNC_SHOULD("count", ">= 0"));
        })
    ], Stream.prototype, "take", null);
    __decorate([
        requireCheck(function (count) {
            if (count === void 0) { count = 1; }
            assert(count >= 0, Log$1.info.FUNC_SHOULD("count", ">= 0"));
        })
    ], Stream.prototype, "takeLast", null);
    return Stream;
}(Entity));

var BaseStream = (function (_super) {
    __extends(BaseStream, _super);
    function BaseStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BaseStream.prototype.subscribe = function (arg1, onError, onCompleted) {
        var observer = null;
        if (this.handleSubject(arg1)) {
            return;
        }
        observer = arg1 instanceof Observer
            ? AutoDetachObserver.create(arg1)
            : AutoDetachObserver.create(arg1, onError, onCompleted);
        observer.setDisposable(this.buildStream(observer));
        return observer;
    };
    BaseStream.prototype.buildStream = function (observer) {
        _super.prototype.buildStream.call(this, observer);
        return this.subscribeCore(observer);
    };
    return BaseStream;
}(Stream));

var AnonymousObserver = (function (_super) {
    __extends(AnonymousObserver, _super);
    function AnonymousObserver() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnonymousObserver.create = function (onNext, onError, onCompleted) {
        return new this(onNext, onError, onCompleted);
    };
    AnonymousObserver.prototype.onNext = function (value) {
        this.onUserNext(value);
    };
    AnonymousObserver.prototype.onError = function (error) {
        this.onUserError(error);
    };
    AnonymousObserver.prototype.onCompleted = function () {
        this.onUserCompleted();
    };
    return AnonymousObserver;
}(Observer));

var DoObserver = (function (_super) {
    __extends(DoObserver, _super);
    function DoObserver(currentObserver, prevObserver) {
        var _this = _super.call(this, null, null, null) || this;
        _this._currentObserver = null;
        _this._prevObserver = null;
        _this._currentObserver = currentObserver;
        _this._prevObserver = prevObserver;
        return _this;
    }
    DoObserver.create = function (currentObserver, prevObserver) {
        return new this(currentObserver, prevObserver);
    };
    DoObserver.prototype.onNext = function (value) {
        try {
            this._prevObserver.next(value);
        }
        catch (e) {
            this._prevObserver.error(e);
            this._currentObserver.error(e);
        }
        finally {
            this._currentObserver.next(value);
        }
    };
    DoObserver.prototype.onError = function (error) {
        try {
            this._prevObserver.error(error);
        }
        catch (e) {
        }
        finally {
            this._currentObserver.error(error);
        }
    };
    DoObserver.prototype.onCompleted = function () {
        try {
            this._prevObserver.completed();
        }
        catch (e) {
            this._prevObserver.error(e);
            this._currentObserver.error(e);
        }
        finally {
            this._currentObserver.completed();
        }
    };
    return DoObserver;
}(Observer));

function registerClass(className) {
    return function (target) {
        ClassMapUtils.addClassMap(className, target);
    };
}

var DoStream = (function (_super) {
    __extends(DoStream, _super);
    function DoStream(source, onNext, onError, onCompleted) {
        var _this = _super.call(this, null) || this;
        _this._source = null;
        _this._observer = null;
        _this._source = source;
        _this._observer = AnonymousObserver.create(onNext, onError, onCompleted);
        _this.scheduler = _this._source.scheduler;
        return _this;
    }
    DoStream.create = function (source, onNext, onError, onCompleted) {
        var obj = new this(source, onNext, onError, onCompleted);
        return obj;
    };
    DoStream.prototype.subscribeCore = function (observer) {
        return this._source.buildStream(DoObserver.create(observer, this._observer));
    };
    DoStream = __decorate([
        registerClass("DoStream")
    ], DoStream);
    return DoStream;
}(BaseStream));

var GroupDisposable = (function (_super) {
    __extends(GroupDisposable, _super);
    function GroupDisposable(disposable) {
        var _this = _super.call(this, "GroupDisposable") || this;
        _this._group = Collection.create();
        _this._isDisposed = false;
        if (disposable) {
            _this._group.addChild(disposable);
        }
        return _this;
    }
    GroupDisposable.create = function (disposable) {
        var obj = new this(disposable);
        return obj;
    };
    GroupDisposable.prototype.add = function (disposable) {
        this._group.addChild(disposable);
        return this;
    };
    GroupDisposable.prototype.remove = function (disposable) {
        this._group.removeChild(disposable);
        return this;
    };
    GroupDisposable.prototype.getCount = function () {
        return this._group.getCount();
    };
    GroupDisposable.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._group.forEach(function (disposable) {
            disposable.dispose();
        });
    };
    return GroupDisposable;
}(Entity));

var ConcatObserver = (function (_super) {
    __extends(ConcatObserver, _super);
    function ConcatObserver(currentObserver, startNextStream) {
        var _this = _super.call(this, null, null, null) || this;
        _this.currentObserver = null;
        _this._startNextStream = null;
        _this.currentObserver = currentObserver;
        _this._startNextStream = startNextStream;
        return _this;
    }
    ConcatObserver.create = function (currentObserver, startNextStream) {
        return new this(currentObserver, startNextStream);
    };
    ConcatObserver.prototype.onNext = function (value) {
        this.currentObserver.next(value);
    };
    ConcatObserver.prototype.onError = function (error) {
        this.currentObserver.error(error);
    };
    ConcatObserver.prototype.onCompleted = function () {
        this._startNextStream();
    };
    return ConcatObserver;
}(Observer));

var ConcatStream = (function (_super) {
    __extends(ConcatStream, _super);
    function ConcatStream(sources) {
        var _this = _super.call(this, null) || this;
        _this._sources = Collection.create();
        var self = _this;
        _this.scheduler = sources[0].scheduler;
        sources.forEach(function (source) {
            if (JudgeUtils$3.isPromise(source)) {
                self._sources.addChild(fromPromise(source));
            }
            else {
                self._sources.addChild(source);
            }
        });
        return _this;
    }
    ConcatStream.create = function (sources) {
        var obj = new this(sources);
        return obj;
    };
    ConcatStream.prototype.subscribeCore = function (observer) {
        var self = this, count = this._sources.getCount(), d = GroupDisposable.create();
        function loopRecursive(i) {
            if (i === count) {
                observer.completed();
                return;
            }
            d.add(self._sources.getChild(i).buildStream(ConcatObserver.create(observer, function () {
                loopRecursive(i + 1);
            })));
        }
        this.scheduler.publishRecursive(observer, 0, loopRecursive);
        return GroupDisposable.create(d);
    };
    ConcatStream = __decorate([
        registerClass("ConcatStream")
    ], ConcatStream);
    return ConcatStream;
}(BaseStream));

var MapObserver = (function (_super) {
    __extends(MapObserver, _super);
    function MapObserver(currentObserver, selector) {
        var _this = _super.call(this, null, null, null) || this;
        _this._currentObserver = null;
        _this._selector = null;
        _this._currentObserver = currentObserver;
        _this._selector = selector;
        return _this;
    }
    MapObserver.create = function (currentObserver, selector) {
        return new this(currentObserver, selector);
    };
    MapObserver.prototype.onNext = function (value) {
        var result = null;
        try {
            result = this._selector(value);
        }
        catch (e) {
            this._currentObserver.error(e);
        }
        finally {
            this._currentObserver.next(result);
        }
    };
    MapObserver.prototype.onError = function (error) {
        this._currentObserver.error(error);
    };
    MapObserver.prototype.onCompleted = function () {
        this._currentObserver.completed();
    };
    return MapObserver;
}(Observer));

var MapStream = (function (_super) {
    __extends(MapStream, _super);
    function MapStream(source, selector) {
        var _this = _super.call(this, null) || this;
        _this._source = null;
        _this._selector = null;
        _this._source = source;
        _this.scheduler = _this._source.scheduler;
        _this._selector = selector;
        return _this;
    }
    MapStream.create = function (source, selector) {
        var obj = new this(source, selector);
        return obj;
    };
    MapStream.prototype.subscribeCore = function (observer) {
        return this._source.buildStream(MapObserver.create(observer, this._selector));
    };
    MapStream = __decorate([
        registerClass("MapStream")
    ], MapStream);
    return MapStream;
}(BaseStream));

var MergeAllObserver = (function (_super) {
    __extends(MergeAllObserver, _super);
    function MergeAllObserver(currentObserver, groupDisposable) {
        var _this = _super.call(this, null, null, null) || this;
        _this.done = false;
        _this.currentObserver = null;
        _this._groupDisposable = null;
        _this.currentObserver = currentObserver;
        _this._groupDisposable = groupDisposable;
        return _this;
    }
    MergeAllObserver.create = function (currentObserver, groupDisposable) {
        return new this(currentObserver, groupDisposable);
    };
    MergeAllObserver.prototype.onNext = function (innerSource) {
        if (JudgeUtils$3.isPromise(innerSource)) {
            innerSource = fromPromise(innerSource);
        }
        var disposable = SingleDisposable.create(), innerObserver = InnerObserver.create(this, innerSource, this._groupDisposable);
        this._groupDisposable.add(disposable);
        innerObserver.disposable = disposable;
        disposable.setDispose(innerSource.buildStream(innerObserver));
    };
    MergeAllObserver.prototype.onError = function (error) {
        this.currentObserver.error(error);
    };
    MergeAllObserver.prototype.onCompleted = function () {
        this.done = true;
        if (this._groupDisposable.getCount() <= 1) {
            this.currentObserver.completed();
        }
    };
    __decorate([
        requireCheck(function (innerSource) {
            assert(innerSource instanceof Stream || JudgeUtils$3.isPromise(innerSource), Log$1.info.FUNC_MUST_BE("innerSource", "Stream or Promise"));
        })
    ], MergeAllObserver.prototype, "onNext", null);
    return MergeAllObserver;
}(Observer));
var InnerObserver = (function (_super) {
    __extends(InnerObserver, _super);
    function InnerObserver(parent, currentStream, groupDisposable) {
        var _this = _super.call(this, null, null, null) || this;
        _this.disposable = null;
        _this._parent = null;
        _this._currentStream = null;
        _this._groupDisposable = null;
        _this._parent = parent;
        _this._currentStream = currentStream;
        _this._groupDisposable = groupDisposable;
        return _this;
    }
    InnerObserver.create = function (parent, currentStream, groupDisposable) {
        var obj = new this(parent, currentStream, groupDisposable);
        return obj;
    };
    InnerObserver.prototype.onNext = function (value) {
        this._parent.currentObserver.next(value);
    };
    InnerObserver.prototype.onError = function (error) {
        this._parent.currentObserver.error(error);
    };
    InnerObserver.prototype.onCompleted = function () {
        var currentStream = this._currentStream, parent = this._parent;
        if (!!this.disposable) {
            this.disposable.dispose();
            this._groupDisposable.remove(this.disposable);
        }
        if (this._isAsync() && this._groupDisposable.getCount() <= 1) {
            parent.currentObserver.completed();
        }
    };
    InnerObserver.prototype._isAsync = function () {
        return this._parent.done;
    };
    return InnerObserver;
}(Observer));

var MergeAllStream = (function (_super) {
    __extends(MergeAllStream, _super);
    function MergeAllStream(source) {
        var _this = _super.call(this, null) || this;
        _this._source = null;
        _this._source = source;
        _this.scheduler = _this._source.scheduler;
        return _this;
    }
    MergeAllStream.create = function (source) {
        var obj = new this(source);
        return obj;
    };
    MergeAllStream.prototype.subscribeCore = function (observer) {
        var groupDisposable = GroupDisposable.create();
        groupDisposable.add(this._source.buildStream(MergeAllObserver.create(observer, groupDisposable)));
        return groupDisposable;
    };
    MergeAllStream = __decorate([
        registerClass("MergeAllStream")
    ], MergeAllStream);
    return MergeAllStream;
}(BaseStream));

var SkipUntilOtherObserver = (function (_super) {
    __extends(SkipUntilOtherObserver, _super);
    function SkipUntilOtherObserver(prevObserver, skipUntilStream) {
        var _this = _super.call(this, null, null, null) || this;
        _this.otherDisposable = null;
        _this._prevObserver = null;
        _this._skipUntilStream = null;
        _this._prevObserver = prevObserver;
        _this._skipUntilStream = skipUntilStream;
        return _this;
    }
    SkipUntilOtherObserver.create = function (prevObserver, skipUntilStream) {
        return new this(prevObserver, skipUntilStream);
    };
    SkipUntilOtherObserver.prototype.onNext = function (value) {
        this._skipUntilStream.isOpen = true;
        this.otherDisposable.dispose();
    };
    SkipUntilOtherObserver.prototype.onError = function (error) {
        this._prevObserver.error(error);
    };
    SkipUntilOtherObserver.prototype.onCompleted = function () {
        this.otherDisposable.dispose();
    };
    return SkipUntilOtherObserver;
}(Observer));

var SkipUntilSourceObserver = (function (_super) {
    __extends(SkipUntilSourceObserver, _super);
    function SkipUntilSourceObserver(prevObserver, skipUntilStream) {
        var _this = _super.call(this, null, null, null) || this;
        _this._prevObserver = null;
        _this._skipUntilStream = null;
        _this._prevObserver = prevObserver;
        _this._skipUntilStream = skipUntilStream;
        return _this;
    }
    SkipUntilSourceObserver.create = function (prevObserver, skipUntilStream) {
        return new this(prevObserver, skipUntilStream);
    };
    SkipUntilSourceObserver.prototype.onNext = function (value) {
        if (this._skipUntilStream.isOpen) {
            this._prevObserver.next(value);
        }
    };
    SkipUntilSourceObserver.prototype.onError = function (error) {
        this._prevObserver.error(error);
    };
    SkipUntilSourceObserver.prototype.onCompleted = function () {
        if (this._skipUntilStream.isOpen) {
            this._prevObserver.completed();
        }
    };
    return SkipUntilSourceObserver;
}(Observer));

var SkipUntilStream = (function (_super) {
    __extends(SkipUntilStream, _super);
    function SkipUntilStream(source, otherStream) {
        var _this = _super.call(this, null) || this;
        _this.isOpen = false;
        _this._source = null;
        _this._otherStream = null;
        _this._source = source;
        _this._otherStream = JudgeUtils$3.isPromise(otherStream) ? fromPromise(otherStream) : otherStream;
        _this.scheduler = _this._source.scheduler;
        return _this;
    }
    SkipUntilStream.create = function (source, otherSteam) {
        var obj = new this(source, otherSteam);
        return obj;
    };
    SkipUntilStream.prototype.subscribeCore = function (observer) {
        var group = GroupDisposable.create(), otherDisposable = null, skipUntilOtherObserver = null;
        group.add(this._source.buildStream(SkipUntilSourceObserver.create(observer, this)));
        skipUntilOtherObserver = SkipUntilOtherObserver.create(observer, this);
        otherDisposable = this._otherStream.buildStream(skipUntilOtherObserver);
        skipUntilOtherObserver.otherDisposable = otherDisposable;
        group.add(otherDisposable);
        return group;
    };
    SkipUntilStream = __decorate([
        registerClass("SkipUntilStream")
    ], SkipUntilStream);
    return SkipUntilStream;
}(BaseStream));

var TakeUntilObserver = (function (_super) {
    __extends(TakeUntilObserver, _super);
    function TakeUntilObserver(prevObserver) {
        var _this = _super.call(this, null, null, null) || this;
        _this._prevObserver = null;
        _this._prevObserver = prevObserver;
        return _this;
    }
    TakeUntilObserver.create = function (prevObserver) {
        return new this(prevObserver);
    };
    TakeUntilObserver.prototype.onNext = function (value) {
        this._prevObserver.completed();
    };
    TakeUntilObserver.prototype.onError = function (error) {
        this._prevObserver.error(error);
    };
    TakeUntilObserver.prototype.onCompleted = function () {
    };
    return TakeUntilObserver;
}(Observer));

var TakeUntilStream = (function (_super) {
    __extends(TakeUntilStream, _super);
    function TakeUntilStream(source, otherStream) {
        var _this = _super.call(this, null) || this;
        _this._source = null;
        _this._otherStream = null;
        _this._source = source;
        _this._otherStream = JudgeUtils$3.isPromise(otherStream) ? fromPromise(otherStream) : otherStream;
        _this.scheduler = _this._source.scheduler;
        return _this;
    }
    TakeUntilStream.create = function (source, otherSteam) {
        var obj = new this(source, otherSteam);
        return obj;
    };
    TakeUntilStream.prototype.subscribeCore = function (observer) {
        var group = GroupDisposable.create(), autoDetachObserver = AutoDetachObserver.create(observer), sourceDisposable = null;
        sourceDisposable = this._source.buildStream(observer);
        group.add(sourceDisposable);
        autoDetachObserver.setDisposable(sourceDisposable);
        group.add(this._otherStream.buildStream(TakeUntilObserver.create(autoDetachObserver)));
        return group;
    };
    TakeUntilStream = __decorate([
        registerClass("TakeUntilStream")
    ], TakeUntilStream);
    return TakeUntilStream;
}(BaseStream));

var FilterObserver = (function (_super) {
    __extends(FilterObserver, _super);
    function FilterObserver(prevObserver, predicate, source) {
        var _this = _super.call(this, null, null, null) || this;
        _this.prevObserver = null;
        _this.source = null;
        _this.i = 0;
        _this.predicate = null;
        _this.prevObserver = prevObserver;
        _this.predicate = predicate;
        _this.source = source;
        return _this;
    }
    FilterObserver.create = function (prevObserver, predicate, source) {
        return new this(prevObserver, predicate, source);
    };
    FilterObserver.prototype.onNext = function (value) {
        try {
            if (this.predicate(value, this.i++, this.source)) {
                this.prevObserver.next(value);
            }
        }
        catch (e) {
            this.prevObserver.error(e);
        }
    };
    FilterObserver.prototype.onError = function (error) {
        this.prevObserver.error(error);
    };
    FilterObserver.prototype.onCompleted = function () {
        this.prevObserver.completed();
    };
    return FilterObserver;
}(Observer));

var FilterStream = (function (_super) {
    __extends(FilterStream, _super);
    function FilterStream(source, predicate, thisArg) {
        var _this = _super.call(this, null) || this;
        _this.predicate = null;
        _this._source = null;
        _this._source = source;
        _this.predicate = FunctionUtils.bind(thisArg, predicate);
        return _this;
    }
    FilterStream_1 = FilterStream;
    FilterStream.create = function (source, predicate, thisArg) {
        var obj = new this(source, predicate, thisArg);
        return obj;
    };
    FilterStream.prototype.subscribeCore = function (observer) {
        return this._source.subscribe(this.createObserver(observer));
    };
    FilterStream.prototype.internalFilter = function (predicate, thisArg) {
        return this.createStreamForInternalFilter(this._source, this._innerPredicate(predicate, this), thisArg);
    };
    FilterStream.prototype.createObserver = function (observer) {
        return FilterObserver.create(observer, this.predicate, this);
    };
    FilterStream.prototype.createStreamForInternalFilter = function (source, innerPredicate, thisArg) {
        return FilterStream_1.create(source, innerPredicate, thisArg);
    };
    FilterStream.prototype._innerPredicate = function (predicate, self) {
        var _this = this;
        return function (value, i, o) {
            return self.predicate(value, i, o) && predicate.call(_this, value, i, o);
        };
    };
    FilterStream = FilterStream_1 = __decorate([
        registerClass("FilterStream")
    ], FilterStream);
    return FilterStream;
    var FilterStream_1;
}(BaseStream));

var FilterState;
(function (FilterState) {
    FilterState[FilterState["TRIGGER"] = 0] = "TRIGGER";
    FilterState[FilterState["ENTER"] = 1] = "ENTER";
    FilterState[FilterState["LEAVE"] = 2] = "LEAVE";
})(FilterState || (FilterState = {}));

var FilterWithStateObserver = (function (_super) {
    __extends(FilterWithStateObserver, _super);
    function FilterWithStateObserver() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._isTrigger = false;
        return _this;
    }
    FilterWithStateObserver.create = function (prevObserver, predicate, source) {
        return new this(prevObserver, predicate, source);
    };
    FilterWithStateObserver.prototype.onNext = function (value) {
        var data = null;
        try {
            if (this.predicate(value, this.i++, this.source)) {
                if (!this._isTrigger) {
                    data = {
                        value: value,
                        state: FilterState.ENTER
                    };
                }
                else {
                    data = {
                        value: value,
                        state: FilterState.TRIGGER
                    };
                }
                this.prevObserver.next(data);
                this._isTrigger = true;
            }
            else {
                if (this._isTrigger) {
                    data = {
                        value: value,
                        state: FilterState.LEAVE
                    };
                    this.prevObserver.next(data);
                }
                this._isTrigger = false;
            }
        }
        catch (e) {
            this.prevObserver.error(e);
        }
    };
    return FilterWithStateObserver;
}(FilterObserver));

var FilterWithStateStream = (function (_super) {
    __extends(FilterWithStateStream, _super);
    function FilterWithStateStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FilterWithStateStream_1 = FilterWithStateStream;
    FilterWithStateStream.create = function (source, predicate, thisArg) {
        var obj = new this(source, predicate, thisArg);
        return obj;
    };
    FilterWithStateStream.prototype.createObserver = function (observer) {
        return FilterWithStateObserver.create(observer, this.predicate, this);
    };
    FilterWithStateStream.prototype.createStreamForInternalFilter = function (source, innerPredicate, thisArg) {
        return FilterWithStateStream_1.create(source, innerPredicate, thisArg);
    };
    FilterWithStateStream = FilterWithStateStream_1 = __decorate([
        registerClass("FilterWithStateStream")
    ], FilterWithStateStream);
    return FilterWithStateStream;
    var FilterWithStateStream_1;
}(FilterStream));

var MergeObserver = (function (_super) {
    __extends(MergeObserver, _super);
    function MergeObserver(currentObserver, maxConcurrent, groupDisposable) {
        var _this = _super.call(this, null, null, null) || this;
        _this.done = false;
        _this.currentObserver = null;
        _this.activeCount = 0;
        _this.q = [];
        _this._maxConcurrent = null;
        _this._groupDisposable = null;
        _this.currentObserver = currentObserver;
        _this._maxConcurrent = maxConcurrent;
        _this._groupDisposable = groupDisposable;
        return _this;
    }
    MergeObserver.create = function (currentObserver, maxConcurrent, groupDisposable) {
        return new this(currentObserver, maxConcurrent, groupDisposable);
    };
    MergeObserver.prototype.handleSubscribe = function (innerSource) {
        if (JudgeUtils$3.isPromise(innerSource)) {
            innerSource = fromPromise(innerSource);
        }
        var disposable = SingleDisposable.create(), innerObserver = InnerObserver$1.create(this, innerSource, this._groupDisposable);
        this._groupDisposable.add(disposable);
        innerObserver.disposable = disposable;
        disposable.setDispose(innerSource.buildStream(innerObserver));
    };
    MergeObserver.prototype.onNext = function (innerSource) {
        if (this._isNotReachMaxConcurrent()) {
            this.activeCount++;
            this.handleSubscribe(innerSource);
            return;
        }
        this.q.push(innerSource);
    };
    MergeObserver.prototype.onError = function (error) {
        this.currentObserver.error(error);
    };
    MergeObserver.prototype.onCompleted = function () {
        this.done = true;
        if (this.activeCount === 0) {
            this.currentObserver.completed();
        }
    };
    MergeObserver.prototype._isNotReachMaxConcurrent = function () {
        return this.activeCount < this._maxConcurrent;
    };
    __decorate([
        requireCheck(function (innerSource) {
            assert(innerSource instanceof Stream || JudgeUtils$3.isPromise(innerSource), Log$1.info.FUNC_MUST_BE("innerSource", "Stream or Promise"));
        })
    ], MergeObserver.prototype, "onNext", null);
    return MergeObserver;
}(Observer));
var InnerObserver$1 = (function (_super) {
    __extends(InnerObserver, _super);
    function InnerObserver(parent, currentStream, groupDisposable) {
        var _this = _super.call(this, null, null, null) || this;
        _this.disposable = null;
        _this._parent = null;
        _this._currentStream = null;
        _this._groupDisposable = null;
        _this._parent = parent;
        _this._currentStream = currentStream;
        _this._groupDisposable = groupDisposable;
        return _this;
    }
    InnerObserver.create = function (parent, currentStream, groupDisposable) {
        var obj = new this(parent, currentStream, groupDisposable);
        return obj;
    };
    InnerObserver.prototype.onNext = function (value) {
        this._parent.currentObserver.next(value);
    };
    InnerObserver.prototype.onError = function (error) {
        this._parent.currentObserver.error(error);
    };
    InnerObserver.prototype.onCompleted = function () {
        var parent = this._parent;
        if (!!this.disposable) {
            this.disposable.dispose();
            this._groupDisposable.remove(this.disposable);
        }
        if (parent.q.length > 0) {
            parent.handleSubscribe(parent.q.shift());
        }
        else {
            parent.activeCount -= 1;
            if (this._isAsync() && parent.activeCount === 0) {
                parent.currentObserver.completed();
            }
        }
    };
    InnerObserver.prototype._isAsync = function () {
        return this._parent.done;
    };
    return InnerObserver;
}(Observer));

var MergeStream = (function (_super) {
    __extends(MergeStream, _super);
    function MergeStream(source, maxConcurrent) {
        var _this = _super.call(this, null) || this;
        _this._source = null;
        _this._maxConcurrent = null;
        _this._source = source;
        _this._maxConcurrent = maxConcurrent;
        _this.scheduler = _this._source.scheduler;
        return _this;
    }
    MergeStream.create = function (source, maxConcurrent) {
        var obj = new this(source, maxConcurrent);
        return obj;
    };
    MergeStream.prototype.subscribeCore = function (observer) {
        var groupDisposable = GroupDisposable.create();
        groupDisposable.add(this._source.buildStream(MergeObserver.create(observer, this._maxConcurrent, groupDisposable)));
        return groupDisposable;
    };
    MergeStream = __decorate([
        registerClass("MergeStream")
    ], MergeStream);
    return MergeStream;
}(BaseStream));

var RepeatStream = (function (_super) {
    __extends(RepeatStream, _super);
    function RepeatStream(source, count) {
        var _this = _super.call(this, null) || this;
        _this._source = null;
        _this._count = null;
        _this._source = source;
        _this._count = count;
        _this.scheduler = _this._source.scheduler;
        return _this;
    }
    RepeatStream.create = function (source, count) {
        var obj = new this(source, count);
        return obj;
    };
    RepeatStream.prototype.subscribeCore = function (observer) {
        var self = this, d = GroupDisposable.create();
        function loopRecursive(count) {
            if (count === 0) {
                observer.completed();
                return;
            }
            d.add(self._source.buildStream(ConcatObserver.create(observer, function () {
                loopRecursive(count - 1);
            })));
        }
        this.scheduler.publishRecursive(observer, this._count, loopRecursive);
        return GroupDisposable.create(d);
    };
    RepeatStream = __decorate([
        registerClass("RepeatStream")
    ], RepeatStream);
    return RepeatStream;
}(BaseStream));

var IgnoreElementsObserver = (function (_super) {
    __extends(IgnoreElementsObserver, _super);
    function IgnoreElementsObserver(currentObserver) {
        var _this = _super.call(this, null, null, null) || this;
        _this._currentObserver = null;
        _this._currentObserver = currentObserver;
        return _this;
    }
    IgnoreElementsObserver.create = function (currentObserver) {
        return new this(currentObserver);
    };
    IgnoreElementsObserver.prototype.onNext = function (value) {
    };
    IgnoreElementsObserver.prototype.onError = function (error) {
        this._currentObserver.error(error);
    };
    IgnoreElementsObserver.prototype.onCompleted = function () {
        this._currentObserver.completed();
    };
    return IgnoreElementsObserver;
}(Observer));

var IgnoreElementsStream = (function (_super) {
    __extends(IgnoreElementsStream, _super);
    function IgnoreElementsStream(source) {
        var _this = _super.call(this, null) || this;
        _this._source = null;
        _this._source = source;
        _this.scheduler = _this._source.scheduler;
        return _this;
    }
    IgnoreElementsStream.create = function (source) {
        var obj = new this(source);
        return obj;
    };
    IgnoreElementsStream.prototype.subscribeCore = function (observer) {
        return this._source.buildStream(IgnoreElementsObserver.create(observer));
    };
    IgnoreElementsStream = __decorate([
        registerClass("IgnoreElementsStream")
    ], IgnoreElementsStream);
    return IgnoreElementsStream;
}(BaseStream));

var root$1;
if (JudgeUtils$3.isNodeJs() && typeof global != "undefined") {
    root$1 = global;
}
else if (typeof window != "undefined") {
    root$1 = window;
}
else if (typeof self != "undefined") {
    root$1 = self;
}
else {
    Log$1.error("no avaliable root!");
}

root$1.requestNextAnimationFrame = (function () {
    var originalRequestAnimationFrame = undefined, wrapper = undefined, callback = undefined, geckoVersion = null, userAgent = root$1.navigator && root$1.navigator.userAgent, index = 0, self = this;
    wrapper = function (time) {
        time = root$1.performance.now();
        self.callback(time);
    };
    if (root$1.requestAnimationFrame) {
        return requestAnimationFrame;
    }
    if (root$1.webkitRequestAnimationFrame) {
        originalRequestAnimationFrame = root$1.webkitRequestAnimationFrame;
        root$1.webkitRequestAnimationFrame = function (callback, element) {
            self.callback = callback;
            return originalRequestAnimationFrame(wrapper, element);
        };
    }
    if (root$1.msRequestAnimationFrame) {
        originalRequestAnimationFrame = root$1.msRequestAnimationFrame;
        root$1.msRequestAnimationFrame = function (callback) {
            self.callback = callback;
            return originalRequestAnimationFrame(wrapper);
        };
    }
    if (root$1.mozRequestAnimationFrame) {
        index = userAgent.indexOf('rv:');
        if (userAgent.indexOf('Gecko') != -1) {
            geckoVersion = userAgent.substr(index + 3, 3);
            if (geckoVersion === '2.0') {
                root$1.mozRequestAnimationFrame = undefined;
            }
        }
    }
    return root$1.webkitRequestAnimationFrame ||
        root$1.mozRequestAnimationFrame ||
        root$1.oRequestAnimationFrame ||
        root$1.msRequestAnimationFrame ||
        function (callback, element) {
            var start, finish;
            root$1.setTimeout(function () {
                start = root$1.performance.now();
                callback(start);
                finish = root$1.performance.now();
                self.timeout = 1000 / 60 - (finish - start);
            }, self.timeout);
        };
}());
root$1.cancelNextRequestAnimationFrame = root$1.cancelRequestAnimationFrame
    || root$1.webkitCancelAnimationFrame
    || root$1.webkitCancelRequestAnimationFrame
    || root$1.mozCancelRequestAnimationFrame
    || root$1.oCancelRequestAnimationFrame
    || root$1.msCancelRequestAnimationFrame
    || clearTimeout;

var Scheduler = (function () {
    function Scheduler() {
        this._requestLoopId = null;
    }
    Scheduler.create = function () {
        var obj = new this();
        return obj;
    };
    Object.defineProperty(Scheduler.prototype, "requestLoopId", {
        get: function () {
            return this._requestLoopId;
        },
        set: function (requestLoopId) {
            this._requestLoopId = requestLoopId;
        },
        enumerable: true,
        configurable: true
    });
    Scheduler.prototype.publishRecursive = function (observer, initial, action) {
        action(initial);
    };
    Scheduler.prototype.publishInterval = function (observer, initial, interval, action) {
        return root$1.setInterval(function () {
            initial = action(initial);
        }, interval);
    };
    Scheduler.prototype.publishIntervalRequest = function (observer, action) {
        var self = this, loop = function (time) {
            var isEnd = action(time);
            if (isEnd) {
                return;
            }
            self._requestLoopId = root$1.requestNextAnimationFrame(loop);
        };
        this._requestLoopId = root$1.requestNextAnimationFrame(loop);
    };
    Scheduler.prototype.publishTimeout = function (observer, time, action) {
        return root$1.setTimeout(function () {
            action(time);
            observer.completed();
        }, time);
    };
    return Scheduler;
}());

var AnonymousStream = (function (_super) {
    __extends(AnonymousStream, _super);
    function AnonymousStream(subscribeFunc) {
        var _this = _super.call(this, subscribeFunc) || this;
        _this.scheduler = Scheduler.create();
        return _this;
    }
    AnonymousStream.create = function (subscribeFunc) {
        var obj = new this(subscribeFunc);
        return obj;
    };
    AnonymousStream.prototype.buildStream = function (observer) {
        return SingleDisposable.create((this.subscribeFunc(observer) || function () { }));
    };
    AnonymousStream.prototype.subscribe = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var observer = null;
        if (args[0] instanceof Subject) {
            var subject = args[0];
            this.handleSubject(subject);
            return;
        }
        else if (JudgeUtils$3.isIObserver(args[0])) {
            observer = AutoDetachObserver.create(args[0]);
        }
        else {
            var onNext = args[0], onError = args[1] || null, onCompleted = args[2] || null;
            observer = AutoDetachObserver.create(onNext, onError, onCompleted);
        }
        observer.setDisposable(this.buildStream(observer));
        return observer;
    };
    return AnonymousStream;
}(Stream));

var FromArrayStream = (function (_super) {
    __extends(FromArrayStream, _super);
    function FromArrayStream(array, scheduler) {
        var _this = _super.call(this, null) || this;
        _this._array = null;
        _this._array = array;
        _this.scheduler = scheduler;
        return _this;
    }
    FromArrayStream.create = function (array, scheduler) {
        var obj = new this(array, scheduler);
        return obj;
    };
    FromArrayStream.prototype.subscribeCore = function (observer) {
        var array = this._array, len = array.length;
        function loopRecursive(i) {
            if (i < len) {
                observer.next(array[i]);
                loopRecursive(i + 1);
            }
            else {
                observer.completed();
            }
        }
        this.scheduler.publishRecursive(observer, 0, loopRecursive);
        return SingleDisposable.create();
    };
    return FromArrayStream;
}(BaseStream));

var FromPromiseStream = (function (_super) {
    __extends(FromPromiseStream, _super);
    function FromPromiseStream(promise, scheduler) {
        var _this = _super.call(this, null) || this;
        _this._promise = null;
        _this._promise = promise;
        _this.scheduler = scheduler;
        return _this;
    }
    FromPromiseStream.create = function (promise, scheduler) {
        var obj = new this(promise, scheduler);
        return obj;
    };
    FromPromiseStream.prototype.subscribeCore = function (observer) {
        this._promise.then(function (data) {
            observer.next(data);
            observer.completed();
        }, function (err) {
            observer.error(err);
        }, observer);
        return SingleDisposable.create();
    };
    return FromPromiseStream;
}(BaseStream));

var FromEventPatternStream = (function (_super) {
    __extends(FromEventPatternStream, _super);
    function FromEventPatternStream(addHandler, removeHandler) {
        var _this = _super.call(this, null) || this;
        _this._addHandler = null;
        _this._removeHandler = null;
        _this._addHandler = addHandler;
        _this._removeHandler = removeHandler;
        return _this;
    }
    FromEventPatternStream.create = function (addHandler, removeHandler) {
        var obj = new this(addHandler, removeHandler);
        return obj;
    };
    FromEventPatternStream.prototype.subscribeCore = function (observer) {
        var self = this;
        function innerHandler(event) {
            observer.next(event);
        }
        this._addHandler(innerHandler);
        return SingleDisposable.create(function () {
            self._removeHandler(innerHandler);
        });
    };
    return FromEventPatternStream;
}(BaseStream));

var IntervalStream = (function (_super) {
    __extends(IntervalStream, _super);
    function IntervalStream(interval, scheduler) {
        var _this = _super.call(this, null) || this;
        _this._interval = null;
        _this._interval = interval;
        _this.scheduler = scheduler;
        return _this;
    }
    IntervalStream.create = function (interval, scheduler) {
        var obj = new this(interval, scheduler);
        obj.initWhenCreate();
        return obj;
    };
    IntervalStream.prototype.initWhenCreate = function () {
        this._interval = this._interval <= 0 ? 1 : this._interval;
    };
    IntervalStream.prototype.subscribeCore = function (observer) {
        var self = this, id = null;
        id = this.scheduler.publishInterval(observer, 0, this._interval, function (count) {
            observer.next(count);
            return count + 1;
        });
        return SingleDisposable.create(function () {
            root$1.clearInterval(id);
        });
    };
    return IntervalStream;
}(BaseStream));

var IntervalRequestStream = (function (_super) {
    __extends(IntervalRequestStream, _super);
    function IntervalRequestStream(scheduler) {
        var _this = _super.call(this, null) || this;
        _this._isEnd = false;
        _this.scheduler = scheduler;
        return _this;
    }
    IntervalRequestStream.create = function (scheduler) {
        var obj = new this(scheduler);
        return obj;
    };
    IntervalRequestStream.prototype.subscribeCore = function (observer) {
        var self = this;
        this.scheduler.publishIntervalRequest(observer, function (time) {
            observer.next(time);
            return self._isEnd;
        });
        return SingleDisposable.create(function () {
            root$1.cancelNextRequestAnimationFrame(self.scheduler.requestLoopId);
            self._isEnd = true;
        });
    };
    return IntervalRequestStream;
}(BaseStream));

var TimeoutStream = (function (_super) {
    __extends(TimeoutStream, _super);
    function TimeoutStream(time, scheduler) {
        var _this = _super.call(this, null) || this;
        _this._time = null;
        _this._time = time;
        _this.scheduler = scheduler;
        return _this;
    }
    TimeoutStream.create = function (time, scheduler) {
        var obj = new this(time, scheduler);
        return obj;
    };
    TimeoutStream.prototype.subscribeCore = function (observer) {
        var id = null;
        id = this.scheduler.publishTimeout(observer, this._time, function (time) {
            observer.next(time);
        });
        return SingleDisposable.create(function () {
            root$1.clearTimeout(id);
        });
    };
    __decorate([
        requireCheck(function (time, scheduler) {
            assert(time > 0, Log$1.info.FUNC_SHOULD("time", "> 0"));
        })
    ], TimeoutStream, "create", null);
    return TimeoutStream;
}(BaseStream));

var DeferStream = (function (_super) {
    __extends(DeferStream, _super);
    function DeferStream(buildStreamFunc) {
        var _this = _super.call(this, null) || this;
        _this._buildStreamFunc = null;
        _this._buildStreamFunc = buildStreamFunc;
        return _this;
    }
    DeferStream.create = function (buildStreamFunc) {
        var obj = new this(buildStreamFunc);
        return obj;
    };
    DeferStream.prototype.subscribeCore = function (observer) {
        var group = GroupDisposable.create();
        group.add(this._buildStreamFunc().buildStream(observer));
        return group;
    };
    return DeferStream;
}(BaseStream));

var Operator = (function () {
    function Operator() {
    }
    Operator_1 = Operator;
    Operator.empty = function () {
        return Operator_1.createStream(function (observer) {
            observer.completed();
        });
    };
    Operator.createStream = function (subscribeFunc) {
        return AnonymousStream.create(subscribeFunc);
    };
    Operator.fromArray = function (array, scheduler) {
        if (scheduler === void 0) { scheduler = Scheduler.create(); }
        return FromArrayStream.create(array, scheduler);
    };
    Operator = Operator_1 = __decorate([
        registerClass("Operator")
    ], Operator);
    return Operator;
    var Operator_1;
}());
var createStream = Operator.createStream;

var fromArray = Operator.fromArray;
var fromPromise = function (promise, scheduler) {
    if (scheduler === void 0) { scheduler = Scheduler.create(); }
    return FromPromiseStream.create(promise, scheduler);
};



var intervalRequest = function (scheduler) {
    if (scheduler === void 0) { scheduler = Scheduler.create(); }
    return IntervalRequestStream.create(scheduler);
};

var callFunc = function (func, context) {
    if (context === void 0) { context = root$1; }
    return createStream(function (observer) {
        try {
            observer.next(func.call(context, null));
        }
        catch (e) {
            observer.error(e);
        }
        observer.completed();
    });
};


var just = function (returnValue) {
    return createStream(function (observer) {
        observer.next(returnValue);
        observer.completed();
    });
};

var root$2;
if (JudgeUtils$2.isNodeJs() && typeof global != "undefined") {
    root$2 = global;
}
else if (typeof window != "undefined") {
    root$2 = window;
}
else if (typeof self != "undefined") {
    root$2 = self;
}
else {
    Log$$1.error("no avaliable root!");
}

var ETextureFormat;
(function (ETextureFormat) {
    ETextureFormat["RGB"] = "RGB";
    ETextureFormat["RGBA"] = "RGBA";
    ETextureFormat["ALPHA"] = "ALPHA";
    ETextureFormat["LUMINANCE"] = "LUMINANCE";
    ETextureFormat["LUMINANCE_ALPHA"] = "LUMINANCE_ALPHA";
    ETextureFormat["RGB_S3TC_DXT1"] = "RGB_S3TC_DXT1";
    ETextureFormat["RGBA_S3TC_DXT1"] = "RGBA_S3TC_DXT1";
    ETextureFormat["RGBA_S3TC_DXT3"] = "RGBA_S3TC_DXT3";
    ETextureFormat["RGBA_S3TC_DXT5"] = "RGBA_S3TC_DXT5";
})(ETextureFormat || (ETextureFormat = {}));

var ETextureType;
(function (ETextureType) {
    ETextureType["UNSIGNED_BYTE"] = "UNSIGNED_BYTE";
    ETextureType["UNSIGNED_SHORT_5_6_5"] = "UNSIGNED_SHORT_5_6_5";
    ETextureType["UNSIGNED_SHORT_4_4_4_4"] = "UNSIGNED_SHORT_4_4_4_4";
    ETextureType["UNSIGNED_SHORT_5_5_5_1"] = "UNSIGNED_SHORT_5_5_5_1";
})(ETextureType || (ETextureType = {}));

var CompileConfig = {
    isCompileTest: true,
    closeContractTest: false
};

var InitConfigData = (function () {
    function InitConfigData() {
    }
    InitConfigData.isTest = null;
    return InitConfigData;
}());

var InitConfigWorkerData = (function () {
    function InitConfigWorkerData() {
    }
    InitConfigWorkerData.isTest = null;
    return InitConfigWorkerData;
}());

var Queue = (function (_super) {
    __extends(Queue, _super);
    function Queue(children) {
        if (children === void 0) { children = []; }
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Queue.create = function (children) {
        if (children === void 0) { children = []; }
        var obj = new this(children);
        return obj;
    };
    Object.defineProperty(Queue.prototype, "front", {
        get: function () {
            return this.children[this.children.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Queue.prototype, "rear", {
        get: function () {
            return this.children[0];
        },
        enumerable: true,
        configurable: true
    });
    Queue.prototype.push = function (element) {
        this.children.unshift(element);
    };
    Queue.prototype.pop = function () {
        return this.children.pop();
    };
    Queue.prototype.clear = function () {
        this.removeAllChildren();
    };
    return Queue;
}(List));

var Stack = (function (_super) {
    __extends(Stack, _super);
    function Stack(children) {
        if (children === void 0) { children = []; }
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Stack.create = function (children) {
        if (children === void 0) { children = []; }
        var obj = new this(children);
        return obj;
    };
    Object.defineProperty(Stack.prototype, "top", {
        get: function () {
            return this.children[this.children.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Stack.prototype.push = function (element) {
        this.children.push(element);
    };
    Stack.prototype.pop = function () {
        return this.children.pop();
    };
    Stack.prototype.clear = function () {
        this.removeAllChildren();
    };
    Stack.prototype.clone = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var target = null, isDeep = null;
        if (args.length === 0) {
            isDeep = false;
            target = Stack.create();
        }
        else if (args.length === 1) {
            if (JudgeUtils$1.isBoolean(args[0])) {
                target = Stack.create();
                isDeep = args[0];
            }
            else {
                target = args[0];
                isDeep = false;
            }
        }
        else {
            target = args[0];
            isDeep = args[1];
        }
        if (isDeep === true) {
            target.setChildren(ExtendUtils.extendDeep(this.children));
        }
        else {
            target.setChildren(ExtendUtils.extend([], this.children));
        }
        return target;
    };
    Stack.prototype.filter = function (func) {
        var children = this.children, result = [], value = null;
        for (var i = 0, len = children.length; i < len; i++) {
            value = children[i];
            if (func.call(children, value, i)) {
                result.push(value);
            }
        }
        return Collection.create(result);
    };
    Stack.prototype.findOne = function (func) {
        var scope = this.children, result = null;
        this.forEach(function (value, index) {
            if (!func.call(scope, value, index)) {
                return;
            }
            result = value;
            return $BREAK;
        });
        return result;
    };
    Stack.prototype.reverse = function () {
        return Collection.create(this.copyChildren().reverse());
    };
    Stack.prototype.removeChild = function (arg) {
        return Collection.create(this.removeChildHelper(arg));
    };
    Stack.prototype.sort = function (func, isSortSelf) {
        if (isSortSelf === void 0) { isSortSelf = false; }
        if (isSortSelf) {
            this.children.sort(func);
            return this;
        }
        return Collection.create(this.copyChildren().sort(func));
    };
    Stack.prototype.map = function (func) {
        var resultArr = [];
        this.forEach(function (e, index) {
            var result = func(e, index);
            if (result !== $REMOVE) {
                resultArr.push(result);
            }
        });
        return Collection.create(resultArr);
    };
    Stack.prototype.removeRepeatItems = function () {
        var noRepeatList = Collection.create();
        this.forEach(function (item) {
            if (noRepeatList.hasChild(item)) {
                return;
            }
            noRepeatList.addChild(item);
        });
        return noRepeatList;
    };
    Stack.prototype.hasRepeatItems = function () {
        var noRepeatList = Collection.create(), hasRepeat = false;
        this.forEach(function (item) {
            if (noRepeatList.hasChild(item)) {
                hasRepeat = true;
                return $BREAK;
            }
            noRepeatList.addChild(item);
        });
        return hasRepeat;
    };
    return Stack;
}(List));

var DomQuery = (function () {
    function DomQuery() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._doms = null;
        if (JudgeUtils$1.isDom(args[0])) {
            this._doms = [args[0]];
        }
        else if (this._isDomEleStr(args[0])) {
            this._doms = [this._buildDom(args[0])];
        }
        else {
            this._doms = document.querySelectorAll(args[0]);
        }
        return this;
    }
    DomQuery.create = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var obj = new this(args[0]);
        return obj;
    };
    DomQuery.prototype.get = function (index) {
        return this._doms[index];
    };
    DomQuery.prototype.prepend = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var targetDom = null;
        targetDom = this._buildDom(args[0]);
        for (var _a = 0, _b = this._doms; _a < _b.length; _a++) {
            var dom = _b[_a];
            if (dom.nodeType === 1) {
                dom.insertBefore(targetDom, dom.firstChild);
            }
        }
        return this;
    };
    DomQuery.prototype.prependTo = function (eleStr) {
        var targetDom = null;
        targetDom = DomQuery.create(eleStr);
        for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
            var dom = _a[_i];
            if (dom.nodeType === 1) {
                targetDom.prepend(dom);
            }
        }
        return this;
    };
    DomQuery.prototype.remove = function () {
        for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
            var dom = _a[_i];
            if (dom && dom.parentNode && dom.tagName != 'BODY') {
                dom.parentNode.removeChild(dom);
            }
        }
        return this;
    };
    DomQuery.prototype.css = function (property, value) {
        for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
            var dom = _a[_i];
            dom.style[property] = value;
        }
    };
    DomQuery.prototype.attr = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 1) {
            var name = args[0];
            return this.get(0).getAttribute(name);
        }
        else {
            var name = args[0], value = args[1];
            for (var _a = 0, _b = this._doms; _a < _b.length; _a++) {
                var dom = _b[_a];
                dom.setAttribute(name, value);
            }
        }
    };
    DomQuery.prototype.text = function (str) {
        var dom = this.get(0);
        if (str !== void 0) {
            if (dom.textContent !== void 0) {
                dom.textContent = str;
            }
            else {
                dom.innerText = str;
            }
        }
        else {
            return dom.textContent !== void 0 ? dom.textContent : dom.innerText;
        }
    };
    DomQuery.prototype._isDomEleStr = function (eleStr) {
        return eleStr.match(/<(\w+)[^>]*><\/\1>/) !== null;
    };
    DomQuery.prototype._buildDom = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (JudgeUtils$1.isString(args[0])) {
            var div = this._createElement("div"), eleStr = args[0];
            div.innerHTML = eleStr;
            return div.firstChild;
        }
        return args[0];
    };
    DomQuery.prototype._createElement = function (eleStr) {
        return document.createElement(eleStr);
    };
    return DomQuery;
}());

var _describeContext = null;
function assert$1(cond, message) {
    if (message === void 0) { message = "contract error"; }
    Log$1.error(!cond, message);
}
function describe$1(message, func, preCondition, context) {
    if (preCondition === void 0) { preCondition = function () { return true; }; }
    if (context === void 0) { context = this; }
    if (preCondition.call(context, null)) {
        _describeContext = context;
        try {
            func.call(context, null);
        }
        catch (e) {
            assert$1(false, message + "->" + e.message);
        }
        finally {
            _describeContext = null;
        }
    }
}
function it$1(message, func, context) {
    try {
        if (arguments.length === 3) {
            func.call(context, null);
        }
        else {
            if (_describeContext) {
                func.call(_describeContext, null);
            }
            else {
                func();
            }
        }
    }
    catch (e) {
        assert$1(false, message + "->" + e.message);
    }
}
function requireFunc(checkFunc, bodyFunc, compileIsTest, runtimeIsTestFunc) {
    if (!compileIsTest) {
        return bodyFunc;
    }
    return function () {
        var paramArr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paramArr[_i] = arguments[_i];
        }
        if (!runtimeIsTestFunc()) {
            return bodyFunc.apply(null, paramArr);
        }
        checkFunc.apply(null, paramArr);
        return bodyFunc.apply(null, paramArr);
    };
}
function ensureFunc$1(checkFunc, bodyFunc, compileIsTest, runtimeIsTestFunc) {
    if (!compileIsTest) {
        return bodyFunc;
    }
    return function () {
        var paramArr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paramArr[_i] = arguments[_i];
        }
        if (!runtimeIsTestFunc()) {
            return bodyFunc.apply(null, paramArr);
        }
        var result = bodyFunc.apply(null, paramArr);
        checkFunc.apply(null, [result].concat(paramArr));
        return result;
    };
}

var _getCompileIsTest = function () { return CompileConfig.isCompileTest; };
var _getRunTimeIsTest = function () {
    if (InitConfigData.isTest === true || InitConfigWorkerData.isTest === true) {
        return true;
    }
    return false;
};
var describe$$1 = describe$1;
var it$$1 = it$1;
function requireCheck$1(inFunc) {
    return function (target, name, descriptor) {
        if (_getCompileIsTest()) {
            var value_1 = descriptor.value;
            descriptor.value = function (args) {
                if (_getRunTimeIsTest()) {
                    inFunc.apply(this, arguments);
                }
                return value_1.apply(this, arguments);
            };
        }
        return descriptor;
    };
}
function requireCheckFunc(checkFunc, bodyFunc) {
    return requireFunc(checkFunc, bodyFunc, _getCompileIsTest(), _getRunTimeIsTest);
}
function ensure$1(outFunc) {
    return function (target, name, descriptor) {
        if (CompileConfig.isCompileTest) {
            var value_2 = descriptor.value;
            descriptor.value = function (args) {
                var result = value_2.apply(this, arguments);
                if (_getRunTimeIsTest()) {
                    var params = [result];
                    for (var i = 0, len = arguments.length; i < len; i++) {
                        params[i + 1] = arguments[i];
                    }
                    outFunc.apply(this, params);
                }
                return result;
            };
        }
        return descriptor;
    };
}
function ensureFunc$$1(checkFunc, bodyFunc) {
    return ensureFunc$1(checkFunc, bodyFunc, _getCompileIsTest(), _getRunTimeIsTest);
}
function ensureGetter$1(outFunc) {
    return function (target, name, descriptor) {
        if (CompileConfig.isCompileTest) {
            var getter_1 = descriptor.get;
            descriptor.get = function () {
                var result = getter_1.call(this);
                if (_getRunTimeIsTest()) {
                    outFunc.call(this, result);
                }
                return result;
            };
        }
        return descriptor;
    };
}

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var wdet$1 = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	factory(exports);
}(commonjsGlobal, (function (exports) { 'use strict';

	function __extends(d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var ExpectData = (function () {
	    function ExpectData() {
	    }
	    return ExpectData;
	}());
	ExpectData.assertion = null;
	ExpectData.source = null;
	ExpectData.isNot = null;

	var JudgeUtils = (function () {
	    function JudgeUtils() {
	    }
	    JudgeUtils.isArray = function (arr) {
	        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	        var length = arr && arr.length;
	        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	    };
	    JudgeUtils.isArrayExactly = function (arr) {
	        return Object.prototype.toString.call(arr) === "[object Array]";
	    };
	    JudgeUtils.isNumber = function (num) {
	        return typeof num == "number";
	    };
	    JudgeUtils.isNumberExactly = function (num) {
	        return Object.prototype.toString.call(num) === "[object Number]";
	    };
	    JudgeUtils.isString = function (str) {
	        return typeof str == "string";
	    };
	    JudgeUtils.isStringExactly = function (str) {
	        return Object.prototype.toString.call(str) === "[object String]";
	    };
	    JudgeUtils.isBoolean = function (bool) {
	        return bool === true || bool === false || toString.call(bool) === '[boolect Boolean]';
	    };
	    JudgeUtils.isDom = function (obj) {
	        return !!(obj && obj.nodeType === 1);
	    };
	    JudgeUtils.isObject = function (obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };
	    JudgeUtils.isDirectObject = function (obj) {
	        return Object.prototype.toString.call(obj) === "[object Object]";
	    };
	    JudgeUtils.isHostMethod = function (object, property) {
	        var type = typeof object[property];
	        return type === "function" ||
	            (type === "object" && !!object[property]);
	    };
	    JudgeUtils.isNodeJs = function () {
	        return ((typeof commonjsGlobal != "undefined" && commonjsGlobal.module) || ('object' != "undefined")) && 'object' != "undefined";
	    };
	    JudgeUtils.isFunction = function (func) {
	        return true;
	    };
	    return JudgeUtils;
	}());
	if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    JudgeUtils.isFunction = function (func) {
	        return typeof func == 'function';
	    };
	}
	else {
	    JudgeUtils.isFunction = function (func) {
	        return Object.prototype.toString.call(func) === "[object Function]";
	    };
	}

	var $BREAK = {
	    break: true
	};
	var $REMOVE = void 0;

	var List = (function () {
	    function List() {
	        this.children = null;
	    }
	    List.prototype.getCount = function () {
	        return this.children.length;
	    };
	    List.prototype.hasChild = function (child) {
	        var c = null, children = this.children;
	        for (var i = 0, len = children.length; i < len; i++) {
	            c = children[i];
	            if (child.uid && c.uid && child.uid == c.uid) {
	                return true;
	            }
	            else if (child === c) {
	                return true;
	            }
	        }
	        return false;
	    };
	    List.prototype.hasChildWithFunc = function (func) {
	        for (var i = 0, len = this.children.length; i < len; i++) {
	            if (func(this.children[i], i)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    List.prototype.getChildren = function () {
	        return this.children;
	    };
	    List.prototype.getChild = function (index) {
	        return this.children[index];
	    };
	    List.prototype.addChild = function (child) {
	        this.children.push(child);
	        return this;
	    };
	    List.prototype.addChildren = function (arg) {
	        if (JudgeUtils.isArray(arg)) {
	            var children = arg;
	            this.children = this.children.concat(children);
	        }
	        else if (arg instanceof List) {
	            var children = arg;
	            this.children = this.children.concat(children.getChildren());
	        }
	        else {
	            var child = arg;
	            this.addChild(child);
	        }
	        return this;
	    };
	    List.prototype.setChildren = function (children) {
	        this.children = children;
	        return this;
	    };
	    List.prototype.unShiftChild = function (child) {
	        this.children.unshift(child);
	    };
	    List.prototype.removeAllChildren = function () {
	        this.children = [];
	        return this;
	    };
	    List.prototype.forEach = function (func, context) {
	        this._forEach(this.children, func, context);
	        return this;
	    };
	    List.prototype.toArray = function () {
	        return this.children;
	    };
	    List.prototype.copyChildren = function () {
	        return this.children.slice(0);
	    };
	    List.prototype.removeChildHelper = function (arg) {
	        var result = null;
	        if (JudgeUtils.isFunction(arg)) {
	            var func = arg;
	            result = this._removeChild(this.children, func);
	        }
	        else if (arg.uid) {
	            result = this._removeChild(this.children, function (e) {
	                if (!e.uid) {
	                    return false;
	                }
	                return e.uid === arg.uid;
	            });
	        }
	        else {
	            result = this._removeChild(this.children, function (e) {
	                return e === arg;
	            });
	        }
	        return result;
	    };
	    List.prototype._forEach = function (arr, func, context) {
	        var scope = context, i = 0, len = arr.length;
	        for (i = 0; i < len; i++) {
	            if (func.call(scope, arr[i], i) === $BREAK) {
	                break;
	            }
	        }
	    };
	    List.prototype._removeChild = function (arr, func) {
	        var self = this, removedElementArr = [], remainElementArr = [];
	        this._forEach(arr, function (e, index) {
	            if (!!func.call(self, e)) {
	                removedElementArr.push(e);
	            }
	            else {
	                remainElementArr.push(e);
	            }
	        });
	        this.children = remainElementArr;
	        return removedElementArr;
	    };
	    return List;
	}());

	var ExtendUtils = (function () {
	    function ExtendUtils() {
	    }
	    ExtendUtils.extendDeep = function (parent, child, filter) {
	        if (filter === void 0) { filter = function (val, i) { return true; }; }
	        var i = null, len = 0, toStr = Object.prototype.toString, sArr = "[object Array]", sOb = "[object Object]", type = "", _child = null;
	        if (toStr.call(parent) === sArr) {
	            _child = child || [];
	            for (i = 0, len = parent.length; i < len; i++) {
	                var member = parent[i];
	                if (!filter(member, i)) {
	                    continue;
	                }
	                if (member.clone) {
	                    _child[i] = member.clone();
	                    continue;
	                }
	                type = toStr.call(member);
	                if (type === sArr || type === sOb) {
	                    _child[i] = type === sArr ? [] : {};
	                    ExtendUtils.extendDeep(member, _child[i]);
	                }
	                else {
	                    _child[i] = member;
	                }
	            }
	        }
	        else if (toStr.call(parent) === sOb) {
	            _child = child || {};
	            for (i in parent) {
	                var member = parent[i];
	                if (!filter(member, i)) {
	                    continue;
	                }
	                if (member.clone) {
	                    _child[i] = member.clone();
	                    continue;
	                }
	                type = toStr.call(member);
	                if (type === sArr || type === sOb) {
	                    _child[i] = type === sArr ? [] : {};
	                    ExtendUtils.extendDeep(member, _child[i]);
	                }
	                else {
	                    _child[i] = member;
	                }
	            }
	        }
	        else {
	            _child = parent;
	        }
	        return _child;
	    };
	    ExtendUtils.extend = function (destination, source) {
	        var property = "";
	        for (property in source) {
	            destination[property] = source[property];
	        }
	        return destination;
	    };
	    ExtendUtils.copyPublicAttri = function (source) {
	        var property = null, destination = {};
	        this.extendDeep(source, destination, function (item, property) {
	            return property.slice(0, 1) !== "_"
	                && !JudgeUtils.isFunction(item);
	        });
	        return destination;
	    };
	    return ExtendUtils;
	}());

	var Collection = (function (_super) {
	    __extends(Collection, _super);
	    function Collection(children) {
	        if (children === void 0) { children = []; }
	        var _this = _super.call(this) || this;
	        _this.children = children;
	        return _this;
	    }
	    Collection.create = function (children) {
	        if (children === void 0) { children = []; }
	        var obj = new this(children);
	        return obj;
	    };
	    Collection.prototype.clone = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var target = null, isDeep = null;
	        if (args.length === 0) {
	            isDeep = false;
	            target = Collection.create();
	        }
	        else if (args.length === 1) {
	            if (JudgeUtils.isBoolean(args[0])) {
	                target = Collection.create();
	                isDeep = args[0];
	            }
	            else {
	                target = args[0];
	                isDeep = false;
	            }
	        }
	        else {
	            target = args[0];
	            isDeep = args[1];
	        }
	        if (isDeep === true) {
	            target.setChildren(ExtendUtils.extendDeep(this.children));
	        }
	        else {
	            target.setChildren(ExtendUtils.extend([], this.children));
	        }
	        return target;
	    };
	    Collection.prototype.filter = function (func) {
	        var children = this.children, result = [], value = null;
	        for (var i = 0, len = children.length; i < len; i++) {
	            value = children[i];
	            if (func.call(children, value, i)) {
	                result.push(value);
	            }
	        }
	        return Collection.create(result);
	    };
	    Collection.prototype.findOne = function (func) {
	        var scope = this.children, result = null;
	        this.forEach(function (value, index) {
	            if (!func.call(scope, value, index)) {
	                return;
	            }
	            result = value;
	            return $BREAK;
	        });
	        return result;
	    };
	    Collection.prototype.reverse = function () {
	        return Collection.create(this.copyChildren().reverse());
	    };
	    Collection.prototype.removeChild = function (arg) {
	        return Collection.create(this.removeChildHelper(arg));
	    };
	    Collection.prototype.sort = function (func, isSortSelf) {
	        if (isSortSelf === void 0) { isSortSelf = false; }
	        if (isSortSelf) {
	            this.children.sort(func);
	            return this;
	        }
	        return Collection.create(this.copyChildren().sort(func));
	    };
	    Collection.prototype.map = function (func) {
	        var resultArr = [];
	        this.forEach(function (e, index) {
	            var result = func(e, index);
	            if (result !== $REMOVE) {
	                resultArr.push(result);
	            }
	        });
	        return Collection.create(resultArr);
	    };
	    Collection.prototype.removeRepeatItems = function () {
	        var noRepeatList = Collection.create();
	        this.forEach(function (item) {
	            if (noRepeatList.hasChild(item)) {
	                return;
	            }
	            noRepeatList.addChild(item);
	        });
	        return noRepeatList;
	    };
	    Collection.prototype.hasRepeatItems = function () {
	        var noRepeatList = Collection.create(), hasRepeat = false;
	        this.forEach(function (item) {
	            if (noRepeatList.hasChild(item)) {
	                hasRepeat = true;
	                return $BREAK;
	            }
	            noRepeatList.addChild(item);
	        });
	        return hasRepeat;
	    };
	    return Collection;
	}(List));

	var Log = (function () {
	    function Log() {
	    }
	    Log.log = function () {
	        var messages = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            messages[_i] = arguments[_i];
	        }
	        if (!this._exec("log", messages)) {
	            root.alert(messages.join(","));
	        }
	        this._exec("trace", messages);
	    };
	    Log.assert = function (cond) {
	        if (cond) {
	            if (!this._exec("assert", arguments, 1)) {
	                this.log.apply(this, Array.prototype.slice.call(arguments, 1));
	            }
	        }
	    };
	    Log.error = function (cond) {
	        if (cond) {
	            throw new Error(Array.prototype.slice.call(arguments, 1).join("\n"));
	        }
	    };
	    Log.warn = function () {
	        var result = this._exec("warn", arguments);
	        if (!result) {
	            this.log.apply(this, arguments);
	        }
	        else {
	            this._exec("trace", ["warn trace"]);
	        }
	    };
	    Log._exec = function (consoleMethod, args, sliceBegin) {
	        if (sliceBegin === void 0) { sliceBegin = 0; }
	        if (root.console && root.console[consoleMethod]) {
	            root.console[consoleMethod].apply(root.console, Array.prototype.slice.call(args, sliceBegin));
	            return true;
	        }
	        return false;
	    };
	    return Log;
	}());
	Log.info = {
	    INVALID_PARAM: "invalid parameter",
	    helperFunc: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var result = "";
	        args.forEach(function (val) {
	            result += String(val) + " ";
	        });
	        return result.slice(0, -1);
	    },
	    assertion: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (args.length === 2) {
	            return this.helperFunc(args[0], args[1]);
	        }
	        else if (args.length === 3) {
	            return this.helperFunc(args[1], args[0], args[2]);
	        }
	        else {
	            throw new Error("args.length must <= 3");
	        }
	    },
	    FUNC_INVALID: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("invalid");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_BE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must be");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_NOT_BE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must not be");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_SHOULD: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("should");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_SHOULD_NOT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("should not");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_SUPPORT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("support");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_NOT_SUPPORT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("not support");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_DEFINE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must define");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_NOT_DEFINE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must not define");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_UNKNOW: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("unknow");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_EXPECT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("expect");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_UNEXPECT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("unexpect");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_EXIST: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("exist");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_NOT_EXIST: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("not exist");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_ONLY: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("only");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_CAN_NOT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("can't");
	        return this.assertion.apply(this, args);
	    }
	};

	var root;
	if (JudgeUtils.isNodeJs() && typeof commonjsGlobal != "undefined") {
	    root = commonjsGlobal;
	}
	else if (typeof window != "undefined") {
	    root = window;
	}
	else if (typeof self != "undefined") {
	    root = self;
	}
	else {
	    Log.error("no avaliable root!");
	}

	var Hash = (function () {
	    function Hash(children) {
	        if (children === void 0) { children = {}; }
	        this._children = null;
	        this._children = children;
	    }
	    Hash.create = function (children) {
	        if (children === void 0) { children = {}; }
	        var obj = new this(children);
	        return obj;
	    };
	    Hash.prototype.getChildren = function () {
	        return this._children;
	    };
	    Hash.prototype.getCount = function () {
	        var result = 0, children = this._children, key = null;
	        for (key in children) {
	            if (children.hasOwnProperty(key)) {
	                result++;
	            }
	        }
	        return result;
	    };
	    Hash.prototype.getKeys = function () {
	        var result = Collection.create(), children = this._children, key = null;
	        for (key in children) {
	            if (children.hasOwnProperty(key)) {
	                result.addChild(key);
	            }
	        }
	        return result;
	    };
	    Hash.prototype.getValues = function () {
	        var result = Collection.create(), children = this._children, key = null;
	        for (key in children) {
	            if (children.hasOwnProperty(key)) {
	                result.addChild(children[key]);
	            }
	        }
	        return result;
	    };
	    Hash.prototype.getChild = function (key) {
	        return this._children[key];
	    };
	    Hash.prototype.setValue = function (key, value) {
	        this._children[key] = value;
	        return this;
	    };
	    Hash.prototype.addChild = function (key, value) {
	        this._children[key] = value;
	        return this;
	    };
	    Hash.prototype.addChildren = function (arg) {
	        var i = null, children = null;
	        if (arg instanceof Hash) {
	            children = arg.getChildren();
	        }
	        else {
	            children = arg;
	        }
	        for (i in children) {
	            if (children.hasOwnProperty(i)) {
	                this.addChild(i, children[i]);
	            }
	        }
	        return this;
	    };
	    Hash.prototype.appendChild = function (key, value) {
	        if (this._children[key] instanceof Collection) {
	            var c = (this._children[key]);
	            c.addChild(value);
	        }
	        else {
	            this._children[key] = (Collection.create().addChild(value));
	        }
	        return this;
	    };
	    Hash.prototype.setChildren = function (children) {
	        this._children = children;
	    };
	    Hash.prototype.removeChild = function (arg) {
	        var result = [];
	        if (JudgeUtils.isString(arg)) {
	            var key = arg;
	            result.push(this._children[key]);
	            this._children[key] = void 0;
	            delete this._children[key];
	        }
	        else if (JudgeUtils.isFunction(arg)) {
	            var func_1 = arg, self_1 = this;
	            this.forEach(function (val, key) {
	                if (func_1(val, key)) {
	                    result.push(self_1._children[key]);
	                    self_1._children[key] = void 0;
	                    delete self_1._children[key];
	                }
	            });
	        }
	        return Collection.create(result);
	    };
	    Hash.prototype.removeAllChildren = function () {
	        this._children = {};
	    };
	    Hash.prototype.hasChild = function (key) {
	        return this._children[key] !== void 0;
	    };
	    Hash.prototype.hasChildWithFunc = function (func) {
	        var result = false;
	        this.forEach(function (val, key) {
	            if (func(val, key)) {
	                result = true;
	                return $BREAK;
	            }
	        });
	        return result;
	    };
	    Hash.prototype.forEach = function (func, context) {
	        var children = this._children;
	        for (var i in children) {
	            if (children.hasOwnProperty(i)) {
	                if (func.call(context, children[i], i) === $BREAK) {
	                    break;
	                }
	            }
	        }
	        return this;
	    };
	    Hash.prototype.filter = function (func) {
	        var result = {}, children = this._children, value = null;
	        for (var key in children) {
	            if (children.hasOwnProperty(key)) {
	                value = children[key];
	                if (func.call(children, value, key)) {
	                    result[key] = value;
	                }
	            }
	        }
	        return Hash.create(result);
	    };
	    Hash.prototype.findOne = function (func) {
	        var result = [], self = this, scope = this._children;
	        this.forEach(function (val, key) {
	            if (!func.call(scope, val, key)) {
	                return;
	            }
	            result = [key, self.getChild(key)];
	            return $BREAK;
	        });
	        return result;
	    };
	    Hash.prototype.map = function (func) {
	        var resultMap = {};
	        this.forEach(function (val, key) {
	            var result = func(val, key);
	            if (result !== $REMOVE) {
	                Log.error(!JudgeUtils.isArray(result) || result.length !== 2, Log.info.FUNC_MUST_BE("iterator", "[key, value]"));
	                resultMap[result[0]] = result[1];
	            }
	        });
	        return Hash.create(resultMap);
	    };
	    Hash.prototype.toCollection = function () {
	        var result = Collection.create();
	        this.forEach(function (val, key) {
	            if (val instanceof Collection) {
	                result.addChildren(val);
	            }
	            else {
	                result.addChild(val);
	            }
	        });
	        return result;
	    };
	    Hash.prototype.toArray = function () {
	        var result = [];
	        this.forEach(function (val, key) {
	            if (val instanceof Collection) {
	                result = result.concat(val.getChildren());
	            }
	            else {
	                result.push(val);
	            }
	        });
	        return result;
	    };
	    Hash.prototype.clone = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var target = null, isDeep = null;
	        if (args.length === 0) {
	            isDeep = false;
	            target = Hash.create();
	        }
	        else if (args.length === 1) {
	            if (JudgeUtils.isBoolean(args[0])) {
	                target = Hash.create();
	                isDeep = args[0];
	            }
	            else {
	                target = args[0];
	                isDeep = false;
	            }
	        }
	        else {
	            target = args[0];
	            isDeep = args[1];
	        }
	        if (isDeep === true) {
	            target.setChildren(ExtendUtils.extendDeep(this._children));
	        }
	        else {
	            target.setChildren(ExtendUtils.extend({}, this._children));
	        }
	        return target;
	    };
	    return Hash;
	}());

	var Queue = (function (_super) {
	    __extends(Queue, _super);
	    function Queue(children) {
	        if (children === void 0) { children = []; }
	        var _this = _super.call(this) || this;
	        _this.children = children;
	        return _this;
	    }
	    Queue.create = function (children) {
	        if (children === void 0) { children = []; }
	        var obj = new this(children);
	        return obj;
	    };
	    Object.defineProperty(Queue.prototype, "front", {
	        get: function () {
	            return this.children[this.children.length - 1];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Queue.prototype, "rear", {
	        get: function () {
	            return this.children[0];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Queue.prototype.push = function (element) {
	        this.children.unshift(element);
	    };
	    Queue.prototype.pop = function () {
	        return this.children.pop();
	    };
	    Queue.prototype.clear = function () {
	        this.removeAllChildren();
	    };
	    return Queue;
	}(List));

	var Stack = (function (_super) {
	    __extends(Stack, _super);
	    function Stack(children) {
	        if (children === void 0) { children = []; }
	        var _this = _super.call(this) || this;
	        _this.children = children;
	        return _this;
	    }
	    Stack.create = function (children) {
	        if (children === void 0) { children = []; }
	        var obj = new this(children);
	        return obj;
	    };
	    Object.defineProperty(Stack.prototype, "top", {
	        get: function () {
	            return this.children[this.children.length - 1];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Stack.prototype.push = function (element) {
	        this.children.push(element);
	    };
	    Stack.prototype.pop = function () {
	        return this.children.pop();
	    };
	    Stack.prototype.clear = function () {
	        this.removeAllChildren();
	    };
	    Stack.prototype.clone = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var target = null, isDeep = null;
	        if (args.length === 0) {
	            isDeep = false;
	            target = Stack.create();
	        }
	        else if (args.length === 1) {
	            if (JudgeUtils.isBoolean(args[0])) {
	                target = Stack.create();
	                isDeep = args[0];
	            }
	            else {
	                target = args[0];
	                isDeep = false;
	            }
	        }
	        else {
	            target = args[0];
	            isDeep = args[1];
	        }
	        if (isDeep === true) {
	            target.setChildren(ExtendUtils.extendDeep(this.children));
	        }
	        else {
	            target.setChildren(ExtendUtils.extend([], this.children));
	        }
	        return target;
	    };
	    Stack.prototype.filter = function (func) {
	        var children = this.children, result = [], value = null;
	        for (var i = 0, len = children.length; i < len; i++) {
	            value = children[i];
	            if (func.call(children, value, i)) {
	                result.push(value);
	            }
	        }
	        return Collection.create(result);
	    };
	    Stack.prototype.findOne = function (func) {
	        var scope = this.children, result = null;
	        this.forEach(function (value, index) {
	            if (!func.call(scope, value, index)) {
	                return;
	            }
	            result = value;
	            return $BREAK;
	        });
	        return result;
	    };
	    Stack.prototype.reverse = function () {
	        return Collection.create(this.copyChildren().reverse());
	    };
	    Stack.prototype.removeChild = function (arg) {
	        return Collection.create(this.removeChildHelper(arg));
	    };
	    Stack.prototype.sort = function (func, isSortSelf) {
	        if (isSortSelf === void 0) { isSortSelf = false; }
	        if (isSortSelf) {
	            this.children.sort(func);
	            return this;
	        }
	        return Collection.create(this.copyChildren().sort(func));
	    };
	    Stack.prototype.map = function (func) {
	        var resultArr = [];
	        this.forEach(function (e, index) {
	            var result = func(e, index);
	            if (result !== $REMOVE) {
	                resultArr.push(result);
	            }
	        });
	        return Collection.create(resultArr);
	    };
	    Stack.prototype.removeRepeatItems = function () {
	        var noRepeatList = Collection.create();
	        this.forEach(function (item) {
	            if (noRepeatList.hasChild(item)) {
	                return;
	            }
	            noRepeatList.addChild(item);
	        });
	        return noRepeatList;
	    };
	    Stack.prototype.hasRepeatItems = function () {
	        var noRepeatList = Collection.create(), hasRepeat = false;
	        this.forEach(function (item) {
	            if (noRepeatList.hasChild(item)) {
	                hasRepeat = true;
	                return $BREAK;
	            }
	            noRepeatList.addChild(item);
	        });
	        return hasRepeat;
	    };
	    return Stack;
	}(List));

	var DomQuery = (function () {
	    function DomQuery() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        this._doms = null;
	        if (JudgeUtils.isDom(args[0])) {
	            this._doms = [args[0]];
	        }
	        else if (this._isDomEleStr(args[0])) {
	            this._doms = [this._buildDom(args[0])];
	        }
	        else {
	            this._doms = document.querySelectorAll(args[0]);
	        }
	        return this;
	    }
	    DomQuery.create = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var obj = new this(args[0]);
	        return obj;
	    };
	    DomQuery.prototype.get = function (index) {
	        return this._doms[index];
	    };
	    DomQuery.prototype.prepend = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var targetDom = null;
	        targetDom = this._buildDom(args[0]);
	        for (var _a = 0, _b = this._doms; _a < _b.length; _a++) {
	            var dom = _b[_a];
	            if (dom.nodeType === 1) {
	                dom.insertBefore(targetDom, dom.firstChild);
	            }
	        }
	        return this;
	    };
	    DomQuery.prototype.prependTo = function (eleStr) {
	        var targetDom = null;
	        targetDom = DomQuery.create(eleStr);
	        for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
	            var dom = _a[_i];
	            if (dom.nodeType === 1) {
	                targetDom.prepend(dom);
	            }
	        }
	        return this;
	    };
	    DomQuery.prototype.remove = function () {
	        for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
	            var dom = _a[_i];
	            if (dom && dom.parentNode && dom.tagName != 'BODY') {
	                dom.parentNode.removeChild(dom);
	            }
	        }
	        return this;
	    };
	    DomQuery.prototype.css = function (property, value) {
	        for (var _i = 0, _a = this._doms; _i < _a.length; _i++) {
	            var dom = _a[_i];
	            dom.style[property] = value;
	        }
	    };
	    DomQuery.prototype.attr = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (args.length === 1) {
	            var name = args[0];
	            return this.get(0).getAttribute(name);
	        }
	        else {
	            var name = args[0], value = args[1];
	            for (var _a = 0, _b = this._doms; _a < _b.length; _a++) {
	                var dom = _b[_a];
	                dom.setAttribute(name, value);
	            }
	        }
	    };
	    DomQuery.prototype.text = function (str) {
	        var dom = this.get(0);
	        if (str !== void 0) {
	            if (dom.textContent !== void 0) {
	                dom.textContent = str;
	            }
	            else {
	                dom.innerText = str;
	            }
	        }
	        else {
	            return dom.textContent !== void 0 ? dom.textContent : dom.innerText;
	        }
	    };
	    DomQuery.prototype._isDomEleStr = function (eleStr) {
	        return eleStr.match(/<(\w+)[^>]*><\/\1>/) !== null;
	    };
	    DomQuery.prototype._buildDom = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (JudgeUtils.isString(args[0])) {
	            var div = this._createElement("div"), eleStr = args[0];
	            div.innerHTML = eleStr;
	            return div.firstChild;
	        }
	        return args[0];
	    };
	    DomQuery.prototype._createElement = function (eleStr) {
	        return document.createElement(eleStr);
	    };
	    return DomQuery;
	}());

	var Assertion = (function () {
	    function Assertion() {
	    }
	    Assertion.create = function () {
	        var obj = new this();
	        return obj;
	    };
	    Object.defineProperty(Assertion.prototype, "not", {
	        get: function () {
	            ExpectData.isNot = true;
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Assertion.prototype, "be", {
	        get: function () {
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Assertion.prototype, "true", {
	        get: function () {
	            var source = ExpectData.source;
	            this._assert(!!source === true, "true");
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Assertion.prototype, "false", {
	        get: function () {
	            var source = ExpectData.source;
	            this._assert(!!source === false, "false");
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Assertion.prototype, "exist", {
	        get: function () {
	            var source = ExpectData.source;
	            this._assert(source !== null && source !== void 0, "exist");
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Assertion.prototype, "null", {
	        get: function () {
	            var source = ExpectData.source;
	            this._assert(source === null, "null");
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Assertion.prototype, "undefined", {
	        get: function () {
	            var source = ExpectData.source;
	            this._assert(source === void 0, "undefined");
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Assertion.prototype.equal = function (n) {
	        var source = ExpectData.source;
	        this._assert(source === n, "equal", n);
	        return this;
	    };
	    Assertion.prototype.gt = function (n) {
	        var source = ExpectData.source;
	        this._assert(source > n, ">", n);
	        return this;
	    };
	    Assertion.prototype.gte = function (n) {
	        var source = ExpectData.source;
	        this._assert(source >= n, ">=", n);
	        return this;
	    };
	    Assertion.prototype.lt = function (n) {
	        var source = ExpectData.source;
	        this._assert(source < n, "<", n);
	        return this;
	    };
	    Assertion.prototype.lte = function (n) {
	        var source = ExpectData.source;
	        this._assert(source <= n, "<=", n);
	        return this;
	    };
	    Assertion.prototype.a = function (type) {
	        var source = ExpectData.source;
	        switch (type) {
	            case "number":
	                this._assert(JudgeUtils.isNumber(source), "number");
	                break;
	            case "array":
	                this._assert(JudgeUtils.isArrayExactly(source), "array");
	                break;
	            case "boolean":
	                this._assert(JudgeUtils.isBoolean(source), "boolean");
	                break;
	            case "string":
	                this._assert(JudgeUtils.isStringExactly(source), "string");
	                break;
	            default:
	                break;
	        }
	    };
	    Assertion.prototype._buildFailMsg = function (operationStr, target) {
	        if (!!target) {
	            return "expected " + this._format(ExpectData.source) + " to be " + operationStr + " " + target;
	        }
	        return "expected " + this._format(ExpectData.source) + " to be " + operationStr;
	    };
	    Assertion.prototype._assert = function (passCondition, failMsg, target) {
	        var pass = null, failMessage = null;
	        if (ExpectData.isNot) {
	            pass = !passCondition;
	        }
	        else {
	            pass = passCondition;
	        }
	        if (pass) {
	            ExpectData.isNot = false;
	            return;
	        }
	        failMessage = this._buildFailMsg(failMsg, target);
	        if (ExpectData.isNot) {
	            ExpectData.isNot = false;
	            failMessage = failMessage.replace("to be", "not to be");
	        }
	        throw new Error(failMessage);
	    };
	    Assertion.prototype._format = function (source) {
	        return source;
	    };
	    return Assertion;
	}());

	var expect = function (source) {
	    var assertion = ExpectData.assertion;
	    ExpectData.source = source;
	    return assertion;
	};
	var _initData = function () {
	    ExpectData.assertion = Assertion.create();
	    ExpectData.isNot = false;
	};
	_initData();

	exports.Assertion = Assertion;
	exports.ExpectData = ExpectData;
	exports.expect = expect;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

});

unwrapExports(wdet$1);
var wdet_1 = wdet$1.expect;

var EGPUPrecision;
(function (EGPUPrecision) {
    EGPUPrecision[EGPUPrecision["HIGHP"] = 0] = "HIGHP";
    EGPUPrecision[EGPUPrecision["MEDIUMP"] = 1] = "MEDIUMP";
    EGPUPrecision[EGPUPrecision["LOWP"] = 2] = "LOWP";
})(EGPUPrecision || (EGPUPrecision = {}));

var detectExtension = function (state, gl, GPUDetectDataFromSystem) {
    GPUDetectDataFromSystem.extensionCompressedTextureS3TC = getExtension("WEBGL_compressed_texture_s3tc", state, gl);
    GPUDetectDataFromSystem.extensionTextureFilterAnisotropic = getExtension("EXT_texture_filter_anisotropic", state, gl);
    GPUDetectDataFromSystem.extensionInstancedArrays = getExtension("ANGLE_instanced_arrays", state, gl);
    GPUDetectDataFromSystem.extensionUintIndices = getExtension("element_index_uint", state, gl);
    GPUDetectDataFromSystem.extensionDepthTexture = getExtension("depth_texture", state, gl);
    GPUDetectDataFromSystem.extensionVao = getExtension("vao", state, gl);
    GPUDetectDataFromSystem.extensionStandardDerivatives = getExtension("standard_derivatives", state, gl);
};
var detectCapabilty = function (state, gl, GPUDetectDataFromSystem) {
    GPUDetectDataFromSystem.maxTextureUnit = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    GPUDetectDataFromSystem.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    GPUDetectDataFromSystem.maxCubemapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    GPUDetectDataFromSystem.maxAnisotropy = _getMaxAnisotropy(state, gl, GPUDetectDataFromSystem);
    GPUDetectDataFromSystem.maxBoneCount = _getMaxBoneCount(state, gl);
    _detectPrecision(state, gl, GPUDetectDataFromSystem);
};
var _getMaxBoneCount = function (state, gl) {
    var numUniforms = null, maxBoneCount = null;
    numUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    numUniforms -= 4 * 4;
    numUniforms -= 1;
    numUniforms -= 4 * 4;
    maxBoneCount = Math.floor(numUniforms / 4);
    return Math.min(maxBoneCount, 128);
};
var _getMaxAnisotropy = function (state, gl, GPUDetectDataFromSystem) {
    var extension = GPUDetectDataFromSystem.extensionTextureFilterAnisotropic;
    return extension !== null ? gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
};
var _detectPrecision = function (state, gl, GPUDetectDataFromSystem) {
    if (!gl.getShaderPrecisionFormat) {
        GPUDetectDataFromSystem.precision = EGPUPrecision.HIGHP;
        return;
    }
    var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT), vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT), fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT), fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT), highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0, mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
    if (!highpAvailable) {
        if (mediumpAvailable) {
            GPUDetectDataFromSystem.precision = EGPUPrecision.MEDIUMP;
            Log$$1.warn(Log$$1.info.FUNC_NOT_SUPPORT("gpu", "highp, using mediump"));
        }
        else {
            GPUDetectDataFromSystem.precision = EGPUPrecision.LOWP;
            Log$$1.warn(Log$$1.info.FUNC_NOT_SUPPORT("gpu", "highp and mediump, using lowp"));
        }
    }
    else {
        GPUDetectDataFromSystem.precision = EGPUPrecision.HIGHP;
    }
};
var getExtension = function (name, state, gl) {
    var extension = null;
    switch (name) {
        case "EXT_texture_filter_anisotropic":
            extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        case "ANGLE_instanced_arrays":
            extension = gl.getExtension("ANGLE_instanced_arrays");
            break;
        case "element_index_uint":
            extension = gl.getExtension("OES_element_index_uint") !== null;
            break;
        case "depth_texture":
            extension = gl.getExtension("WEBKIT_WEBGL_depth_texture") !== null || gl.getExtension("WEBGL_depth_texture") !== null;
            break;
        case "vao":
            extension = gl.getExtension("OES_vertex_array_object");
            break;
        case "standard_derivatives":
            extension = gl.getExtension("OES_standard_derivatives");
            break;
        default:
            extension = gl.getExtension(name);
            break;
    }
    return extension;
};
var hasExtensionUintIndices = function (GPUDetectDataFromSystem) { return GPUDetectDataFromSystem.extensionUintIndices === true; };
var getMaxTextureUnit = function (GPUDetectDataFromSystem) { return GPUDetectDataFromSystem.maxTextureUnit; };
var getPrecision = function (GPUDetectDataFromSystem) { return GPUDetectDataFromSystem.precision; };
var hasExtension = function (extension) { return !!extension; };

var isCached$1 = function (unitIndex, textureIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem) {
    return _getActiveTexture(unitIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem) === textureIndex;
};
var _getActiveTexture = requireCheckFunc(function (unitIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem) {
    _checkUnit(unitIndex, GPUDetectDataFromSystem);
}, function (unitIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem) {
    return TextureCacheDataFromSystem.bindTextureUnitCache[unitIndex];
});
var addActiveTexture$1 = requireCheckFunc(function (unitIndex, textureIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem) {
    _checkUnit(unitIndex, GPUDetectDataFromSystem);
}, function (unitIndex, textureIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem) {
    TextureCacheDataFromSystem.bindTextureUnitCache[unitIndex] = textureIndex;
});
var _checkUnit = function (unitIndex, GPUDetectDataFromSystem) {
    var maxTextureUnit = getMaxTextureUnit(GPUDetectDataFromSystem);
    it$$1("texture unitIndex should >= 0, but actual is " + unitIndex, function () {
        wdet_1(unitIndex).gte(0);
    });
    it$$1("trying to cache " + unitIndex + " texture unitIndexs, but GPU only supports " + maxTextureUnit + " unitIndexs", function () {
        wdet_1(unitIndex).lt(maxTextureUnit);
    });
};
var clearAllBindTextureUnitCache$1 = function (TextureCacheDataFromSystem) {
    TextureCacheDataFromSystem.bindTextureUnitCache = [];
};
var initData$3 = function (TextureCacheDataFromSystem) {
    TextureCacheDataFromSystem.bindTextureUnitCache = [];
};

var isCached$$1 = isCached$1;
var addActiveTexture$$1 = addActiveTexture$1;

var initData$2 = initData$3;

var deleteVal = function (key, arr) { return arr[key] = void 0; };
var isNotValidVal = function (val) { return isUndefined(val); };
var isValidVal = function (val) { return isNotUndefined(val); };
var deleteBySwap = function (index, lastIndex, array) {
    if (lastIndex === -1) {
        return null;
    }
    array[index] = array[lastIndex];
    array.pop();
};
var hasDuplicateItems = function (arr) {
    var noRepeatArr = [], hasRepeat = false;
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var item = arr_1[_i];
        if (!item) {
            continue;
        }
        if (_contain(noRepeatArr, item)) {
            hasRepeat = true;
            break;
        }
        noRepeatArr.push(item);
    }
    return hasRepeat;
};
var _contain = function (arr, item) {
    var c = null;
    for (var i = 0, len = arr.length; i < len; i++) {
        c = arr[i];
        if (item === c) {
            return true;
        }
    }
    return false;
};
var removeDuplicateItems = function (arr) {
    var resultArr = [];
    for (var _i = 0, arr_2 = arr; _i < arr_2.length; _i++) {
        var ele = arr_2[_i];
        if (_contain(resultArr, ele)) {
            continue;
        }
        resultArr.push(ele);
    }
    
    return resultArr;
};
var removeItem = function (arr, item) {
    return filter(arr, function (ele) {
        return ele !== item;
    });
};
var replaceItem = function (arr, oldItem, newItem) {
    for (var i = 0, len = arr.length; i < len; i++) {
        var val = arr[i];
        if (val === oldItem) {
            arr[i] = newItem;
        }
    }
    return arr;
};
var filter = function (arr, func) {
    var result = [];
    if (isUndefined(arr)) {
        return result;
    }
    for (var _i = 0, arr_3 = arr; _i < arr_3.length; _i++) {
        var ele = arr_3[_i];
        if (func(ele)) {
            result.push(ele);
        }
    }
    return result;
};
var forEach = function (arr, func) {
    if (isUndefined(arr)) {
        return;
    }
    for (var i = 0, len = arr.length; i < len; i++) {
        func(arr[i], i);
    }
};

var TextureData = (function () {
    function TextureData() {
    }
    TextureData.index = null;
    TextureData.glTextures = null;
    TextureData.sourceMap = null;
    TextureData.textureMap = null;
    TextureData.uniformSamplerNameMap = null;
    TextureData.buffer = null;
    TextureData.widths = null;
    TextureData.heights = null;
    TextureData.isNeedUpdates = null;
    TextureData.defaultWidth = null;
    TextureData.defaultHeight = null;
    TextureData.defaultIsNeedUpdate = null;
    TextureData.disposedTextureDataMap = null;
    TextureData.needInitedTextureIndexArr = null;
    TextureData.needAddedSourceArr = null;
    return TextureData;
}());

var ComponentData = (function () {
    function ComponentData() {
    }
    ComponentData.addComponentHandleMap = {};
    ComponentData.disposeHandleMap = {};
    ComponentData.initHandleMap = {};
    return ComponentData;
}());

var ClassUtils = (function () {
    function ClassUtils() {
    }
    ClassUtils.getClassNameByInstance = function (obj) {
        return obj.constructor["className"];
    };
    ClassUtils.getClassNameByClass = function (_class) {
        return _class["className"];
    };
    ClassUtils.addClass = function (className, _class) {
        this._classMap[className] = _class;
    };
    ClassUtils.addClassNameAttributeToClass = function (className, _class) {
        _class["className"] = className;
    };
    ClassUtils.getClass = function (className) {
        return this._classMap[className];
    };
    ClassUtils._classMap = {};
    __decorate([
        ensure$1(function (className) {
            it$$1("should exist class name", function () {
                wdet_1(className).exist;
                wdet_1(className !== "").true;
            });
        })
    ], ClassUtils, "getClassNameByInstance", null);
    __decorate([
        ensure$1(function (className) {
            it$$1("should exist class name", function () {
                wdet_1(className).exist;
                wdet_1(className !== "").true;
            });
        })
    ], ClassUtils, "getClassNameByClass", null);
    return ClassUtils;
}());

var _generateTypeId = function () {
    var result = _typeId;
    _typeId += 1;
    return String(result);
};
var getTypeIdFromClass = function (_class) {
    return _table[ClassUtils.getClassNameByClass(_class)];
};
var getTypeIdFromComponent = function (component) {
    return _table[ClassUtils.getClassNameByInstance(component)];
};
var _addTypeId = function (componentClassNameArr, table) {
    var id = _generateTypeId();
    for (var _i = 0, componentClassNameArr_1 = componentClassNameArr; _i < componentClassNameArr_1.length; _i++) {
        var className = componentClassNameArr_1[_i];
        table[className] = id;
    }
};
var _typeId = 1;
var _table = {};
_addTypeId(["ThreeDTransform"], _table);
_addTypeId(["BoxGeometry"], _table);
_addTypeId(["CustomGeometry"], _table);
_addTypeId(["BasicMaterial"], _table);
_addTypeId(["LightMaterial"], _table);
_addTypeId(["MeshRenderer"], _table);
_addTypeId(["Tag"], _table);
_addTypeId(["CameraController"], _table);
_addTypeId(["AmbientLight"], _table);
_addTypeId(["DirectionLight"], _table);
_addTypeId(["PointLight"], _table);

var deleteVal$1 = function (key, obj) { return obj[key] = void 0; };
var deleteBySwap$1 = function (sourceIndex, targetIndex, obj) {
    obj[sourceIndex] = obj[targetIndex];
    deleteVal$1(targetIndex, obj);
};
var isValidMapValue = function (val) {
    return isNotUndefined(val);
};
var isNotValidMapValue = function (val) {
    return isUndefined(val);
};
var createMap = function () { return Object.create(null); };

var _addHandle = function (_class, handleMap, handle) {
    var typeId = getTypeIdFromClass(_class);
    handleMap[typeId] = handle;
};
var addAddComponentHandle = function (_class, handle) {
    _addHandle(_class, ComponentData.addComponentHandleMap, handle);
};
var addDisposeHandle = function (_class, handle) {
    _addHandle(_class, ComponentData.disposeHandleMap, handle);
};
var addInitHandle = function (_class, handle) {
    _addHandle(_class, ComponentData.initHandleMap, handle);
};
var execHandle = function (component, handleMapName, args) {
    var handle = ComponentData[handleMapName][getTypeIdFromComponent(component)];
    if (_isHandleNotExist(handle)) {
        return;
    }
    if (!!args) {
        handle.apply(null, args);
    }
    else {
        handle(component);
    }
};
var execInitHandle = function (typeId, index, state) {
    var handle = ComponentData.initHandleMap[typeId];
    if (_isHandleNotExist(handle)) {
        return;
    }
    handle(index, state);
};
var _isHandleNotExist = function (handle) { return isNotValidMapValue(handle); };
var checkComponentShouldAlive = function (component, data, isAlive) {
    it$$1("component should alive", function () {
        wdet_1(isAlive(component, data)).true;
    });
};
var addComponentToGameObjectMap = requireCheckFunc(function (gameObjectMap, index, gameObject) {
}, function (gameObjectMap, index, gameObject) {
    gameObjectMap[index] = gameObject;
});
var getComponentGameObject = function (gameObjectMap, index) {
    return gameObjectMap[index];
};
var generateComponentIndex = function (ComponentData$$1) {
    return ComponentData$$1.index++;
};
var deleteComponent = requireCheckFunc(function (index, componentMap) {
    it$$1("index should >= 0", function () {
        wdet_1(index).gte(0);
    });
}, function (index, componentMap) {
    markComponentIndexRemoved(componentMap[index]);
    deleteVal$1(index, componentMap);
});
var deleteComponentBySwapArray = requireCheckFunc(function (sourceIndex, targetIndex, componentMap) {
    it$$1("targetIndex should >= 0", function () {
        wdet_1(targetIndex).gte(0);
    });
}, function (sourceIndex, targetIndex, componentMap) {
    componentMap[targetIndex].index = sourceIndex;
    markComponentIndexRemoved(componentMap[sourceIndex]);
    deleteBySwap(sourceIndex, targetIndex, componentMap);
});
var markComponentIndexRemoved = function (component) {
    component.index = -1;
};
var isComponentIndexNotRemoved = function (component) {
    return component.index !== -1;
};

var isObject_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
exports.default = isObject;
});

unwrapExports(isObject_1);

var _baseCreate = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isObject_js_1 = isObject_1;
var objectCreate = Object.create;
var baseCreate = (function () {
    function object() { }
    return function (proto) {
        if (!isObject_js_1.default(proto)) {
            return {};
        }
        if (objectCreate) {
            return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
    };
}());
exports.default = baseCreate;
});

unwrapExports(_baseCreate);

var _baseLodash = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function baseLodash() {
}
exports.default = baseLodash;
});

unwrapExports(_baseLodash);

var _LodashWrapper = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseCreate_js_1 = _baseCreate;
var _baseLodash_js_1 = _baseLodash;
function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
    this.__index__ = 0;
    this.__values__ = undefined;
}
LodashWrapper.prototype = _baseCreate_js_1.default(_baseLodash_js_1.default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
exports.default = LodashWrapper;
});

unwrapExports(_LodashWrapper);

var _arrayPush = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
        array[offset + index] = values[index];
    }
    return array;
}
exports.default = arrayPush;
});

unwrapExports(_arrayPush);

var _freeGlobal = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
exports.default = freeGlobal;
});

unwrapExports(_freeGlobal);

var _root = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _freeGlobal_js_1 = _freeGlobal;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = _freeGlobal_js_1.default || freeSelf || Function('return this')();
exports.default = root;
});

unwrapExports(_root);

var _Symbol = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _root_js_1 = _root;
var Symbol = _root_js_1.default.Symbol;
exports.default = Symbol;
});

unwrapExports(_Symbol);

var _getRawTag = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _Symbol_js_1 = _Symbol;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = _Symbol_js_1.default ? _Symbol_js_1.default.toStringTag : undefined;
function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    }
    catch (e) { }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        }
        else {
            delete value[symToStringTag];
        }
    }
    return result;
}
exports.default = getRawTag;
});

unwrapExports(_getRawTag);

var _objectToString = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString(value) {
    return nativeObjectToString.call(value);
}
exports.default = objectToString;
});

unwrapExports(_objectToString);

var _baseGetTag = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _Symbol_js_1 = _Symbol;
var _getRawTag_js_1 = _getRawTag;
var _objectToString_js_1 = _objectToString;
var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
var symToStringTag = _Symbol_js_1.default ? _Symbol_js_1.default.toStringTag : undefined;
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
        ? _getRawTag_js_1.default(value)
        : _objectToString_js_1.default(value);
}
exports.default = baseGetTag;
});

unwrapExports(_baseGetTag);

var isObjectLike_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
exports.default = isObjectLike;
});

unwrapExports(isObjectLike_1);

var _baseIsArguments = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseGetTag_js_1 = _baseGetTag;
var isObjectLike_js_1 = isObjectLike_1;
var argsTag = '[object Arguments]';
function baseIsArguments(value) {
    return isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == argsTag;
}
exports.default = baseIsArguments;
});

unwrapExports(_baseIsArguments);

var isArguments_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseIsArguments_js_1 = _baseIsArguments;
var isObjectLike_js_1 = isObjectLike_1;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var isArguments = _baseIsArguments_js_1.default(function () { return arguments; }()) ? _baseIsArguments_js_1.default : function (value) {
    return isObjectLike_js_1.default(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
};
exports.default = isArguments;
});

unwrapExports(isArguments_1);

var isArray_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray = Array.isArray;
exports.default = isArray;
});

unwrapExports(isArray_1);

var _isFlattenable = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _Symbol_js_1 = _Symbol;
var isArguments_js_1 = isArguments_1;
var isArray_js_1 = isArray_1;
var spreadableSymbol = _Symbol_js_1.default ? _Symbol_js_1.default.isConcatSpreadable : undefined;
function isFlattenable(value) {
    return isArray_js_1.default(value) || isArguments_js_1.default(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
}
exports.default = isFlattenable;
});

unwrapExports(_isFlattenable);

var _baseFlatten = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _arrayPush_js_1 = _arrayPush;
var _isFlattenable_js_1 = _isFlattenable;
function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = _isFlattenable_js_1.default);
    result || (result = []);
    while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            }
            else {
                _arrayPush_js_1.default(result, value);
            }
        }
        else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
exports.default = baseFlatten;
});

unwrapExports(_baseFlatten);

var flatten_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseFlatten_js_1 = _baseFlatten;
function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? _baseFlatten_js_1.default(array, 1) : [];
}
exports.default = flatten;
});

unwrapExports(flatten_1);

var _apply = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function apply(func, thisArg, args) {
    switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
exports.default = apply;
});

unwrapExports(_apply);

var _overRest = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _apply_js_1 = _apply;
var nativeMax = Math.max;
function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return _apply_js_1.default(func, this, otherArgs);
    };
}
exports.default = overRest;
});

unwrapExports(_overRest);

var constant_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function constant(value) {
    return function () {
        return value;
    };
}
exports.default = constant;
});

unwrapExports(constant_1);

var isFunction_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseGetTag_js_1 = _baseGetTag;
var isObject_js_1 = isObject_1;
var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
function isFunction(value) {
    if (!isObject_js_1.default(value)) {
        return false;
    }
    var tag = _baseGetTag_js_1.default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
exports.default = isFunction;
});

unwrapExports(isFunction_1);

var _coreJsData = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _root_js_1 = _root;
var coreJsData = _root_js_1.default['__core-js_shared__'];
exports.default = coreJsData;
});

unwrapExports(_coreJsData);

var _isMasked = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _coreJsData_js_1 = _coreJsData;
var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(_coreJsData_js_1.default && _coreJsData_js_1.default.keys && _coreJsData_js_1.default.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
}());
function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
}
exports.default = isMasked;
});

unwrapExports(_isMasked);

var _toSource = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        }
        catch (e) { }
        try {
            return (func + '');
        }
        catch (e) { }
    }
    return '';
}
exports.default = toSource;
});

unwrapExports(_toSource);

var _baseIsNative = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction_js_1 = isFunction_1;
var _isMasked_js_1 = _isMasked;
var isObject_js_1 = isObject_1;
var _toSource_js_1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
function baseIsNative(value) {
    if (!isObject_js_1.default(value) || _isMasked_js_1.default(value)) {
        return false;
    }
    var pattern = isFunction_js_1.default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource_js_1.default(value));
}
exports.default = baseIsNative;
});

unwrapExports(_baseIsNative);

var _getValue = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
exports.default = getValue;
});

unwrapExports(_getValue);

var _getNative = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseIsNative_js_1 = _baseIsNative;
var _getValue_js_1 = _getValue;
function getNative(object, key) {
    var value = _getValue_js_1.default(object, key);
    return _baseIsNative_js_1.default(value) ? value : undefined;
}
exports.default = getNative;
});

unwrapExports(_getNative);

var _defineProperty = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _getNative_js_1 = _getNative;
var defineProperty = (function () {
    try {
        var func = _getNative_js_1.default(Object, 'defineProperty');
        func({}, '', {});
        return func;
    }
    catch (e) { }
}());
exports.default = defineProperty;
});

unwrapExports(_defineProperty);

var identity_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(value) {
    return value;
}
exports.default = identity;
});

unwrapExports(identity_1);

var _baseSetToString = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var constant_js_1 = constant_1;
var _defineProperty_js_1 = _defineProperty;
var identity_js_1 = identity_1;
var baseSetToString = !_defineProperty_js_1.default ? identity_js_1.default : function (func, string) {
    return _defineProperty_js_1.default(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant_js_1.default(string),
        'writable': true
    });
};
exports.default = baseSetToString;
});

unwrapExports(_baseSetToString);

var _shortOut = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function () {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
            if (++count >= HOT_COUNT) {
                return arguments[0];
            }
        }
        else {
            count = 0;
        }
        return func.apply(undefined, arguments);
    };
}
exports.default = shortOut;
});

unwrapExports(_shortOut);

var _setToString = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseSetToString_js_1 = _baseSetToString;
var _shortOut_js_1 = _shortOut;
var setToString = _shortOut_js_1.default(_baseSetToString_js_1.default);
exports.default = setToString;
});

unwrapExports(_setToString);

var _flatRest = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var flatten_js_1 = flatten_1;
var _overRest_js_1 = _overRest;
var _setToString_js_1 = _setToString;
function flatRest(func) {
    return _setToString_js_1.default(_overRest_js_1.default(func, undefined, flatten_js_1.default), func + '');
}
exports.default = flatRest;
});

unwrapExports(_flatRest);

var _WeakMap = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _getNative_js_1 = _getNative;
var _root_js_1 = _root;
var WeakMap = _getNative_js_1.default(_root_js_1.default, 'WeakMap');
exports.default = WeakMap;
});

unwrapExports(_WeakMap);

var _metaMap = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _WeakMap_js_1 = _WeakMap;
var metaMap = _WeakMap_js_1.default && new _WeakMap_js_1.default;
exports.default = metaMap;
});

unwrapExports(_metaMap);

var noop_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function noop() {
}
exports.default = noop;
});

unwrapExports(noop_1);

var _getData = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _metaMap_js_1 = _metaMap;
var noop_js_1 = noop_1;
var getData = !_metaMap_js_1.default ? noop_js_1.default : function (func) {
    return _metaMap_js_1.default.get(func);
};
exports.default = getData;
});

unwrapExports(_getData);

var _realNames = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var realNames = {};
exports.default = realNames;
});

unwrapExports(_realNames);

var _getFuncName = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _realNames_js_1 = _realNames;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function getFuncName(func) {
    var result = (func.name + ''), array = _realNames_js_1.default[result], length = hasOwnProperty.call(_realNames_js_1.default, result) ? array.length : 0;
    while (length--) {
        var data = array[length], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
            return data.name;
        }
    }
    return result;
}
exports.default = getFuncName;
});

unwrapExports(_getFuncName);

var _LazyWrapper = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseCreate_js_1 = _baseCreate;
var _baseLodash_js_1 = _baseLodash;
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__dir__ = 1;
    this.__filtered__ = false;
    this.__iteratees__ = [];
    this.__takeCount__ = MAX_ARRAY_LENGTH;
    this.__views__ = [];
}
LazyWrapper.prototype = _baseCreate_js_1.default(_baseLodash_js_1.default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
exports.default = LazyWrapper;
});

unwrapExports(_LazyWrapper);

var _copyArray = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
        array[index] = source[index];
    }
    return array;
}
exports.default = copyArray;
});

unwrapExports(_copyArray);

var _wrapperClone = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _LazyWrapper_js_1 = _LazyWrapper;
var _LodashWrapper_js_1 = _LodashWrapper;
var _copyArray_js_1 = _copyArray;
function wrapperClone(wrapper) {
    if (wrapper instanceof _LazyWrapper_js_1.default) {
        return wrapper.clone();
    }
    var result = new _LodashWrapper_js_1.default(wrapper.__wrapped__, wrapper.__chain__);
    result.__actions__ = _copyArray_js_1.default(wrapper.__actions__);
    result.__index__ = wrapper.__index__;
    result.__values__ = wrapper.__values__;
    return result;
}
exports.default = wrapperClone;
});

unwrapExports(_wrapperClone);

var wrapperLodash = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _LazyWrapper_js_1 = _LazyWrapper;
var _LodashWrapper_js_1 = _LodashWrapper;
var _baseLodash_js_1 = _baseLodash;
var isArray_js_1 = isArray_1;
var isObjectLike_js_1 = isObjectLike_1;
var _wrapperClone_js_1 = _wrapperClone;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function lodash(value) {
    if (isObjectLike_js_1.default(value) && !isArray_js_1.default(value) && !(value instanceof _LazyWrapper_js_1.default)) {
        if (value instanceof _LodashWrapper_js_1.default) {
            return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
            return _wrapperClone_js_1.default(value);
        }
    }
    return new _LodashWrapper_js_1.default(value);
}
lodash.prototype = _baseLodash_js_1.default.prototype;
lodash.prototype.constructor = lodash;
exports.default = lodash;
});

unwrapExports(wrapperLodash);

var _isLaziable = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _LazyWrapper_js_1 = _LazyWrapper;
var _getData_js_1 = _getData;
var _getFuncName_js_1 = _getFuncName;
var wrapperLodash_js_1 = wrapperLodash;
function isLaziable(func) {
    var funcName = _getFuncName_js_1.default(func), other = wrapperLodash_js_1.default[funcName];
    if (typeof other != 'function' || !(funcName in _LazyWrapper_js_1.default.prototype)) {
        return false;
    }
    if (func === other) {
        return true;
    }
    var data = _getData_js_1.default(other);
    return !!data && func === data[0];
}
exports.default = isLaziable;
});

unwrapExports(_isLaziable);

var _createFlow = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _LodashWrapper_js_1 = _LodashWrapper;
var _flatRest_js_1 = _flatRest;
var _getData_js_1 = _getData;
var _getFuncName_js_1 = _getFuncName;
var isArray_js_1 = isArray_1;
var _isLaziable_js_1 = _isLaziable;
var FUNC_ERROR_TEXT = 'Expected a function';
var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
function createFlow(fromRight) {
    return _flatRest_js_1.default(function (funcs) {
        var length = funcs.length, index = length, prereq = _LodashWrapper_js_1.default.prototype.thru;
        if (fromRight) {
            funcs.reverse();
        }
        while (index--) {
            var func = funcs[index];
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && _getFuncName_js_1.default(func) == 'wrapper') {
                var wrapper = new _LodashWrapper_js_1.default([], true);
            }
        }
        index = wrapper ? index : length;
        while (++index < length) {
            func = funcs[index];
            var funcName = _getFuncName_js_1.default(func), data = funcName == 'wrapper' ? _getData_js_1.default(func) : undefined;
            if (data && _isLaziable_js_1.default(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1) {
                wrapper = wrapper[_getFuncName_js_1.default(data[0])].apply(wrapper, data[3]);
            }
            else {
                wrapper = (func.length == 1 && _isLaziable_js_1.default(func))
                    ? wrapper[funcName]()
                    : wrapper.thru(func);
            }
        }
        return function () {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray_js_1.default(value)) {
                return wrapper.plant(value).value();
            }
            var index = 0, result = length ? funcs[index].apply(this, args) : value;
            while (++index < length) {
                result = funcs[index].call(this, result);
            }
            return result;
        };
    });
}
exports.default = createFlow;
});

unwrapExports(_createFlow);

var flowRight_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _createFlow_js_1 = _createFlow;
var flowRight = _createFlow_js_1.default(true);
exports.default = flowRight;
});

var flowRight = unwrapExports(flowRight_1);

var _arrayMap = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
exports.default = arrayMap;
});

unwrapExports(_arrayMap);

var isSymbol_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseGetTag_js_1 = _baseGetTag;
var isObjectLike_js_1 = isObjectLike_1;
var symbolTag = '[object Symbol]';
function isSymbol(value) {
    return typeof value == 'symbol' ||
        (isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == symbolTag);
}
exports.default = isSymbol;
});

unwrapExports(isSymbol_1);

var _baseToString = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _Symbol_js_1 = _Symbol;
var _arrayMap_js_1 = _arrayMap;
var isArray_js_1 = isArray_1;
var isSymbol_js_1 = isSymbol_1;
var INFINITY = 1 / 0;
var symbolProto = _Symbol_js_1.default ? _Symbol_js_1.default.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isArray_js_1.default(value)) {
        return _arrayMap_js_1.default(value, baseToString) + '';
    }
    if (isSymbol_js_1.default(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}
exports.default = baseToString;
});

unwrapExports(_baseToString);

var toString_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseToString_js_1 = _baseToString;
function toString(value) {
    return value == null ? '' : _baseToString_js_1.default(value);
}
exports.default = toString;
});

var toString$1 = unwrapExports(toString_1);

var IO = (function () {
    function IO(func) {
        this.func = null;
        this.func = func;
    }
    IO.of = function (func) {
        var obj = new this(func);
        return obj;
    };
    IO.prototype.chain = function (f) {
        var io = this;
        return IO.of(function () {
            var next = f(io.func.apply(io, arguments));
            return next.func.apply(next, arguments);
        });
    };
    IO.prototype.map = function (f) {
        return IO.of(flowRight(f, this.func));
    };
    
    IO.prototype.ap = function (thatIO) {
        return this.chain(function (f) {
            return thatIO.map(f);
        });
    };
    
    IO.prototype.run = function () {
        return this.func.apply(this, arguments);
    };
    
    IO.prototype.toString = function () {
        return "IO(" + toString$1(this.run()) + ")";
    };
    return IO;
}());

var _baseSetData = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var identity_js_1 = identity_1;
var _metaMap_js_1 = _metaMap;
var baseSetData = !_metaMap_js_1.default ? identity_js_1.default : function (func, data) {
    _metaMap_js_1.default.set(func, data);
    return func;
};
exports.default = baseSetData;
});

unwrapExports(_baseSetData);

var _createCtor = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseCreate_js_1 = _baseCreate;
var isObject_js_1 = isObject_1;
function createCtor(Ctor) {
    return function () {
        var args = arguments;
        switch (args.length) {
            case 0: return new Ctor;
            case 1: return new Ctor(args[0]);
            case 2: return new Ctor(args[0], args[1]);
            case 3: return new Ctor(args[0], args[1], args[2]);
            case 4: return new Ctor(args[0], args[1], args[2], args[3]);
            case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = _baseCreate_js_1.default(Ctor.prototype), result = Ctor.apply(thisBinding, args);
        return isObject_js_1.default(result) ? result : thisBinding;
    };
}
exports.default = createCtor;
});

unwrapExports(_createCtor);

var _createBind = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _createCtor_js_1 = _createCtor;
var _root_js_1 = _root;
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = _createCtor_js_1.default(func);
    function wrapper() {
        var fn = (this && this !== _root_js_1.default && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
    }
    return wrapper;
}
exports.default = createBind;
});

unwrapExports(_createBind);

var _composeArgs = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
    while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
            result[holders[argsIndex]] = args[argsIndex];
        }
    }
    while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
    }
    return result;
}
exports.default = composeArgs;
});

unwrapExports(_composeArgs);

var _composeArgsRight = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nativeMax = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
    while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
    }
    var offset = argsIndex;
    while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
    }
    return result;
}
exports.default = composeArgsRight;
});

unwrapExports(_composeArgsRight);

var _countHolders = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function countHolders(array, placeholder) {
    var length = array.length, result = 0;
    while (length--) {
        if (array[length] === placeholder) {
            ++result;
        }
    }
    return result;
}
exports.default = countHolders;
});

unwrapExports(_countHolders);

var _setData = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseSetData_js_1 = _baseSetData;
var _shortOut_js_1 = _shortOut;
var setData = _shortOut_js_1.default(_baseSetData_js_1.default);
exports.default = setData;
});

unwrapExports(_setData);

var _getWrapDetails = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
}
exports.default = getWrapDetails;
});

unwrapExports(_getWrapDetails);

var _insertWrapDetails = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
    var length = details.length;
    if (!length) {
        return source;
    }
    var lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
    details = details.join(length > 2 ? ', ' : ' ');
    return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}
exports.default = insertWrapDetails;
});

unwrapExports(_insertWrapDetails);

var _arrayEach = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
            break;
        }
    }
    return array;
}
exports.default = arrayEach;
});

unwrapExports(_arrayEach);

var _baseFindIndex = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
exports.default = baseFindIndex;
});

unwrapExports(_baseFindIndex);

var _baseIsNaN = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function baseIsNaN(value) {
    return value !== value;
}
exports.default = baseIsNaN;
});

unwrapExports(_baseIsNaN);

var _strictIndexOf = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
exports.default = strictIndexOf;
});

unwrapExports(_strictIndexOf);

var _baseIndexOf = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseFindIndex_js_1 = _baseFindIndex;
var _baseIsNaN_js_1 = _baseIsNaN;
var _strictIndexOf_js_1 = _strictIndexOf;
function baseIndexOf(array, value, fromIndex) {
    return value === value
        ? _strictIndexOf_js_1.default(array, value, fromIndex)
        : _baseFindIndex_js_1.default(array, _baseIsNaN_js_1.default, fromIndex);
}
exports.default = baseIndexOf;
});

unwrapExports(_baseIndexOf);

var _arrayIncludes = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseIndexOf_js_1 = _baseIndexOf;
function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOf_js_1.default(array, value, 0) > -1;
}
exports.default = arrayIncludes;
});

unwrapExports(_arrayIncludes);

var _updateWrapDetails = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _arrayEach_js_1 = _arrayEach;
var _arrayIncludes_js_1 = _arrayIncludes;
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
    _arrayEach_js_1.default(wrapFlags, function (pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !_arrayIncludes_js_1.default(details, value)) {
            details.push(value);
        }
    });
    return details.sort();
}
exports.default = updateWrapDetails;
});

unwrapExports(_updateWrapDetails);

var _setWrapToString = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _getWrapDetails_js_1 = _getWrapDetails;
var _insertWrapDetails_js_1 = _insertWrapDetails;
var _setToString_js_1 = _setToString;
var _updateWrapDetails_js_1 = _updateWrapDetails;
function setWrapToString(wrapper, reference, bitmask) {
    var source = (reference + '');
    return _setToString_js_1.default(wrapper, _insertWrapDetails_js_1.default(source, _updateWrapDetails_js_1.default(_getWrapDetails_js_1.default(source), bitmask)));
}
exports.default = setWrapToString;
});

unwrapExports(_setWrapToString);

var _createRecurry = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _isLaziable_js_1 = _isLaziable;
var _setData_js_1 = _setData;
var _setWrapToString_js_1 = _setWrapToString;
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
    bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
    }
    var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
    ];
    var result = wrapFunc.apply(undefined, newData);
    if (_isLaziable_js_1.default(func)) {
        _setData_js_1.default(result, newData);
    }
    result.placeholder = placeholder;
    return _setWrapToString_js_1.default(result, func, bitmask);
}
exports.default = createRecurry;
});

unwrapExports(_createRecurry);

var _getHolder = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getHolder(func) {
    var object = func;
    return object.placeholder;
}
exports.default = getHolder;
});

unwrapExports(_getHolder);

var _isIndex = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length &&
        (typeof value == 'number' || reIsUint.test(value)) &&
        (value > -1 && value % 1 == 0 && value < length);
}
exports.default = isIndex;
});

unwrapExports(_isIndex);

var _reorder = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _copyArray_js_1 = _copyArray;
var _isIndex_js_1 = _isIndex;
var nativeMin = Math.min;
function reorder(array, indexes) {
    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = _copyArray_js_1.default(array);
    while (length--) {
        var index = indexes[length];
        array[length] = _isIndex_js_1.default(index, arrLength) ? oldArray[index] : undefined;
    }
    return array;
}
exports.default = reorder;
});

unwrapExports(_reorder);

var _replaceHolders = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PLACEHOLDER = '__lodash_placeholder__';
function replaceHolders(array, placeholder) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
        }
    }
    return result;
}
exports.default = replaceHolders;
});

unwrapExports(_replaceHolders);

var _createHybrid = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _composeArgs_js_1 = _composeArgs;
var _composeArgsRight_js_1 = _composeArgsRight;
var _countHolders_js_1 = _countHolders;
var _createCtor_js_1 = _createCtor;
var _createRecurry_js_1 = _createRecurry;
var _getHolder_js_1 = _getHolder;
var _reorder_js_1 = _reorder;
var _replaceHolders_js_1 = _replaceHolders;
var _root_js_1 = _root;
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_ARY_FLAG = 128, WRAP_FLIP_FLAG = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : _createCtor_js_1.default(func);
    function wrapper() {
        var length = arguments.length, args = Array(length), index = length;
        while (index--) {
            args[index] = arguments[index];
        }
        if (isCurried) {
            var placeholder = _getHolder_js_1.default(wrapper), holdersCount = _countHolders_js_1.default(args, placeholder);
        }
        if (partials) {
            args = _composeArgs_js_1.default(args, partials, holders, isCurried);
        }
        if (partialsRight) {
            args = _composeArgsRight_js_1.default(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
            var newHolders = _replaceHolders_js_1.default(args, placeholder);
            return _createRecurry_js_1.default(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
        }
        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
        length = args.length;
        if (argPos) {
            args = _reorder_js_1.default(args, argPos);
        }
        else if (isFlip && length > 1) {
            args.reverse();
        }
        if (isAry && ary < length) {
            args.length = ary;
        }
        if (this && this !== _root_js_1.default && this instanceof wrapper) {
            fn = Ctor || _createCtor_js_1.default(fn);
        }
        return fn.apply(thisBinding, args);
    }
    return wrapper;
}
exports.default = createHybrid;
});

unwrapExports(_createHybrid);

var _createCurry = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _apply_js_1 = _apply;
var _createCtor_js_1 = _createCtor;
var _createHybrid_js_1 = _createHybrid;
var _createRecurry_js_1 = _createRecurry;
var _getHolder_js_1 = _getHolder;
var _replaceHolders_js_1 = _replaceHolders;
var _root_js_1 = _root;
function createCurry(func, bitmask, arity) {
    var Ctor = _createCtor_js_1.default(func);
    function wrapper() {
        var length = arguments.length, args = Array(length), index = length, placeholder = _getHolder_js_1.default(wrapper);
        while (index--) {
            args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
            ? []
            : _replaceHolders_js_1.default(args, placeholder);
        length -= holders.length;
        if (length < arity) {
            return _createRecurry_js_1.default(func, bitmask, _createHybrid_js_1.default, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== _root_js_1.default && this instanceof wrapper) ? Ctor : func;
        return _apply_js_1.default(fn, this, args);
    }
    return wrapper;
}
exports.default = createCurry;
});

unwrapExports(_createCurry);

var _createPartial = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _apply_js_1 = _apply;
var _createCtor_js_1 = _createCtor;
var _root_js_1 = _root;
var WRAP_BIND_FLAG = 1;
function createPartial(func, bitmask, thisArg, partials) {
    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = _createCtor_js_1.default(func);
    function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this && this !== _root_js_1.default && this instanceof wrapper) ? Ctor : func;
        while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
        }
        return _apply_js_1.default(fn, isBind ? thisArg : this, args);
    }
    return wrapper;
}
exports.default = createPartial;
});

unwrapExports(_createPartial);

var _mergeData = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _composeArgs_js_1 = _composeArgs;
var _composeArgsRight_js_1 = _composeArgsRight;
var _replaceHolders_js_1 = _replaceHolders;
var PLACEHOLDER = '__lodash_placeholder__';
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
var nativeMin = Math.min;
function mergeData(data, source) {
    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
    var isCombo = ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
    if (!(isCommon || isCombo)) {
        return data;
    }
    if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
    }
    var value = source[3];
    if (value) {
        var partials = data[3];
        data[3] = partials ? _composeArgs_js_1.default(partials, value, source[4]) : value;
        data[4] = partials ? _replaceHolders_js_1.default(data[3], PLACEHOLDER) : source[4];
    }
    value = source[5];
    if (value) {
        partials = data[5];
        data[5] = partials ? _composeArgsRight_js_1.default(partials, value, source[6]) : value;
        data[6] = partials ? _replaceHolders_js_1.default(data[5], PLACEHOLDER) : source[6];
    }
    value = source[7];
    if (value) {
        data[7] = value;
    }
    if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
    }
    if (data[9] == null) {
        data[9] = source[9];
    }
    data[0] = source[0];
    data[1] = newBitmask;
    return data;
}
exports.default = mergeData;
});

unwrapExports(_mergeData);

var toNumber_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isObject_js_1 = isObject_1;
var isSymbol_js_1 = isSymbol_1;
var NAN = 0 / 0;
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol_js_1.default(value)) {
        return NAN;
    }
    if (isObject_js_1.default(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject_js_1.default(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
}
exports.default = toNumber;
});

unwrapExports(toNumber_1);

var toFinite_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var toNumber_js_1 = toNumber_1;
var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308;
function toFinite(value) {
    if (!value) {
        return value === 0 ? value : 0;
    }
    value = toNumber_js_1.default(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
exports.default = toFinite;
});

unwrapExports(toFinite_1);

var toInteger_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var toFinite_js_1 = toFinite_1;
function toInteger(value) {
    var result = toFinite_js_1.default(value), remainder = result % 1;
    return result === result ? (remainder ? result - remainder : result) : 0;
}
exports.default = toInteger;
});

unwrapExports(toInteger_1);

var _createWrap = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseSetData_js_1 = _baseSetData;
var _createBind_js_1 = _createBind;
var _createCurry_js_1 = _createCurry;
var _createHybrid_js_1 = _createHybrid;
var _createPartial_js_1 = _createPartial;
var _getData_js_1 = _getData;
var _mergeData_js_1 = _mergeData;
var _setData_js_1 = _setData;
var _setWrapToString_js_1 = _setWrapToString;
var toInteger_js_1 = toInteger_1;
var FUNC_ERROR_TEXT = 'Expected a function';
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
var nativeMax = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
    if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
    }
    ary = ary === undefined ? ary : nativeMax(toInteger_js_1.default(ary), 0);
    arity = arity === undefined ? arity : toInteger_js_1.default(arity);
    length -= holders ? holders.length : 0;
    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = undefined;
    }
    var data = isBindKey ? undefined : _getData_js_1.default(func);
    var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
    ];
    if (data) {
        _mergeData_js_1.default(newData, data);
    }
    func = newData[0];
    bitmask = newData[1];
    thisArg = newData[2];
    partials = newData[3];
    holders = newData[4];
    arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);
    if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
    }
    if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = _createBind_js_1.default(func, bitmask, thisArg);
    }
    else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = _createCurry_js_1.default(func, bitmask, arity);
    }
    else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = _createPartial_js_1.default(func, bitmask, thisArg, partials);
    }
    else {
        result = _createHybrid_js_1.default.apply(undefined, newData);
    }
    var setter = data ? _baseSetData_js_1.default : _setData_js_1.default;
    return _setWrapToString_js_1.default(setter(result, newData), func, bitmask);
}
exports.default = createWrap;
});

unwrapExports(_createWrap);

var curry_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _createWrap_js_1 = _createWrap;
var WRAP_CURRY_FLAG = 8;
function curry(func, arity, guard) {
    arity = guard ? undefined : arity;
    var result = _createWrap_js_1.default(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
    result.placeholder = curry.placeholder;
    return result;
}
curry.placeholder = {};
exports.default = curry;
});

var curry = unwrapExports(curry_1);

var getCanvas = function (state) {
    return state.getIn(["View", "dom"]);
};
var setCanvas = curry(function (dom, state) {
    return state.setIn(["View", "dom"], dom);
});
var getX = curry(function (dom) {
    return Number(dom.style.left.slice(0, -2));
});
var setX = curry(function (x, dom) {
    return IO.of(function () {
        dom.style.left = x + "px";
        return dom;
    });
});
var getY = curry(function (dom) {
    return Number(dom.style.top.slice(0, -2));
});
var setY = curry(function (y, dom) {
    return IO.of(function () {
        dom.style.top = y + "px";
        return dom;
    });
});
var getWidth$1 = curry(function (dom) {
    return dom.clientWidth;
});
var setWidth$1 = curry(function (width, dom) {
    return IO.of(function () {
        dom.width = width;
        return dom;
    });
});
var getHeight$1 = curry(function (dom) {
    return dom.clientHeight;
});
var setHeight$1 = curry(function (height, dom) {
    return IO.of(function () {
        dom.height = height;
        return dom;
    });
});
var getStyleWidth = curry(function (dom) {
    return dom.style.width;
});
var setStyleWidth = curry(function (width, dom) {
    return IO.of(function () {
        dom.style.width = width;
        return dom;
    });
});
var getStyleHeight = curry(function (dom) {
    return dom.style.height;
});
var setStyleHeight = curry(function (height, dom) {
    return IO.of(function () {
        dom.style.height = height;
        return dom;
    });
});
var initCanvas = function (dom) {
    return IO.of(function () {
        dom.style.cssText = "position:absolute;left:0;top:0;";
        return dom;
    });
};
var getWebgl1Context = function (options, dom) {
    return getOnlyWebgl1Context(options, dom);
};
var getWebgl2Context = function (options, dom) {
    return getOnlyWebgl2Context(options, dom);
};
var getOnlyWebgl1Context = function (options, dom) {
    return dom.getContext("webgl", options) || dom.getContext("experimental-webgl", options);
};
var getOnlyWebgl2Context = function (options, dom) {
    return dom.getContext("webgl2", options);
};

var compose = flowRight;
var chain = curry(function (f, m) {
    return m.chain(f);
});
var map = curry(function (f, m) {
    return m.map(f);
});
var filterArray = curry(function (f, arr) {
    return filter(arr, f);
});
var forEachArray = curry(function (f, arr) {
    return forEach(arr, f);
});

var EScreenSize;
(function (EScreenSize) {
    EScreenSize[EScreenSize["FULL"] = 0] = "FULL";
})(EScreenSize || (EScreenSize = {}));

function registerClass$1(className) {
    return function (_class) {
        ClassUtils.addClassNameAttributeToClass(className, _class);
        ClassUtils.addClass(className, _class);
    };
}

var Vector3 = (function () {
    function Vector3() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.values = null;
        this.values = new Float32Array(3);
        if (args.length > 0) {
            this.values[0] = args[0];
            this.values[1] = args[1];
            this.values[2] = args[2];
        }
    }
    Vector3_1 = Vector3;
    Vector3.create = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var m = null;
        if (args.length === 0) {
            m = new this();
        }
        else {
            m = new this(args[0], args[1], args[2]);
        }
        return m;
    };
    Object.defineProperty(Vector3.prototype, "x", {
        get: function () {
            return this.values[0];
        },
        set: function (x) {
            this.values[0] = x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector3.prototype, "y", {
        get: function () {
            return this.values[1];
        },
        set: function (y) {
            this.values[1] = y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector3.prototype, "z", {
        get: function () {
            return this.values[2];
        },
        set: function (z) {
            this.values[2] = z;
        },
        enumerable: true,
        configurable: true
    });
    Vector3.prototype.normalize = function () {
        var v = this.values;
        var d = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        if (d === 0) {
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            return this;
        }
        v[0] = v[0] / d;
        v[1] = v[1] / d;
        v[2] = v[2] / d;
        if (v[0] === -0) {
            v[0] = 0;
        }
        if (v[1] === -0) {
            v[1] = 0;
        }
        if (v[2] === -0) {
            v[2] = 0;
        }
        return this;
    };
    Vector3.prototype.isZero = function () {
        var v = this.values;
        return v[0] === 0 && v[1] === 0 && v[2] === 0;
    };
    Vector3.prototype.scale = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var v = this.values;
        if (args.length === 1) {
            var scalar = args[0];
            v[0] *= scalar;
            v[1] *= scalar;
            v[2] *= scalar;
        }
        else if (args.length === 3) {
            var x = args[0], y = args[1], z = args[2];
            v[0] *= x;
            v[1] *= y;
            v[2] *= z;
        }
        return this;
    };
    Vector3.prototype.set = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length === 3) {
            this.x = args[0];
            this.y = args[1];
            this.z = args[2];
        }
        else {
            var v = args[0];
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
        }
        return this;
    };
    Vector3.prototype.sub = function (v) {
        this.values[0] = this.values[0] - v.values[0];
        this.values[1] = this.values[1] - v.values[1];
        this.values[2] = this.values[2] - v.values[2];
        return this;
    };
    Vector3.prototype.sub2 = function (v1, v2) {
        this.values[0] = v1.values[0] - v2.values[0];
        this.values[1] = v1.values[1] - v2.values[1];
        this.values[2] = v1.values[2] - v2.values[2];
        return this;
    };
    Vector3.prototype.add = function (v) {
        this.values[0] = this.values[0] + v.values[0];
        this.values[1] = this.values[1] + v.values[1];
        this.values[2] = this.values[2] + v.values[2];
        return this;
    };
    Vector3.prototype.add2 = function (v1, v2) {
        this.values[0] = v1.values[0] + v2.values[0];
        this.values[1] = v1.values[1] + v2.values[1];
        this.values[2] = v1.values[2] + v2.values[2];
        return this;
    };
    Vector3.prototype.mul = function (v) {
        this.values[0] = this.values[0] * v.values[0];
        this.values[1] = this.values[1] * v.values[1];
        this.values[2] = this.values[2] * v.values[2];
        return this;
    };
    Vector3.prototype.mul2 = function (v1, v2) {
        this.values[0] = v1.values[0] * v2.values[0];
        this.values[1] = v1.values[1] * v2.values[1];
        this.values[2] = v1.values[2] * v2.values[2];
        return this;
    };
    Vector3.prototype.reverse = function () {
        this.values[0] = -this.values[0];
        this.values[1] = -this.values[1];
        this.values[2] = -this.values[2];
        return this;
    };
    Vector3.prototype.clone = function () {
        var result = Vector3_1.create(), i = 0, len = this.values.length;
        for (i = 0; i < len; i++) {
            result.values[i] = this.values[i];
        }
        return result;
    };
    Vector3.prototype.toVector4 = function () {
        return Vector4.create(this.values[0], this.values[1], this.values[2], 1.0);
    };
    Vector3.prototype.length = function () {
        var v = this.values;
        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
    };
    Vector3.prototype.cross = function (lhs, rhs) {
        var a, b, r, ax, ay, az, bx, by, bz;
        a = lhs.values;
        b = rhs.values;
        r = this.values;
        ax = a[0];
        ay = a[1];
        az = a[2];
        bx = b[0];
        by = b[1];
        bz = b[2];
        r[0] = ay * bz - by * az;
        r[1] = az * bx - bz * ax;
        r[2] = ax * by - bx * ay;
        return this;
    };
    Vector3.prototype.lerp = function (lhs, rhs, alpha) {
        var a = lhs.values, b = rhs.values, r = this.values;
        r[0] = a[0] + alpha * (b[0] - a[0]);
        r[1] = a[1] + alpha * (b[1] - a[1]);
        r[2] = a[2] + alpha * (b[2] - a[2]);
        return this;
    };
    Vector3.prototype.dot = function (rhs) {
        var a = this.values, b = rhs.values;
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    };
    Vector3.prototype.calAngleCos = function (v1) {
        var l = this.length() * v1.length();
        if (l === 0) {
            return NaN;
        }
        return this.dot(v1) / l;
    };
    Vector3.prototype.min = function (v) {
        if (this.x > v.x) {
            this.x = v.x;
        }
        if (this.y > v.y) {
            this.y = v.y;
        }
        if (this.z > v.z) {
            this.z = v.z;
        }
        return this;
    };
    Vector3.prototype.max = function (v) {
        if (this.x < v.x) {
            this.x = v.x;
        }
        if (this.y < v.y) {
            this.y = v.y;
        }
        if (this.z < v.z) {
            this.z = v.z;
        }
        return this;
    };
    Vector3.prototype.isEqual = function (v) {
        return this.x === v.x && this.y === v.y && this.z === v.z;
    };
    Vector3.prototype.toArray = function () {
        return [this.x, this.y, this.z];
    };
    Vector3.prototype.applyMatrix3 = function (m) {
        var x = this.x, y = this.y, z = this.z, e = m.values;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
    };
    Vector3.prototype.applyMatrix4 = function (m) {
        var x = this.x, y = this.y, z = this.z, e = m.values;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
    };
    Vector3.prototype.distanceTo = function (v) {
        return Math.sqrt(this.distanceToSquared(v));
    };
    Vector3.prototype.distanceToSquared = function (v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return Math.pow(dx, 2) + Math.pow(dy, 2) + Math.pow(dz, 2);
    };
    Vector3.up = null;
    Vector3.forward = null;
    Vector3.right = null;
    Vector3 = Vector3_1 = __decorate([
        registerClass$1("Vector3")
    ], Vector3);
    return Vector3;
    var Vector3_1;
}());
Vector3.up = Vector3.create(0, 1, 0);
Vector3.forward = Vector3.create(0, 0, 1);
Vector3.right = Vector3.create(1, 0, 0);

var Vector4 = (function () {
    function Vector4() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.values = new Float32Array(4);
        if (args.length > 0) {
            this.values[0] = args[0];
            this.values[1] = args[1];
            this.values[2] = args[2];
            this.values[3] = args[3];
        }
    }
    Vector4_1 = Vector4;
    Vector4.create = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var m = null;
        if (args.length === 0) {
            m = new this();
        }
        else {
            m = new this(args[0], args[1], args[2], args[3]);
        }
        return m;
    };
    Object.defineProperty(Vector4.prototype, "x", {
        get: function () {
            return this.values[0];
        },
        set: function (x) {
            this.values[0] = x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector4.prototype, "y", {
        get: function () {
            return this.values[1];
        },
        set: function (y) {
            this.values[1] = y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector4.prototype, "z", {
        get: function () {
            return this.values[2];
        },
        set: function (z) {
            this.values[2] = z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector4.prototype, "w", {
        get: function () {
            return this.values[3];
        },
        set: function (w) {
            this.values[3] = w;
        },
        enumerable: true,
        configurable: true
    });
    Vector4.prototype.normalize = function () {
        var v = this.values;
        var d = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2] + v[3] * v[3]);
        if (d === 0) {
            return Vector4_1.create(0, 0, 0, 0);
        }
        v[0] = v[0] / d;
        v[1] = v[1] / d;
        v[2] = v[2] / d;
        v[3] = v[3] / d;
        return this;
    };
    Vector4.prototype.isEqual = function (v) {
        return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
    };
    Vector4.prototype.clone = function () {
        return this.copyHelper(Vector4_1.create());
    };
    Vector4.prototype.toVector3 = function () {
        return Vector3.create(this.values[0], this.values[1], this.values[2]);
    };
    Vector4.prototype.lengthManhattan = function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    };
    Vector4.prototype.multiplyScalar = function (scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    };
    Vector4.prototype.divideScalar = function (scalar) {
        this.multiplyScalar(1 / scalar);
        return this;
    };
    Vector4.prototype.dot = function (v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };
    Vector4.prototype.set = function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    };
    Vector4.prototype.applyMatrix4 = function (mat4Values, isChangeSelf) {
        if (isChangeSelf === void 0) { isChangeSelf = false; }
        var vec4 = this.values, x = null, y = null, z = null, w = null;
        x = vec4[0] * mat4Values[0] + vec4[1] * mat4Values[4] + vec4[2] * mat4Values[8] + vec4[3] * mat4Values[12];
        y = vec4[0] * mat4Values[1] + vec4[1] * mat4Values[5] + vec4[2] * mat4Values[9] + vec4[3] * mat4Values[13];
        z = vec4[0] * mat4Values[2] + vec4[1] * mat4Values[6] + vec4[2] * mat4Values[10] + vec4[3] * mat4Values[14];
        w = vec4[0] * mat4Values[3] + vec4[1] * mat4Values[7] + vec4[2] * mat4Values[11] + vec4[3] * mat4Values[15];
        if (isChangeSelf) {
            this.set(x, y, z, w);
            return this;
        }
        return Vector4_1.create(x, y, z, w);
    };
    Vector4.prototype.copyHelper = function (vector4) {
        var result = vector4, i = 0, len = this.values.length;
        for (i = 0; i < len; i++) {
            result.values[i] = this.values[i];
        }
        return result;
    };
    Vector4 = Vector4_1 = __decorate([
        registerClass$1("Vector4")
    ], Vector4);
    return Vector4;
    var Vector4_1;
}());

var RectRegion = (function (_super) {
    __extends(RectRegion, _super);
    function RectRegion() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RectRegion_1 = RectRegion;
    Object.defineProperty(RectRegion.prototype, "width", {
        get: function () {
            return this.z;
        },
        set: function (width) {
            this.z = width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectRegion.prototype, "height", {
        get: function () {
            return this.w;
        },
        set: function (height) {
            this.w = height;
        },
        enumerable: true,
        configurable: true
    });
    RectRegion.prototype.clone = function () {
        return this.copyHelper(RectRegion_1.create());
    };
    RectRegion.prototype.isNotEmpty = function () {
        return this.x !== 0
            || this.y !== 0
            || this.width !== 0
            || this.height !== 0;
    };
    RectRegion = RectRegion_1 = __decorate([
        registerClass$1("RectRegion")
    ], RectRegion);
    return RectRegion;
    var RectRegion_1;
}(Vector4));

var getRootProperty = function (propertyName) {
    return IO.of(function () {
        return root$2[propertyName];
    });
};

var immutable$1 = createCommonjsModule(function (module, exports) {
/**
 *  Copyright (c) 2014-2015, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */

(function (global, factory) {
  module.exports = factory();
}(commonjsGlobal, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

  function createClass(ctor, superClass) {
    if (superClass) {
      ctor.prototype = Object.create(superClass.prototype);
    }
    ctor.prototype.constructor = ctor;
  }

  function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }


  createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }


  createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }


  createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }



  function isIterable(maybeIterable) {
    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
  }

  function isKeyed(maybeKeyed) {
    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
  }

  function isIndexed(maybeIndexed) {
    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
  }

  function isAssociative(maybeAssociative) {
    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
  }

  function isOrdered(maybeOrdered) {
    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
  }

  Iterable.isIterable = isIterable;
  Iterable.isKeyed = isKeyed;
  Iterable.isIndexed = isIndexed;
  Iterable.isAssociative = isAssociative;
  Iterable.isOrdered = isOrdered;

  Iterable.Keyed = KeyedIterable;
  Iterable.Indexed = IndexedIterable;
  Iterable.Set = SetIterable;


  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  // Used for setting prototype methods that IE8 chokes on.
  var DELETE = 'delete';

  // Constants describing the size of trie nodes.
  var SHIFT = 5; // Resulted in best performance after ______?
  var SIZE = 1 << SHIFT;
  var MASK = SIZE - 1;

  // A consistent shared value representing "not set" which equals nothing other
  // than itself, and nothing that could be provided externally.
  var NOT_SET = {};

  // Boolean references, Rough equivalent of `bool &`.
  var CHANGE_LENGTH = { value: false };
  var DID_ALTER = { value: false };

  function MakeRef(ref) {
    ref.value = false;
    return ref;
  }

  function SetRef(ref) {
    ref && (ref.value = true);
  }

  // A function which returns a value representing an "owner" for transient writes
  // to tries. The return value will only ever equal itself, and will not equal
  // the return of any subsequent call of this function.
  function OwnerID() {}

  // http://jsperf.com/copy-array-inline
  function arrCopy(arr, offset) {
    offset = offset || 0;
    var len = Math.max(0, arr.length - offset);
    var newArr = new Array(len);
    for (var ii = 0; ii < len; ii++) {
      newArr[ii] = arr[ii + offset];
    }
    return newArr;
  }

  function ensureSize(iter) {
    if (iter.size === undefined) {
      iter.size = iter.__iterate(returnTrue);
    }
    return iter.size;
  }

  function wrapIndex(iter, index) {
    // This implements "is array index" which the ECMAString spec defines as:
    //
    //     A String property name P is an array index if and only if
    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
    //     to 2^321.
    //
    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
    if (typeof index !== 'number') {
      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
      if ('' + uint32Index !== index || uint32Index === 4294967295) {
        return NaN;
      }
      index = uint32Index;
    }
    return index < 0 ? ensureSize(iter) + index : index;
  }

  function returnTrue() {
    return true;
  }

  function wholeSlice(begin, end, size) {
    return (begin === 0 || (size !== undefined && begin <= -size)) &&
      (end === undefined || (size !== undefined && end >= size));
  }

  function resolveBegin(begin, size) {
    return resolveIndex(begin, size, 0);
  }

  function resolveEnd(end, size) {
    return resolveIndex(end, size, size);
  }

  function resolveIndex(index, size, defaultIndex) {
    return index === undefined ?
      defaultIndex :
      index < 0 ?
        Math.max(0, size + index) :
        size === undefined ?
          index :
          Math.min(size, index);
  }

  /* global Symbol */

  var ITERATE_KEYS = 0;
  var ITERATE_VALUES = 1;
  var ITERATE_ENTRIES = 2;

  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';

  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


  function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function() {
      return '[Iterator]';
    };


  Iterator.KEYS = ITERATE_KEYS;
  Iterator.VALUES = ITERATE_VALUES;
  Iterator.ENTRIES = ITERATE_ENTRIES;

  Iterator.prototype.inspect =
  Iterator.prototype.toSource = function () { return this.toString(); };
  Iterator.prototype[ITERATOR_SYMBOL] = function () {
    return this;
  };


  function iteratorValue(type, k, v, iteratorResult) {
    var value = type === 0 ? k : type === 1 ? v : [k, v];
    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
      value: value, done: false
    });
    return iteratorResult;
  }

  function iteratorDone() {
    return { value: undefined, done: true };
  }

  function hasIterator(maybeIterable) {
    return !!getIteratorFn(maybeIterable);
  }

  function isIterator(maybeIterator) {
    return maybeIterator && typeof maybeIterator.next === 'function';
  }

  function getIterator(iterable) {
    var iteratorFn = getIteratorFn(iterable);
    return iteratorFn && iteratorFn.call(iterable);
  }

  function getIteratorFn(iterable) {
    var iteratorFn = iterable && (
      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]
    );
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  function isArrayLike(value) {
    return value && typeof value.length === 'number';
  }

  createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() :
        isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function(/*...values*/) {
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function() {
      return this;
    };

    Seq.prototype.toString = function() {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, true);
    };



  createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ?
        emptySequence().toKeyedSeq() :
        isIterable(value) ?
          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
          keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function() {
      return this;
    };



  createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function(/*...values*/) {
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function() {
      return this;
    };

    IndexedSeq.prototype.toString = function() {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function(fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function(type, reverse) {
      return seqIterator(this, type, reverse, false);
    };



  createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (
        value === null || value === undefined ? emptySequence() :
        !isIterable(value) ? indexedSeqFromValue(value) :
        isKeyed(value) ? value.entrySeq() : value
      ).toSetSeq();
    }

    SetSeq.of = function(/*...values*/) {
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function() {
      return this;
    };



  Seq.isSeq = isSeq;
  Seq.Keyed = KeyedSeq;
  Seq.Set = SetSeq;
  Seq.Indexed = IndexedSeq;

  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

  Seq.prototype[IS_SEQ_SENTINEL] = true;



  createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function(fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function(type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function() 
        {return ii > maxIndex ?
          iteratorDone() :
          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
      );
    };



  createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function(key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function(fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function(type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, key, object[key]);
      });
    };

  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };



  createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function()  {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };




  // # pragma Helper functions

  function isSeq(maybeSeq) {
    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
  }

  var EMPTY_SEQ;

  function emptySequence() {
    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
  }

  function keyedSeqFromValue(value) {
    var seq =
      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
      typeof value === 'object' ? new ObjectSeq(value) :
      undefined;
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of [k, v] entries, '+
        'or keyed object: ' + value
      );
    }
    return seq;
  }

  function indexedSeqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value);
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values: ' + value
      );
    }
    return seq;
  }

  function seqFromValue(value) {
    var seq = maybeIndexedSeqFromValue(value) ||
      (typeof value === 'object' && new ObjectSeq(value));
    if (!seq) {
      throw new TypeError(
        'Expected Array or iterable object of values, or keyed object: ' + value
      );
    }
    return seq;
  }

  function maybeIndexedSeqFromValue(value) {
    return (
      isArrayLike(value) ? new ArraySeq(value) :
      isIterator(value) ? new IteratorSeq(value) :
      hasIterator(value) ? new IterableSeq(value) :
      undefined
    );
  }

  function seqIterate(seq, fn, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var entry = cache[reverse ? maxIndex - ii : ii];
        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
          return ii + 1;
        }
      }
      return ii;
    }
    return seq.__iterateUncached(fn, reverse);
  }

  function seqIterator(seq, type, reverse, useKeys) {
    var cache = seq._cache;
    if (cache) {
      var maxIndex = cache.length - 1;
      var ii = 0;
      return new Iterator(function()  {
        var entry = cache[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ?
          iteratorDone() :
          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
      });
    }
    return seq.__iteratorUncached(type, reverse);
  }

  function fromJS(json, converter) {
    return converter ?
      fromJSWith(converter, json, '', {'': json}) :
      fromJSDefault(json);
  }

  function fromJSWith(converter, json, key, parentJSON) {
    if (Array.isArray(json)) {
      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    if (isPlainObj(json)) {
      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
    }
    return json;
  }

  function fromJSDefault(json) {
    if (Array.isArray(json)) {
      return IndexedSeq(json).map(fromJSDefault).toList();
    }
    if (isPlainObj(json)) {
      return KeyedSeq(json).map(fromJSDefault).toMap();
    }
    return json;
  }

  function isPlainObj(value) {
    return value && (value.constructor === Object || value.constructor === undefined);
  }

  /**
   * An extension of the "same-value" algorithm as [described for use by ES6 Map
   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
   *
   * NaN is considered the same as NaN, however -0 and 0 are considered the same
   * value, which is different from the algorithm described by
   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
   *
   * This is extended further to allow Objects to describe the values they
   * represent, by way of `valueOf` or `equals` (and `hashCode`).
   *
   * Note: because of this extension, the key equality of Immutable.Map and the
   * value equality of Immutable.Set will differ from ES6 Map and Set.
   *
   * ### Defining custom values
   *
   * The easiest way to describe the value an object represents is by implementing
   * `valueOf`. For example, `Date` represents a value by returning a unix
   * timestamp for `valueOf`:
   *
   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
   *     var date2 = new Date(1234567890000);
   *     date1.valueOf(); // 1234567890000
   *     assert( date1 !== date2 );
   *     assert( Immutable.is( date1, date2 ) );
   *
   * Note: overriding `valueOf` may have other implications if you use this object
   * where JavaScript expects a primitive, such as implicit string coercion.
   *
   * For more complex types, especially collections, implementing `valueOf` may
   * not be performant. An alternative is to implement `equals` and `hashCode`.
   *
   * `equals` takes another object, presumably of similar type, and returns true
   * if the it is equal. Equality is symmetrical, so the same result should be
   * returned if this and the argument are flipped.
   *
   *     assert( a.equals(b) === b.equals(a) );
   *
   * `hashCode` returns a 32bit integer number representing the object which will
   * be used to determine how to store the value object in a Map or Set. You must
   * provide both or neither methods, one must not exist without the other.
   *
   * Also, an important relationship between these methods must be upheld: if two
   * values are equal, they *must* return the same hashCode. If the values are not
   * equal, they might have the same hashCode; this is called a hash collision,
   * and while undesirable for performance reasons, it is acceptable.
   *
   *     if (a.equals(b)) {
   *       assert( a.hashCode() === b.hashCode() );
   *     }
   *
   * All Immutable collections implement `equals` and `hashCode`.
   *
   */
  function is(valueA, valueB) {
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
    if (typeof valueA.valueOf === 'function' &&
        typeof valueB.valueOf === 'function') {
      valueA = valueA.valueOf();
      valueB = valueB.valueOf();
      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
    }
    if (typeof valueA.equals === 'function' &&
        typeof valueB.equals === 'function' &&
        valueA.equals(valueB)) {
      return true;
    }
    return false;
  }

  function deepEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (
      !isIterable(b) ||
      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
      isKeyed(a) !== isKeyed(b) ||
      isIndexed(a) !== isIndexed(b) ||
      isOrdered(a) !== isOrdered(b)
    ) {
      return false;
    }

    if (a.size === 0 && b.size === 0) {
      return true;
    }

    var notAssociative = !isAssociative(a);

    if (isOrdered(a)) {
      var entries = a.entries();
      return b.every(function(v, k)  {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done;
    }

    var flipped = false;

    if (a.size === undefined) {
      if (b.size === undefined) {
        if (typeof a.cacheResult === 'function') {
          a.cacheResult();
        }
      } else {
        flipped = true;
        var _ = a;
        a = b;
        b = _;
      }
    }

    var allEqual = true;
    var bSize = b.__iterate(function(v, k)  {
      if (notAssociative ? !a.has(v) :
          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
        allEqual = false;
        return false;
      }
    });

    return allEqual && a.size === bSize;
  }

  createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function() {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function(searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this :
        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function() {
      return this;
    };

    Repeat.prototype.indexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function(searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function(fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
      var ii = 0;
      return new Iterator(function() 
        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
      );
    };

    Repeat.prototype.equals = function(other) {
      return other instanceof Repeat ?
        is(this._value, other._value) :
        deepEqual(other);
    };


  var EMPTY_REPEAT;

  function invariant(condition, error) {
    if (!condition) throw new Error(error);
  }

  createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function() {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' +
        this._start + '...' + this._end +
        (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]';
    };

    Range.prototype.get = function(index, notSetValue) {
      return this.has(index) ?
        this._start + wrapIndex(this, index) * this._step :
        notSetValue;
    };

    Range.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 &&
        possibleIndex < this.size &&
        possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function(fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function(type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function()  {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function(other) {
      return other instanceof Range ?
        this._start === other._start &&
        this._end === other._end &&
        this._step === other._step :
        deepEqual(this, other);
    };


  var EMPTY_RANGE;

  createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }


  createClass(KeyedCollection, Collection);function KeyedCollection() {}

  createClass(IndexedCollection, Collection);function IndexedCollection() {}

  createClass(SetCollection, Collection);function SetCollection() {}


  Collection.Keyed = KeyedCollection;
  Collection.Indexed = IndexedCollection;
  Collection.Set = SetCollection;

  var imul =
    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
    Math.imul :
    function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
    };

  // v8 has an optimization for storing 31-bit signed numbers.
  // Values which have either 00 or 11 as the high order bits qualify.
  // This function drops the highest order bit in a signed number, maintaining
  // the sign bit.
  function smi(i32) {
    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
  }

  function hash(o) {
    if (o === false || o === null || o === undefined) {
      return 0;
    }
    if (typeof o.valueOf === 'function') {
      o = o.valueOf();
      if (o === false || o === null || o === undefined) {
        return 0;
      }
    }
    if (o === true) {
      return 1;
    }
    var type = typeof o;
    if (type === 'number') {
      if (o !== o || o === Infinity) {
        return 0;
      }
      var h = o | 0;
      if (h !== o) {
        h ^= o * 0xFFFFFFFF;
      }
      while (o > 0xFFFFFFFF) {
        o /= 0xFFFFFFFF;
        h ^= o;
      }
      return smi(h);
    }
    if (type === 'string') {
      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
    }
    if (typeof o.hashCode === 'function') {
      return o.hashCode();
    }
    if (type === 'object') {
      return hashJSObj(o);
    }
    if (typeof o.toString === 'function') {
      return hashString(o.toString());
    }
    throw new Error('Value type ' + type + ' cannot be hashed.');
  }

  function cachedHashString(string) {
    var hash = stringHashCache[string];
    if (hash === undefined) {
      hash = hashString(string);
      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
        STRING_HASH_CACHE_SIZE = 0;
        stringHashCache = {};
      }
      STRING_HASH_CACHE_SIZE++;
      stringHashCache[string] = hash;
    }
    return hash;
  }

  // http://jsperf.com/hashing-strings
  function hashString(string) {
    // This is the hash from JVM
    // The hash code for a string is computed as
    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
    // where s[i] is the ith character of the string and n is the length of
    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
    // (exclusive) by dropping high bits.
    var hash = 0;
    for (var ii = 0; ii < string.length; ii++) {
      hash = 31 * hash + string.charCodeAt(ii) | 0;
    }
    return smi(hash);
  }

  function hashJSObj(obj) {
    var hash;
    if (usingWeakMap) {
      hash = weakMap.get(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = obj[UID_HASH_KEY];
    if (hash !== undefined) {
      return hash;
    }

    if (!canDefineProperty) {
      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      hash = getIENodeHash(obj);
      if (hash !== undefined) {
        return hash;
      }
    }

    hash = ++objHashUID;
    if (objHashUID & 0x40000000) {
      objHashUID = 0;
    }

    if (usingWeakMap) {
      weakMap.set(obj, hash);
    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
      throw new Error('Non-extensible objects are not allowed as keys.');
    } else if (canDefineProperty) {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': hash
      });
    } else if (obj.propertyIsEnumerable !== undefined &&
               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
      // Since we can't define a non-enumerable property on the object
      // we'll hijack one of the less-used non-enumerable properties to
      // save our hash on it. Since this is a function it will not show up in
      // `JSON.stringify` which is what we want.
      obj.propertyIsEnumerable = function() {
        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
      };
      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
    } else if (obj.nodeType !== undefined) {
      // At this point we couldn't get the IE `uniqueID` to use as a hash
      // and we couldn't use a non-enumerable property to exploit the
      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
      // itself.
      obj[UID_HASH_KEY] = hash;
    } else {
      throw new Error('Unable to set a non-enumerable property on object.');
    }

    return hash;
  }

  // Get references to ES5 object methods.
  var isExtensible = Object.isExtensible;

  // True if Object.defineProperty works as expected. IE8 fails this test.
  var canDefineProperty = (function() {
    try {
      Object.defineProperty({}, '@', {});
      return true;
    } catch (e) {
      return false;
    }
  }());

  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
  // and avoid memory leaks from the IE cloneNode bug.
  function getIENodeHash(node) {
    if (node && node.nodeType > 0) {
      switch (node.nodeType) {
        case 1: // Element
          return node.uniqueID;
        case 9: // Document
          return node.documentElement && node.documentElement.uniqueID;
      }
    }
  }

  // If possible, use a WeakMap.
  var usingWeakMap = typeof WeakMap === 'function';
  var weakMap;
  if (usingWeakMap) {
    weakMap = new WeakMap();
  }

  var objHashUID = 0;

  var UID_HASH_KEY = '__immutablehash__';
  if (typeof Symbol === 'function') {
    UID_HASH_KEY = Symbol(UID_HASH_KEY);
  }

  var STRING_HASH_CACHE_MIN_STRLEN = 16;
  var STRING_HASH_CACHE_MAX_SIZE = 255;
  var STRING_HASH_CACHE_SIZE = 0;
  var stringHashCache = {};

  function assertNotInfinite(size) {
    invariant(
      size !== Infinity,
      'Cannot perform this action with an infinite size.'
    );
  }

  createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() :
        isMap(value) && !isOrdered(value) ? value :
        emptyMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function(map ) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function() {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function(k, notSetValue) {
      return this._root ?
        this._root.get(0, undefined, k, notSetValue) :
        notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function(k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function()  {return v});
    };

    Map.prototype.remove = function(k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function()  {return NOT_SET});
    };

    Map.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ?
        k(this) :
        this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(
        this,
        forceIterator(keyPath),
        notSetValue,
        updater
      );
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function(/*...iters*/) {
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.merge === 'function' ?
          m.merge.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(
        keyPath,
        emptyMap(),
        function(m ) {return typeof m.mergeDeep === 'function' ?
          m.mergeDeep.apply(m, iters) :
          iters[iters.length - 1]}
      );
    };

    Map.prototype.sort = function(comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function() {
      return this.__altered;
    };

    Map.prototype.__iterator = function(type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry ) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };


  function isMap(maybeMap) {
    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
  }

  Map.isMap = isMap;

  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

  var MapPrototype = Map.prototype;
  MapPrototype[IS_MAP_SENTINEL] = true;
  MapPrototype[DELETE] = MapPrototype.remove;
  MapPrototype.removeIn = MapPrototype.deleteIn;


  // #pragma Trie Nodes



    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };




    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue :
        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & (bit - 1));
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ?
        setIn(nodes, idx, newNode, isEditable) :
        spliceOut(nodes, idx, isEditable) :
        spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };




    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };




    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };




    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };



  // #pragma Iterators

  ArrayMapNode.prototype.iterate =
  HashCollisionNode.prototype.iterate = function (fn, reverse) {
    var entries = this.entries;
    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  };

  BitmapIndexedNode.prototype.iterate =
  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  };

  ValueNode.prototype.iterate = function (fn, reverse) {
    return fn(this.entry);
  };

  createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };


  function mapIteratorValue(type, entry) {
    return iteratorValue(type, entry[0], entry[1]);
  }

  function mapIteratorFrame(node, prev) {
    return {
      node: node,
      index: 0,
      __prev: prev
    };
  }

  function makeMap(size, root, ownerID, hash) {
    var map = Object.create(MapPrototype);
    map.size = size;
    map._root = root;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_MAP;
  function emptyMap() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }

  function updateMap(map, k, v) {
    var newRoot;
    var newSize;
    if (!map._root) {
      if (v === NOT_SET) {
        return map;
      }
      newSize = 1;
      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
    } else {
      var didChangeSize = MakeRef(CHANGE_LENGTH);
      var didAlter = MakeRef(DID_ALTER);
      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
      if (!didAlter.value) {
        return map;
      }
      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
    }
    if (map.__ownerID) {
      map.size = newSize;
      map._root = newRoot;
      map.__hash = undefined;
      map.__altered = true;
      return map;
    }
    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
  }

  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
    if (!node) {
      if (value === NOT_SET) {
        return node;
      }
      SetRef(didAlter);
      SetRef(didChangeSize);
      return new ValueNode(ownerID, keyHash, [key, value]);
    }
    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
  }

  function isLeafNode(node) {
    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
  }

  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
    if (node.keyHash === keyHash) {
      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
    }

    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

    var newNode;
    var nodes = idx1 === idx2 ?
      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
  }

  function createNodes(ownerID, entries, key, value) {
    if (!ownerID) {
      ownerID = new OwnerID();
    }
    var node = new ValueNode(ownerID, hash(key), [key, value]);
    for (var ii = 0; ii < entries.length; ii++) {
      var entry = entries[ii];
      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
    }
    return node;
  }

  function packNodes(ownerID, nodes, count, excluding) {
    var bitmap = 0;
    var packedII = 0;
    var packedNodes = new Array(count);
    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
      var node = nodes[ii];
      if (node !== undefined && ii !== excluding) {
        bitmap |= bit;
        packedNodes[packedII++] = node;
      }
    }
    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
  }

  function expandNodes(ownerID, nodes, bitmap, including, node) {
    var count = 0;
    var expandedNodes = new Array(SIZE);
    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
    }
    expandedNodes[including] = node;
    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
  }

  function mergeIntoMapWith(map, merger, iterables) {
    var iters = [];
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = KeyedIterable(value);
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    return mergeIntoCollectionWith(map, merger, iters);
  }

  function deepMerger(existing, value, key) {
    return existing && existing.mergeDeep && isIterable(value) ?
      existing.mergeDeep(value) :
      is(existing, value) ? existing : value;
  }

  function deepMergerWith(merger) {
    return function(existing, value, key)  {
      if (existing && existing.mergeDeepWith && isIterable(value)) {
        return existing.mergeDeepWith(merger, value);
      }
      var nextValue = merger(existing, value, key);
      return is(existing, nextValue) ? existing : nextValue;
    };
  }

  function mergeIntoCollectionWith(collection, merger, iters) {
    iters = iters.filter(function(x ) {return x.size !== 0});
    if (iters.length === 0) {
      return collection;
    }
    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
      return collection.constructor(iters[0]);
    }
    return collection.withMutations(function(collection ) {
      var mergeIntoMap = merger ?
        function(value, key)  {
          collection.update(key, NOT_SET, function(existing )
            {return existing === NOT_SET ? value : merger(existing, value, key)}
          );
        } :
        function(value, key)  {
          collection.set(key, value);
        };
      for (var ii = 0; ii < iters.length; ii++) {
        iters[ii].forEach(mergeIntoMap);
      }
    });
  }

  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
    var isNotSet = existing === NOT_SET;
    var step = keyPathIter.next();
    if (step.done) {
      var existingValue = isNotSet ? notSetValue : existing;
      var newValue = updater(existingValue);
      return newValue === existingValue ? existing : newValue;
    }
    invariant(
      isNotSet || (existing && existing.set),
      'invalid keyPath'
    );
    var key = step.value;
    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
    var nextUpdated = updateInDeepMap(
      nextExisting,
      keyPathIter,
      notSetValue,
      updater
    );
    return nextUpdated === nextExisting ? existing :
      nextUpdated === NOT_SET ? existing.remove(key) :
      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
  }

  function popCount(x) {
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0f0f0f0f;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x7f;
  }

  function setIn(array, idx, val, canEdit) {
    var newArray = canEdit ? array : arrCopy(array);
    newArray[idx] = val;
    return newArray;
  }

  function spliceIn(array, idx, val, canEdit) {
    var newLen = array.length + 1;
    if (canEdit && idx + 1 === newLen) {
      array[idx] = val;
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        newArray[ii] = val;
        after = -1;
      } else {
        newArray[ii] = array[ii + after];
      }
    }
    return newArray;
  }

  function spliceOut(array, idx, canEdit) {
    var newLen = array.length - 1;
    if (canEdit && idx === newLen) {
      array.pop();
      return array;
    }
    var newArray = new Array(newLen);
    var after = 0;
    for (var ii = 0; ii < newLen; ii++) {
      if (ii === idx) {
        after = 1;
      }
      newArray[ii] = array[ii + after];
    }
    return newArray;
  }

  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

  createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function(list ) {
        list.setSize(size);
        iter.forEach(function(v, i)  {return list.set(i, v)});
      });
    }

    List.of = function(/*...values*/) {
      return this(arguments);
    };

    List.prototype.toString = function() {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function(index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function(index) {
      return !this.has(index) ? this :
        index === 0 ? this.shift() :
        index === this.size - 1 ? this.pop() :
        this.splice(index, 1);
    };

    List.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function(/*...values*/) {
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list ) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function() {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function(/*...values*/) {
      var values = arguments;
      return this.withMutations(function(list ) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function() {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function(/*...iters*/) {
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function(/*...iters*/) {
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function(size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(
        this,
        resolveBegin(begin, size),
        resolveEnd(end, size)
      );
    };

    List.prototype.__iterator = function(type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function()  {
        var value = values();
        return value === DONE ?
          iteratorDone() :
          iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function(fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };


  function isList(maybeList) {
    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
  }

  List.isList = isList;

  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

  var ListPrototype = List.prototype;
  ListPrototype[IS_LIST_SENTINEL] = true;
  ListPrototype[DELETE] = ListPrototype.remove;
  ListPrototype.setIn = MapPrototype.setIn;
  ListPrototype.deleteIn =
  ListPrototype.removeIn = MapPrototype.removeIn;
  ListPrototype.update = MapPrototype.update;
  ListPrototype.updateIn = MapPrototype.updateIn;
  ListPrototype.mergeIn = MapPrototype.mergeIn;
  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  ListPrototype.withMutations = MapPrototype.withMutations;
  ListPrototype.asMutable = MapPrototype.asMutable;
  ListPrototype.asImmutable = MapPrototype.asImmutable;
  ListPrototype.wasAltered = MapPrototype.wasAltered;



    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = (index >>> level) & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = ((index - 1) >>> level) & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };



  var DONE = {};

  function iterateList(list, reverse) {
    var left = list._origin;
    var right = list._capacity;
    var tailPos = getTailOffset(right);
    var tail = list._tail;

    return iterateNodeOrLeaf(list._root, list._level, 0);

    function iterateNodeOrLeaf(node, level, offset) {
      return level === 0 ?
        iterateLeaf(node, offset) :
        iterateNode(node, level, offset);
    }

    function iterateLeaf(node, offset) {
      var array = offset === tailPos ? tail && tail.array : node && node.array;
      var from = offset > left ? 0 : left - offset;
      var to = right - offset;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        return array && array[idx];
      };
    }

    function iterateNode(node, level, offset) {
      var values;
      var array = node && node.array;
      var from = offset > left ? 0 : (left - offset) >> level;
      var to = ((right - offset) >> level) + 1;
      if (to > SIZE) {
        to = SIZE;
      }
      return function()  {
        do {
          if (values) {
            var value = values();
            if (value !== DONE) {
              return value;
            }
            values = null;
          }
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          values = iterateNodeOrLeaf(
            array && array[idx], level - SHIFT, offset + (idx << level)
          );
        } while (true);
      };
    }
  }

  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
    var list = Object.create(ListPrototype);
    list.size = capacity - origin;
    list._origin = origin;
    list._capacity = capacity;
    list._level = level;
    list._root = root;
    list._tail = tail;
    list.__ownerID = ownerID;
    list.__hash = hash;
    list.__altered = false;
    return list;
  }

  var EMPTY_LIST;
  function emptyList() {
    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
  }

  function updateList(list, index, value) {
    index = wrapIndex(list, index);

    if (index !== index) {
      return list;
    }

    if (index >= list.size || index < 0) {
      return list.withMutations(function(list ) {
        index < 0 ?
          setListBounds(list, index).set(0, value) :
          setListBounds(list, 0, index + 1).set(index, value);
      });
    }

    index += list._origin;

    var newTail = list._tail;
    var newRoot = list._root;
    var didAlter = MakeRef(DID_ALTER);
    if (index >= getTailOffset(list._capacity)) {
      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
    } else {
      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
    }

    if (!didAlter.value) {
      return list;
    }

    if (list.__ownerID) {
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
  }

  function updateVNode(node, ownerID, level, index, value, didAlter) {
    var idx = (index >>> level) & MASK;
    var nodeHas = node && idx < node.array.length;
    if (!nodeHas && value === undefined) {
      return node;
    }

    var newNode;

    if (level > 0) {
      var lowerNode = node && node.array[idx];
      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
      if (newLowerNode === lowerNode) {
        return node;
      }
      newNode = editableVNode(node, ownerID);
      newNode.array[idx] = newLowerNode;
      return newNode;
    }

    if (nodeHas && node.array[idx] === value) {
      return node;
    }

    SetRef(didAlter);

    newNode = editableVNode(node, ownerID);
    if (value === undefined && idx === newNode.array.length - 1) {
      newNode.array.pop();
    } else {
      newNode.array[idx] = value;
    }
    return newNode;
  }

  function editableVNode(node, ownerID) {
    if (ownerID && node && ownerID === node.ownerID) {
      return node;
    }
    return new VNode(node ? node.array.slice() : [], ownerID);
  }

  function listNodeFor(list, rawIndex) {
    if (rawIndex >= getTailOffset(list._capacity)) {
      return list._tail;
    }
    if (rawIndex < 1 << (list._level + SHIFT)) {
      var node = list._root;
      var level = list._level;
      while (node && level > 0) {
        node = node.array[(rawIndex >>> level) & MASK];
        level -= SHIFT;
      }
      return node;
    }
  }

  function setListBounds(list, begin, end) {
    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      end = end | 0;
    }
    var owner = list.__ownerID || new OwnerID();
    var oldOrigin = list._origin;
    var oldCapacity = list._capacity;
    var newOrigin = oldOrigin + begin;
    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
      return list;
    }

    // If it's going to end after it starts, it's empty.
    if (newOrigin >= newCapacity) {
      return list.clear();
    }

    var newLevel = list._level;
    var newRoot = list._root;

    // New origin might need creating a higher root.
    var offsetShift = 0;
    while (newOrigin + offsetShift < 0) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
      newLevel += SHIFT;
      offsetShift += 1 << newLevel;
    }
    if (offsetShift) {
      newOrigin += offsetShift;
      oldOrigin += offsetShift;
      newCapacity += offsetShift;
      oldCapacity += offsetShift;
    }

    var oldTailOffset = getTailOffset(oldCapacity);
    var newTailOffset = getTailOffset(newCapacity);

    // New size might need creating a higher root.
    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
      newLevel += SHIFT;
    }

    // Locate or create the new tail.
    var oldTail = list._tail;
    var newTail = newTailOffset < oldTailOffset ?
      listNodeFor(list, newCapacity - 1) :
      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

    // Merge Tail into tree.
    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
      newRoot = editableVNode(newRoot, owner);
      var node = newRoot;
      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
        var idx = (oldTailOffset >>> level) & MASK;
        node = node.array[idx] = editableVNode(node.array[idx], owner);
      }
      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
    }

    // If the size has been reduced, there's a chance the tail needs to be trimmed.
    if (newCapacity < oldCapacity) {
      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
    }

    // If the new origin is within the tail, then we do not need a root.
    if (newOrigin >= newTailOffset) {
      newOrigin -= newTailOffset;
      newCapacity -= newTailOffset;
      newLevel = SHIFT;
      newRoot = null;
      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
      offsetShift = 0;

      // Identify the new top root node of the subtree of the old root.
      while (newRoot) {
        var beginIndex = (newOrigin >>> newLevel) & MASK;
        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
          break;
        }
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot.array[beginIndex];
      }

      // Trim the new sides of the new root.
      if (newRoot && newOrigin > oldOrigin) {
        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
      }
      if (newRoot && newTailOffset < oldTailOffset) {
        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
      }
      if (offsetShift) {
        newOrigin -= offsetShift;
        newCapacity -= offsetShift;
      }
    }

    if (list.__ownerID) {
      list.size = newCapacity - newOrigin;
      list._origin = newOrigin;
      list._capacity = newCapacity;
      list._level = newLevel;
      list._root = newRoot;
      list._tail = newTail;
      list.__hash = undefined;
      list.__altered = true;
      return list;
    }
    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
  }

  function mergeIntoListWith(list, merger, iterables) {
    var iters = [];
    var maxSize = 0;
    for (var ii = 0; ii < iterables.length; ii++) {
      var value = iterables[ii];
      var iter = IndexedIterable(value);
      if (iter.size > maxSize) {
        maxSize = iter.size;
      }
      if (!isIterable(value)) {
        iter = iter.map(function(v ) {return fromJS(v)});
      }
      iters.push(iter);
    }
    if (maxSize > list.size) {
      list = list.setSize(maxSize);
    }
    return mergeIntoCollectionWith(list, merger, iters);
  }

  function getTailOffset(size) {
    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
  }

  createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() :
        isOrderedMap(value) ? value :
        emptyOrderedMap().withMutations(function(map ) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k)  {return map.set(k, v)});
        });
    }

    OrderedMap.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedMap.prototype.toString = function() {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function(k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function(k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._list.__iterate(
        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
        reverse
      );
    };

    OrderedMap.prototype.__iterator = function(type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };


  function isOrderedMap(maybeOrderedMap) {
    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
  }

  OrderedMap.isOrderedMap = isOrderedMap;

  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



  function makeOrderedMap(map, list, ownerID, hash) {
    var omap = Object.create(OrderedMap.prototype);
    omap.size = map ? map.size : 0;
    omap._map = map;
    omap._list = list;
    omap.__ownerID = ownerID;
    omap.__hash = hash;
    return omap;
  }

  var EMPTY_ORDERED_MAP;
  function emptyOrderedMap() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
  }

  function updateOrderedMap(omap, k, v) {
    var map = omap._map;
    var list = omap._list;
    var i = map.get(k);
    var has = i !== undefined;
    var newMap;
    var newList;
    if (v === NOT_SET) { // removed
      if (!has) {
        return omap;
      }
      if (list.size >= SIZE && list.size >= map.size * 2) {
        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
        if (omap.__ownerID) {
          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
        }
      } else {
        newMap = map.remove(k);
        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
      }
    } else {
      if (has) {
        if (v === list.get(i)[1]) {
          return omap;
        }
        newMap = map;
        newList = list.set(i, [k, v]);
      } else {
        newMap = map.set(k, list.size);
        newList = list.set(list.size, [k, v]);
      }
    }
    if (omap.__ownerID) {
      omap.size = newMap.size;
      omap._map = newMap;
      omap._list = newList;
      omap.__hash = undefined;
      return omap;
    }
    return makeOrderedMap(newMap, newList);
  }

  createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function(key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var ii;
      return this._iter.__iterate(
        this._useKeys ?
          function(v, k)  {return fn(v, k, this$0)} :
          ((ii = reverse ? resolveSize(this) : 0),
            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
        reverse
      );
    };

    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


  createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function(value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, iterations++, step.value, step)
      });
    };



  createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function(key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
    };

    ToSetSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        return step.done ? step :
          iteratorValue(type, step.value, step.value, step);
      });
    };



  createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._iter.__iterate(function(entry ) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(
            indexedIterable ? entry.get(1) : entry[1],
            indexedIterable ? entry.get(0) : entry[0],
            this$0
          );
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(
              type,
              indexedIterable ? entry.get(0) : entry[0],
              indexedIterable ? entry.get(1) : entry[1],
              step
            );
          }
        }
      });
    };


  ToIndexedSequence.prototype.cacheResult =
  ToKeyedSequence.prototype.cacheResult =
  ToSetSequence.prototype.cacheResult =
  FromEntriesSequence.prototype.cacheResult =
    cacheResultThrough;


  function flipFactory(iterable) {
    var flipSequence = makeSequence(iterable);
    flipSequence._iter = iterable;
    flipSequence.size = iterable.size;
    flipSequence.flip = function()  {return iterable};
    flipSequence.reverse = function () {
      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
      reversedSequence.flip = function()  {return iterable.reverse()};
      return reversedSequence;
    };
    flipSequence.has = function(key ) {return iterable.includes(key)};
    flipSequence.includes = function(key ) {return iterable.has(key)};
    flipSequence.cacheResult = cacheResultThrough;
    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
    };
    flipSequence.__iteratorUncached = function(type, reverse) {
      if (type === ITERATE_ENTRIES) {
        var iterator = iterable.__iterator(type, reverse);
        return new Iterator(function()  {
          var step = iterator.next();
          if (!step.done) {
            var k = step.value[0];
            step.value[0] = step.value[1];
            step.value[1] = k;
          }
          return step;
        });
      }
      return iterable.__iterator(
        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
        reverse
      );
    };
    return flipSequence;
  }


  function mapFactory(iterable, mapper, context) {
    var mappedSequence = makeSequence(iterable);
    mappedSequence.size = iterable.size;
    mappedSequence.has = function(key ) {return iterable.has(key)};
    mappedSequence.get = function(key, notSetValue)  {
      var v = iterable.get(key, NOT_SET);
      return v === NOT_SET ?
        notSetValue :
        mapper.call(context, v, key, iterable);
    };
    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(
        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
        reverse
      );
    };
    mappedSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      return new Iterator(function()  {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        return iteratorValue(
          type,
          key,
          mapper.call(context, entry[1], key, iterable),
          step
        );
      });
    };
    return mappedSequence;
  }


  function reverseFactory(iterable, useKeys) {
    var reversedSequence = makeSequence(iterable);
    reversedSequence._iter = iterable;
    reversedSequence.size = iterable.size;
    reversedSequence.reverse = function()  {return iterable};
    if (iterable.flip) {
      reversedSequence.flip = function () {
        var flipSequence = flipFactory(iterable);
        flipSequence.reverse = function()  {return iterable.flip()};
        return flipSequence;
      };
    }
    reversedSequence.get = function(key, notSetValue) 
      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
    reversedSequence.has = function(key )
      {return iterable.has(useKeys ? key : -1 - key)};
    reversedSequence.includes = function(value ) {return iterable.includes(value)};
    reversedSequence.cacheResult = cacheResultThrough;
    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
    };
    reversedSequence.__iterator =
      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
    return reversedSequence;
  }


  function filterFactory(iterable, predicate, context, useKeys) {
    var filterSequence = makeSequence(iterable);
    if (useKeys) {
      filterSequence.has = function(key ) {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
      };
      filterSequence.get = function(key, notSetValue)  {
        var v = iterable.get(key, NOT_SET);
        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
          v : notSetValue;
      };
    }
    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      }, reverse);
      return iterations;
    };
    filterSequence.__iteratorUncached = function (type, reverse) {
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterations = 0;
      return new Iterator(function()  {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          var value = entry[1];
          if (predicate.call(context, value, key, iterable)) {
            return iteratorValue(type, useKeys ? key : iterations++, value, step);
          }
        }
      });
    };
    return filterSequence;
  }


  function countByFactory(iterable, grouper, context) {
    var groups = Map().asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        0,
        function(a ) {return a + 1}
      );
    });
    return groups.asImmutable();
  }


  function groupByFactory(iterable, grouper, context) {
    var isKeyedIter = isKeyed(iterable);
    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
    iterable.__iterate(function(v, k)  {
      groups.update(
        grouper.call(context, v, k, iterable),
        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
      );
    });
    var coerce = iterableClass(iterable);
    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
  }


  function sliceFactory(iterable, begin, end, useKeys) {
    var originalSize = iterable.size;

    // Sanitize begin & end using this shorthand for ToInt32(argument)
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
    if (begin !== undefined) {
      begin = begin | 0;
    }
    if (end !== undefined) {
      if (end === Infinity) {
        end = originalSize;
      } else {
        end = end | 0;
      }
    }

    if (wholeSlice(begin, end, originalSize)) {
      return iterable;
    }

    var resolvedBegin = resolveBegin(begin, originalSize);
    var resolvedEnd = resolveEnd(end, originalSize);

    // begin or end will be NaN if they were provided as negative numbers and
    // this iterable's size is unknown. In that case, cache first so there is
    // a known size and these do not resolve to NaN.
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
    }

    // Note: resolvedEnd is undefined when the original sequence's length is
    // unknown and this slice did not supply an end and should contain all
    // elements after resolvedBegin.
    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
    var resolvedSize = resolvedEnd - resolvedBegin;
    var sliceSize;
    if (resolvedSize === resolvedSize) {
      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
    }

    var sliceSeq = makeSequence(iterable);

    // If iterable.size is undefined, the size of the realized sliceSeq is
    // unknown at this point unless the number of items to slice is 0
    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
      sliceSeq.get = function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index >= 0 && index < sliceSize ?
          iterable.get(index + resolvedBegin, notSetValue) :
          notSetValue;
      };
    }

    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (sliceSize === 0) {
        return 0;
      }
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var skipped = 0;
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k)  {
        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
                 iterations !== sliceSize;
        }
      });
      return iterations;
    };

    sliceSeq.__iteratorUncached = function(type, reverse) {
      if (sliceSize !== 0 && reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      // Don't bother instantiating parent iterator if taking 0.
      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
      var skipped = 0;
      var iterations = 0;
      return new Iterator(function()  {
        while (skipped++ < resolvedBegin) {
          iterator.next();
        }
        if (++iterations > sliceSize) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (useKeys || type === ITERATE_VALUES) {
          return step;
        } else if (type === ITERATE_KEYS) {
          return iteratorValue(type, iterations - 1, undefined, step);
        } else {
          return iteratorValue(type, iterations - 1, step.value[1], step);
        }
      });
    };

    return sliceSeq;
  }


  function takeWhileFactory(iterable, predicate, context) {
    var takeSequence = makeSequence(iterable);
    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterations = 0;
      iterable.__iterate(function(v, k, c) 
        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
      );
      return iterations;
    };
    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var iterating = true;
      return new Iterator(function()  {
        if (!iterating) {
          return iteratorDone();
        }
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var k = entry[0];
        var v = entry[1];
        if (!predicate.call(context, v, k, this$0)) {
          iterating = false;
          return iteratorDone();
        }
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return takeSequence;
  }


  function skipWhileFactory(iterable, predicate, context, useKeys) {
    var skipSequence = makeSequence(iterable);
    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var isSkipping = true;
      var iterations = 0;
      iterable.__iterate(function(v, k, c)  {
        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
          iterations++;
          return fn(v, useKeys ? k : iterations - 1, this$0);
        }
      });
      return iterations;
    };
    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
      var skipping = true;
      var iterations = 0;
      return new Iterator(function()  {
        var step, k, v;
        do {
          step = iterator.next();
          if (step.done) {
            if (useKeys || type === ITERATE_VALUES) {
              return step;
            } else if (type === ITERATE_KEYS) {
              return iteratorValue(type, iterations++, undefined, step);
            } else {
              return iteratorValue(type, iterations++, step.value[1], step);
            }
          }
          var entry = step.value;
          k = entry[0];
          v = entry[1];
          skipping && (skipping = predicate.call(context, v, k, this$0));
        } while (skipping);
        return type === ITERATE_ENTRIES ? step :
          iteratorValue(type, k, v, step);
      });
    };
    return skipSequence;
  }


  function concatFactory(iterable, values) {
    var isKeyedIterable = isKeyed(iterable);
    var iters = [iterable].concat(values).map(function(v ) {
      if (!isIterable(v)) {
        v = isKeyedIterable ?
          keyedSeqFromValue(v) :
          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedIterable) {
        v = KeyedIterable(v);
      }
      return v;
    }).filter(function(v ) {return v.size !== 0});

    if (iters.length === 0) {
      return iterable;
    }

    if (iters.length === 1) {
      var singleton = iters[0];
      if (singleton === iterable ||
          isKeyedIterable && isKeyed(singleton) ||
          isIndexed(iterable) && isIndexed(singleton)) {
        return singleton;
      }
    }

    var concatSeq = new ArraySeq(iters);
    if (isKeyedIterable) {
      concatSeq = concatSeq.toKeyedSeq();
    } else if (!isIndexed(iterable)) {
      concatSeq = concatSeq.toSetSeq();
    }
    concatSeq = concatSeq.flatten(true);
    concatSeq.size = iters.reduce(
      function(sum, seq)  {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      },
      0
    );
    return concatSeq;
  }


  function flattenFactory(iterable, depth, useKeys) {
    var flatSequence = makeSequence(iterable);
    flatSequence.__iterateUncached = function(fn, reverse) {
      var iterations = 0;
      var stopped = false;
      function flatDeep(iter, currentDepth) {var this$0 = this;
        iter.__iterate(function(v, k)  {
          if ((!depth || currentDepth < depth) && isIterable(v)) {
            flatDeep(v, currentDepth + 1);
          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
            stopped = true;
          }
          return !stopped;
        }, reverse);
      }
      flatDeep(iterable, 0);
      return iterations;
    };
    flatSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(type, reverse);
      var stack = [];
      var iterations = 0;
      return new Iterator(function()  {
        while (iterator) {
          var step = iterator.next();
          if (step.done !== false) {
            iterator = stack.pop();
            continue;
          }
          var v = step.value;
          if (type === ITERATE_ENTRIES) {
            v = v[1];
          }
          if ((!depth || stack.length < depth) && isIterable(v)) {
            stack.push(iterator);
            iterator = v.__iterator(type, reverse);
          } else {
            return useKeys ? step : iteratorValue(type, iterations++, v, step);
          }
        }
        return iteratorDone();
      });
    };
    return flatSequence;
  }


  function flatMapFactory(iterable, mapper, context) {
    var coerce = iterableClass(iterable);
    return iterable.toSeq().map(
      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
    ).flatten(true);
  }


  function interposeFactory(iterable, separator) {
    var interposedSequence = makeSequence(iterable);
    interposedSequence.size = iterable.size && iterable.size * 2 -1;
    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
      var iterations = 0;
      iterable.__iterate(function(v, k) 
        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
        fn(v, iterations++, this$0) !== false},
        reverse
      );
      return iterations;
    };
    interposedSequence.__iteratorUncached = function(type, reverse) {
      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      var step;
      return new Iterator(function()  {
        if (!step || iterations % 2) {
          step = iterator.next();
          if (step.done) {
            return step;
          }
        }
        return iterations % 2 ?
          iteratorValue(type, iterations++, separator) :
          iteratorValue(type, iterations++, step.value, step);
      });
    };
    return interposedSequence;
  }


  function sortFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    var isKeyedIterable = isKeyed(iterable);
    var index = 0;
    var entries = iterable.toSeq().map(
      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
    ).toArray();
    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
      isKeyedIterable ?
      function(v, i)  { entries[i].length = 2; } :
      function(v, i)  { entries[i] = v[1]; }
    );
    return isKeyedIterable ? KeyedSeq(entries) :
      isIndexed(iterable) ? IndexedSeq(entries) :
      SetSeq(entries);
  }


  function maxFactory(iterable, comparator, mapper) {
    if (!comparator) {
      comparator = defaultComparator;
    }
    if (mapper) {
      var entry = iterable.toSeq()
        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
      return entry && entry[0];
    } else {
      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
    }
  }

  function maxCompare(comparator, a, b) {
    var comp = comparator(b, a);
    // b is considered the new max if the comparator declares them equal, but
    // they are not equal and b is in fact a nullish value.
    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
  }


  function zipWithFactory(keyIter, zipper, iters) {
    var zipSequence = makeSequence(keyIter);
    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
    // Note: this a generic base implementation of __iterate in terms of
    // __iterator which may be more generically useful in the future.
    zipSequence.__iterate = function(fn, reverse) {
      /* generic:
      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        iterations++;
        if (fn(step.value[1], step.value[0], this) === false) {
          break;
        }
      }
      return iterations;
      */
      // indexed:
      var iterator = this.__iterator(ITERATE_VALUES, reverse);
      var step;
      var iterations = 0;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    zipSequence.__iteratorUncached = function(type, reverse) {
      var iterators = iters.map(function(i )
        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
      );
      var iterations = 0;
      var isDone = false;
      return new Iterator(function()  {
        var steps;
        if (!isDone) {
          steps = iterators.map(function(i ) {return i.next()});
          isDone = steps.some(function(s ) {return s.done});
        }
        if (isDone) {
          return iteratorDone();
        }
        return iteratorValue(
          type,
          iterations++,
          zipper.apply(null, steps.map(function(s ) {return s.value}))
        );
      });
    };
    return zipSequence
  }


  // #pragma Helper Functions

  function reify(iter, seq) {
    return isSeq(iter) ? seq : iter.constructor(seq);
  }

  function validateEntry(entry) {
    if (entry !== Object(entry)) {
      throw new TypeError('Expected [K, V] tuple: ' + entry);
    }
  }

  function resolveSize(iter) {
    assertNotInfinite(iter.size);
    return ensureSize(iter);
  }

  function iterableClass(iterable) {
    return isKeyed(iterable) ? KeyedIterable :
      isIndexed(iterable) ? IndexedIterable :
      SetIterable;
  }

  function makeSequence(iterable) {
    return Object.create(
      (
        isKeyed(iterable) ? KeyedSeq :
        isIndexed(iterable) ? IndexedSeq :
        SetSeq
      ).prototype
    );
  }

  function cacheResultThrough() {
    if (this._iter.cacheResult) {
      this._iter.cacheResult();
      this.size = this._iter.size;
      return this;
    } else {
      return Seq.prototype.cacheResult.call(this);
    }
  }

  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  function forceIterator(keyPath) {
    var iter = getIterator(keyPath);
    if (!iter) {
      // Array might not be iterable in this environment, so we need a fallback
      // to our wrapped type.
      if (!isArrayLike(keyPath)) {
        throw new TypeError('Expected iterable or array-like: ' + keyPath);
      }
      iter = getIterator(Iterable(keyPath));
    }
    return iter;
  }

  createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function() {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };


  var RecordPrototype = Record.prototype;
  RecordPrototype[DELETE] = RecordPrototype.remove;
  RecordPrototype.deleteIn =
  RecordPrototype.removeIn = MapPrototype.removeIn;
  RecordPrototype.merge = MapPrototype.merge;
  RecordPrototype.mergeWith = MapPrototype.mergeWith;
  RecordPrototype.mergeIn = MapPrototype.mergeIn;
  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
  RecordPrototype.setIn = MapPrototype.setIn;
  RecordPrototype.update = MapPrototype.update;
  RecordPrototype.updateIn = MapPrototype.updateIn;
  RecordPrototype.withMutations = MapPrototype.withMutations;
  RecordPrototype.asMutable = MapPrototype.asMutable;
  RecordPrototype.asImmutable = MapPrototype.asImmutable;


  function makeRecord(likeRecord, map, ownerID) {
    var record = Object.create(Object.getPrototypeOf(likeRecord));
    record._map = map;
    record.__ownerID = ownerID;
    return record;
  }

  function recordName(record) {
    return record._name || record.constructor.name || 'Record';
  }

  function setProps(prototype, names) {
    try {
      names.forEach(setProp.bind(undefined, prototype));
    } catch (error) {
      // Object.defineProperty failed. Probably IE8.
    }
  }

  function setProp(prototype, name) {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      }
    });
  }

  createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() :
        isSet(value) && !isOrdered(value) ? value :
        emptySet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    Set.of = function(/*...values*/) {
      return this(arguments);
    };

    Set.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function() {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function(value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function(value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function(value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function() {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x ) {return x.size !== 0});
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set ) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
        }
      });
    };

    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (!iters.every(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter ) {return SetIterable(iter)});
      var originalSet = this;
      return this.withMutations(function(set ) {
        originalSet.forEach(function(value ) {
          if (iters.some(function(iter ) {return iter.includes(value)})) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function(comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function(mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
    };

    Set.prototype.__iterator = function(type, reverse) {
      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };


  function isSet(maybeSet) {
    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
  }

  Set.isSet = isSet;

  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

  var SetPrototype = Set.prototype;
  SetPrototype[IS_SET_SENTINEL] = true;
  SetPrototype[DELETE] = SetPrototype.remove;
  SetPrototype.mergeDeep = SetPrototype.merge;
  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
  SetPrototype.withMutations = MapPrototype.withMutations;
  SetPrototype.asMutable = MapPrototype.asMutable;
  SetPrototype.asImmutable = MapPrototype.asImmutable;

  SetPrototype.__empty = emptySet;
  SetPrototype.__make = makeSet;

  function updateSet(set, newMap) {
    if (set.__ownerID) {
      set.size = newMap.size;
      set._map = newMap;
      return set;
    }
    return newMap === set._map ? set :
      newMap.size === 0 ? set.__empty() :
      set.__make(newMap);
  }

  function makeSet(map, ownerID) {
    var set = Object.create(SetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_SET;
  function emptySet() {
    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
  }

  createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() :
        isOrderedSet(value) ? value :
        emptyOrderedSet().withMutations(function(set ) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v ) {return set.add(v)});
        });
    }

    OrderedSet.of = function(/*...values*/) {
      return this(arguments);
    };

    OrderedSet.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function() {
      return this.__toString('OrderedSet {', '}');
    };


  function isOrderedSet(maybeOrderedSet) {
    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
  }

  OrderedSet.isOrderedSet = isOrderedSet;

  var OrderedSetPrototype = OrderedSet.prototype;
  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

  OrderedSetPrototype.__empty = emptyOrderedSet;
  OrderedSetPrototype.__make = makeOrderedSet;

  function makeOrderedSet(map, ownerID) {
    var set = Object.create(OrderedSetPrototype);
    set.size = map ? map.size : 0;
    set._map = map;
    set.__ownerID = ownerID;
    return set;
  }

  var EMPTY_ORDERED_SET;
  function emptyOrderedSet() {
    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
  }

  createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() :
        isStack(value) ? value :
        emptyStack().unshiftAll(value);
    }

    Stack.of = function(/*...values*/) {
      return this(arguments);
    };

    Stack.prototype.toString = function() {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function() {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function(/*...values*/) {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value ) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function() {
      return this.slice(1);
    };

    Stack.prototype.unshift = function(/*...values*/) {
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function(begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function(fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function(type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function()  {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };


  function isStack(maybeStack) {
    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
  }

  Stack.isStack = isStack;

  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

  var StackPrototype = Stack.prototype;
  StackPrototype[IS_STACK_SENTINEL] = true;
  StackPrototype.withMutations = MapPrototype.withMutations;
  StackPrototype.asMutable = MapPrototype.asMutable;
  StackPrototype.asImmutable = MapPrototype.asImmutable;
  StackPrototype.wasAltered = MapPrototype.wasAltered;


  function makeStack(size, head, ownerID, hash) {
    var map = Object.create(StackPrototype);
    map.size = size;
    map._head = head;
    map.__ownerID = ownerID;
    map.__hash = hash;
    map.__altered = false;
    return map;
  }

  var EMPTY_STACK;
  function emptyStack() {
    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
  }

  /**
   * Contributes additional methods to a constructor
   */
  function mixin(ctor, methods) {
    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
    Object.keys(methods).forEach(keyCopier);
    Object.getOwnPropertySymbols &&
      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
    return ctor;
  }

  Iterable.Iterator = Iterator;

  mixin(Iterable, {

    // ### Conversion to other types

    toArray: function() {
      assertNotInfinite(this.size);
      var array = new Array(this.size || 0);
      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
      return array;
    },

    toIndexedSeq: function() {
      return new ToIndexedSequence(this);
    },

    toJS: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
      ).__toJS();
    },

    toJSON: function() {
      return this.toSeq().map(
        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
      ).__toJS();
    },

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, true);
    },

    toMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return Map(this.toKeyedSeq());
    },

    toObject: function() {
      assertNotInfinite(this.size);
      var object = {};
      this.__iterate(function(v, k)  { object[k] = v; });
      return object;
    },

    toOrderedMap: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedMap(this.toKeyedSeq());
    },

    toOrderedSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
    },

    toSet: function() {
      // Use Late Binding here to solve the circular dependency.
      return Set(isKeyed(this) ? this.valueSeq() : this);
    },

    toSetSeq: function() {
      return new ToSetSequence(this);
    },

    toSeq: function() {
      return isIndexed(this) ? this.toIndexedSeq() :
        isKeyed(this) ? this.toKeyedSeq() :
        this.toSetSeq();
    },

    toStack: function() {
      // Use Late Binding here to solve the circular dependency.
      return Stack(isKeyed(this) ? this.valueSeq() : this);
    },

    toList: function() {
      // Use Late Binding here to solve the circular dependency.
      return List(isKeyed(this) ? this.valueSeq() : this);
    },


    // ### Common JavaScript methods and properties

    toString: function() {
      return '[Iterable]';
    },

    __toString: function(head, tail) {
      if (this.size === 0) {
        return head + tail;
      }
      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    concat: function() {var values = SLICE$0.call(arguments, 0);
      return reify(this, concatFactory(this, values));
    },

    includes: function(searchValue) {
      return this.some(function(value ) {return is(value, searchValue)});
    },

    entries: function() {
      return this.__iterator(ITERATE_ENTRIES);
    },

    every: function(predicate, context) {
      assertNotInfinite(this.size);
      var returnValue = true;
      this.__iterate(function(v, k, c)  {
        if (!predicate.call(context, v, k, c)) {
          returnValue = false;
          return false;
        }
      });
      return returnValue;
    },

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, true));
    },

    find: function(predicate, context, notSetValue) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[1] : notSetValue;
    },

    forEach: function(sideEffect, context) {
      assertNotInfinite(this.size);
      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
    },

    join: function(separator) {
      assertNotInfinite(this.size);
      separator = separator !== undefined ? '' + separator : ',';
      var joined = '';
      var isFirst = true;
      this.__iterate(function(v ) {
        isFirst ? (isFirst = false) : (joined += separator);
        joined += v !== null && v !== undefined ? v.toString() : '';
      });
      return joined;
    },

    keys: function() {
      return this.__iterator(ITERATE_KEYS);
    },

    map: function(mapper, context) {
      return reify(this, mapFactory(this, mapper, context));
    },

    reduce: function(reducer, initialReduction, context) {
      assertNotInfinite(this.size);
      var reduction;
      var useFirst;
      if (arguments.length < 2) {
        useFirst = true;
      } else {
        reduction = initialReduction;
      }
      this.__iterate(function(v, k, c)  {
        if (useFirst) {
          useFirst = false;
          reduction = v;
        } else {
          reduction = reducer.call(context, reduction, v, k, c);
        }
      });
      return reduction;
    },

    reduceRight: function(reducer, initialReduction, context) {
      var reversed = this.toKeyedSeq().reverse();
      return reversed.reduce.apply(reversed, arguments);
    },

    reverse: function() {
      return reify(this, reverseFactory(this, true));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, true));
    },

    some: function(predicate, context) {
      return !this.every(not(predicate), context);
    },

    sort: function(comparator) {
      return reify(this, sortFactory(this, comparator));
    },

    values: function() {
      return this.__iterator(ITERATE_VALUES);
    },


    // ### More sequential methods

    butLast: function() {
      return this.slice(0, -1);
    },

    isEmpty: function() {
      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
    },

    count: function(predicate, context) {
      return ensureSize(
        predicate ? this.toSeq().filter(predicate, context) : this
      );
    },

    countBy: function(grouper, context) {
      return countByFactory(this, grouper, context);
    },

    equals: function(other) {
      return deepEqual(this, other);
    },

    entrySeq: function() {
      var iterable = this;
      if (iterable._cache) {
        // We cache as an entries array, so we can just return the cache!
        return new ArraySeq(iterable._cache);
      }
      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
      return entriesSequence;
    },

    filterNot: function(predicate, context) {
      return this.filter(not(predicate), context);
    },

    findEntry: function(predicate, context, notSetValue) {
      var found = notSetValue;
      this.__iterate(function(v, k, c)  {
        if (predicate.call(context, v, k, c)) {
          found = [k, v];
          return false;
        }
      });
      return found;
    },

    findKey: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry && entry[0];
    },

    findLast: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
    },

    findLastEntry: function(predicate, context, notSetValue) {
      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
    },

    findLastKey: function(predicate, context) {
      return this.toKeyedSeq().reverse().findKey(predicate, context);
    },

    first: function() {
      return this.find(returnTrue);
    },

    flatMap: function(mapper, context) {
      return reify(this, flatMapFactory(this, mapper, context));
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, true));
    },

    fromEntrySeq: function() {
      return new FromEntriesSequence(this);
    },

    get: function(searchKey, notSetValue) {
      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
    },

    getIn: function(searchKeyPath, notSetValue) {
      var nested = this;
      // Note: in an ES6 environment, we would prefer:
      // for (var key of searchKeyPath) {
      var iter = forceIterator(searchKeyPath);
      var step;
      while (!(step = iter.next()).done) {
        var key = step.value;
        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
        if (nested === NOT_SET) {
          return notSetValue;
        }
      }
      return nested;
    },

    groupBy: function(grouper, context) {
      return groupByFactory(this, grouper, context);
    },

    has: function(searchKey) {
      return this.get(searchKey, NOT_SET) !== NOT_SET;
    },

    hasIn: function(searchKeyPath) {
      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
    },

    isSubset: function(iter) {
      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
      return this.every(function(value ) {return iter.includes(value)});
    },

    isSuperset: function(iter) {
      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
      return iter.isSubset(this);
    },

    keyOf: function(searchValue) {
      return this.findKey(function(value ) {return is(value, searchValue)});
    },

    keySeq: function() {
      return this.toSeq().map(keyMapper).toIndexedSeq();
    },

    last: function() {
      return this.toSeq().reverse().first();
    },

    lastKeyOf: function(searchValue) {
      return this.toKeyedSeq().reverse().keyOf(searchValue);
    },

    max: function(comparator) {
      return maxFactory(this, comparator);
    },

    maxBy: function(mapper, comparator) {
      return maxFactory(this, comparator, mapper);
    },

    min: function(comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
    },

    minBy: function(mapper, comparator) {
      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
    },

    rest: function() {
      return this.slice(1);
    },

    skip: function(amount) {
      return this.slice(Math.max(0, amount));
    },

    skipLast: function(amount) {
      return reify(this, this.toSeq().reverse().skip(amount).reverse());
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, true));
    },

    skipUntil: function(predicate, context) {
      return this.skipWhile(not(predicate), context);
    },

    sortBy: function(mapper, comparator) {
      return reify(this, sortFactory(this, comparator, mapper));
    },

    take: function(amount) {
      return this.slice(0, Math.max(0, amount));
    },

    takeLast: function(amount) {
      return reify(this, this.toSeq().reverse().take(amount).reverse());
    },

    takeWhile: function(predicate, context) {
      return reify(this, takeWhileFactory(this, predicate, context));
    },

    takeUntil: function(predicate, context) {
      return this.takeWhile(not(predicate), context);
    },

    valueSeq: function() {
      return this.toIndexedSeq();
    },


    // ### Hashable Object

    hashCode: function() {
      return this.__hash || (this.__hash = hashIterable(this));
    }


    // ### Internal

    // abstract __iterate(fn, reverse)

    // abstract __iterator(type, reverse)
  });

  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

  var IterablePrototype = Iterable.prototype;
  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
  IterablePrototype.__toJS = IterablePrototype.toArray;
  IterablePrototype.__toStringMapper = quoteString;
  IterablePrototype.inspect =
  IterablePrototype.toSource = function() { return this.toString(); };
  IterablePrototype.chain = IterablePrototype.flatMap;
  IterablePrototype.contains = IterablePrototype.includes;

  mixin(KeyedIterable, {

    // ### More sequential methods

    flip: function() {
      return reify(this, flipFactory(this));
    },

    mapEntries: function(mapper, context) {var this$0 = this;
      var iterations = 0;
      return reify(this,
        this.toSeq().map(
          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
        ).fromEntrySeq()
      );
    },

    mapKeys: function(mapper, context) {var this$0 = this;
      return reify(this,
        this.toSeq().flip().map(
          function(k, v)  {return mapper.call(context, k, v, this$0)}
        ).flip()
      );
    }

  });

  var KeyedIterablePrototype = KeyedIterable.prototype;
  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



  mixin(IndexedIterable, {

    // ### Conversion to other types

    toKeyedSeq: function() {
      return new ToKeyedSequence(this, false);
    },


    // ### ES6 Collection methods (ES6 Array and Map)

    filter: function(predicate, context) {
      return reify(this, filterFactory(this, predicate, context, false));
    },

    findIndex: function(predicate, context) {
      var entry = this.findEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    indexOf: function(searchValue) {
      var key = this.keyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    lastIndexOf: function(searchValue) {
      var key = this.lastKeyOf(searchValue);
      return key === undefined ? -1 : key;
    },

    reverse: function() {
      return reify(this, reverseFactory(this, false));
    },

    slice: function(begin, end) {
      return reify(this, sliceFactory(this, begin, end, false));
    },

    splice: function(index, removeNum /*, ...values*/) {
      var numArgs = arguments.length;
      removeNum = Math.max(removeNum | 0, 0);
      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
        return this;
      }
      // If index is negative, it should resolve relative to the size of the
      // collection. However size may be expensive to compute if not cached, so
      // only call count() if the number is in fact negative.
      index = resolveBegin(index, index < 0 ? this.count() : this.size);
      var spliced = this.slice(0, index);
      return reify(
        this,
        numArgs === 1 ?
          spliced :
          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
      );
    },


    // ### More collection methods

    findLastIndex: function(predicate, context) {
      var entry = this.findLastEntry(predicate, context);
      return entry ? entry[0] : -1;
    },

    first: function() {
      return this.get(0);
    },

    flatten: function(depth) {
      return reify(this, flattenFactory(this, depth, false));
    },

    get: function(index, notSetValue) {
      index = wrapIndex(this, index);
      return (index < 0 || (this.size === Infinity ||
          (this.size !== undefined && index > this.size))) ?
        notSetValue :
        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
    },

    has: function(index) {
      index = wrapIndex(this, index);
      return index >= 0 && (this.size !== undefined ?
        this.size === Infinity || index < this.size :
        this.indexOf(index) !== -1
      );
    },

    interpose: function(separator) {
      return reify(this, interposeFactory(this, separator));
    },

    interleave: function(/*...iterables*/) {
      var iterables = [this].concat(arrCopy(arguments));
      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
      var interleaved = zipped.flatten(true);
      if (zipped.size) {
        interleaved.size = zipped.size * iterables.length;
      }
      return reify(this, interleaved);
    },

    keySeq: function() {
      return Range(0, this.size);
    },

    last: function() {
      return this.get(-1);
    },

    skipWhile: function(predicate, context) {
      return reify(this, skipWhileFactory(this, predicate, context, false));
    },

    zip: function(/*, ...iterables */) {
      var iterables = [this].concat(arrCopy(arguments));
      return reify(this, zipWithFactory(this, defaultZipper, iterables));
    },

    zipWith: function(zipper/*, ...iterables */) {
      var iterables = arrCopy(arguments);
      iterables[0] = this;
      return reify(this, zipWithFactory(this, zipper, iterables));
    }

  });

  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



  mixin(SetIterable, {

    // ### ES6 Collection methods (ES6 Array and Map)

    get: function(value, notSetValue) {
      return this.has(value) ? value : notSetValue;
    },

    includes: function(value) {
      return this.has(value);
    },


    // ### More sequential methods

    keySeq: function() {
      return this.valueSeq();
    }

  });

  SetIterable.prototype.has = IterablePrototype.includes;
  SetIterable.prototype.contains = SetIterable.prototype.includes;


  // Mixin subclasses

  mixin(KeyedSeq, KeyedIterable.prototype);
  mixin(IndexedSeq, IndexedIterable.prototype);
  mixin(SetSeq, SetIterable.prototype);

  mixin(KeyedCollection, KeyedIterable.prototype);
  mixin(IndexedCollection, IndexedIterable.prototype);
  mixin(SetCollection, SetIterable.prototype);


  // #pragma Helper functions

  function keyMapper(v, k) {
    return k;
  }

  function entryMapper(v, k) {
    return [k, v];
  }

  function not(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    }
  }

  function neg(predicate) {
    return function() {
      return -predicate.apply(this, arguments);
    }
  }

  function quoteString(value) {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  }

  function defaultZipper() {
    return arrCopy(arguments);
  }

  function defaultNegComparator(a, b) {
    return a < b ? 1 : a > b ? -1 : 0;
  }

  function hashIterable(iterable) {
    if (iterable.size === Infinity) {
      return 0;
    }
    var ordered = isOrdered(iterable);
    var keyed = isKeyed(iterable);
    var h = ordered ? 1 : 0;
    var size = iterable.__iterate(
      keyed ?
        ordered ?
          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
        ordered ?
          function(v ) { h = 31 * h + hash(v) | 0; } :
          function(v ) { h = h + hash(v) | 0; }
    );
    return murmurHashOfSize(size, h);
  }

  function murmurHashOfSize(size, h) {
    h = imul(h, 0xCC9E2D51);
    h = imul(h << 15 | h >>> -15, 0x1B873593);
    h = imul(h << 13 | h >>> -13, 5);
    h = (h + 0xE6546B64 | 0) ^ size;
    h = imul(h ^ h >>> 16, 0x85EBCA6B);
    h = imul(h ^ h >>> 13, 0xC2B2AE35);
    h = smi(h ^ h >>> 16);
    return h;
  }

  function hashMerge(a, b) {
    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
  }

  var Immutable = {

    Iterable: Iterable,

    Seq: Seq,
    Collection: Collection,
    Map: Map,
    OrderedMap: OrderedMap,
    List: List,
    Stack: Stack,
    Set: Set,
    OrderedSet: OrderedSet,

    Record: Record,
    Range: Range,
    Repeat: Repeat,

    is: is,
    fromJS: fromJS

  };

  return Immutable;

}));
});

var immutable_1 = immutable$1.fromJS;
var immutable_2 = immutable$1.Map;

var createState = function () {
    return immutable_2();
};
var isValueExist = function (val) {
    return val !== void 0;
};

var ESide;
(function (ESide) {
    ESide[ESide["NONE"] = 0] = "NONE";
    ESide[ESide["BOTH"] = 1] = "BOTH";
    ESide[ESide["BACK"] = 2] = "BACK";
    ESide[ESide["FRONT"] = 3] = "FRONT";
})(ESide || (ESide = {}));

var EWebGLVersion;
(function (EWebGLVersion) {
    EWebGLVersion[EWebGLVersion["WEBGL1"] = 0] = "WEBGL1";
    EWebGLVersion[EWebGLVersion["WEBGL2"] = 1] = "WEBGL2";
})(EWebGLVersion || (EWebGLVersion = {}));

var isWebgl1 = function (WebGLDetectData) { return WebGLDetectData.version === EWebGLVersion.WEBGL1; };
var isWebgl2 = function (WebGLDetectData) { return WebGLDetectData.version === EWebGLVersion.WEBGL2; };

var getGL$1 = function (DeviceManagerDataFromSystem, state) {
    return DeviceManagerDataFromSystem.gl;
};
var setGL$1 = curry(function (gl, DeviceManagerDataFromSystem, state) {
    DeviceManagerDataFromSystem.gl = gl;
    return state;
});
var setContextConfig$1 = curry(function (contextConfig, state) {
    return state.setIn(["DeviceManager", "contextConfig"], contextConfig);
});
var setPixelRatio$1 = curry(function (pixelRatio, state) {
    if (pixelRatio === null) {
        return state;
    }
    return state.setIn(["DeviceManager", "pixelRatio"], pixelRatio);
});
var getViewport$1 = function (state) {
    return state.getIn(["DeviceManager", "viewport"]);
};
var setViewportToState$1 = function (x, y, width, height, state) {
    return state.setIn(["DeviceManager", "viewport"], RectRegion.create(x, y, width, height));
};
var setCanvasPixelRatio$1 = curry(function (useDevicePixelRatio, canvas) {
    return IO.of(function () {
        var pixelRatio = getRootProperty("devicePixelRatio").run();
        canvas.width = Math.round(canvas.width * pixelRatio);
        canvas.height = Math.round(canvas.height * pixelRatio);
        return pixelRatio;
    });
});
var setViewportOfGL$1 = curry(function (DeviceManagerDataFromSystem, state, _a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    return IO.of(function () {
        var gl = getGL$1(DeviceManagerDataFromSystem, state), viewport = getViewport$1(state);
        if (isValueExist(viewport) && viewport.x === x && viewport.y === y && viewport.width === width && viewport.height === height) {
            return state;
        }
        gl.viewport(x, y, width, height);
        return setViewportToState$1(x, y, width, height, state);
    });
});
var _setBodyByScreenSize = function (screenSize, DomQuery) {
    return IO.of(function () {
        if (screenSize === EScreenSize.FULL) {
            DomQuery.create("body").css("margin", "0");
        }
        return screenSize;
    });
};
var _getScreenData = function (screenSize) {
    return IO.of(function () {
        var x = null, y = null, width = null, height = null, styleWidth = null, styleHeight = null;
        if (screenSize === EScreenSize.FULL) {
            x = 0;
            y = 0;
            width = getRootProperty("innerWidth").run();
            height = getRootProperty("innerHeight").run();
            styleWidth = "100%";
            styleHeight = "100%";
        }
        else {
            x = screenSize.x || 0;
            y = screenSize.y || 0;
            width = screenSize.width || getRootProperty("innerWidth").run();
            height = screenSize.height || getRootProperty("innerHeight").run();
            styleWidth = width + "px";
            styleHeight = height + "px";
        }
        return {
            x: x,
            y: y,
            width: width,
            height: height,
            styleWidth: styleWidth,
            styleHeight: styleHeight
        };
    });
};
var getScreenSize$1 = function (state) {
    return state.getIn(["Main", "screenSize"]);
};
var setScreen$1 = function (canvas, setScreenData, DeviceManagerDataFromSystem, state, DomQuery) {
    return IO.of(requireCheckFunc(function () {
        it$$1("should exist MainData.screenSize", function () {
            wdet_1(getScreenSize$1(state)).exist;
        });
    }, function () {
        initCanvas(canvas).run();
        return compose(chain(setScreenData(DeviceManagerDataFromSystem, canvas, state)), chain(_getScreenData), _setBodyByScreenSize)(getScreenSize$1(state), DomQuery).run();
    }));
};
var clear$1 = function (gl, DeviceManagerDataFromSystem) {
    setColorWrite$1(gl, true, true, true, true, DeviceManagerDataFromSystem);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
};

var setClearColor$1 = function (gl, color, DeviceManagerDataFromSystem) {
    var clearColor = DeviceManagerDataFromSystem.clearColor;
    if (clearColor && clearColor.isEqual(color)) {
        return;
    }
    gl.clearColor(color.r, color.g, color.b, color.a);
    setClearColorData(color, DeviceManagerDataFromSystem);
};
var setClearColorData = function (color, DeviceManagerDataFromSystem) {
    DeviceManagerDataFromSystem.clearColor = color;
};
var setColorWrite$1 = function (gl, writeRed, writeGreen, writeBlue, writeAlpha, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.writeRed !== writeRed
        || DeviceManagerDataFromSystem.writeGreen !== writeGreen
        || DeviceManagerDataFromSystem.writeBlue !== writeBlue
        || DeviceManagerDataFromSystem.writeAlpha !== writeAlpha) {
        gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
        DeviceManagerDataFromSystem.writeRed = writeRed;
        DeviceManagerDataFromSystem.writeGreen = writeGreen;
        DeviceManagerDataFromSystem.writeBlue = writeBlue;
        DeviceManagerDataFromSystem.writeAlpha = writeAlpha;
    }
};
var setSide$1 = function (gl, side, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.side !== side) {
        switch (side) {
            case ESide.NONE:
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT_AND_BACK);
                break;
            case ESide.BOTH:
                gl.disable(gl.CULL_FACE);
                break;
            case ESide.FRONT:
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                break;
            case ESide.BACK:
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT);
                break;
            default:
                Log$$1.error(true, Log$$1.info.FUNC_UNEXPECT("side", side));
                break;
        }
        DeviceManagerDataFromSystem.side = side;
    }
};
var setDepthWrite = function (gl, value, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.depthWrite !== value) {
        gl.depthMask(value);
        DeviceManagerDataFromSystem.depthWrite = value;
    }
};
var setBlend = function (gl, value, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.blend !== value) {
        if (value) {
            gl.enable(gl.BLEND);
        }
        else {
            gl.disable(gl.BLEND);
        }
        DeviceManagerDataFromSystem.blend = value;
    }
};
var setBlendFunc = function (gl, blendSrc, blendDst, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.blendSrc !== blendSrc || DeviceManagerDataFromSystem.blendDst !== blendDst) {
        if (DeviceManagerDataFromSystem.blend) {
            gl.blendFunc(gl[blendSrc], gl[blendDst]);
        }
        DeviceManagerDataFromSystem.blendSrc = blendSrc;
        DeviceManagerDataFromSystem.blendDst = blendDst;
    }
};
var setBlendEquation = function (gl, blendEquation, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.blendEquation !== blendEquation) {
        if (DeviceManagerDataFromSystem.blend) {
            gl.blendEquation(gl[blendEquation]);
        }
        DeviceManagerDataFromSystem.blendEquation = blendEquation;
    }
};

var setDepthTest = function (gl, value, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.depthTest !== value) {
        if (value) {
            gl.enable(gl.DEPTH_TEST);
        }
        else {
            gl.disable(gl.DEPTH_TEST);
        }
        DeviceManagerDataFromSystem.depthTest = value;
    }
};
var setScissorTest = function (gl, value, DeviceManagerDataFromSystem) {
    if (DeviceManagerDataFromSystem.scissorTest !== value) {
        if (value) {
            gl.enable(gl.SCISSOR_TEST);
        }
        else {
            gl.disable(gl.SCISSOR_TEST);
        }
        DeviceManagerDataFromSystem.scissorTest = value;
    }
};
var getOnlyGL = function (canvas, options, WebGLDetectDataFromSystem) {
    if (isWebgl1(WebGLDetectDataFromSystem)) {
        Log$$1.log("use webgl1");
        return getWebgl1Context(options, canvas);
    }
    else if (isWebgl2(WebGLDetectDataFromSystem)) {
        Log$$1.log("use webgl2");
        return getWebgl2Context(options, canvas);
    }
    else {
        return null;
    }
};
var initData$5 = function (DeviceManagerDataFromSystem) {
    DeviceManagerDataFromSystem.gl = null;
    DeviceManagerDataFromSystem.clearColor = null;
    DeviceManagerDataFromSystem.writeRed = null;
    DeviceManagerDataFromSystem.writeGreen = null;
    DeviceManagerDataFromSystem.writeBlue = null;
    DeviceManagerDataFromSystem.writeAlpha = null;
    DeviceManagerDataFromSystem.side = null;
    DeviceManagerDataFromSystem.depthWrite = null;
    DeviceManagerDataFromSystem.blend = null;
    DeviceManagerDataFromSystem.blendSrc = null;
    DeviceManagerDataFromSystem.blendDst = null;
    DeviceManagerDataFromSystem.depthTest = null;
    DeviceManagerDataFromSystem.scissorTest = null;
    DeviceManagerDataFromSystem.blendEquation = null;
    DeviceManagerDataFromSystem.blendFuncSeparate = null;
};

var createGL = curry(function (canvas, contextConfig, WebGLDetectData, DeviceManagerData, state) {
    return IO.of(function () {
        var gl = getOnlyGL(canvas, contextConfig.get("options").toObject(), WebGLDetectData);
        if (!gl) {
            DomQuery.create("<p class='not-support-webgl'></p>").prependTo("body").text("Your device doesn't support WebGL");
        }
        return compose(setCanvas(canvas), setContextConfig$$1(contextConfig), setGL$$1(gl, DeviceManagerData))(state);
    });
});
var getGL$$1 = getGL$1;
var setGL$$1 = setGL$1;
var setContextConfig$$1 = setContextConfig$1;
var setPixelRatio$$1 = setPixelRatio$1;
var getViewport$$1 = getViewport$1;
var setViewportToState$$1 = setViewportToState$1;
var setViewportOfGL$$1 = setViewportOfGL$1;
var setCanvasPixelRatio$$1 = curry(function (useDevicePixelRatio, canvas, state) {
    return IO.of(function () {
        if (!useDevicePixelRatio) {
            return state;
        }
        var pixelRatio = setCanvasPixelRatio$1(useDevicePixelRatio, canvas).run();
        return setPixelRatio$$1(pixelRatio, state);
    });
});

var setScreen$$1 = curry(function (canvas, DeviceManagerData, DomQuery$$1, state) {
    return setScreen$1(canvas, _setScreenData, DeviceManagerData, state, DomQuery$$1);
});
var _setScreenData = curry(function (DeviceManagerData, canvas, state, data) {
    var x = data.x, y = data.y, width = data.width, height = data.height, styleWidth = data.styleWidth, styleHeight = data.styleHeight;
    return IO.of(function () {
        compose(chain(setStyleWidth(styleWidth)), chain(setStyleHeight(styleHeight)), chain(setHeight$1(height)), chain(setWidth$1(width)), chain(setY(y)), setX(x))(canvas).run();
        return setViewportOfGL$$1(DeviceManagerData, state, data).run();
    });
});
var clear$$1 = clear$1;
var getClearColor = function (DeviceManagerData) {
    return DeviceManagerData.clearColor;
};
var setClearColor$$1 = setClearColor$1;

var setSide$$1 = setSide$1;
var initData$4 = initData$5;

var DeviceManagerDataCommon = (function () {
    function DeviceManagerDataCommon() {
    }
    DeviceManagerDataCommon.gl = null;
    DeviceManagerDataCommon.clearColor = null;
    DeviceManagerDataCommon.writeRed = null;
    DeviceManagerDataCommon.writeGreen = null;
    DeviceManagerDataCommon.writeBlue = null;
    DeviceManagerDataCommon.writeAlpha = null;
    DeviceManagerDataCommon.side = null;
    DeviceManagerDataCommon.depthWrite = null;
    DeviceManagerDataCommon.blend = null;
    DeviceManagerDataCommon.depthTest = null;
    DeviceManagerDataCommon.scissorTest = null;
    DeviceManagerDataCommon.blendSrc = null;
    DeviceManagerDataCommon.blendDst = null;
    DeviceManagerDataCommon.blendEquation = null;
    DeviceManagerDataCommon.blendFuncSeparate = null;
    return DeviceManagerDataCommon;
}());

var DeviceManagerData = (function (_super) {
    __extends(DeviceManagerData, _super);
    function DeviceManagerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DeviceManagerData.webglVersion = null;
    return DeviceManagerData;
}(DeviceManagerDataCommon));

var WorkerDetectData = (function () {
    function WorkerDetectData() {
    }
    WorkerDetectData.isSupportRenderWorkerAndSharedArrayBuffer = null;
    WorkerDetectData.isSupportSharedArrayBuffer = null;
    WorkerDetectData.renderWorkerFileDir = null;
    return WorkerDetectData;
}());

var RenderWorkerConfig = {
    useRenderWorker: true
};

var detect = curry(function (WorkerDetectData$$1) {
    if (typeof root$2.isSupportSharedArrayBuffer_wonder !== "undefined" && typeof root$2.isSupportRenderWorkerAndSharedArrayBuffer_wonder !== "undefined") {
        WorkerDetectData$$1.isSupportSharedArrayBuffer = root$2.isSupportSharedArrayBuffer_wonder;
        WorkerDetectData$$1.isSupportRenderWorkerAndSharedArrayBuffer = root$2.isSupportRenderWorkerAndSharedArrayBuffer_wonder;
        return;
    }
    var canvas = DomQuery.create("<canvas></canvas>").get(0);
    if (typeof SharedArrayBuffer !== "undefined") {
        WorkerDetectData$$1.isSupportSharedArrayBuffer = true;
    }
    else {
        WorkerDetectData$$1.isSupportSharedArrayBuffer = false;
    }
    if (("transferControlToOffscreen" in canvas) && WorkerDetectData$$1.isSupportSharedArrayBuffer) {
        WorkerDetectData$$1.isSupportRenderWorkerAndSharedArrayBuffer = true;
    }
    else {
        WorkerDetectData$$1.isSupportRenderWorkerAndSharedArrayBuffer = false;
    }
});
var isSupportSharedArrayBuffer = function () {
    return WorkerDetectData.isSupportSharedArrayBuffer;
};
var isSupportRenderWorkerAndSharedArrayBuffer = function () {
    return RenderWorkerConfig.useRenderWorker && WorkerDetectData.isSupportRenderWorkerAndSharedArrayBuffer;
};
var setWorkerConfig = function (config, WorkerDetectData$$1) {
    return IO.of(function () {
        WorkerDetectData$$1.renderWorkerFileDir = config.renderWorkerFileDir;
    });
};
var getRenderWorkerFilePath = function () {
    return _getValidFileDir(WorkerDetectData.renderWorkerFileDir) + "wd.renderWorker.js";
};
var _getValidFileDir = function (dir) {
    if (dir.slice(-1) !== '/') {
        return dir + "/";
    }
    return dir;
};
detect(WorkerDetectData);

var MeshRendererData = (function () {
    function MeshRendererData() {
    }
    MeshRendererData.renderGameObjectArray = null;
    MeshRendererData.gameObjectMap = null;
    MeshRendererData.meshRendererMap = null;
    MeshRendererData.index = null;
    MeshRendererData.count = null;
    return MeshRendererData;
}());

var Component = (function () {
    function Component() {
        this.index = null;
    }
    Component = __decorate([
        registerClass$1("Component")
    ], Component);
    return Component;
}());

var MeshRenderer = (function (_super) {
    __extends(MeshRenderer, _super);
    function MeshRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MeshRenderer = __decorate([
        registerClass$1("MeshRenderer")
    ], MeshRenderer);
    return MeshRenderer;
}(Component));
var createMeshRenderer = function () {
    return create$1(MeshRendererData);
};
var getMeshRendererGameObject = requireCheckFunc(function (component) {
    _checkShouldAlive$1(component, MeshRendererData);
}, function (component) {
    return getGameObject(component.index, MeshRendererData);
});
var getMeshRendererRenderList = function () {
    return getRenderList(null, MeshRendererData);
};
var _checkShouldAlive$1 = function (component, MeshRendererData$$1) {
    checkComponentShouldAlive(component, MeshRendererData$$1, function (component, MeshRendererData$$1) {
        return isComponentIndexNotRemoved(component);
    });
};

var checkIndexShouldEqualCount = function (ComponentData) {
    it$$1("ComponentData.index should === ComponentData.count", function () {
        wdet_1(ComponentData.index).equal(ComponentData.count);
    });
    it$$1("ComponentData.index should >= 0", function () {
        wdet_1(ComponentData.index).gte(0);
    });
    it$$1("ComponentData.count should >= 0", function () {
        wdet_1(ComponentData.count).gte(0);
    });
};

var addAddComponentHandle$1 = function (_class) {
    addAddComponentHandle(_class, addComponent);
};
var addDisposeHandle$1 = function (_class) {
    addDisposeHandle(_class, disposeComponent);
};
var create$1 = requireCheckFunc(function (MeshRendererData$$1) {
    checkIndexShouldEqualCount(MeshRendererData$$1);
}, function (MeshRendererData$$1) {
    var renderer = new MeshRenderer(), index = generateComponentIndex(MeshRendererData$$1);
    renderer.index = index;
    MeshRendererData$$1.count += 1;
    MeshRendererData$$1.meshRendererMap[index] = renderer;
    return renderer;
});
var _setRenderGameObjectArray = requireCheckFunc(function (index, gameObject, renderGameObjectArray) {
    it$$1("should not exist gameObject", function () {
        wdet_1(renderGameObjectArray[index]).not.exist;
    });
}, function (index, gameObject, renderGameObjectArray) {
    renderGameObjectArray[index] = gameObject;
});
var addComponent = function (component, gameObject) {
    _setRenderGameObjectArray(component.index, gameObject, MeshRendererData.renderGameObjectArray);
    addComponentToGameObjectMap(MeshRendererData.gameObjectMap, component.index, gameObject);
};
var disposeComponent = ensureFunc$$1(function (returnVal, component) {
    checkIndexShouldEqualCount(MeshRendererData);
}, function (component) {
    var sourceIndex = component.index, lastComponentIndex = null;
    MeshRendererData.count -= 1;
    MeshRendererData.index -= 1;
    lastComponentIndex = MeshRendererData.count;
    deleteBySwap(sourceIndex, lastComponentIndex, MeshRendererData.renderGameObjectArray);
    deleteBySwap(sourceIndex, lastComponentIndex, MeshRendererData.gameObjectMap);
    deleteComponentBySwapArray(sourceIndex, lastComponentIndex, MeshRendererData.meshRendererMap);
});
var getGameObject = function (index, Data) {
    return getComponentGameObject(Data.gameObjectMap, index);
};
var getRenderList = curry(function (state, MeshRendererData$$1) {
    return MeshRendererData$$1.renderGameObjectArray;
});
var initData$7 = function (MeshRendererData$$1) {
    MeshRendererData$$1.renderGameObjectArray = [];
    MeshRendererData$$1.gameObjectMap = [];
    MeshRendererData$$1.meshRendererMap = [];
    MeshRendererData$$1.index = 0;
    MeshRendererData$$1.count = 0;
};

var GameObjectData = (function () {
    function GameObjectData() {
    }
    GameObjectData.uid = null;
    GameObjectData.disposeCount = null;
    GameObjectData.componentMap = null;
    GameObjectData.parentMap = null;
    GameObjectData.childrenMap = null;
    GameObjectData.aliveUIdArray = null;
    return GameObjectData;
}());

var DataBufferConfig = {
    transformDataBufferCount: 20 * 1000,
    geometryDataBufferCount: 1000 * 1000,
    basicMaterialDataBufferCount: 20 * 1000,
    lightMaterialDataBufferCount: 20 * 1000,
    textureDataBufferCount: 20 * 1000,
    ambientLightDataBufferCount: 1,
    directionLightDataBufferCount: 10,
    pointLightDataBufferCount: 1000,
    frontAmbientLightCount: 1,
    frontDirectionLightCount: 4,
    frontPointLightCount: 4,
    deferAmbientLightCount: 1,
    deferDirectionLightCount: 10,
    deferPointLightCount: 1000,
    renderCommandBufferCount: 10 * 1024,
    geometryIndicesBufferBits: 16
};

var ThreeDTransformData = (function () {
    function ThreeDTransformData() {
    }
    Object.defineProperty(ThreeDTransformData, "maxCount", {
        get: function () {
            return DataBufferConfig.transformDataBufferCount;
        },
        enumerable: true,
        configurable: true
    });
    ThreeDTransformData.localToWorldMatrices = null;
    ThreeDTransformData.localPositions = null;
    ThreeDTransformData.localRotations = null;
    ThreeDTransformData.localScales = null;
    ThreeDTransformData.defaultPosition = null;
    ThreeDTransformData.defaultRotation = null;
    ThreeDTransformData.defaultScale = null;
    ThreeDTransformData.defaultLocalToWorldMatrice = null;
    ThreeDTransformData.firstDirtyIndex = null;
    ThreeDTransformData.index = null;
    ThreeDTransformData.notUsedIndexLinkList = null;
    ThreeDTransformData.isTranslateMap = null;
    ThreeDTransformData.parentMap = null;
    ThreeDTransformData.childrenMap = null;
    ThreeDTransformData.cacheMap = null;
    ThreeDTransformData.tempMap = null;
    ThreeDTransformData.transformMap = null;
    ThreeDTransformData.count = null;
    ThreeDTransformData.uid = null;
    ThreeDTransformData.disposeCount = null;
    ThreeDTransformData.isClearCacheMap = null;
    ThreeDTransformData.gameObjectMap = null;
    ThreeDTransformData.aliveUIdArray = null;
    ThreeDTransformData.buffer = null;
    return ThreeDTransformData;
}());
var ThreeDTransformRelationData = (function () {
    function ThreeDTransformRelationData() {
        this.index = null;
        this.parent = null;
        this.children = null;
    }
    ThreeDTransformRelationData.create = function () {
        var obj = new this();
        return obj;
    };
    return ThreeDTransformRelationData;
}());

var Vector2 = (function () {
    function Vector2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.values = new Float32Array(2);
        if (args.length > 0) {
            this.values[0] = args[0];
            this.values[1] = args[1];
        }
    }
    Vector2_1 = Vector2;
    Vector2.create = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var m = null;
        if (args.length === 0) {
            m = new this();
        }
        else {
            m = new this(args[0], args[1]);
        }
        return m;
    };
    Object.defineProperty(Vector2.prototype, "x", {
        get: function () {
            return this.values[0];
        },
        set: function (x) {
            this.values[0] = x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector2.prototype, "y", {
        get: function () {
            return this.values[1];
        },
        set: function (y) {
            this.values[1] = y;
        },
        enumerable: true,
        configurable: true
    });
    Vector2.prototype.set = function (x, y) {
        this.x = x;
        this.y = y;
    };
    Vector2.prototype.add = function (v) {
        this.values[0] = this.values[0] + v.values[0];
        this.values[1] = this.values[1] + v.values[1];
        return this;
    };
    Vector2.prototype.addScalar = function (s) {
        this.values[0] += s;
        this.values[1] += s;
        return this;
    };
    Vector2.prototype.multiplyScalar = function (s) {
        this.values[0] *= s;
        this.values[1] *= s;
        return this;
    };
    Vector2.prototype.mul = function (v) {
        this.values[0] = this.values[0] * v.values[0];
        this.values[1] = this.values[1] * v.values[1];
        return this;
    };
    Vector2.prototype.isEqual = function (v) {
        return this.x === v.x && this.y === v.y;
    };
    Vector2.prototype.clone = function () {
        return Vector2_1.create(this.x, this.y);
    };
    Vector2 = Vector2_1 = __decorate([
        registerClass$1("Vector2")
    ], Vector2);
    return Vector2;
    var Vector2_1;
}());

var DEG_TO_RAD = Math.PI / 180;
var RAD_TO_DEG = 180 / Math.PI;

var Matrix3 = (function () {
    function Matrix3() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.values = null;
        if (args.length === 1) {
            this.values = args[0];
        }
        else {
            this.values = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        }
    }
    Matrix3_1 = Matrix3;
    Matrix3.create = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var m = null;
        if (args.length === 0) {
            m = new this();
        }
        else {
            m = new this(args[0]);
        }
        return m;
    };
    Object.defineProperty(Matrix3.prototype, "a", {
        get: function () {
            return this.values[0];
        },
        set: function (a) {
            this.values[0] = a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix3.prototype, "c", {
        get: function () {
            return this.values[1];
        },
        set: function (c) {
            this.values[1] = c;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix3.prototype, "b", {
        get: function () {
            return this.values[3];
        },
        set: function (b) {
            this.values[3] = b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix3.prototype, "d", {
        get: function () {
            return this.values[4];
        },
        set: function (d) {
            this.values[4] = d;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix3.prototype, "tx", {
        get: function () {
            return this.values[6];
        },
        set: function (tx) {
            this.values[6] = tx;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix3.prototype, "ty", {
        get: function () {
            return this.values[7];
        },
        set: function (ty) {
            this.values[7] = ty;
        },
        enumerable: true,
        configurable: true
    });
    Matrix3.prototype.setIdentity = function () {
        var e = this.values;
        e[0] = 1;
        e[3] = 0;
        e[6] = 0;
        e[1] = 0;
        e[4] = 1;
        e[7] = 0;
        e[2] = 0;
        e[5] = 0;
        e[8] = 1;
        return this;
    };
    Matrix3.prototype.invert = function () {
        var a1 = this.values[0];
        var b1 = this.values[1];
        var c1 = this.values[3];
        var d1 = this.values[4];
        var tx1 = this.values[6];
        var ty1 = this.values[7];
        var n = a1 * d1 - b1 * c1;
        this.values[0] = d1 / n;
        this.values[1] = -b1 / n;
        this.values[3] = -c1 / n;
        this.values[4] = a1 / n;
        this.values[6] = (c1 * ty1 - d1 * tx1) / n;
        this.values[7] = -(a1 * ty1 - b1 * tx1) / n;
        return this;
    };
    Matrix3.prototype.multiplyScalar = function (s) {
        var te = this.values;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    };
    Matrix3.prototype.multiplyVector2 = function (vector) {
        var x = vector.x, y = vector.y, result = Vector2.create(), e = this.values;
        result.x = e[0] * x + e[3] * y;
        result.y = e[1] * x + e[4] * y;
        return result;
    };
    Matrix3.prototype.multiplyPoint = function (vector) {
        var x = vector.x, y = vector.y, result = Vector2.create(), e = this.values;
        result.x = e[0] * x + e[3] * y + this.tx;
        result.y = e[1] * x + e[4] * y + this.ty;
        return result;
    };
    Matrix3.prototype.multiply = function (matrix) {
        var m11 = this.a * matrix.a + this.c * matrix.b;
        var m12 = this.b * matrix.a + this.d * matrix.b;
        var m21 = this.a * matrix.c + this.c * matrix.d;
        var m22 = this.b * matrix.c + this.d * matrix.d;
        var dx = this.a * matrix.tx + this.c * matrix.ty + this.tx;
        var dy = this.b * matrix.tx + this.d * matrix.ty + this.ty;
        this.a = m11;
        this.b = m12;
        this.c = m21;
        this.d = m22;
        this.tx = dx;
        this.ty = dy;
        return this;
    };
    Matrix3.prototype.transpose = function () {
        var tmp, m = this.values;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    };
    Matrix3.prototype.clone = function () {
        return Matrix3_1.create().set(this);
    };
    Matrix3.prototype.cloneToArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        var values = this.values;
        for (var index = 0; index < 9; index++) {
            array[offset + index] = values[index];
        }
        return this;
    };
    Matrix3.prototype.set = function (matrix) {
        var te = this.values, values = matrix.values;
        te[0] = values[0];
        te[3] = values[3];
        te[6] = values[6];
        te[1] = values[1];
        te[4] = values[4];
        te[7] = values[7];
        te[2] = values[2];
        te[5] = values[5];
        te[8] = values[8];
        return this;
    };
    Matrix3.prototype.setTS = function (t, s) {
        this.setPosition(t.x, t.y);
        this.setScale(s.x, s.y);
    };
    Matrix3.prototype.rotate = function (angle) {
        var rad = angle * DEG_TO_RAD;
        var c = Math.cos(rad);
        var s = Math.sin(rad);
        var m11 = this.a * c + this.c * s;
        var m12 = this.b * c + this.d * s;
        var m21 = this.a * -s + this.c * c;
        var m22 = this.b * -s + this.d * c;
        this.a = m11;
        this.b = m12;
        this.c = m21;
        this.d = m22;
        return this;
    };
    Matrix3.prototype.setRotation = function (angle) {
        var rad = angle * DEG_TO_RAD;
        var cos_a = Math.cos(rad);
        var sin_a = Math.sin(rad);
        var values = this.values;
        values[0] = cos_a;
        values[1] = -sin_a;
        values[3] = sin_a;
        values[4] = cos_a;
        return this;
    };
    Matrix3.prototype.translate = function (x, y) {
        this.tx += this.a * x + this.c * y;
        this.ty += this.b * x + this.d * y;
    };
    Matrix3.prototype.setPosition = function (x, y) {
        this.tx = x;
        this.ty = y;
    };
    Matrix3.prototype.scale = function (x, y) {
        this.a *= x;
        this.b *= x;
        this.c *= y;
        this.d *= y;
        return this;
    };
    Matrix3.prototype.setScale = function (x, y) {
        var values = this.values;
        values[0] = x;
        values[4] = y;
        return this;
    };
    Matrix3.prototype.getTranslation = function () {
        return Vector2.create(this.tx, this.ty);
    };
    Matrix3.prototype.getScale = function () {
        return Vector2.create(Math.sqrt(this.a * this.a + this.b * this.b), Math.sqrt(this.c * this.c + this.d * this.d));
    };
    Matrix3.prototype.getRotation = function () {
        return this._getSkewX();
    };
    Matrix3.prototype.getSkew = function () {
        return Vector2.create(this._getSkewX(), this._getSkewY());
    };
    Matrix3.prototype._getDeltaTransformPoint = function (matrix, point) {
        return {
            x: point.x * matrix.a + point.y * matrix.c + 0,
            y: point.x * matrix.b + point.y * matrix.d + 0
        };
    };
    Matrix3.prototype._getSkewX = function () {
        var px = this._getDeltaTransformPoint(this, { x: 0, y: 1 });
        return ((180 / Math.PI) * Math.atan2(px.y, px.x) - 90);
    };
    Matrix3.prototype._getSkewY = function () {
        var py = this._getDeltaTransformPoint(this, { x: 1, y: 0 });
        return ((180 / Math.PI) * Math.atan2(py.y, py.x));
    };
    Matrix3 = Matrix3_1 = __decorate([
        registerClass$1("Matrix3")
    ], Matrix3);
    return Matrix3;
    var Matrix3_1;
}());

var Quaternion = (function () {
    function Quaternion(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 1; }
        this.x = null;
        this.y = null;
        this.z = null;
        this.w = null;
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    Quaternion_1 = Quaternion;
    Quaternion.create = function (x, y, z, w) {
        var obj = new this(x, y, z, w);
        return obj;
    };
    Quaternion.prototype.setFromEulerAngles = function (eulerAngles) {
        var sx, cx, sy, cy, sz, cz, halfToRad, ex = eulerAngles.x, ey = eulerAngles.y, ez = eulerAngles.z;
        halfToRad = 0.5 * DEG_TO_RAD;
        ex *= halfToRad;
        ey *= halfToRad;
        ez *= halfToRad;
        sx = Math.sin(ex);
        cx = Math.cos(ex);
        sy = Math.sin(ey);
        cy = Math.cos(ey);
        sz = Math.sin(ez);
        cz = Math.cos(ez);
        this.x = sx * cy * cz - cx * sy * sz;
        this.y = cx * sy * cz + sx * cy * sz;
        this.z = cx * cy * sz - sx * sy * cz;
        this.w = cx * cy * cz + sx * sy * sz;
        return this;
    };
    Quaternion.prototype.multiply = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w, rhs1, rhs2, result = this;
        if (args.length === 1) {
            rhs1 = this;
            rhs2 = args[0];
        }
        else if (args.length === 2) {
            rhs1 = args[0];
            rhs2 = args[1];
        }
        q1x = rhs1.x;
        q1y = rhs1.y;
        q1z = rhs1.z;
        q1w = rhs1.w;
        q2x = rhs2.x;
        q2y = rhs2.y;
        q2z = rhs2.z;
        q2w = rhs2.w;
        result.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
        result.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
        result.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
        result.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
        return result;
    };
    Quaternion.prototype.setFromMatrix = function (matrix) {
        var m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz, m;
        m = matrix.values;
        m00 = m[0];
        m01 = m[1];
        m02 = m[2];
        m10 = m[4];
        m11 = m[5];
        m12 = m[6];
        m20 = m[8];
        m21 = m[9];
        m22 = m[10];
        lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
        ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
        lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);
        m00 *= lx;
        m01 *= lx;
        m02 *= lx;
        m10 *= ly;
        m11 *= ly;
        m12 *= ly;
        m20 *= lz;
        m21 *= lz;
        m22 *= lz;
        tr = m00 + m11 + m22;
        if (tr >= 0) {
            s = Math.sqrt(tr + 1);
            this.w = s * 0.5;
            s = 0.5 / s;
            this.x = (m12 - m21) * s;
            this.y = (m20 - m02) * s;
            this.z = (m01 - m10) * s;
        }
        else {
            if (m00 > m11) {
                if (m00 > m22) {
                    rs = (m00 - (m11 + m22)) + 1;
                    rs = Math.sqrt(rs);
                    this.x = rs * 0.5;
                    rs = 0.5 / rs;
                    this.w = (m12 - m21) * rs;
                    this.y = (m01 + m10) * rs;
                    this.z = (m02 + m20) * rs;
                }
                else {
                    rs = (m22 - (m00 + m11)) + 1;
                    rs = Math.sqrt(rs);
                    this.z = rs * 0.5;
                    rs = 0.5 / rs;
                    this.w = (m01 - m10) * rs;
                    this.x = (m20 + m02) * rs;
                    this.y = (m21 + m12) * rs;
                }
            }
            else if (m11 > m22) {
                rs = (m11 - (m22 + m00)) + 1;
                rs = Math.sqrt(rs);
                this.y = rs * 0.5;
                rs = 0.5 / rs;
                this.w = (m20 - m02) * rs;
                this.z = (m12 + m21) * rs;
                this.x = (m10 + m01) * rs;
            }
            else {
                rs = (m22 - (m00 + m11)) + 1;
                rs = Math.sqrt(rs);
                this.z = rs * 0.5;
                rs = 0.5 / rs;
                this.w = (m01 - m10) * rs;
                this.x = (m20 + m02) * rs;
                this.y = (m21 + m12) * rs;
            }
        }
        return this;
    };
    Quaternion.prototype.setFromAxisAngle = function (angle, axis) {
        var sa, ca;
        axis = axis.normalize();
        angle *= 0.5 * DEG_TO_RAD;
        sa = Math.sin(angle);
        ca = Math.cos(angle);
        this.x = sa * axis.x;
        this.y = sa * axis.y;
        this.z = sa * axis.z;
        this.w = ca;
        return this;
    };
    Quaternion.prototype.invert = function () {
        return this.conjugate().normalize();
    };
    Quaternion.prototype.conjugate = function () {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        return this;
    };
    Quaternion.prototype.clone = function () {
        return Quaternion_1.create(this.x, this.y, this.z, this.w);
    };
    Quaternion.prototype.normalize = function () {
        var len = this.length();
        if (len === 0) {
            this.x = this.y = this.z = 0;
            this.w = 1;
        }
        else {
            len = 1 / len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
            this.w *= len;
        }
        return this;
    };
    Quaternion.prototype.length = function () {
        var x, y, z, w;
        x = this.x;
        y = this.y;
        z = this.z;
        w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };
    Quaternion.prototype.multiplyVector3 = function (vector) {
        var q = this;
        var x = vector.x;
        var y = vector.y;
        var z = vector.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        return Vector3.create(ix * qw + iw * -qx + iy * -qz - iz * -qy, iy * qw + iw * -qy + iz * -qx - ix * -qz, iz * qw + iw * -qz + ix * -qy - iy * -qx);
    };
    Quaternion.prototype.set = function (x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    };
    Quaternion.prototype.sub = function (quat) {
        var result = quat.clone().invert().multiply(this);
        this.set(result.x, result.y, result.z, result.w);
        return this;
    };
    Quaternion.prototype.getEulerAngles = function () {
        var x, y, z, qx, qy, qz, qw, a2;
        qx = this.x;
        qy = this.y;
        qz = this.z;
        qw = this.w;
        a2 = 2 * (qw * qy - qx * qz);
        if (a2 <= -0.99999) {
            x = 2 * Math.atan2(qx, qw);
            y = -Math.PI / 2;
            z = 0;
        }
        else if (a2 >= 0.99999) {
            x = 2 * Math.atan2(qx, qw);
            y = Math.PI / 2;
            z = 0;
        }
        else {
            x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
            y = Math.asin(a2);
            z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
        }
        return Vector3.create(x, y, z).scale(RAD_TO_DEG);
    };
    Quaternion.prototype.slerp = function (left, right, amount) {
        if (amount === 0) {
            this.set(left.x, left.y, left.z, left.w);
            return this;
        }
        else if (amount === 1) {
            this.set(right.x, right.y, right.z, right.w);
            return this;
        }
        var num2;
        var num3;
        var num = amount;
        var num4 = (((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w);
        var flag = false;
        if (num4 < 0) {
            flag = true;
            num4 = -num4;
        }
        if (num4 > 0.999999) {
            num3 = 1 - num;
            num2 = flag ? -num : num;
        }
        else {
            var num5 = Math.acos(num4);
            var num6 = (1.0 / Math.sin(num5));
            num3 = (Math.sin((1.0 - num) * num5)) * num6;
            num2 = flag ? ((-Math.sin(num * num5)) * num6) : ((Math.sin(num * num5)) * num6);
        }
        this.set((num3 * left.x) + (num2 * right.x), (num3 * left.y) + (num2 * right.y), (num3 * left.z) + (num2 * right.z), (num3 * left.w) + (num2 * right.w));
        return this;
    };
    Quaternion = Quaternion_1 = __decorate([
        registerClass$1("Quaternion")
    ], Quaternion);
    return Quaternion;
    var Quaternion_1;
}());

var Matrix4 = (function () {
    function Matrix4() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.values = null;
        if (args.length === 1) {
            this.values = args[0];
        }
        else {
            this.values = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
    }
    Matrix4_1 = Matrix4;
    Matrix4.create = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var m = null;
        if (args.length === 0) {
            m = new this();
        }
        else {
            m = new this(args[0]);
        }
        return m;
    };
    Matrix4.prototype.set = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
        var te = this.values;
        te[0] = initialM11;
        te[1] = initialM12;
        te[2] = initialM13;
        te[3] = initialM14;
        te[4] = initialM21;
        te[5] = initialM22;
        te[6] = initialM23;
        te[7] = initialM24;
        te[8] = initialM31;
        te[9] = initialM32;
        te[10] = initialM33;
        te[11] = initialM34;
        te[12] = initialM41;
        te[13] = initialM42;
        te[14] = initialM43;
        te[15] = initialM44;
        return this;
    };
    Matrix4.prototype.setIdentity = function () {
        var e = this.values;
        e[0] = 1;
        e[4] = 0;
        e[8] = 0;
        e[12] = 0;
        e[1] = 0;
        e[5] = 1;
        e[9] = 0;
        e[13] = 0;
        e[2] = 0;
        e[6] = 0;
        e[10] = 1;
        e[14] = 0;
        e[3] = 0;
        e[7] = 0;
        e[11] = 0;
        e[15] = 1;
        return this;
    };
    Matrix4.prototype.invert = function () {
        var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, invDet, m;
        m = this.values;
        a00 = m[0];
        a01 = m[1];
        a02 = m[2];
        a03 = m[3];
        a10 = m[4];
        a11 = m[5];
        a12 = m[6];
        a13 = m[7];
        a20 = m[8];
        a21 = m[9];
        a22 = m[10];
        a23 = m[11];
        a30 = m[12];
        a31 = m[13];
        a32 = m[14];
        a33 = m[15];
        b00 = a00 * a11 - a01 * a10;
        b01 = a00 * a12 - a02 * a10;
        b02 = a00 * a13 - a03 * a10;
        b03 = a01 * a12 - a02 * a11;
        b04 = a01 * a13 - a03 * a11;
        b05 = a02 * a13 - a03 * a12;
        b06 = a20 * a31 - a21 * a30;
        b07 = a20 * a32 - a22 * a30;
        b08 = a20 * a33 - a23 * a30;
        b09 = a21 * a32 - a22 * a31;
        b10 = a21 * a33 - a23 * a31;
        b11 = a22 * a33 - a23 * a32;
        invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);
        m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        m[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        m[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        m[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        m[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        m[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        m[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        m[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        m[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
        return this;
    };
    Matrix4.prototype.invertTo3x3 = function () {
        var a11, a21, a31, a12, a22, a32, a13, a23, a33, m, r, det, idet;
        var mat3 = Matrix3.create();
        m = this.values;
        r = mat3.values;
        a11 = m[10] * m[5] - m[6] * m[9];
        a21 = -m[10] * m[1] + m[2] * m[9];
        a31 = m[6] * m[1] - m[2] * m[5];
        a12 = -m[10] * m[4] + m[6] * m[8];
        a22 = m[10] * m[0] - m[2] * m[8];
        a32 = -m[6] * m[0] + m[2] * m[4];
        a13 = m[9] * m[4] - m[5] * m[8];
        a23 = -m[9] * m[0] + m[1] * m[8];
        a33 = m[5] * m[0] - m[1] * m[4];
        det = m[0] * a11 + m[1] * a12 + m[2] * a13;
        if (det === 0) {
            Log$$1.warn("can't invert matrix, determinant is 0");
            return mat3;
        }
        idet = 1 / det;
        r[0] = idet * a11;
        r[1] = idet * a21;
        r[2] = idet * a31;
        r[3] = idet * a12;
        r[4] = idet * a22;
        r[5] = idet * a32;
        r[6] = idet * a13;
        r[7] = idet * a23;
        r[8] = idet * a33;
        return mat3;
    };
    Matrix4.prototype.transpose = function () {
        var te = this.values;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    };
    Matrix4.prototype.setTranslate = function (x, y, z) {
        var e = this.values;
        e[0] = 1;
        e[4] = 0;
        e[8] = 0;
        e[12] = x;
        e[1] = 0;
        e[5] = 1;
        e[9] = 0;
        e[13] = y;
        e[2] = 0;
        e[6] = 0;
        e[10] = 1;
        e[14] = z;
        e[3] = 0;
        e[7] = 0;
        e[11] = 0;
        e[15] = 1;
        return this;
    };
    Matrix4.prototype.translate = function (x, y, z, GlobalTempData) {
        this.applyMatrix(GlobalTempData.matrix4_1.setTranslate(x, y, z), GlobalTempData);
        return this;
    };
    Matrix4.prototype.setRotate = function (angle, x, y, z) {
        var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;
        var angle = Math.PI * angle / 180;
        e = this.values;
        s = Math.sin(angle);
        c = Math.cos(angle);
        if (0 !== x && 0 === y && 0 === z) {
            if (x < 0) {
                s = -s;
            }
            e[0] = 1;
            e[4] = 0;
            e[8] = 0;
            e[12] = 0;
            e[1] = 0;
            e[5] = c;
            e[9] = -s;
            e[13] = 0;
            e[2] = 0;
            e[6] = s;
            e[10] = c;
            e[14] = 0;
            e[3] = 0;
            e[7] = 0;
            e[11] = 0;
            e[15] = 1;
        }
        else if (0 === x && 0 !== y && 0 === z) {
            if (y < 0) {
                s = -s;
            }
            e[0] = c;
            e[4] = 0;
            e[8] = s;
            e[12] = 0;
            e[1] = 0;
            e[5] = 1;
            e[9] = 0;
            e[13] = 0;
            e[2] = -s;
            e[6] = 0;
            e[10] = c;
            e[14] = 0;
            e[3] = 0;
            e[7] = 0;
            e[11] = 0;
            e[15] = 1;
        }
        else if (0 === x && 0 === y && 0 !== z) {
            if (z < 0) {
                s = -s;
            }
            e[0] = c;
            e[4] = -s;
            e[8] = 0;
            e[12] = 0;
            e[1] = s;
            e[5] = c;
            e[9] = 0;
            e[13] = 0;
            e[2] = 0;
            e[6] = 0;
            e[10] = 1;
            e[14] = 0;
            e[3] = 0;
            e[7] = 0;
            e[11] = 0;
            e[15] = 1;
        }
        else {
            len = Math.sqrt(x * x + y * y + z * z);
            if (len !== 1) {
                rlen = 1 / len;
                x *= rlen;
                y *= rlen;
                z *= rlen;
            }
            nc = 1 - c;
            xy = x * y;
            yz = y * z;
            zx = z * x;
            xs = x * s;
            ys = y * s;
            zs = z * s;
            e[0] = x * x * nc + c;
            e[1] = xy * nc + zs;
            e[2] = zx * nc - ys;
            e[3] = 0;
            e[4] = xy * nc - zs;
            e[5] = y * y * nc + c;
            e[6] = yz * nc + xs;
            e[7] = 0;
            e[8] = zx * nc + ys;
            e[9] = yz * nc - xs;
            e[10] = z * z * nc + c;
            e[11] = 0;
            e[12] = 0;
            e[13] = 0;
            e[14] = 0;
            e[15] = 1;
        }
        return this;
    };
    Matrix4.prototype.rotate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var angle = args[0];
        if (args.length === 3) {
            var vector3 = args[1], GlobalTempData = args[2];
            this.applyMatrix(GlobalTempData.matrix4_1.setRotate(angle, vector3.values[0], vector3.values[1], vector3.values[2]), GlobalTempData);
        }
        else if (args.length === 5) {
            var x = args[1], y = args[2], z = args[3], GlobalTempData = args[4];
            this.applyMatrix(GlobalTempData.matrix4_1.setRotate(angle, x, y, z), GlobalTempData);
        }
        return this;
    };
    Matrix4.prototype.setScale = function (x, y, z) {
        var e = this.values;
        e[0] = x;
        e[4] = 0;
        e[8] = 0;
        e[12] = 0;
        e[1] = 0;
        e[5] = y;
        e[9] = 0;
        e[13] = 0;
        e[2] = 0;
        e[6] = 0;
        e[10] = z;
        e[14] = 0;
        e[3] = 0;
        e[7] = 0;
        e[11] = 0;
        e[15] = 1;
        return this;
    };
    Matrix4.prototype.scale = function (x, y, z, GlobalTempData) {
        this.applyMatrix(GlobalTempData.matrix4_1.setScale(x, y, z), GlobalTempData);
        return this;
    };
    Matrix4.prototype.setOrtho = function (left, right, bottom, top, near, far) {
        var e = this.values, rw, rh, rd;
        rw = 1 / (right - left);
        rh = 1 / (top - bottom);
        rd = 1 / (far - near);
        e[0] = 2 * rw;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 2 * rh;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
        e[9] = 0;
        e[10] = -2 * rd;
        e[11] = 0;
        e[12] = -(right + left) * rw;
        e[13] = -(top + bottom) * rh;
        e[14] = -(far + near) * rd;
        e[15] = 1;
        return this;
    };
    Matrix4.prototype.ortho = function (left, right, bottom, top, near, far, GlobalTempData) {
        this.applyMatrix(Matrix4_1.create().setOrtho(left, right, bottom, top, near, far), GlobalTempData);
        return this;
    };
    Matrix4.prototype.setPerspective = function (fovy, aspect, near, far) {
        var e = null, rd = null, s = null, ct = null, fovy = Math.PI * fovy / 180 / 2;
        s = Math.sin(fovy);
        Log$$1.error(s === 0, Log$$1.info.FUNC_MUST_NOT_BE("frustum", "null"));
        rd = 1 / (far - near);
        ct = Math.cos(fovy) / s;
        e = this.values;
        e[0] = ct / aspect;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = ct;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
        e[9] = 0;
        e[10] = -(far + near) * rd;
        e[11] = -1;
        e[12] = 0;
        e[13] = 0;
        e[14] = -2 * near * far * rd;
        e[15] = 0;
        return this;
    };
    Matrix4.prototype.perspective = function (fovy, aspect, near, far, GlobalTempData) {
        this.applyMatrix(Matrix4_1.create().setPerspective(fovy, aspect, near, far), GlobalTempData);
        return this;
    };
    Matrix4.prototype.applyMatrix = function (other, GlobalTempData, notChangeSelf) {
        if (notChangeSelf === void 0) { notChangeSelf = false; }
        var a = this, tempMat4 = GlobalTempData.matrix4_3;
        if (notChangeSelf) {
            return tempMat4.multiply(other, a);
        }
        this.values = tempMat4.multiply(other, a).values;
        return this;
    };
    Matrix4.prototype.multiply = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var mat1 = null, mat2 = null, result = null;
        result = this.values;
        if (args.length === 1) {
            mat1 = this.values;
            mat2 = args[0].values;
        }
        else if (args.length === 2) {
            mat1 = args[0].values;
            mat2 = args[1].values;
        }
        var a = mat1[0], b = mat1[1], c = mat1[2], d = mat1[3], e = mat1[4], f = mat1[5], g = mat1[6], h = mat1[7], i = mat1[8], j = mat1[9], k = mat1[10], l = mat1[11], m = mat1[12], n = mat1[13], o = mat1[14], p = mat1[15], A = mat2[0], B = mat2[1], C = mat2[2], D = mat2[3], E = mat2[4], F = mat2[5], G = mat2[6], H = mat2[7], I = mat2[8], J = mat2[9], K = mat2[10], L = mat2[11], M = mat2[12], N = mat2[13], O = mat2[14], P = mat2[15];
        result[0] = A * a + B * e + C * i + D * m;
        result[1] = A * b + B * f + C * j + D * n;
        result[2] = A * c + B * g + C * k + D * o;
        result[3] = A * d + B * h + C * l + D * p;
        result[4] = E * a + F * e + G * i + H * m;
        result[5] = E * b + F * f + G * j + H * n;
        result[6] = E * c + F * g + G * k + H * o;
        result[7] = E * d + F * h + G * l + H * p;
        result[8] = I * a + J * e + K * i + L * m;
        result[9] = I * b + J * f + K * j + L * n;
        result[10] = I * c + J * g + K * k + L * o;
        result[11] = I * d + J * h + K * l + L * p;
        result[12] = M * a + N * e + O * i + P * m;
        result[13] = M * b + N * f + O * j + P * n;
        result[14] = M * c + N * g + O * k + P * o;
        result[15] = M * d + N * h + O * l + P * p;
        return this;
    };
    Matrix4.prototype.multiplyVector4 = function (vector, isChangeVector) {
        if (isChangeVector === void 0) { isChangeVector = false; }
        var mat1 = this.values, vec4 = vector.values, x = null, y = null, z = null, w = null;
        x = vec4[0] * mat1[0] + vec4[1] * mat1[4] + vec4[2] * mat1[8] + vec4[3] * mat1[12];
        y = vec4[0] * mat1[1] + vec4[1] * mat1[5] + vec4[2] * mat1[9] + vec4[3] * mat1[13];
        z = vec4[0] * mat1[2] + vec4[1] * mat1[6] + vec4[2] * mat1[10] + vec4[3] * mat1[14];
        w = vec4[0] * mat1[3] + vec4[1] * mat1[7] + vec4[2] * mat1[11] + vec4[3] * mat1[15];
        if (isChangeVector) {
            vector.set(x, y, z, w);
            return vector;
        }
        return Vector4.create(x, y, z, w);
    };
    Matrix4.prototype.multiplyVector3 = function (vector) {
        var mat1 = this.values, vec3 = vector.values;
        var result = [];
        result[0] = vec3[0] * mat1[0] + vec3[1] * mat1[4] + vec3[2] * mat1[8];
        result[1] = vec3[0] * mat1[1] + vec3[1] * mat1[5] + vec3[2] * mat1[9];
        result[2] = vec3[0] * mat1[2] + vec3[1] * mat1[6] + vec3[2] * mat1[10];
        return Vector3.create(result[0], result[1], result[2]);
    };
    Matrix4.prototype.multiplyPoint = function (vector) {
        var mat1 = this.values, vec3 = vector.values;
        var result = [];
        result[0] = vec3[0] * mat1[0] + vec3[1] * mat1[4] + vec3[2] * mat1[8] + mat1[12];
        result[1] = vec3[0] * mat1[1] + vec3[1] * mat1[5] + vec3[2] * mat1[9] + mat1[13];
        result[2] = vec3[0] * mat1[2] + vec3[1] * mat1[6] + vec3[2] * mat1[10] + mat1[14];
        return Vector3.create(result[0], result[1], result[2]);
    };
    Matrix4.prototype.clone = function () {
        var result = Matrix4_1.create(), i = 0, len = this.values.length;
        for (i = 0; i < len; i++) {
            result.values[i] = this.values[i];
        }
        return result;
    };
    Matrix4.prototype.cloneToArray = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        var values = this.values;
        for (var index = 0; index < 16; index++) {
            array[offset + index] = values[index];
        }
        return this;
    };
    Matrix4.prototype.getX = function () {
        return Vector3.create(this.values[0], this.values[1], this.values[2]);
    };
    Matrix4.prototype.getY = function () {
        return Vector3.create(this.values[4], this.values[5], this.values[6]);
    };
    Matrix4.prototype.getZ = function () {
        return Vector3.create(this.values[8], this.values[9], this.values[10]);
    };
    Matrix4.prototype.getTranslation = function () {
        return Vector3.create(this.values[12], this.values[13], this.values[14]);
    };
    Matrix4.prototype.getScale = function () {
        return Vector3.create(this.getX().length(), this.getY().length(), this.getZ().length());
    };
    Matrix4.prototype.getRotation = function () {
        return Quaternion.create().setFromMatrix(this);
    };
    Matrix4.prototype.getEulerAngles = function () {
        var x, y, z, sx, sy, sz, m, halfPi;
        var scale = this.getScale();
        sx = scale.x;
        sy = scale.y;
        sz = scale.z;
        m = this.values;
        y = Math.asin(-m[2] / sx);
        halfPi = Math.PI * 0.5;
        if (y < halfPi) {
            if (y > -halfPi) {
                x = Math.atan2(m[6] / sy, m[10] / sz);
                z = Math.atan2(m[1] / sx, m[0] / sx);
            }
            else {
                z = 0;
                x = -Math.atan2(m[4] / sy, m[5] / sy);
            }
        }
        else {
            z = 0;
            x = Math.atan2(m[4] / sy, m[5] / sy);
        }
        return Vector3.create(x, y, z).scale(RAD_TO_DEG);
    };
    Matrix4.prototype.setTRS = function (t, r, s) {
        var tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, x2, y2, z2, xx, xy, xz, yy, yz, zz, wx, wy, wz, m;
        tx = t.x;
        ty = t.y;
        tz = t.z;
        qx = r.x;
        qy = r.y;
        qz = r.z;
        qw = r.w;
        sx = s.x;
        sy = s.y;
        sz = s.z;
        x2 = qx + qx;
        y2 = qy + qy;
        z2 = qz + qz;
        xx = qx * x2;
        xy = qx * y2;
        xz = qx * z2;
        yy = qy * y2;
        yz = qy * z2;
        zz = qz * z2;
        wx = qw * x2;
        wy = qw * y2;
        wz = qw * z2;
        m = this.values;
        m[0] = (1 - (yy + zz)) * sx;
        m[1] = (xy + wz) * sx;
        m[2] = (xz - wy) * sx;
        m[3] = 0;
        m[4] = (xy - wz) * sy;
        m[5] = (1 - (xx + zz)) * sy;
        m[6] = (yz + wx) * sy;
        m[7] = 0;
        m[8] = (xz + wy) * sz;
        m[9] = (yz - wx) * sz;
        m[10] = (1 - (xx + yy)) * sz;
        m[11] = 0;
        m[12] = tx;
        m[13] = ty;
        m[14] = tz;
        m[15] = 1;
        return this;
    };
    __decorate([
        requireCheck$1(function (angle, x, y, z) {
            it$$1("axis's component shouldn't all be zero", function () {
                wdet_1(x === 0 && y === 0 && z === 0).false;
            });
        })
    ], Matrix4.prototype, "setRotate", null);
    __decorate([
        requireCheck$1(function (left, right, bottom, top, near, far) {
            it$$1("frustum should not be null", function () {
                wdet_1(left !== right && bottom !== top && near !== far).true;
            });
        })
    ], Matrix4.prototype, "setOrtho", null);
    __decorate([
        requireCheck$1(function (fovy, aspect, near, far) {
            it$$1("frustum should not be null", function () {
                wdet_1(near !== far && aspect !== 0).true;
            });
            it$$1("near should > 0", function () {
                wdet_1(near).gt(0);
            });
            it$$1("far should > 0", function () {
                wdet_1(far).gt(0);
            });
        })
    ], Matrix4.prototype, "setPerspective", null);
    Matrix4 = Matrix4_1 = __decorate([
        registerClass$1("Matrix4")
    ], Matrix4);
    return Matrix4;
    var Matrix4_1;
}());

var GlobalTempData = (function () {
    function GlobalTempData() {
    }
    GlobalTempData.matrix4_1 = Matrix4.create();
    GlobalTempData.matrix4_2 = Matrix4.create();
    GlobalTempData.matrix4_3 = Matrix4.create();
    GlobalTempData.vector3_1 = Vector3.create();
    GlobalTempData.vector3_2 = Vector3.create();
    GlobalTempData.vector3_3 = Vector3.create();
    GlobalTempData.vector3_4 = Vector3.create();
    GlobalTempData.quaternion_1 = Quaternion.create();
    return GlobalTempData;
}());

var ThreeDTransform = (function (_super) {
    __extends(ThreeDTransform, _super);
    function ThreeDTransform() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.uid = null;
        return _this;
    }
    ThreeDTransform = __decorate([
        registerClass$1("ThreeDTransform")
    ], ThreeDTransform);
    return ThreeDTransform;
}(Component));
var createThreeDTransform = function () {
    return create$3(ThreeDTransformData);
};
var getThreeDTransformPosition = requireCheckFunc(function (component) {
    checkShouldAlive(component, ThreeDTransformData);
}, function (component) {
    return getPosition(component, ThreeDTransformData);
});
var setThreeDTransformPosition = requireCheckFunc(function (component, position) {
    checkShouldAlive(component, ThreeDTransformData);
}, function (component, position) {
    setPosition(component, position, GlobalTempData, ThreeDTransformData);
});
var getThreeDTransformLocalToWorldMatrix = requireCheckFunc(function (component) {
    checkShouldAlive(component, ThreeDTransformData);
}, function (component) {
    return getLocalToWorldMatrix(component, getTempLocalToWorldMatrix(component, ThreeDTransformData), ThreeDTransformData);
});
var getThreeDTransformLocalPosition = requireCheckFunc(function (component) {
    checkShouldAlive(component, ThreeDTransformData);
}, function (component) {
    return getLocalPosition(component, ThreeDTransformData);
});
var setThreeDTransformLocalPosition = requireCheckFunc(function (component, localPosition) {
    checkShouldAlive(component, ThreeDTransformData);
}, function (component, localPosition) {
    setLocalPosition(component, localPosition, ThreeDTransformData);
});
var setThreeDTransformBatchTransformDatas = function (batchData) {
    setBatchDatas$$1(batchData, GlobalTempData, ThreeDTransformData);
};
var getThreeDTransformParent = requireCheckFunc(function (component) {
    checkShouldAlive(component, ThreeDTransformData);
}, function (component) {
    return getParent$1(component, ThreeDTransformData);
});
var setThreeDTransformParent = requireCheckFunc(function (parent, child) {
    checkShouldAlive(child, ThreeDTransformData);
}, function (parent, child) {
    setParent$1(parent, child, ThreeDTransformData);
});
var getThreeDTransformGameObject = requireCheckFunc(function (component) {
    checkShouldAlive(component, ThreeDTransformData);
}, function (component) {
    return getGameObject$1(component.uid, ThreeDTransformData);
});

var cacheFunc = function (hasCacheFunc, getCacheFunc, setCacheFunc, bodyFunc) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (hasCacheFunc.apply(null, args)) {
            return getCacheFunc.apply(null, args);
        }
        var result = bodyFunc.apply(null, args);
        args.push(result);
        setCacheFunc.apply(null, args);
        return result;
    };
};

var getUId = requireCheckFunc(function (index, ThreeDTransformData) {
    it$$1("index should exist", function () {
        wdet_1(index).exist;
    });
    it$$1("transform should exist", function () {
        wdet_1(ThreeDTransformData.transformMap[index]).exist;
    });
}, function (index, ThreeDTransformData) {
    return ThreeDTransformData.transformMap[index].uid;
});
var isIndexUsed = ensureFunc$$1(function (isExist, index, ThreeDTransformData) {
}, function (index, ThreeDTransformData) {
    return isValidMapValue(ThreeDTransformData.transformMap[index]);
});
var getStartIndexInArrayBuffer = function () { return 1; };

var removeChildEntity = function (children, targetUId) {
    for (var i = 0, len = children.length; i < len; ++i) {
        if (children[i].uid === targetUId) {
            children.splice(i, 1);
            break;
        }
    }
};

var getParent$2 = requireCheckFunc(function (uid, ThreeDTransformData) {
    it$$1("uid should exist", function () {
        wdet_1(uid).exist;
    });
}, function (uid, ThreeDTransformData) {
    return ThreeDTransformData.parentMap[uid];
});
var setParent$2 = requireCheckFunc(function (parent, child, ThreeDTransformData) {
    it$$1("parent should not be self", function () {
        if (parent !== null) {
            wdet_1(_isTransformEqual(child, parent)).false;
        }
    });
}, function (parent, child, ThreeDTransformData) {
    var index = child.index, uid = child.uid, parentIndexInArrayBuffer = null, currentParent = getParent$2(uid, ThreeDTransformData), isCurrentParentExisit = isParentExist(currentParent);
    if (parent === null) {
        if (isCurrentParentExisit) {
            _removeHierarchyFromParent(currentParent, uid, ThreeDTransformData);
            addItAndItsChildrenToDirtyList(index, uid, ThreeDTransformData);
        }
        return;
    }
    parentIndexInArrayBuffer = parent.index;
    if (isCurrentParentExisit) {
        if (isNotChangeParent(currentParent.index, parentIndexInArrayBuffer)) {
            return;
        }
        _removeHierarchyFromParent(currentParent, uid, ThreeDTransformData);
    }
    _addToParent(uid, child, parent, ThreeDTransformData);
    addItAndItsChildrenToDirtyList(index, uid, ThreeDTransformData);
});
var _isTransformEqual = function (tra1, tra2) { return tra1.uid === tra2.uid; };
var getChildren$1 = function (uid, ThreeDTransformData) {
    return ThreeDTransformData.childrenMap[uid];
};
var isParentExist = function (parent) { return isNotUndefined(parent); };
var isChildrenExist = function (children) { return isNotUndefined(children); };
var isNotChangeParent = function (currentParentIndexInArrayBuffer, newParentIndexInArrayBuffer) {
    return currentParentIndexInArrayBuffer === newParentIndexInArrayBuffer;
};
var removeHierarchyData = function (uid, ThreeDTransformData) {
    deleteVal$1(uid, ThreeDTransformData.childrenMap);
};
var _removeHierarchyFromParent = function (parent, targetUId, ThreeDTransformData) {
    var parentUId = parent.uid, children = getChildren$1(parentUId, ThreeDTransformData);
    deleteVal$1(targetUId, ThreeDTransformData.parentMap);
    if (isNotValidMapValue(children)) {
        return;
    }
    _removeChild(parentUId, targetUId, children, ThreeDTransformData);
};
var _removeChild = function (parentUId, targetUId, children, ThreeDTransformData) {
    removeChildEntity(children, targetUId);
};
var _addChild$1 = requireCheckFunc(function (uid, child, ThreeDTransformData) {
    it$$1("children should be empty array if has no child", function () {
        wdet_1(getChildren$1(uid, ThreeDTransformData)).be.a("array");
    });
}, function (uid, child, ThreeDTransformData) {
    var children = getChildren$1(uid, ThreeDTransformData);
    children.push(child);
});
var setChildren$1 = function (uid, children, ThreeDTransformData) {
    ThreeDTransformData.childrenMap[uid] = children;
};
var _setParent$1 = function (uid, parent, ThreeDTransformData) {
    ThreeDTransformData.parentMap[uid] = parent;
};
var _addToParent = requireCheckFunc(function (targetUId, target, parent, ThreeDTransformData) {
    it$$1("the child one should not has parent", function () {
        wdet_1(isValidMapValue(getParent$2(targetUId, ThreeDTransformData))).false;
    });
    it$$1("parent should not already has the child", function () {
        var parentUId = parent.uid, children = getChildren$1(parentUId, ThreeDTransformData);
        if (isValidMapValue(children)) {
            wdet_1(children.indexOf(target)).equal(-1);
        }
    });
}, function (targetUId, target, parent, ThreeDTransformData) {
    var parentUId = parent.uid;
    _setParent$1(targetUId, parent, ThreeDTransformData);
    _addChild$1(parentUId, target, ThreeDTransformData);
});

var getMatrix3DataSize = function () { return 9; };
var getMatrix4DataSize = function () { return 16; };
var getVector3DataSize = function () { return 3; };
var getQuaternionDataSize = function () { return 4; };
var getSlice = function (typeArr, startIndex, endIndex) {
    return typeArr.slice(startIndex, endIndex);
};
var getSubarray = function (typeArr, startIndex, endIndex) {
    return typeArr.subarray(startIndex, endIndex);
};
var deleteBySwapAndNotReset = function (sourceIndex, targetIndex, typeArr) {
    typeArr[sourceIndex] = typeArr[targetIndex];
};
var deleteBySwapAndReset = function (sourceIndex, targetIndex, typeArr, length, defaultValueArr) {
    for (var i = 0; i < length; i++) {
        typeArr[sourceIndex + i] = typeArr[targetIndex + i];
        typeArr[targetIndex + i] = defaultValueArr[i];
    }
};
var deleteSingleValueBySwapAndReset = function (sourceIndex, lastIndex, typeArr, resetValue) {
    typeArr[sourceIndex] = typeArr[lastIndex];
    typeArr[lastIndex] = resetValue;
};
var deleteOneItemBySwapAndReset = function (sourceIndex, targetIndex, typeArr, defaultValue) {
    typeArr[sourceIndex] = typeArr[targetIndex];
    typeArr[targetIndex] = defaultValue;
};
var set = function (typeArr, valArr, offset) {
    if (offset === void 0) { offset = 0; }
    typeArr.set(valArr, offset);
};
var setMatrices3 = function (typeArr, mat, index) {
    var values = mat.values;
    typeArr[index] = values[0];
    typeArr[index + 1] = values[1];
    typeArr[index + 2] = values[2];
    typeArr[index + 3] = values[3];
    typeArr[index + 4] = values[4];
    typeArr[index + 5] = values[5];
    typeArr[index + 6] = values[6];
    typeArr[index + 7] = values[7];
    typeArr[index + 8] = values[8];
};
var setMatrices = function (typeArr, mat, index) {
    var values = mat.values;
    typeArr[index] = values[0];
    typeArr[index + 1] = values[1];
    typeArr[index + 2] = values[2];
    typeArr[index + 3] = values[3];
    typeArr[index + 4] = values[4];
    typeArr[index + 5] = values[5];
    typeArr[index + 6] = values[6];
    typeArr[index + 7] = values[7];
    typeArr[index + 8] = values[8];
    typeArr[index + 9] = values[9];
    typeArr[index + 10] = values[10];
    typeArr[index + 11] = values[11];
    typeArr[index + 12] = values[12];
    typeArr[index + 13] = values[13];
    typeArr[index + 14] = values[14];
    typeArr[index + 15] = values[15];
};
var setMatrix4ByIndex = requireCheckFunc(function (mat, typeArr, index) {
    it$$1("should not exceed type arr's length", function () {
        wdet_1(index + 15).lte(typeArr.length - 1);
    });
}, function (mat, typeArr, index) {
    mat.set(typeArr[index], typeArr[index + 1], typeArr[index + 2], typeArr[index + 3], typeArr[index + 4], typeArr[index + 5], typeArr[index + 6], typeArr[index + 7], typeArr[index + 8], typeArr[index + 9], typeArr[index + 10], typeArr[index + 11], typeArr[index + 12], typeArr[index + 13], typeArr[index + 14], typeArr[index + 15]);
    return mat;
});
var setVectors = function (typeArr, vec, index) {
    var values = vec.values;
    typeArr[index] = values[0];
    typeArr[index + 1] = values[1];
    typeArr[index + 2] = values[2];
};
var setVector3ByIndex = requireCheckFunc(function (vec, typeArr, index) {
    it$$1("should not exceed type arr's length", function () {
        wdet_1(index + 2).lte(typeArr.length - 1);
    });
}, function (vec, typeArr, index) {
    var values = vec.values;
    values[0] = typeArr[index];
    values[1] = typeArr[index + 1];
    values[2] = typeArr[index + 2];
    return vec;
});
var setQuaternions = function (typeArr, qua, index) {
    typeArr[index] = qua.x;
    typeArr[index + 1] = qua.y;
    typeArr[index + 2] = qua.z;
    typeArr[index + 3] = qua.z;
};
var setQuaternionByIndex = requireCheckFunc(function (qua, typeArr, index) {
    it$$1("should not exceed type arr's length", function () {
        wdet_1(index + 3).lte(typeArr.length - 1);
    });
}, function (qua, typeArr, index) {
    qua.set(typeArr[index], typeArr[index + 1], typeArr[index + 2], typeArr[index + 3]);
    return qua;
});

var createMatrix4ByIndex = function (mat, typeArr, index) {
    return setMatrix4ByIndex(mat, typeArr, index);
};
var createVector3ByIndex = function (vec, typeArr, index) {
    return setVector3ByIndex(vec, typeArr, index);
};
var fillTypeArr = requireCheckFunc(function (typeArr, dataArr, startIndex, count) {
    it$$1("should not exceed type arr's length", function () {
        wdet_1(count + startIndex).lte(typeArr.length);
    });
}, function (typeArr, dataArr, startIndex, count) {
    typeArr.set(dataArr, startIndex);
});
var setTypeArrayValue = requireCheckFunc(function (typeArr, index, value) {
    it$$1("should not exceed type arr's length", function () {
        wdet_1(index).lte(typeArr.length - 1);
    });
}, function (typeArr, index, value) {
    typeArr[index] = value;
});
var setSingleValue = function (typeArr, index, value) {
    var size = 1, i = index * size;
    setTypeArrayValue(typeArr, i, value);
};
var computeBufferLength = function (count, size) { return count * size; };

var swap = requireCheckFunc(function (index1, index2, ThreeDTransformData) {
    it$$1("source index and target index should be used", function () {
        wdet_1(isIndexUsed(index1, ThreeDTransformData)).true;
        wdet_1(isIndexUsed(index2, ThreeDTransformData)).true;
    });
}, function (index1, index2, ThreeDTransformData) {
    swapTypeArrData(index1, index2, ThreeDTransformData);
    swapTransformMapData(index1, index2, ThreeDTransformData);
    return ThreeDTransformData;
});
var swapTransformMapData = requireCheckFunc(function (index1, index2, ThreeDTransformData) {
    it$$1("source index and target index should be used", function () {
        wdet_1(isIndexUsed(index1, ThreeDTransformData)).true;
        wdet_1(isIndexUsed(index2, ThreeDTransformData)).true;
    });
}, function (index1, index2, ThreeDTransformData) {
    return _changeMapData(index1, index2, _swapTransformMap, ThreeDTransformData);
});
var swapTypeArrData = function (index1, index2, ThreeDTransformData) {
    return _changeTypeArrData(index1, index2, _swapTypeArr, ThreeDTransformData);
};
var _swapTypeArr = function (dataArr, index1, index2, length) {
    for (var i = 0; i < length; i++) {
        var newIndex1 = index1 + i, newIndex2 = index2 + i, temp = dataArr[newIndex2];
        dataArr[newIndex2] = dataArr[newIndex1];
        dataArr[newIndex1] = temp;
    }
};
var _swapTransformMap = function (transformMap, sourceIndex, targetIndex) {
    var sourceTransform = transformMap[sourceIndex], targetTransform = transformMap[targetIndex];
    sourceTransform.index = targetIndex;
    targetTransform.index = sourceIndex;
    transformMap[targetIndex] = sourceTransform;
    transformMap[sourceIndex] = targetTransform;
};
var _changeTypeArrData = function (sourceIndex, targetIndex, changeFunc, ThreeDTransformData) {
    if (sourceIndex === targetIndex) {
        return ThreeDTransformData;
    }
    var mat4SourceIndex = getMatrix4DataIndexInArrayBuffer(sourceIndex), mat4TargetIndex = getMatrix4DataIndexInArrayBuffer(targetIndex), mat4Size = getMatrix4DataSize(), vec3SourceIndex = getVector3DataIndexInArrayBuffer(sourceIndex), vec3TargetIndex = getVector3DataIndexInArrayBuffer(targetIndex), vec3Size = getVector3DataSize(), quaSourceIndex = getQuaternionDataIndexInArrayBuffer(sourceIndex), quaTargetIndex = getQuaternionDataIndexInArrayBuffer(targetIndex), quaSize = getQuaternionDataSize();
    changeFunc(ThreeDTransformData.localToWorldMatrices, mat4SourceIndex, mat4TargetIndex, mat4Size);
    changeFunc(ThreeDTransformData.localPositions, vec3SourceIndex, vec3TargetIndex, vec3Size);
    changeFunc(ThreeDTransformData.localRotations, quaSourceIndex, quaTargetIndex, quaSize);
    _changeLocalScaleData(vec3SourceIndex, vec3TargetIndex, vec3Size, ThreeDTransformData, changeFunc);
    return ThreeDTransformData;
};
var _changeLocalScaleData = requireCheckFunc(function (vec3SourceIndex, vec3TargetIndex, vec3Size, ThreeDTransformData, changeFunc) {
    it$$1("source localScale data shouldn't be [0,0,0]", function () {
        if (ThreeDTransformData.localScales[vec3SourceIndex] === 0
            && ThreeDTransformData.localScales[vec3SourceIndex + 1] === 0
            && ThreeDTransformData.localScales[vec3SourceIndex + 2] === 0) {
            wdet_1(false).true;
        }
    });
}, function (vec3SourceIndex, vec3TargetIndex, vec3Size, ThreeDTransformData, changeFunc) {
    changeFunc(ThreeDTransformData.localScales, vec3SourceIndex, vec3TargetIndex, vec3Size);
});
var _changeMapData = function (sourceIndex, targetIndex, changeFunc, ThreeDTransformData) {
    if (sourceIndex === targetIndex) {
        return ThreeDTransformData;
    }
    changeFunc(ThreeDTransformData.transformMap, sourceIndex, targetIndex);
    return ThreeDTransformData;
};
var _moveToTypeArr = function (dataArr, sourceIndex, targetIndex, length) {
    for (var i = 0; i < length; i++) {
        var newIndex1 = sourceIndex + i, newIndex2 = targetIndex + i;
        dataArr[newIndex2] = dataArr[newIndex1];
    }
};
var _moveToTransformMap = function (transformMap, sourceIndex, targetIndex) {
    var sourceTransform = transformMap[sourceIndex];
    sourceTransform.index = targetIndex;
    transformMap[targetIndex] = sourceTransform;
    deleteVal$1(sourceIndex, transformMap);
};
var moveToIndex = ensureFunc$$1(function (returnVal, sourceIndex, targetIndex, ThreeDTransformData) {
    it$$1("source index should not be used", function () {
        wdet_1(isIndexUsed(sourceIndex, ThreeDTransformData)).false;
    });
}, requireCheckFunc(function (sourceIndex, targetIndex, ThreeDTransformData) {
    it$$1("source index should be used", function () {
        wdet_1(isIndexUsed(sourceIndex, ThreeDTransformData)).true;
    });
    it$$1("target index should not be used", function () {
        wdet_1(isIndexUsed(targetIndex, ThreeDTransformData)).false;
    });
}, function (sourceIndex, targetIndex, ThreeDTransformData) {
    moveTypeArrDataToIndex(sourceIndex, targetIndex, ThreeDTransformData);
    moveMapDataToIndex(sourceIndex, targetIndex, ThreeDTransformData);
    addNotUsedIndex(sourceIndex, ThreeDTransformData.notUsedIndexLinkList);
    return ThreeDTransformData;
}));
var moveMapDataToIndex = ensureFunc$$1(function (returnVal, sourceIndex, targetIndex, ThreeDTransformData) {
    it$$1("source index should not be used", function () {
        wdet_1(isIndexUsed(sourceIndex, ThreeDTransformData)).false;
    });
}, requireCheckFunc(function (sourceIndex, targetIndex, ThreeDTransformData) {
    it$$1("source index should be used", function () {
        wdet_1(isIndexUsed(sourceIndex, ThreeDTransformData)).true;
    });
    it$$1("target index should not be used", function () {
        wdet_1(isIndexUsed(targetIndex, ThreeDTransformData)).false;
    });
}, function (sourceIndex, targetIndex, ThreeDTransformData) {
    return _changeMapData(sourceIndex, targetIndex, _moveToTransformMap, ThreeDTransformData);
}));
var moveTypeArrDataToIndex = function (sourceIndex, targetIndex, ThreeDTransformData) {
    return _changeTypeArrData(sourceIndex, targetIndex, _moveToTypeArr, ThreeDTransformData);
};
var setTransformDataInTypeArr = function (index, mat, qua, positionVec, scaleVec, ThreeDTransformData) {
    setLocalRotationData(qua, getQuaternionDataIndexInArrayBuffer(index), ThreeDTransformData);
    setLocalPositionData(positionVec, getVector3DataIndexInArrayBuffer(index), ThreeDTransformData);
    setLocalScaleData(scaleVec, getVector3DataIndexInArrayBuffer(index), ThreeDTransformData);
    setLocalToWorldMatricesData(mat, getMatrix4DataIndexInArrayBuffer(index), ThreeDTransformData);
};
var setLocalToWorldMatricesData = function (mat, mat4IndexInArrayBuffer, ThreeDTransformData) {
    setMatrices(ThreeDTransformData.localToWorldMatrices, mat, mat4IndexInArrayBuffer);
};
var setLocalPositionData = function (position, vec3IndexInArrayBuffer, ThreeDTransformData) {
    setVectors(ThreeDTransformData.localPositions, position, vec3IndexInArrayBuffer);
    return ThreeDTransformData;
};
var setLocalRotationData = function (qua, quaIndexInArrayBuffer, ThreeDTransformData) {
    setQuaternions(ThreeDTransformData.localRotations, qua, quaIndexInArrayBuffer);
    return ThreeDTransformData;
};
var setLocalScaleData = function (scale, vec3IndexInArrayBuffer, ThreeDTransformData) {
    setVectors(ThreeDTransformData.localScales, scale, vec3IndexInArrayBuffer);
    return ThreeDTransformData;
};
var setPositionData = function (index, parent, vec3IndexInArrayBuffer, position, GlobalTempData, ThreeDTransformData) {
    if (isParentExist(parent)) {
        var index_1 = parent.index;
        setVectors(ThreeDTransformData.localPositions, getLocalToWorldMatrix({
            uid: getUId(index_1, ThreeDTransformData),
            index: index_1
        }, GlobalTempData.matrix4_3, ThreeDTransformData).invert().multiplyPoint(position), vec3IndexInArrayBuffer);
    }
    else {
        setVectors(ThreeDTransformData.localPositions, position, vec3IndexInArrayBuffer);
    }
};
var getMatrix4DataIndexInArrayBuffer = function (index) { return index * getMatrix4DataSize(); };
var getVector3DataIndexInArrayBuffer = function (index) { return index * getVector3DataSize(); };
var getQuaternionDataIndexInArrayBuffer = function (index) { return index * getQuaternionDataSize(); };

var LinkList = (function () {
    function LinkList() {
        this._first = null;
        this._last = null;
    }
    LinkList.create = function () {
        var obj = new this();
        return obj;
    };
    LinkList.prototype.shift = function () {
        var node = this._first;
        if (node === null) {
            return null;
        }
        this._first = node.next;
        return node;
    };
    LinkList.prototype.push = function (node) {
        if (this._last === null) {
            this._first = node;
            this._last = node;
            return;
        }
        this._last.next = node;
        this._last = node;
    };
    LinkList.prototype.hasDuplicateNode = function (val) {
        var node = this._first;
        while (node !== null && node.val !== val) {
            node = node.next;
        }
        if (node === null) {
            return false;
        }
        return false;
    };
    return LinkList;
}());
var LinkNode = (function () {
    function LinkNode(val) {
        this.val = null;
        this.next = null;
        this.val = val;
    }
    LinkNode.create = function (val) {
        var obj = new this(val);
        return obj;
    };
    return LinkNode;
}());

var getIsTranslate = function (uid, ThreeDTransformData) {
    return ThreeDTransformData.isTranslateMap[uid];
};
var setIsTranslate = requireCheckFunc(function (uid, isTranslate, ThreeDTransformData) {
}, function (uid, isTranslate, ThreeDTransformData) {
    ThreeDTransformData.isTranslateMap[uid] = isTranslate;
});
var isTranslate = function (data) {
    return !!data.position || !!data.localPosition;
};

var addFirstDirtyIndex = ensureFunc$$1(function (firstDirtyIndex, ThreeDTransformData) {
    it$$1("firstDirtyIndex should <= maxCount", function () {
        wdet_1(firstDirtyIndex).lte(ThreeDTransformData.maxCount);
    });
}, function (ThreeDTransformData) {
    return ThreeDTransformData.firstDirtyIndex + 1;
});
var minusFirstDirtyIndex = ensureFunc$$1(function (firstDirtyIndex) {
    it$$1("firstDirtyIndex should >= start index:" + getStartIndexInArrayBuffer(), function () {
        wdet_1(firstDirtyIndex).gte(getStartIndexInArrayBuffer());
    });
}, function (firstDirtyIndex) {
    return firstDirtyIndex - 1;
});
var generateNotUsedIndexInArrayBuffer = ensureFunc$$1(function (index, ThreeDTransformData) {
    _checkGeneratedNotUsedIndex(ThreeDTransformData, index);
}, function (ThreeDTransformData) {
    var result = ThreeDTransformData.index;
    if (result >= ThreeDTransformData.firstDirtyIndex) {
        return _getNotUsedIndexFromArr(ThreeDTransformData);
    }
    ThreeDTransformData.index += 1;
    return result;
});
var _isValidArrayValue = function (val) {
    return isNotUndefined(val);
};
var _isValidLinkNode = function (node) {
    return node !== null;
};
var generateNotUsedIndexInNormalList = ensureFunc$$1(function (index, ThreeDTransformData) {
    _checkGeneratedNotUsedIndex(ThreeDTransformData, index);
}, function (ThreeDTransformData) {
    var index = _getNotUsedIndexFromArr(ThreeDTransformData);
    if (_isValidArrayValue(index)) {
        return index;
    }
    index = ThreeDTransformData.index;
    ThreeDTransformData.index += 1;
    return index;
});
var addToDirtyList = requireCheckFunc(function (index, ThreeDTransformData) {
    it$$1("firstDirtyIndex should <= maxCount", function () {
        wdet_1(ThreeDTransformData.firstDirtyIndex).lte(ThreeDTransformData.maxCount);
    });
}, function (index, ThreeDTransformData) {
    var targetDirtyIndex = minusFirstDirtyIndex(ThreeDTransformData.firstDirtyIndex);
    ThreeDTransformData.firstDirtyIndex = targetDirtyIndex;
    if (isIndexUsed(targetDirtyIndex, ThreeDTransformData)) {
        swap(index, targetDirtyIndex, ThreeDTransformData);
    }
    else {
        moveToIndex(index, targetDirtyIndex, ThreeDTransformData);
    }
    return targetDirtyIndex;
});
var _getNotUsedIndexFromArr = function (ThreeDTransformData) {
    var notUsedIndexLinkList = ThreeDTransformData.notUsedIndexLinkList, isValidLinkNode = true, node = null;
    do {
        node = _getNotUsedIndexNode(notUsedIndexLinkList);
        isValidLinkNode = _isValidLinkNode(node);
    } while (isValidLinkNode && isIndexUsed(node.val, ThreeDTransformData));
    if (!isValidLinkNode) {
        return void 0;
    }
    return node.val;
};
var _getNotUsedIndexNode = function (notUsedIndexLinkList) {
    return notUsedIndexLinkList.shift();
};
var addNotUsedIndex = requireCheckFunc(function (index, notUsedIndexLinkList) {
    it$$1("index shouldn't already exist", function () {
        wdet_1(notUsedIndexLinkList.hasDuplicateNode(index)).false;
    });
}, function (index, notUsedIndexLinkList) {
    notUsedIndexLinkList.push(LinkNode.create(index));
});
var isNotDirty = function (index, firstDirtyIndex) {
    return index < firstDirtyIndex;
};
var addItAndItsChildrenToDirtyList = function (rootIndexInArrayBuffer, uid, ThreeDTransformData) {
    var indexInArraybuffer = rootIndexInArrayBuffer, children = getChildren$1(uid, ThreeDTransformData);
    if (isNotDirty(indexInArraybuffer, ThreeDTransformData.firstDirtyIndex)) {
        setIsTranslate(uid, true, ThreeDTransformData);
        addToDirtyList(indexInArraybuffer, ThreeDTransformData);
    }
    if (isChildrenExist(children)) {
        forEach(children, function (child) {
            if (isNotAlive$1(child, ThreeDTransformData)) {
                return;
            }
            addItAndItsChildrenToDirtyList(child.index, child.uid, ThreeDTransformData);
        });
    }
    return ThreeDTransformData;
};
var _checkGeneratedNotUsedIndex = function (ThreeDTransformData, index) {
    it$$1("index should < firstDirtyIndex", function () {
        wdet_1(index).exist;
        wdet_1(index).lt(ThreeDTransformData.firstDirtyIndex);
    });
    it$$1("index should not be used", function () {
        wdet_1(isIndexUsed(index, ThreeDTransformData)).false;
    });
};

var clearCache = curry(function (ThreeDTransformData, state) {
    var count = null, cacheMap = null;
    if (ThreeDTransformData.isClearCacheMap) {
        ThreeDTransformData.isClearCacheMap = false;
        return;
    }
    count = ThreeDTransformData.maxCount;
    cacheMap = ThreeDTransformData.cacheMap;
    for (var i = ThreeDTransformData.firstDirtyIndex; i < count; i++) {
        var uid = getUId(i, ThreeDTransformData), isTranslate$$1 = getIsTranslate(uid, ThreeDTransformData);
        if (isTranslate$$1) {
            deleteVal$1(uid, cacheMap);
            setIsTranslate(uid, false, ThreeDTransformData);
        }
    }
    return state;
});
var clearCacheMap = function (ThreeDTransformData) {
    ThreeDTransformData.cacheMap = {};
    ThreeDTransformData.isClearCacheMap = true;
};
var getLocalToWorldMatrixCache = function (uid, ThreeTransformData) {
    return _getCache(uid, ThreeTransformData).localToWorldMatrix;
};
var setLocalToWorldMatrixCache = function (uid, mat, ThreeTransformData) {
    _getCache(uid, ThreeTransformData).localToWorldMatrix = mat;
};
var getPositionCache = function (uid, ThreeTransformData) {
    return _getCache(uid, ThreeTransformData).position;
};
var setPositionCache = function (uid, pos, ThreeTransformData) {
    _getCache(uid, ThreeTransformData).position = pos;
};
var getLocalPositionCache = function (uid, ThreeTransformData) {
    return _getCache(uid, ThreeTransformData).localPosition;
};
var setLocalPositionCache = function (uid, pos, ThreeTransformData) {
    ThreeTransformData.cacheMap[uid].localPosition = pos;
};
var getNormalMatrixCache = function (uid, ThreeTransformData) {
    return _getCache(uid, ThreeTransformData).normalMatrix;
};
var setNormalMatrixCache = function (uid, mat, ThreeTransformData) {
    _getCache(uid, ThreeTransformData).normalMatrix = mat;
};
var _getCache = function (uid, ThreeTransformData) {
    var cache = ThreeTransformData.cacheMap[uid];
    if (isNotValidMapValue(cache)) {
        cache = {};
        ThreeTransformData.cacheMap[uid] = cache;
    }
    return cache;
};

var update$2 = function (elapsed, GlobalTempData, ThreeDTransformData, state) {
    return compose(_cleanDirtyList(ThreeDTransformData), _updateDirtyList(GlobalTempData, ThreeDTransformData), clearCache(ThreeDTransformData))(state);
};
var _updateDirtyList = requireCheckFunc(curry(function (GlobalTempData, ThreeDTransformData, state) {
    it$$1("firstDirtyIndex should <= maxCount", function () {
        wdet_1(ThreeDTransformData.firstDirtyIndex).lte(ThreeDTransformData.maxCount);
    });
}), curry(function (GlobalTempData, ThreeDTransformData, state) {
    _sortParentBeforeChildInDirtyList(ThreeDTransformData);
    var count = ThreeDTransformData.maxCount;
    for (var i = ThreeDTransformData.firstDirtyIndex; i < count; i++) {
        _transform(i, GlobalTempData, ThreeDTransformData);
    }
    return state;
}));
var _cleanDirtyList = requireCheckFunc(curry(function (ThreeDTransformData, state) {
    it$$1("firstDirtyIndex should <= maxCount", function () {
        wdet_1(ThreeDTransformData.firstDirtyIndex).lte(ThreeDTransformData.maxCount);
    });
}), curry(function (ThreeDTransformData, state) {
    var count = ThreeDTransformData.maxCount;
    for (var i = ThreeDTransformData.firstDirtyIndex; i < count; i++) {
        if (_needMoveOffDirtyList(i)) {
            _moveFromDirtyListToNormalList(i, ThreeDTransformData);
        }
    }
    return state;
}));
var _needMoveOffDirtyList = function (index) {
    return true;
};
var _moveFromDirtyListToNormalList = function (index, ThreeDTransformData) {
    ThreeDTransformData.firstDirtyIndex = addFirstDirtyIndex(ThreeDTransformData);
    moveToIndex(index, generateNotUsedIndexInNormalList(ThreeDTransformData), ThreeDTransformData);
};
var _transform = function (index, GlobalTempData, ThreeDTransformData) {
    var vec3Index = getVector3DataIndexInArrayBuffer(index), quaIndex = getQuaternionDataIndexInArrayBuffer(index), mat4Index = getMatrix4DataIndexInArrayBuffer(index), mat = GlobalTempData.matrix4_2.setTRS(setVector3ByIndex(GlobalTempData.vector3_1, ThreeDTransformData.localPositions, vec3Index), setQuaternionByIndex(GlobalTempData.quaternion_1, ThreeDTransformData.localRotations, quaIndex), setVector3ByIndex(GlobalTempData.vector3_2, ThreeDTransformData.localScales, vec3Index)), parent = getParent$2(getUId(index, ThreeDTransformData), ThreeDTransformData);
    if (isParentExist(parent)) {
        var parentIndex = parent.index;
        return setLocalToWorldMatricesData(setMatrix4ByIndex(GlobalTempData.matrix4_1, ThreeDTransformData.localToWorldMatrices, getMatrix4DataIndexInArrayBuffer(parentIndex))
            .multiply(mat), mat4Index, ThreeDTransformData);
    }
    return setLocalToWorldMatricesData(mat, mat4Index, ThreeDTransformData);
};
var _sortParentBeforeChildInDirtyList = function (ThreeDTransformData) {
    var count = ThreeDTransformData.maxCount;
    for (var i = ThreeDTransformData.firstDirtyIndex; i < count; i++) {
        var parent = getParent$2(getUId(i, ThreeDTransformData), ThreeDTransformData);
        if (isParentExist(parent)) {
            var parentIndex = parent.index;
            if (parentIndex > i) {
                swap(parentIndex, i, ThreeDTransformData);
            }
        }
    }
};

var checkTransformShouldAlive = function (transform, ThreeDTransformData) {
    checkComponentShouldAlive(transform, ThreeDTransformData, function (transform, ThreeDTransformData) {
        return isAlive$1(transform, ThreeDTransformData);
    });
};

var setBatchDatas$1 = requireCheckFunc(function (batchData, GlobalTempData, ThreeTransformData) {
    for (var _i = 0, batchData_1 = batchData; _i < batchData_1.length; _i++) {
        var data = batchData_1[_i];
        checkTransformShouldAlive(data.transform, ThreeTransformData);
    }
}, function (batchData, GlobalTempData, ThreeDTransformData) {
    compose(_addBatchToDirtyListByChangeMapData(ThreeDTransformData, ThreeDTransformData.firstDirtyIndex), _addBatchToDirtyListByChangeTypeArrData(ThreeDTransformData, ThreeDTransformData.firstDirtyIndex), function (_a) {
        var noDirtyIndex = _a[0], targetDirtyIndex = _a[1];
        ThreeDTransformData.firstDirtyIndex = targetDirtyIndex;
        return noDirtyIndex;
    }, _getAllTransfomrsNotDirtyIndexArrAndMarkTransform(batchData), _setBatchTransformData(batchData, GlobalTempData))(ThreeDTransformData);
});
var _setBatchTransformData = curry(function (batchData, GlobalTempData, ThreeDTransformData) {
    for (var _i = 0, batchData_2 = batchData; _i < batchData_2.length; _i++) {
        var data = batchData_2[_i];
        var transform = data.transform, index = transform.index, uid = transform.uid, parent = getParent$2(uid, ThreeDTransformData), vec3IndexInArrayBuffer = getVector3DataIndexInArrayBuffer(index), position = data.position, localPosition = data.localPosition;
        if (localPosition) {
            setLocalPositionData(localPosition, vec3IndexInArrayBuffer, ThreeDTransformData);
        }
        if (position) {
            setPositionData(index, parent, vec3IndexInArrayBuffer, position, GlobalTempData, ThreeDTransformData);
        }
    }
    return ThreeDTransformData;
});
var _getAllTransfomrsNotDirtyIndexArrAndMarkTransform = curry(function (batchData, ThreeDTransformData) {
    var notDirtyIndexArr = [], firstDirtyIndex = ThreeDTransformData.firstDirtyIndex;
    var _getNotDirtyIndex = function (index, uid, notDirtyIndexArr, isTranslate$$1, ThreeDTransformData) {
        var children = getChildren$1(uid, ThreeDTransformData);
        if (isTranslate$$1) {
            setIsTranslate(uid, true, ThreeDTransformData);
        }
        if (isNotDirty(index, firstDirtyIndex)) {
            notDirtyIndexArr.push(index);
            firstDirtyIndex = minusFirstDirtyIndex(firstDirtyIndex);
        }
        if (isChildrenExist(children)) {
            forEach(children, function (child) {
                if (isNotAlive$1(child, ThreeDTransformData)) {
                    return;
                }
                _getNotDirtyIndex(child.index, child.uid, notDirtyIndexArr, isTranslate$$1, ThreeDTransformData);
            });
        }
    };
    for (var _i = 0, batchData_3 = batchData; _i < batchData_3.length; _i++) {
        var data = batchData_3[_i];
        var transform = data.transform, index = transform.index;
        _getNotDirtyIndex(index, transform.uid, notDirtyIndexArr, isTranslate(data), ThreeDTransformData);
    }
    return [notDirtyIndexArr, firstDirtyIndex];
});
var _addBatchToDirtyList = function (ThreeDTransformData, targetDirtyIndex, swapFunc, moveToIndexFunc, notDirtyIndexArr) {
    for (var _i = 0, notDirtyIndexArr_1 = notDirtyIndexArr; _i < notDirtyIndexArr_1.length; _i++) {
        var index = notDirtyIndexArr_1[_i];
        targetDirtyIndex = minusFirstDirtyIndex(targetDirtyIndex);
        if (isIndexUsed(targetDirtyIndex, ThreeDTransformData)) {
            swapFunc(index, targetDirtyIndex, ThreeDTransformData);
        }
        else {
            moveToIndexFunc(index, targetDirtyIndex, ThreeDTransformData);
        }
    }
    return targetDirtyIndex;
};
var _addBatchToDirtyListByChangeTypeArrData = curry(function (ThreeDTransformData, targetDirtyIndex, notDirtyIndexArr) {
    _addBatchToDirtyList(ThreeDTransformData, targetDirtyIndex, swapTypeArrData, moveTypeArrDataToIndex, notDirtyIndexArr);
    return notDirtyIndexArr;
});
var _addBatchToDirtyListByChangeMapData = curry(function (ThreeDTransformData, targetDirtyIndex, notDirtyIndexArr) {
    return _addBatchToDirtyList(ThreeDTransformData, targetDirtyIndex, swapTransformMapData, function (sourceIndex, targetIndex, ThreeDTransformData) {
        moveMapDataToIndex(sourceIndex, targetIndex, ThreeDTransformData);
        addNotUsedIndex(sourceIndex, ThreeDTransformData.notUsedIndexLinkList);
    }, notDirtyIndexArr);
});

var TagData = (function () {
    function TagData() {
    }
    TagData.tagArray = null;
    TagData.slotCountMap = null;
    TagData.usedSlotCountMap = null;
    TagData.indexMap = null;
    TagData.indexInTagArrayMap = null;
    TagData.lastIndexInTagArray = null;
    TagData.tagMap = null;
    TagData.gameObjectMap = null;
    TagData.index = null;
    TagData.count = null;
    TagData.disposeCount = null;
    return TagData;
}());

var Tag = (function (_super) {
    __extends(Tag, _super);
    function Tag() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tag = __decorate([
        registerClass$1("Tag")
    ], Tag);
    return Tag;
}(Component));
var createTag = function (slotCount) {
    if (slotCount === void 0) { slotCount = 4; }
    return create$4(slotCount, TagData);
};
var addTag$1 = requireCheckFunc(function (component, tag) {
    _checkShouldAlive$2(component, TagData);
}, function (component, tag) {
    addTag(component, tag, TagData);
});
var removeTag$1 = requireCheckFunc(function (component, tag) {
    _checkShouldAlive$2(component, TagData);
}, function (component, tag) {
    removeTag(component, tag, TagData);
});
var findGameObjectsByTag$1 = function (tag) {
    return findGameObjectsByTag(tag, TagData);
};
var getTagGameObject = requireCheckFunc(function (component) {
    _checkShouldAlive$2(component, TagData);
}, function (component) {
    return getGameObject$2(component.index, TagData);
});
var _checkShouldAlive$2 = function (tag, TagData$$1) {
    checkComponentShouldAlive(tag, TagData$$1, function (tag, TagData$$1) {
        return isValidMapValue(TagData$$1.indexMap[TagData$$1.indexInTagArrayMap[tag.index]]);
    });
};

var addAddComponentHandle$3 = function (_class) {
    addAddComponentHandle(_class, addComponent$3);
};
var addDisposeHandle$3 = function (_class) {
    addDisposeHandle(_class, disposeComponent$3);
};
var create$4 = ensureFunc$$1(function (tag, slotCount, TagData$$1) {
    it$$1("slot array should has no hole", function () {
        for (var _i = 0, _a = TagData$$1.slotCountMap; _i < _a.length; _i++) {
            var count = _a[_i];
            wdet_1(count).exist;
        }
    });
}, function (slotCount, TagData$$1) {
    var tag = new Tag(), index = generateComponentIndex(TagData$$1);
    tag.index = index;
    TagData$$1.count += 1;
    _setSlotCount(index, slotCount, TagData$$1.slotCountMap);
    _setUsedSlotCount(index, 0, TagData$$1.usedSlotCountMap);
    setNextIndexInTagArrayMap(index, slotCount, TagData$$1.indexInTagArrayMap);
    _initIndexMap(index, slotCount, TagData$$1);
    TagData$$1.lastIndexInTagArray += slotCount;
    TagData$$1.tagMap[index] = tag;
    return tag;
});
var setNextIndexInTagArrayMap = requireCheckFunc(function (index, slotCount, indexInTagArrayMap) {
    it$$1("index should >= 0", function () {
        wdet_1(index).gte(0);
    });
}, function (index, slotCount, indexInTagArrayMap) {
    indexInTagArrayMap[index + 1] = indexInTagArrayMap[index] + slotCount;
});
var _initIndexMap = function (index, slotCount, TagData$$1) {
    var indexMap = TagData$$1.indexMap, lastIndexInTagArray = TagData$$1.lastIndexInTagArray;
    for (var i = lastIndexInTagArray, count = lastIndexInTagArray + slotCount; i < count; i++) {
        indexMap[i] = index;
    }
};
var addTag = requireCheckFunc(function (tagComponent, tag, TagData$$1) {
    it$$1("tag should not already be added", function () {
        var index = tagComponent.index, indexInArray = _convertTagIndexToIndexInArray(index, TagData$$1), tagArray = TagData$$1.tagArray, slotCountMap = TagData$$1.slotCountMap, currentSlotCount = getSlotCount(index, slotCountMap);
        wdet_1(tagArray.slice(indexInArray, indexInArray + currentSlotCount).indexOf(tag) > -1).false;
    });
}, function (tagComponent, tag, TagData$$1) {
    var index = tagComponent.index, indexInArray = _convertTagIndexToIndexInArray(index, TagData$$1), slotCountMap = TagData$$1.slotCountMap, tagArray = TagData$$1.tagArray, usedSlotCountMap = TagData$$1.usedSlotCountMap, currentSlotCount = getSlotCount(index, slotCountMap), currentUsedSlotCount = getUsedSlotCount(index, usedSlotCountMap);
    if (_isSlotAllUsed(currentUsedSlotCount, currentSlotCount)) {
        var increasedSlotCount = _allocateDoubleSlotCountAndAddTag(indexInArray, index, tag, currentSlotCount, currentUsedSlotCount, TagData$$1), slotCount = currentSlotCount + increasedSlotCount;
        _setSlotCount(index, slotCount, slotCountMap);
        _updateIndexInTagArrayMap(index, increasedSlotCount, TagData$$1);
        TagData$$1.lastIndexInTagArray = _updateIndexMap(indexInArray, index, increasedSlotCount, TagData$$1);
    }
    else {
        tagArray[indexInArray + currentUsedSlotCount] = tag;
    }
    _setUsedSlotCount(index, currentUsedSlotCount + 1, usedSlotCountMap);
});
var _updateIndexInTagArrayMap = function (startIndex, increasedSlotCount, TagData$$1) {
    var count = TagData$$1.count, indexInTagArrayMap = TagData$$1.indexInTagArrayMap;
    for (var i = startIndex + 1; i <= count; i++) {
        indexInTagArrayMap[i] += increasedSlotCount;
    }
};
var _updateIndexMap = function (indexInArray, index, increasedSlotCount, TagData$$1) {
    var indexMap = TagData$$1.indexMap, lastIndexInTagArray = TagData$$1.lastIndexInTagArray + increasedSlotCount, spliceParamArr = [indexInArray + increasedSlotCount, 0];
    for (var i = 0; i < increasedSlotCount; i++) {
        spliceParamArr.push(index);
    }
    Array.prototype.splice.apply(indexMap, spliceParamArr);
    return lastIndexInTagArray;
};
var removeTag = requireCheckFunc(function (tagComponent, tag, TagData$$1) {
    it$$1("current used slot count should >= 0", function () {
        var index = tagComponent.index, usedSlotCountMap = TagData$$1.usedSlotCountMap;
        wdet_1(getUsedSlotCount(index, usedSlotCountMap)).gte(0);
    });
}, function (tagComponent, tag, TagData$$1) {
    var index = tagComponent.index, indexInArray = _convertTagIndexToIndexInArray(index, TagData$$1), usedSlotCountMap = TagData$$1.usedSlotCountMap, tagArray = TagData$$1.tagArray, currentUsedSlotCount = getUsedSlotCount(index, usedSlotCountMap), newUsedSlotCount = currentUsedSlotCount;
    for (var i = indexInArray, count = indexInArray + currentUsedSlotCount; i < count; i++) {
        if (tagArray[i] === tag) {
            tagArray[i] = void 0;
            newUsedSlotCount = currentUsedSlotCount - 1;
            break;
        }
    }
    if (newUsedSlotCount <= 0) {
        newUsedSlotCount = 0;
    }
    _setUsedSlotCount(index, newUsedSlotCount, usedSlotCountMap);
});
var addComponent$3 = function (component, gameObject) {
    addComponentToGameObjectMap(TagData.gameObjectMap, component.index, gameObject);
};
var getSlotCount = function (index, slotCountMap) {
    return slotCountMap[index];
};
var _setSlotCount = function (index, slotCount, slotCountMap) {
    slotCountMap[index] = slotCount;
};
var getUsedSlotCount = function (index, usedSlotCountMap) {
    return usedSlotCountMap[index];
};
var _setUsedSlotCount = function (index, slotCount, usedSlotCountMap) {
    usedSlotCountMap[index] = slotCount;
};
var _isSlotAllUsed = requireCheckFunc(function (currentUsedSlotCount, currentSlotCount) {
    it$$1("usedSlotCount should <= slotCount", function () {
        wdet_1(currentUsedSlotCount).lte(currentSlotCount);
    });
}, function (currentUsedSlotCount, currentSlotCount) {
    return currentUsedSlotCount === currentSlotCount;
});
var _allocateDoubleSlotCountAndAddTag = function (indexInArray, index, tag, currentSlotCount, currentUsedSlotCount, TagData$$1) {
    var spliceArr = [indexInArray + currentUsedSlotCount, 0, tag], tagArray = TagData$$1.tagArray;
    for (var i = 0, len = currentSlotCount - 1; i < len; i++) {
        spliceArr.push(null);
    }
    Array.prototype.splice.apply(tagArray, spliceArr);
    return currentSlotCount;
};
var _convertTagIndexToIndexInArray = function (tagIndex, TagData$$1) {
    return TagData$$1.indexInTagArrayMap[tagIndex];
};
var _convertIndexInArrayToTagIndex = function (indexInTagArray, TagData$$1) {
    return TagData$$1.indexMap[indexInTagArray];
};
var disposeComponent$3 = ensureFunc$$1(function (returnVal, tag) {
    it$$1("count should >= 0", function () {
        wdet_1(TagData.count).gte(0);
    });
}, function (tag) {
    var index = tag.index, indexInTagArray = _convertTagIndexToIndexInArray(index, TagData), currentUsedSlotCount = getUsedSlotCount(index, TagData.usedSlotCountMap), tagArray = TagData.tagArray;
    for (var i = indexInTagArray, count = indexInTagArray + currentUsedSlotCount; i < count; i++) {
        tagArray[i] = void 0;
    }
    deleteVal$1(indexInTagArray, TagData.indexMap);
    TagData.count -= 1;
    markComponentIndexRemoved(TagData.tagMap[index]);
    TagData.disposeCount += 1;
    if (isDisposeTooManyComponents(TagData.disposeCount)) {
        reAllocateTag(TagData);
        TagData.disposeCount = 0;
    }
});
var getGameObject$2 = function (index, Data) {
    return getComponentGameObject(Data.gameObjectMap, index);
};
var findGameObjectsByTag = function (targetTag, TagData$$1) {
    var gameObjectArr = [], gameObjectMap = TagData$$1.gameObjectMap;
    forEach(TagData$$1.tagArray, function (tag, indexInTagArray) {
        if (tag === targetTag) {
            gameObjectArr.push(gameObjectMap[_convertIndexInArrayToTagIndex(indexInTagArray, TagData$$1)]);
        }
    });
    return gameObjectArr;
};
var initData$12 = function (TagData$$1) {
    TagData$$1.tagArray = [];
    TagData$$1.slotCountMap = [];
    TagData$$1.usedSlotCountMap = [];
    TagData$$1.indexMap = [];
    TagData$$1.indexInTagArrayMap = [0];
    TagData$$1.gameObjectMap = createMap();
    TagData$$1.tagMap = createMap();
    TagData$$1.lastIndexInTagArray = 0;
    TagData$$1.index = 0;
    TagData$$1.count = 0;
    TagData$$1.disposeCount = 0;
};

var MemoryConfig = {
    maxComponentDisposeCount: 1000
};

var isDisposeTooManyComponents = function (disposeCount, maxComponentDisposeCount) {
    if (maxComponentDisposeCount === void 0) { maxComponentDisposeCount = MemoryConfig.maxComponentDisposeCount; }
    return disposeCount >= maxComponentDisposeCount;
};
var _setMapVal = function (map, key, val) {
    map[key] = val;
};
var _setArrayVal = function (arr, index, val) {
    arr[index] = val;
};
var reAllocateThreeDTransform = function (ThreeDTransformData) {
    var val = null, newParentMap = createMap(), newChildrenMap = createMap(), newIsTranslateMap = createMap(), newGameObjectMap = createMap(), newTempMap = createMap(), newAliveUIdArray = [], aliveUIdArray = ThreeDTransformData.aliveUIdArray, parentMap = ThreeDTransformData.parentMap, childrenMap = ThreeDTransformData.childrenMap, isTranslateMap = ThreeDTransformData.isTranslateMap, gameObjectMap = ThreeDTransformData.gameObjectMap, tempMap = ThreeDTransformData.tempMap;
    clearCacheMap(ThreeDTransformData);
    var disposedUIdArr = [], actualAliveUIdArr = [];
    for (var _i = 0, aliveUIdArray_1 = aliveUIdArray; _i < aliveUIdArray_1.length; _i++) {
        var uid = aliveUIdArray_1[_i];
        val = childrenMap[uid];
        if (isNotValidMapValue(val)) {
            disposedUIdArr.push(uid);
        }
        else {
            actualAliveUIdArr.push(uid);
        }
    }
    _cleanChildrenMap(disposedUIdArr, parentMap, isAlive$1, getChildren$1, setChildren$1, ThreeDTransformData);
    for (var _a = 0, actualAliveUIdArr_1 = actualAliveUIdArr; _a < actualAliveUIdArr_1.length; _a++) {
        var uid = actualAliveUIdArr_1[_a];
        val = childrenMap[uid];
        newAliveUIdArray.push(uid);
        _setMapVal(newChildrenMap, uid, val);
        val = tempMap[uid];
        _setMapVal(newTempMap, uid, val);
        val = parentMap[uid];
        _setMapVal(newParentMap, uid, val);
        val = isTranslateMap[uid];
        _setMapVal(newIsTranslateMap, uid, val);
        val = gameObjectMap[uid];
        _setMapVal(newGameObjectMap, uid, val);
    }
    ThreeDTransformData.parentMap = newParentMap;
    ThreeDTransformData.childrenMap = newChildrenMap;
    ThreeDTransformData.isTranslateMap = newIsTranslateMap;
    ThreeDTransformData.tempMap = newTempMap;
    ThreeDTransformData.gameObjectMap = newGameObjectMap;
    ThreeDTransformData.aliveUIdArray = newAliveUIdArray;
};
var reAllocateGameObject = function (GameObjectData) {
    var val = null, newParentMap = createMap(), newChildrenMap = createMap(), newComponentMap = createMap(), newAliveUIdArray = [], aliveUIdArray = GameObjectData.aliveUIdArray, parentMap = GameObjectData.parentMap, childrenMap = GameObjectData.childrenMap, componentMap = GameObjectData.componentMap, disposedUIdArr = [], actualAliveUIdArr = [];
    for (var _i = 0, aliveUIdArray_2 = aliveUIdArray; _i < aliveUIdArray_2.length; _i++) {
        var uid = aliveUIdArray_2[_i];
        val = componentMap[uid];
        if (isNotValidMapValue(val)) {
            disposedUIdArr.push(uid);
        }
        else {
            actualAliveUIdArr.push(uid);
        }
    }
    _cleanChildrenMap(disposedUIdArr, parentMap, isAlive, getChildren, setChildren, GameObjectData);
    for (var _a = 0, actualAliveUIdArr_2 = actualAliveUIdArr; _a < actualAliveUIdArr_2.length; _a++) {
        var uid = actualAliveUIdArr_2[_a];
        val = componentMap[uid];
        newAliveUIdArray.push(uid);
        _setMapVal(newComponentMap, uid, val);
        val = parentMap[uid];
        _setMapVal(newParentMap, uid, val);
        val = childrenMap[uid];
        _setMapVal(newChildrenMap, uid, val);
    }
    GameObjectData.parentMap = newParentMap;
    GameObjectData.childrenMap = newChildrenMap;
    GameObjectData.componentMap = newComponentMap;
    GameObjectData.aliveUIdArray = newAliveUIdArray;
};
var _cleanChildrenMap = function (disposedUIdArr, parentMap, isAlive$$1, getChildren$$1, setChildren$$1, Data) {
    var isCleanedParentMap = createMap();
    for (var _i = 0, disposedUIdArr_1 = disposedUIdArr; _i < disposedUIdArr_1.length; _i++) {
        var uid = disposedUIdArr_1[_i];
        var parent = parentMap[uid];
        if (_isParentExist$1(parent)) {
            var parentUId = parent.uid;
            if (isValidMapValue(isCleanedParentMap[parentUId])) {
                continue;
            }
            _cleanChildren(parentUId, isAlive$$1, getChildren$$1, setChildren$$1, Data);
            deleteVal$1(uid, parentMap);
        }
    }
};
var _cleanChildren = function (parentUId, isAlive$$1, getChildren$$1, setChildren$$1, Data) {
    var children = getChildren$$1(parentUId, Data);
    if (!_isChildrenExist$1(children)) {
        return;
    }
    var newChildren = [];
    for (var i = 0, len = children.length; i < len; ++i) {
        var child = children[i];
        if (isAlive$$1(child, Data)) {
            newChildren.push(child);
        }
    }
    setChildren$$1(parentUId, newChildren, Data);
};
var _isParentExist$1 = function (parent) { return isNotUndefined(parent); };
var _isChildrenExist$1 = function (children) { return isNotUndefined(children); };
var reAllocateTag = function (TagData) {
    var usedSlotCountMap = TagData.usedSlotCountMap, slotCountMap = TagData.slotCountMap, indexMap = TagData.indexMap, tagArray = TagData.tagArray, gameObjectMap = TagData.gameObjectMap, indexInTagArrayMap = TagData.indexInTagArrayMap, tagMap = TagData.tagMap, newIndexInTagArrayMap = [0], newTagArray = [], newGameObjectMap = createMap(), newUsedSlotCountMap = [], newSlotCountMap = [], newIndexMap = [], newTagMap = createMap(), newIndexInTagArray = 0, newIndexInTagArrayInMap = null, newIndex = 0, newLastIndexInTagArray = 0, hasNewData = false, tagIndex = null;
    for (var _i = 0, indexInTagArrayMap_1 = indexInTagArrayMap; _i < indexInTagArrayMap_1.length; _i++) {
        var indexInTagArray = indexInTagArrayMap_1[_i];
        var index = indexMap[indexInTagArray];
        if (isNotValidVal(index)) {
            continue;
        }
        hasNewData = true;
        var currentUsedSlotCount = getUsedSlotCount(index, usedSlotCountMap), tag = tagMap[index];
        newGameObjectMap[newIndex] = gameObjectMap[index];
        newSlotCountMap[newIndex] = getSlotCount(index, slotCountMap);
        newUsedSlotCountMap[newIndex] = currentUsedSlotCount;
        newIndexInTagArrayInMap = newIndexInTagArray;
        newIndexInTagArrayMap[newIndex] = newIndexInTagArrayInMap;
        tag.index = newIndex;
        newTagMap[newIndex] = tag;
        for (var i = indexInTagArray, count = indexInTagArray + currentUsedSlotCount; i < count; i++) {
            newTagArray[newIndexInTagArray] = tagArray[i];
            newIndexMap[newIndexInTagArray] = newIndex;
            newIndexInTagArray += 1;
        }
        newIndex += 1;
    }
    if (hasNewData) {
        newIndex -= 1;
        newLastIndexInTagArray = newIndexInTagArrayInMap + getSlotCount(newIndex, newSlotCountMap);
        tagIndex = newIndex + 1;
    }
    else {
        tagIndex = 0;
    }
    setNextIndexInTagArrayMap(newIndex, newSlotCountMap[newIndex], newIndexInTagArrayMap);
    TagData.slotCountMap = newSlotCountMap;
    TagData.usedSlotCountMap = newUsedSlotCountMap;
    TagData.gameObjectMap = newGameObjectMap;
    TagData.tagMap = newTagMap;
    TagData.indexMap = newIndexMap;
    TagData.indexInTagArrayMap = newIndexInTagArrayMap;
    TagData.lastIndexInTagArray = newLastIndexInTagArray;
    TagData.tagArray = newTagArray;
    TagData.index = tagIndex;
};
var reAllocateGeometry = ensureFunc$$1(function (returnVal, GeometryData) {
    checkIndexShouldEqualCount(GeometryData);
}, function (GeometryData) {
    var val = null, index = GeometryData.index, vertices = GeometryData.vertices, normals = GeometryData.normals, texCoords = GeometryData.texCoords, indices = GeometryData.indices, verticesInfoList = GeometryData.verticesInfoList, normalsInfoList = GeometryData.normalsInfoList, texCoordsInfoList = GeometryData.texCoordsInfoList, indicesInfoList = GeometryData.indicesInfoList, gameObjectMap = GeometryData.gameObjectMap, geometryMap = GeometryData.geometryMap, computeDataFuncMap = GeometryData.computeDataFuncMap, configDataMap = GeometryData.configDataMap, verticesCacheMap = GeometryData.verticesCacheMap, normalsCacheMap = GeometryData.normalsCacheMap, texCoordsCacheMap = GeometryData.texCoordsCacheMap, indicesCacheMap = GeometryData.indicesCacheMap, newIndexInArrayBuffer = 0, newVerticesOffset = 0, newNormalsOffset = 0, newTexCoordsOffset = 0, newIndicesOffset = 0, newVertivesInfoList = [], newNormalsInfoList = [], newTexCoordsInfoList = [], newIndicesInfoList = [], newGameObjectMap = createMap(), newGeometryMap = createMap(), newComputeDatafuncMap = createMap(), newConfigDataMap = [], newVerticesCacheMap = [], newNormalsCacheMap = [], newTexCoordsCacheMap = [], newIndicesCacheMap = [], newVertices = [], newNormals = [], newTexCoords = [], newIndices = [], disposedIndexArray = [];
    for (var i = 0; i < index; i++) {
        val = geometryMap[i];
        if (isNotValidMapValue(val)) {
            disposedIndexArray.push(i);
            continue;
        }
        var verticesInfo = verticesInfoList[i], normalsInfo = normalsInfoList[i], texCoordsInfo = texCoordsInfoList[i], indicesInfo = indicesInfoList[i];
        _updateInfoList(newVertivesInfoList, newIndexInArrayBuffer, verticesInfo, newVerticesOffset);
        if (isValidVal(normalsInfo)) {
            _updateInfoList(newNormalsInfoList, newIndexInArrayBuffer, normalsInfo, newNormalsOffset);
        }
        if (isValidVal(texCoordsInfo)) {
            _updateInfoList(newTexCoordsInfoList, newIndexInArrayBuffer, texCoordsInfo, newTexCoordsOffset);
        }
        _updateInfoList(newIndicesInfoList, newIndexInArrayBuffer, indicesInfo, newIndicesOffset);
        newVerticesOffset = _fillTypeArr(newVertices, newVerticesOffset, vertices, verticesInfo.startIndex, verticesInfo.endIndex);
        if (isValidVal(normalsInfo)) {
            newNormalsOffset = _fillTypeArr(newNormals, newNormalsOffset, normals, normalsInfo.startIndex, normalsInfo.endIndex);
        }
        if (isValidVal(texCoordsInfo)) {
            newTexCoordsOffset = _fillTypeArr(newTexCoords, newTexCoordsOffset, texCoords, texCoordsInfo.startIndex, texCoordsInfo.endIndex);
        }
        newIndicesOffset = _fillTypeArr(newIndices, newIndicesOffset, indices, indicesInfo.startIndex, indicesInfo.endIndex);
        _updateComponentIndex(geometryMap, newGeometryMap, i, newIndexInArrayBuffer);
        val = computeDataFuncMap[i];
        _setMapVal(newComputeDatafuncMap, newIndexInArrayBuffer, val);
        val = configDataMap[i];
        _setMapVal(newConfigDataMap, newIndexInArrayBuffer, val);
        val = verticesCacheMap[i];
        _setMapVal(newVerticesCacheMap, newIndexInArrayBuffer, val);
        val = normalsCacheMap[i];
        _setMapVal(newNormalsCacheMap, newIndexInArrayBuffer, val);
        val = texCoordsCacheMap[i];
        _setMapVal(newTexCoordsCacheMap, newIndexInArrayBuffer, val);
        val = indicesCacheMap[i];
        _setMapVal(newIndicesCacheMap, newIndexInArrayBuffer, val);
        val = geometryMap[i];
        _setMapVal(newGeometryMap, newIndexInArrayBuffer, val);
        val = gameObjectMap[i];
        _setMapVal(newGameObjectMap, newIndexInArrayBuffer, val);
        newIndexInArrayBuffer += 1;
    }
    set(GeometryData.vertices, newVertices);
    set(GeometryData.normals, newNormals);
    set(GeometryData.texCoords, newTexCoords);
    set(GeometryData.indices, newIndices);
    GeometryData.gameObjectMap = newGameObjectMap;
    GeometryData.verticesInfoList = newVertivesInfoList;
    GeometryData.normalsInfoList = newNormalsInfoList;
    GeometryData.texCoordsInfoList = newTexCoordsInfoList;
    GeometryData.indicesInfoList = newIndicesInfoList;
    GeometryData.geometryMap = newGeometryMap;
    GeometryData.computeDataFuncMap = newComputeDatafuncMap;
    GeometryData.configDataMap = newConfigDataMap;
    GeometryData.verticesCacheMap = newVerticesCacheMap;
    GeometryData.normalsCacheMap = newNormalsCacheMap;
    GeometryData.texCoordsCacheMap = newTexCoordsCacheMap;
    GeometryData.indicesCacheMap = newIndicesCacheMap;
    GeometryData.verticesOffset = newVerticesOffset;
    GeometryData.normalsOffset = newNormalsOffset;
    GeometryData.texCoordsOffset = newTexCoordsOffset;
    GeometryData.indicesOffset = newIndicesOffset;
    GeometryData.index = newIndexInArrayBuffer;
    return disposedIndexArray;
});
var _updateComponentIndex = function (componentMap, newComponentMap, oldIndex, newIndex) {
    var component = componentMap[oldIndex];
    component.index = newIndex;
    newComponentMap[newIndex] = component;
};
var _fillTypeArr = requireCheckFunc(function (targetTypeArr, targetStartIndex, sourceTypeArr, startIndex, endIndex) {
}, function (targetTypeArr, targetStartIndex, sourceTypeArr, startIndex, endIndex) {
    var typeArrIndex = targetStartIndex;
    for (var i = startIndex; i < endIndex; i++) {
        targetTypeArr[typeArrIndex] = sourceTypeArr[i];
        typeArrIndex += 1;
    }
    return typeArrIndex;
});
var _updateInfoList = ensureFunc$$1(function (returnVal, newInfoList, newIndexInArrayBuffer, info, offset) {
    it$$1("info.startIndex should >= 0", function () {
        wdet_1(newInfoList[newIndexInArrayBuffer].startIndex).gte(0);
    });
}, function (newInfoList, newIndexInArrayBuffer, info, offset) {
    var increment = info.endIndex - info.startIndex;
    _setArrayVal(newInfoList, newIndexInArrayBuffer, {
        startIndex: offset,
        endIndex: offset + increment
    });
});

var _data = {};
var registerEvent = function (eventName, func) {
    if (!_data[eventName]) {
        _data[eventName] = [];
    }
    _data[eventName].push(func);
};
var triggerEvent = function (eventName) {
    if (!_data[eventName]) {
        return;
    }
    forEach(_data[eventName], function (func) {
        func();
    });
};

var addAddComponentHandle$2 = function (_class) {
    addAddComponentHandle(_class, addComponent$2);
};
var addDisposeHandle$2 = function (_class) {
    addDisposeHandle(_class, disposeComponent$2);
};
var create$3 = ensureFunc$$1(function (transform, ThreeDTransformData$$1) {
    it$$1("componentMap should has data", function () {
        wdet_1(getChildren$1(transform.uid, ThreeDTransformData$$1)).exist;
    });
    it$$1("count should <= ThreeDTransformData.maxCount", function () {
        wdet_1(ThreeDTransformData$$1.count).lte(ThreeDTransformData$$1.maxCount);
    });
}, function (ThreeDTransformData$$1) {
    var transform = new ThreeDTransform(), index = _generateIndexInArrayBuffer(ThreeDTransformData$$1), uid = _buildUId$1(ThreeDTransformData$$1);
    transform.index = index;
    transform.uid = uid;
    ThreeDTransformData$$1.count += 1;
    _createTempData(uid, ThreeDTransformData$$1);
    _setTransformMap(index, transform, ThreeDTransformData$$1);
    setChildren$1(uid, [], ThreeDTransformData$$1);
    _setDefaultTypeArrData$1(index, ThreeDTransformData$$1);
    ThreeDTransformData$$1.aliveUIdArray.push(uid);
    return transform;
});
var _buildUId$1 = function (ThreeDTransformData$$1) {
    return ThreeDTransformData$$1.uid++;
};
var _generateIndexInArrayBuffer = function (ThreeDTransformData$$1) {
    return generateNotUsedIndexInArrayBuffer(ThreeDTransformData$$1);
};
var _createTempData = function (uid, ThreeDTransformData$$1) {
    ThreeDTransformData$$1.tempMap[uid] = {
        position: Vector3.create(),
        localPosition: Vector3.create(),
        localToWorldMatrix: Matrix4.create()
    };
    return ThreeDTransformData$$1;
};
var checkShouldAlive = function (component, ThreeDTransformData$$1) {
    checkComponentShouldAlive(component, ThreeDTransformData$$1, function (component, ThreeDTransformData$$1) {
        return isChildrenExist(getChildren$1(component.uid, ThreeDTransformData$$1));
    });
};
var init$1 = function (GlobalTempData$$1, ThreeDTransformData$$1, state) {
    return update$1(null, GlobalTempData$$1, ThreeDTransformData$$1, state);
};
var addComponent$2 = function (transform, gameObject) {
    var index = transform.index, uid = transform.uid;
    addComponentToGameObjectMap(ThreeDTransformData.gameObjectMap, uid, gameObject);
    return addItAndItsChildrenToDirtyList(index, uid, ThreeDTransformData);
};
var isAlive$1 = function (transform, ThreeDTransformData$$1) {
    return isValidMapValue(ThreeDTransformData$$1.transformMap[transform.index]);
};
var isNotAlive$1 = function (transform, ThreeDTransformData$$1) {
    return !isAlive$1(transform, ThreeDTransformData$$1);
};
var disposeComponent$2 = function (transform) {
    var index = transform.index, uid = transform.uid;
    if (isNotDirty(index, ThreeDTransformData.firstDirtyIndex)) {
        _disposeFromNormalList(index, uid, GlobalTempData, ThreeDTransformData);
    }
    else {
        _disposeFromDirtyList(index, uid, GlobalTempData, ThreeDTransformData);
    }
    ThreeDTransformData.count -= 1;
    ThreeDTransformData.disposeCount += 1;
    if (isDisposeTooManyComponents(ThreeDTransformData.disposeCount)) {
        reAllocateThreeDTransform(ThreeDTransformData);
        ThreeDTransformData.disposeCount = 0;
    }
};
var getGameObject$1 = function (uid, ThreeDTransformData$$1) { return getComponentGameObject(ThreeDTransformData$$1.gameObjectMap, uid); };
var getParent$1 = function (transform, ThreeDTransformData$$1) {
    var parent = getParent$2(transform.uid, ThreeDTransformData$$1);
    if (isValidMapValue(parent)) {
        return parent;
    }
    return null;
};
var setParent$1 = function (parent, child, ThreeDTransformData$$1) { return setParent$2(parent, child, ThreeDTransformData$$1); };
var getLocalToWorldMatrix = requireCheckFunc(function (transform, mat, ThreeDTransformData$$1) {
    checkTransformShouldAlive(transform, ThreeDTransformData$$1);
}, cacheFunc(function (transform, mat, ThreeDTransformData$$1) {
    return isValidMapValue(getLocalToWorldMatrixCache(transform.uid, ThreeDTransformData$$1));
}, function (transform, mat, ThreeDTransformData$$1) {
    return getLocalToWorldMatrixCache(transform.uid, ThreeDTransformData$$1);
}, function (transform, mat, ThreeDTransformData$$1, returnedMat) {
    setLocalToWorldMatrixCache(transform.uid, returnedMat, ThreeDTransformData$$1);
}, function (transform, mat, ThreeDTransformData$$1) {
    return createMatrix4ByIndex(mat, ThreeDTransformData$$1.localToWorldMatrices, getMatrix4DataIndexInArrayBuffer(transform.index));
}));
var getPosition = requireCheckFunc(function (transform, ThreeDTransformData$$1) {
    checkTransformShouldAlive(transform, ThreeDTransformData$$1);
}, cacheFunc(function (transform, ThreeDTransformData$$1) {
    return isValidMapValue(getPositionCache(transform.uid, ThreeDTransformData$$1));
}, function (transform, ThreeDTransformData$$1) {
    return getPositionCache(transform.uid, ThreeDTransformData$$1);
}, function (transform, ThreeDTransformData$$1, position) {
    setPositionCache(transform.uid, position, ThreeDTransformData$$1);
}, function (transform, ThreeDTransformData$$1) {
    var index = getMatrix4DataIndexInArrayBuffer(transform.index), localToWorldMatrices = ThreeDTransformData$$1.localToWorldMatrices;
    return _getTempData(transform.uid, ThreeDTransformData$$1).position.set(localToWorldMatrices[index + 12], localToWorldMatrices[index + 13], localToWorldMatrices[index + 14]);
}));
var getNormalMatrix = requireCheckFunc(function (transform, GlobalTempData$$1, ThreeDTransformData$$1) {
    checkTransformShouldAlive(transform, ThreeDTransformData$$1);
}, cacheFunc(function (transform, GlobalTempData$$1, ThreeDTransformData$$1) {
    return isValidMapValue(getNormalMatrixCache(transform.uid, ThreeDTransformData$$1));
}, function (transform, GlobalTempData$$1, ThreeDTransformData$$1) {
    return getNormalMatrixCache(transform.uid, ThreeDTransformData$$1);
}, function (transform, GlobalTempData$$1, ThreeDTransformData$$1, mat) {
    setNormalMatrixCache(transform.uid, mat, ThreeDTransformData$$1);
}, function (transform, GlobalTempData$$1, ThreeDTransformData$$1) {
    return getLocalToWorldMatrix(transform, GlobalTempData$$1.matrix4_1, ThreeDTransformData$$1).invertTo3x3().transpose();
}));
var _setTransformMap = function (index, transform, ThreeDTransformData$$1) { return ThreeDTransformData$$1.transformMap[index] = transform; };
var setPosition = requireCheckFunc(function (transform, position, GlobalTempData$$1, ThreeDTransformData$$1) {
    checkTransformShouldAlive(transform, ThreeDTransformData$$1);
}, function (transform, position, GlobalTempData$$1, ThreeDTransformData$$1) {
    var index = transform.index, uid = transform.uid, parent = getParent$2(uid, ThreeDTransformData$$1), vec3IndexInArrayBuffer = getVector3DataIndexInArrayBuffer(index);
    setPositionData(index, parent, vec3IndexInArrayBuffer, position, GlobalTempData$$1, ThreeDTransformData$$1);
    _triggerChangePositionEvent(uid, ThreeDTransformData$$1);
    return addItAndItsChildrenToDirtyList(index, uid, ThreeDTransformData$$1);
});
var setBatchDatas$$1 = function (batchData, GlobalTempData$$1, ThreeDTransformData$$1) { return setBatchDatas$1(batchData, GlobalTempData$$1, ThreeDTransformData$$1); };
var getLocalPosition = requireCheckFunc(function (transform, ThreeDTransformData$$1) {
    checkTransformShouldAlive(transform, ThreeDTransformData$$1);
}, cacheFunc(function (transform, ThreeDTransformData$$1) {
    return isValidMapValue(getLocalPositionCache(transform.uid, ThreeDTransformData$$1));
}, function (transform, ThreeDTransformData$$1) {
    return getLocalPositionCache(transform.uid, ThreeDTransformData$$1);
}, function (transform, ThreeDTransformData$$1, position) {
    setLocalPositionCache(transform.uid, position, ThreeDTransformData$$1);
}, function (transform, ThreeDTransformData$$1) {
    return createVector3ByIndex(_getTempData(transform.uid, ThreeDTransformData$$1).localPosition, ThreeDTransformData$$1.localPositions, getVector3DataIndexInArrayBuffer(transform.index));
}));
var setLocalPosition = requireCheckFunc(function (transform, position, ThreeDTransformData$$1) {
    checkTransformShouldAlive(transform, ThreeDTransformData$$1);
}, function (transform, position, ThreeDTransformData$$1) {
    var index = transform.index, uid = transform.uid, vec3IndexInArrayBuffer = getVector3DataIndexInArrayBuffer(index);
    setLocalPositionData(position, vec3IndexInArrayBuffer, ThreeDTransformData$$1);
    _triggerChangePositionEvent(uid, ThreeDTransformData$$1);
    return addItAndItsChildrenToDirtyList(index, uid, ThreeDTransformData$$1);
});
var _triggerChangePositionEvent = function (uid, ThreeDTransformData$$1) {
    triggerEvent("changePosition");
};
var update$1 = function (elapsed, GlobalTempData$$1, ThreeDTransformData$$1, state) {
    return update$2(elapsed, GlobalTempData$$1, ThreeDTransformData$$1, state);
};
var _disposeItemInDataContainer = function (index, uid, GlobalTempData$$1, ThreeDTransformData$$1) {
    removeHierarchyData(uid, ThreeDTransformData$$1);
    _disposeMapDatas$1(index, uid, ThreeDTransformData$$1);
    return ThreeDTransformData$$1;
};
var _disposeMapDatas$1 = function (index, uid, ThreeDTransformData$$1) {
    deleteVal$1(index, ThreeDTransformData$$1.transformMap);
};
var _disposeFromNormalList = function (index, uid, GlobalTempData$$1, ThreeDTransformData$$1) {
    addNotUsedIndex(index, ThreeDTransformData$$1.notUsedIndexLinkList);
    return _disposeItemInDataContainer(index, uid, GlobalTempData$$1, ThreeDTransformData$$1);
};
var _disposeFromDirtyList = function (index, uid, GlobalTempData$$1, ThreeDTransformData$$1) {
    var firstDirtyIndex = ThreeDTransformData$$1.firstDirtyIndex;
    swap(index, firstDirtyIndex, ThreeDTransformData$$1);
    _disposeItemInDataContainer(firstDirtyIndex, uid, GlobalTempData$$1, ThreeDTransformData$$1);
    ThreeDTransformData$$1.firstDirtyIndex = addFirstDirtyIndex(ThreeDTransformData$$1);
};
var _setDefaultTypeArrData$1 = function (index, ThreeDTransformData$$1) {
    setTransformDataInTypeArr(index, ThreeDTransformData$$1.defaultLocalToWorldMatrice, ThreeDTransformData$$1.defaultRotation, ThreeDTransformData$$1.defaultPosition, ThreeDTransformData$$1.defaultScale, ThreeDTransformData$$1);
};
var getTempLocalToWorldMatrix = function (transform, ThreeDTransformData$$1) { return _getTempData(transform.uid, ThreeDTransformData$$1).localToWorldMatrix; };
var _getTempData = function (uid, ThreeDTransformData$$1) {
    var tempData = ThreeDTransformData$$1.tempMap[uid];
    if (isNotValidMapValue(tempData)) {
        tempData = {};
        ThreeDTransformData$$1.tempMap[uid] = tempData;
    }
    return tempData;
};
var initData$11 = function (GlobalTempData$$1, ThreeDTransformData$$1) {
    _initBufferData$1(ThreeDTransformData$$1);
    ThreeDTransformData$$1.defaultPosition = Vector3.create(0, 0, 0);
    ThreeDTransformData$$1.defaultRotation = Quaternion.create(0, 0, 0, 1);
    ThreeDTransformData$$1.defaultScale = Vector3.create(1, 1, 1);
    ThreeDTransformData$$1.defaultLocalToWorldMatrice = Matrix4.create().setIdentity();
    ThreeDTransformData$$1.notUsedIndexLinkList = LinkList.create();
    ThreeDTransformData$$1.parentMap = createMap();
    ThreeDTransformData$$1.childrenMap = createMap();
    ThreeDTransformData$$1.isTranslateMap = createMap();
    ThreeDTransformData$$1.cacheMap = createMap();
    ThreeDTransformData$$1.tempMap = createMap();
    ThreeDTransformData$$1.transformMap = createMap();
    ThreeDTransformData$$1.gameObjectMap = createMap();
    ThreeDTransformData$$1.firstDirtyIndex = ThreeDTransformData$$1.maxCount;
    ThreeDTransformData$$1.index = getStartIndexInArrayBuffer();
    ThreeDTransformData$$1.uid = 0;
    ThreeDTransformData$$1.disposeCount = 0;
    ThreeDTransformData$$1.isClearCacheMap = false;
    ThreeDTransformData$$1.count = 0;
    ThreeDTransformData$$1.aliveUIdArray = [];
};
var _initBufferData$1 = function (ThreeDTransformData$$1) {
    var buffer = null, count = ThreeDTransformData$$1.maxCount, size = Float32Array.BYTES_PER_ELEMENT * (getMatrix4DataSize() + getVector3DataSize() + getQuaternionDataSize() + getVector3DataSize());
    buffer = new ArrayBuffer(count * size);
    ThreeDTransformData$$1.localToWorldMatrices = new Float32Array(buffer, 0, count * getMatrix4DataSize());
    ThreeDTransformData$$1.localPositions = new Float32Array(buffer, count * Float32Array.BYTES_PER_ELEMENT * getMatrix4DataSize(), count * getVector3DataSize());
    ThreeDTransformData$$1.localRotations = new Float32Array(buffer, count * Float32Array.BYTES_PER_ELEMENT * (getMatrix4DataSize() + getVector3DataSize()), count * getQuaternionDataSize());
    ThreeDTransformData$$1.localScales = new Float32Array(buffer, count * Float32Array.BYTES_PER_ELEMENT * (getMatrix4DataSize() + getVector3DataSize() + getQuaternionDataSize()), count * getVector3DataSize());
    ThreeDTransformData$$1.buffer = buffer;
};

var checkGameObjectShouldAlive = function (gameObject, GameObjectData) {
    it$$1("gameObject is diposed, should release it", function () {
        wdet_1(isAlive(gameObject, GameObjectData)).true;
    });
};

var DirectorData = (function () {
    function DirectorData() {
    }
    DirectorData.state = null;
    DirectorData.isInit = null;
    return DirectorData;
}());

var _generateComponentId = function () {
    var result = _componentId;
    _componentId += 1;
    return String(result);
};
var getComponentIdFromClass = function (_class) {
    return _table$1[ClassUtils.getClassNameByClass(_class)];
};
var getComponentIdFromComponent = function (component) {
    return _table$1[ClassUtils.getClassNameByInstance(component)];
};
var _addComponentId = function (componentClassNameArr, table) {
    var id = _generateComponentId();
    for (var _i = 0, componentClassNameArr_1 = componentClassNameArr; _i < componentClassNameArr_1.length; _i++) {
        var className = componentClassNameArr_1[_i];
        table[className] = id;
    }
};
var _componentId = 1;
var _table$1 = {};
_addComponentId(["ThreeDTransform"], _table$1);
_addComponentId(["Geometry", "BoxGeometry", "CustomGeometry"], _table$1);
_addComponentId(["Material", "BasicMaterial", "LightMaterial"], _table$1);
_addComponentId(["MeshRenderer"], _table$1);
_addComponentId(["Tag"], _table$1);
_addComponentId(["CameraController"], _table$1);
_addComponentId(["Light", "AmbientLight", "DirectionLight", "PointLight"], _table$1);

var GameObject = (function () {
    function GameObject() {
        this.uid = null;
    }
    GameObject = __decorate([
        registerClass$1("GameObject")
    ], GameObject);
    return GameObject;
}());
var createGameObject = function () { return create$2(create$3(ThreeDTransformData), GameObjectData); };
var addGameObjectComponent = requireCheckFunc(function (gameObject, component) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject, component) {
    addComponent$1(gameObject, component, GameObjectData);
});
var disposeGameObject = requireCheckFunc(function (gameObject) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject) {
    dispose$1(gameObject, ThreeDTransformData, GameObjectData);
});
var initGameObject$1 = requireCheckFunc(function (gameObject) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject) {
    initGameObject(gameObject, getState(DirectorData), GameObjectData);
});
var disposeGameObjectComponent = requireCheckFunc(function (gameObject, component) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject, component) {
    disposeComponent$1(gameObject.uid, component, GameObjectData);
});
var getGameObjectComponent = requireCheckFunc(function (gameObject, _class) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject, _class) {
    return getComponent(gameObject.uid, getComponentIdFromClass(_class), GameObjectData);
});
var getGameObjectTransform = requireCheckFunc(function (gameObject) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject) {
    return getTransform(gameObject.uid, GameObjectData);
});
var getGameObjectMaterial = requireCheckFunc(function (gameObject) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject) {
    return getMaterial(gameObject.uid, GameObjectData);
});
var getGameObjectAllComponents = requireCheckFunc(function (gameObject) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject) {
    return getAllComponents(gameObject.uid, GameObjectData);
});
var hasGameObjectComponent = requireCheckFunc(function (gameObject, _class) {
}, function (gameObject, _class) {
    return hasComponent(gameObject, getComponentIdFromClass(_class), GameObjectData);
});
var isGameObjectAlive = function (gameObject) {
    return isAlive(gameObject, GameObjectData);
};
var addGameObject = requireCheckFunc(function (gameObject, child) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject, child) {
    addChild(gameObject, child, ThreeDTransformData, GameObjectData);
});
var addRemovedGameObject = requireCheckFunc(function (gameObject, child) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject, child) {
    addRemovedChild(gameObject, child, MeshRendererData, ThreeDTransformData, GameObjectData);
});
var removeGameObject = requireCheckFunc(function (gameObject, child) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject, child) {
    removeChild(gameObject.uid, child.uid, ThreeDTransformData, GameObjectData);
});
var hasGameObject = requireCheckFunc(function (gameObject, child) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject, child) {
    return hasChild(gameObject, child, GameObjectData);
});
var getGameObjectChildren = requireCheckFunc(function (gameObject) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject) {
    return getAliveChildren(gameObject.uid, GameObjectData);
});
var getGameObjectParent = requireCheckFunc(function (gameObject) {
    checkGameObjectShouldAlive(gameObject, GameObjectData);
}, function (gameObject) {
    return getParent(gameObject.uid, GameObjectData);
});
var setGameObjectParent = requireCheckFunc(function (parent, child) {
    checkGameObjectShouldAlive(parent, GameObjectData);
}, function (parent, child) {
    return setParent$$1(parent, child, ThreeDTransformData, GameObjectData);
});

var GeometryData = (function () {
    function GeometryData() {
    }
    GeometryData.index = null;
    GeometryData.count = null;
    GeometryData.disposeCount = null;
    GeometryData.maxDisposeIndex = null;
    GeometryData.isReallocate = null;
    GeometryData.buffer = null;
    GeometryData.verticesOffset = null;
    GeometryData.normalsOffset = null;
    GeometryData.texCoordsOffset = null;
    GeometryData.indicesOffset = null;
    GeometryData.verticesInfoList = null;
    GeometryData.normalsInfoList = null;
    GeometryData.texCoordsInfoList = null;
    GeometryData.indicesInfoList = null;
    GeometryData.isInit = null;
    GeometryData.verticesWorkerInfoList = null;
    GeometryData.normalsWorkerInfoList = null;
    GeometryData.texCoordsWorkerInfoList = null;
    GeometryData.indicesWorkerInfoList = null;
    GeometryData.disposedGeometryIndexArray = null;
    GeometryData.vertices = null;
    GeometryData.normals = null;
    GeometryData.texCoords = null;
    GeometryData.indices = null;
    GeometryData.verticesCacheMap = null;
    GeometryData.normalsCacheMap = null;
    GeometryData.texCoordsCacheMap = null;
    GeometryData.indicesCacheMap = null;
    GeometryData.indexType = null;
    GeometryData.indexTypeSize = null;
    GeometryData.configDataMap = null;
    GeometryData.computeDataFuncMap = null;
    GeometryData.gameObjectMap = null;
    GeometryData.geometryMap = null;
    return GeometryData;
}());

var EBufferType;
(function (EBufferType) {
    EBufferType["BYTE"] = "BYTE";
    EBufferType["UNSIGNED_BYTE"] = "UNSIGNED_BYTE";
    EBufferType["SHORT"] = "SHORT";
    EBufferType["UNSIGNED_SHORT"] = "UNSIGNED_SHORT";
    EBufferType["INT"] = "INT";
    EBufferType["UNSIGNED_INT"] = "UNSIGNED_INT";
    EBufferType["FLOAT"] = "FLOAT";
})(EBufferType || (EBufferType = {}));

var EDrawMode;
(function (EDrawMode) {
    EDrawMode["POINTS"] = "POINTS";
    EDrawMode["LINES"] = "LINES";
    EDrawMode["LINE_LOOP"] = "LINE_LOOP";
    EDrawMode["LINE_STRIP"] = "LINE_STRIP";
    EDrawMode["TRIANGLES"] = "TRIANGLES";
    EDrawMode["TRIANGLE_STRIP"] = "TRIANGLE_STRIP";
    EDrawMode["TRANGLE_FAN"] = "TRIANGLE_FAN";
})(EDrawMode || (EDrawMode = {}));

var getVertexDataSize = function () { return 3; };
var getNormalDataSize = function () { return 3; };
var getTexCoordsDataSize = function () { return 2; };
var getIndexDataSize = function () { return 1; };
var getUIntArrayClass = function (indexType) {
    switch (indexType) {
        case EBufferType.UNSIGNED_SHORT:
            return Uint16Array;
        case EBufferType.INT:
            return Uint32Array;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_INVALID("indexType:" + indexType));
            break;
    }
};
var getIndexType$1 = function (GeometryDataFromSystem) {
    return GeometryDataFromSystem.indexType;
};
var getIndexTypeSize$1 = function (GeometryDataFromSystem) {
    return GeometryDataFromSystem.indexTypeSize;
};
var hasIndices$1 = function (index, getIndices, GeometryDataFromSystem) {
    var indices = getIndices(index, GeometryDataFromSystem);
    if (isNotValidMapValue(indices)) {
        return false;
    }
    return indices.length > 0;
};
var getDrawMode$2 = function (index, GeometryDataFromSystem) {
    return EDrawMode.TRIANGLES;
};
var getVerticesCount$1 = function (index, getVertices, GeometryDataFromSystem) {
    return getVertices(index, GeometryDataFromSystem).length;
};
var getIndicesCount$1 = function (index, getIndices, GeometryDataFromSystem) {
    return getIndices(index, GeometryDataFromSystem).length;
};
var createBufferViews = function (buffer, count, UintArray, GeometryDataFromSystem) {
    GeometryDataFromSystem.vertices = new Float32Array(buffer, 0, count * getVertexDataSize());
    GeometryDataFromSystem.normals = new Float32Array(buffer, count * Float32Array.BYTES_PER_ELEMENT * getVertexDataSize(), count * getVertexDataSize());
    GeometryDataFromSystem.texCoords = new Float32Array(buffer, count * Float32Array.BYTES_PER_ELEMENT * (getVertexDataSize() + getNormalDataSize()), count * getTexCoordsDataSize());
    GeometryDataFromSystem.indices = new UintArray(buffer, count * Float32Array.BYTES_PER_ELEMENT * (getVertexDataSize() + getNormalDataSize() + getTexCoordsDataSize()), count * getIndexDataSize());
};

var createSharedArrayBufferOrArrayBuffer = function (length) {
    var Buffer = null;
    if (isSupportSharedArrayBuffer()) {
        Buffer = SharedArrayBuffer;
    }
    else {
        Buffer = ArrayBuffer;
    }
    return new Buffer(length);
};

var addAddComponentHandle$4 = function (BoxGeometry, CustomGeometry) {
    addAddComponentHandle(BoxGeometry, addComponent$4);
    addAddComponentHandle(CustomGeometry, addComponent$4);
};
var addInitHandle$1 = function (BoxGeometry, CustomGeometry) {
    addInitHandle(BoxGeometry, initGeometry$1);
    addInitHandle(CustomGeometry, initGeometry$1);
};
var create$5 = requireCheckFunc(function (geometry, GeometryData$$1) {
}, function (geometry, GeometryData$$1) {
    var index = generateComponentIndex(GeometryData$$1);
    geometry.index = index;
    GeometryData$$1.count += 1;
    GeometryData$$1.geometryMap[index] = geometry;
    return geometry;
});
var init$2 = function (GeometryData$$1, state) {
    for (var i = 0, count = GeometryData$$1.count; i < count; i++) {
        initGeometry$1(i, state);
    }
    _markIsInit(GeometryData$$1);
    return state;
};
var initGeometry$1 = function (index, state) {
    var computeDataFunc = GeometryData.computeDataFuncMap[index];
    if (_isComputeDataFuncNotExist(computeDataFunc)) {
        return;
    }
    var _a = computeDataFunc(index, GeometryData), vertices = _a.vertices, normals = _a.normals, texCoords = _a.texCoords, indices = _a.indices;
    setVertices(index, vertices, GeometryData);
    setNormals(index, normals, GeometryData);
    setTexCoords(index, texCoords, GeometryData);
    setIndices(index, indices, GeometryData);
};
var _isComputeDataFuncNotExist = function (func) { return isNotValidMapValue(func); };
var getVertices$1 = function (index, GeometryData$$1) {
    return _getPointData(index, GeometryData$$1.vertices, GeometryData$$1.verticesCacheMap, GeometryData$$1.verticesInfoList);
};
var setVertices = requireCheckFunc(function (index, vertices, GeometryData$$1) {
}, function (index, vertices, GeometryData$$1) {
    GeometryData$$1.verticesOffset = _setPointData(index, vertices, getVertexDataSize(), GeometryData$$1.vertices, GeometryData$$1.verticesCacheMap, GeometryData$$1.verticesInfoList, GeometryData$$1.verticesWorkerInfoList, GeometryData$$1.verticesOffset, GeometryData$$1);
});
var getNormals$1 = function (index, GeometryData$$1) {
    return _getPointData(index, GeometryData$$1.normals, GeometryData$$1.normalsCacheMap, GeometryData$$1.normalsInfoList);
};
var setNormals = requireCheckFunc(function (index, normals, GeometryData$$1) {
}, function (index, normals, GeometryData$$1) {
    GeometryData$$1.normalsOffset = _setPointData(index, normals, getNormalDataSize(), GeometryData$$1.normals, GeometryData$$1.normalsCacheMap, GeometryData$$1.normalsInfoList, GeometryData$$1.normalsWorkerInfoList, GeometryData$$1.normalsOffset, GeometryData$$1);
});
var getTexCoords$1 = function (index, GeometryData$$1) {
    return _getPointData(index, GeometryData$$1.texCoords, GeometryData$$1.texCoordsCacheMap, GeometryData$$1.texCoordsInfoList);
};
var setTexCoords = requireCheckFunc(function (index, texCoords, GeometryData$$1) {
}, function (index, texCoords, GeometryData$$1) {
    GeometryData$$1.texCoordsOffset = _setPointData(index, texCoords, getTexCoordsDataSize(), GeometryData$$1.texCoords, GeometryData$$1.texCoordsCacheMap, GeometryData$$1.texCoordsInfoList, GeometryData$$1.texCoordsWorkerInfoList, GeometryData$$1.texCoordsOffset, GeometryData$$1);
});
var getIndices$1 = function (index, GeometryData$$1) {
    return _getPointData(index, GeometryData$$1.indices, GeometryData$$1.indicesCacheMap, GeometryData$$1.indicesInfoList);
};
var setIndices = requireCheckFunc(function (index, indices, GeometryData$$1) {
}, function (index, indices, GeometryData$$1) {
    GeometryData$$1.indicesOffset = _setPointData(index, indices, getIndexDataSize(), GeometryData$$1.indices, GeometryData$$1.indicesCacheMap, GeometryData$$1.indicesInfoList, GeometryData$$1.indicesWorkerInfoList, GeometryData$$1.indicesOffset, GeometryData$$1);
});
var _getPointData = requireCheckFunc(function (index, points, cacheMap, infoList) {
    it$$1("infoList[index] should exist", function () {
        wdet_1(infoList[index]).exist;
    });
}, function (index, points, cacheMap, infoList) {
    var dataArr = cacheMap[index];
    if (isValidMapValue(dataArr)) {
        return dataArr;
    }
    var info = infoList[index];
    dataArr = getSubarray(points, info.startIndex, info.endIndex);
    cacheMap[index] = dataArr;
    return dataArr;
});
var _setPointData = function (index, dataArr, dataSize, points, cacheMap, infoList, workerInfoList, offset, GeometryData$$1) {
    var count = dataArr.length, startIndex = offset;
    offset += count;
    infoList[index] = _buildInfo(startIndex, offset);
    fillTypeArr(points, dataArr, startIndex, count);
    _removeCache(index, cacheMap);
    if (_isInit(GeometryData$$1)) {
        _addWorkerInfo(workerInfoList, index, startIndex, offset);
    }
    return offset;
};
var _removeCache = function (index, cacheMap) {
    deleteVal$1(index, cacheMap);
};
var _buildInfo = function (startIndex, endIndex) {
    return {
        startIndex: startIndex,
        endIndex: endIndex
    };
};
var addComponent$4 = function (component, gameObject) {
    addComponentToGameObjectMap(GeometryData.gameObjectMap, component.index, gameObject);
};
var disposeComponent$4 = function (component, disposeBuffers) {
    var sourceIndex = component.index;
    deleteComponent(sourceIndex, GeometryData.geometryMap);
    GeometryData.count -= 1;
    GeometryData.disposeCount += 1;
    GeometryData.isReallocate = false;
    if (isDisposeTooManyComponents(GeometryData.disposeCount) || _isBufferNearlyFull(GeometryData)) {
        var disposedIndexArray = reAllocateGeometry(GeometryData);
        disposeBuffers(disposedIndexArray);
        clearWorkerInfoList(GeometryData);
        GeometryData.isReallocate = true;
        GeometryData.disposeCount = 0;
    }
};
var isReallocate = function (GeometryData$$1) {
    return GeometryData$$1.isReallocate;
};
var _isBufferNearlyFull = function (GeometryData$$1) {
    var infoList = GeometryData$$1.indicesInfoList, lastInfo = infoList[infoList.length - 1];
    if (isNotValidVal(lastInfo)) {
        return false;
    }
    return lastInfo.endIndex >= GeometryData$$1.maxDisposeIndex;
};
var getGameObject$3 = function (index, Data) {
    return getComponentGameObject(Data.gameObjectMap, index);
};
var getConfigData = function (index, GeometryData$$1) {
    return GeometryData$$1.configDataMap[index];
};
var _checkIsIndicesBufferNeed32BitsByConfig = function (DataBufferConfig, GPUDetectData) {
    if (DataBufferConfig.geometryIndicesBufferBits === 16) {
        return false;
    }
    return hasExtensionUintIndices(GPUDetectData) === true;
};

var _markIsInit = function (GeometryData$$1) {
    GeometryData$$1.isInit = true;
};
var _isInit = function (GeometryData$$1) {
    return GeometryData$$1.isInit;
};
var clearWorkerInfoList = function (GeometryData$$1) {
    GeometryData$$1.verticesWorkerInfoList = [];
    GeometryData$$1.normalsWorkerInfoList = [];
    GeometryData$$1.texCoordsWorkerInfoList = [];
    GeometryData$$1.indicesWorkerInfoList = [];
};
var hasNewPointData = function (GeometryData$$1) {
    return GeometryData$$1.verticesWorkerInfoList.length > 0;
};
var getDisposedGeometryIndexArrayData = function (GeometryData$$1) {
    return GeometryData$$1.disposedGeometryIndexArray;
};
var hasDisposedGeometryIndexArrayData = function (GeometryData$$1) {
    return GeometryData$$1.disposedGeometryIndexArray.length > 0;
};
var clearDisposedGeometryIndexArray = function (GeometryData$$1) {
    GeometryData$$1.disposedGeometryIndexArray = [];
};
var _addWorkerInfo = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    _addWorkerInfo = function (infoList, index, startIndex, endIndex) {
        infoList.push(_buildWorkerInfo(index, startIndex, endIndex));
    };
}
else {
    _addWorkerInfo = function (infoList, index, startIndex, endIndex) {
    };
}
var _buildWorkerInfo = function (index, startIndex, endIndex) {
    return {
        index: index,
        startIndex: startIndex,
        endIndex: endIndex
    };
};
var initData$13 = function (DataBufferConfig, GeometryData$$1, GPUDetectData) {
    var isIndicesBufferNeed32Bits = _checkIsIndicesBufferNeed32BitsByConfig(DataBufferConfig, GPUDetectData), indicesArrayBytes = null;
    if (isIndicesBufferNeed32Bits) {
        indicesArrayBytes = Uint32Array.BYTES_PER_ELEMENT;
        GeometryData$$1.indexType = EBufferType.UNSIGNED_INT;
    }
    else {
        indicesArrayBytes = Uint16Array.BYTES_PER_ELEMENT;
        GeometryData$$1.indexType = EBufferType.UNSIGNED_SHORT;
    }
    GeometryData$$1.indexTypeSize = indicesArrayBytes;
    GeometryData$$1.configDataMap = createMap();
    GeometryData$$1.verticesCacheMap = createMap();
    GeometryData$$1.normalsCacheMap = createMap();
    GeometryData$$1.texCoordsCacheMap = createMap();
    GeometryData$$1.indicesCacheMap = createMap();
    GeometryData$$1.computeDataFuncMap = createMap();
    GeometryData$$1.gameObjectMap = createMap();
    GeometryData$$1.geometryMap = createMap();
    GeometryData$$1.index = 0;
    GeometryData$$1.count = 0;
    _initBufferData$2(indicesArrayBytes, getUIntArrayClass(GeometryData$$1.indexType), DataBufferConfig, GeometryData$$1);
    GeometryData$$1.verticesInfoList = [];
    GeometryData$$1.normalsInfoList = [];
    GeometryData$$1.texCoordsInfoList = [];
    GeometryData$$1.indicesInfoList = [];
    GeometryData$$1.verticesWorkerInfoList = [];
    GeometryData$$1.normalsWorkerInfoList = [];
    GeometryData$$1.texCoordsWorkerInfoList = [];
    GeometryData$$1.indicesWorkerInfoList = [];
    GeometryData$$1.disposedGeometryIndexArray = [];
    GeometryData$$1.verticesOffset = 0;
    GeometryData$$1.normalsOffset = 0;
    GeometryData$$1.texCoordsOffset = 0;
    GeometryData$$1.indicesOffset = 0;
    GeometryData$$1.disposeCount = 0;
    GeometryData$$1.isReallocate = false;
};
var _initBufferData$2 = function (indicesArrayBytes, UintArray, DataBufferConfig, GeometryData$$1) {
    var buffer = null, count = DataBufferConfig.geometryDataBufferCount, size = Float32Array.BYTES_PER_ELEMENT * (getVertexDataSize() + getNormalDataSize() + getTexCoordsDataSize()) + indicesArrayBytes * getIndexDataSize();
    buffer = createSharedArrayBufferOrArrayBuffer(count * size);
    createBufferViews(buffer, count, UintArray, GeometryData$$1);
    GeometryData$$1.buffer = buffer;
    GeometryData$$1.maxDisposeIndex = GeometryData$$1.indices.length * 0.9;
};
var getIndexType$$1 = null;
var getIndexTypeSize$$1 = null;
var hasIndices$$1 = null;
var getDrawMode$1 = null;
var getVerticesCount$$1 = null;
var getIndicesCount$$1 = null;
if (!isSupportRenderWorkerAndSharedArrayBuffer()) {
    getIndexType$$1 = getIndexType$1;
    getIndexTypeSize$$1 = getIndexTypeSize$1;
    hasIndices$$1 = function (index, GeometryData$$1) { return hasIndices$1(index, getIndices$1, GeometryData$$1); };
    getDrawMode$1 = getDrawMode$2;
    getVerticesCount$$1 = function (index, GeometryData$$1) { return getVerticesCount$1(index, getVertices$1, GeometryData$$1); };
    getIndicesCount$$1 = function (index, GeometryData$$1) { return getIndicesCount$1(index, getIndices$1, GeometryData$$1); };
}

var Geometry = (function (_super) {
    __extends(Geometry, _super);
    function Geometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Geometry = __decorate([
        registerClass$1("Geometry")
    ], Geometry);
    return Geometry;
}(Component));
var getDrawMode$$1 = requireCheckFunc(function (geometry) {
    _checkShouldAlive$3(geometry, GeometryData);
}, function (geometry) {
    return getDrawMode$1(geometry.index, GeometryData);
});
var getVertices$$1 = requireCheckFunc(function (geometry) {
    _checkShouldAlive$3(geometry, GeometryData);
}, function (geometry) {
    return getVertices$1(geometry.index, GeometryData);
});
var getNormals$$1 = requireCheckFunc(function (geometry) {
    _checkShouldAlive$3(geometry, GeometryData);
}, function (geometry) {
    return getNormals$1(geometry.index, GeometryData);
});
var getTexCoords$$1 = requireCheckFunc(function (geometry) {
    _checkShouldAlive$3(geometry, GeometryData);
}, function (geometry) {
    return getTexCoords$1(geometry.index, GeometryData);
});
var getIndices$$1 = requireCheckFunc(function (geometry) {
    _checkShouldAlive$3(geometry, GeometryData);
}, function (geometry) {
    return getIndices$1(geometry.index, GeometryData);
});
var getGeometryConfigData = requireCheckFunc(function (geometry) {
    _checkShouldAlive$3(geometry, GeometryData);
}, function (geometry) {
    return getConfigData(geometry.index, GeometryData);
});
var initGeometry$$1 = function (geometry) {
    initGeometry$1(geometry.index, getState(DirectorData));
};
var getGeometryGameObject = requireCheckFunc(function (geometry) {
    _checkShouldAlive$3(geometry, GeometryData);
}, function (geometry) {
    return getGameObject$3(geometry.index, GeometryData);
});
var _checkShouldAlive$3 = function (geometry, GeometryData$$1) {
    checkComponentShouldAlive(geometry, GeometryData$$1, function (geometry, GeometryData$$1) {
        return isComponentIndexNotRemoved(geometry);
    });
};

function cache(judgeFunc, returnCacheValueFunc, setCacheFunc) {
    return function (target, name, descriptor) {
        var value = descriptor.value;
        descriptor.value = function (args) {
            var result = null, setArgs = null;
            if (judgeFunc.apply(this, arguments)) {
                return returnCacheValueFunc.apply(this, arguments);
            }
            result = value.apply(this, arguments);
            setArgs = [result];
            for (var i = 0, len = arguments.length; i < len; i++) {
                setArgs[i + 1] = arguments[i];
            }
            setCacheFunc.apply(this, setArgs);
            return result;
        };
        return descriptor;
    };
}

var REGEX_RGBA = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([^\)]+)\)$/i;
var REGEX_RGBA_2 = /^rgba\((\d+\.\d+),\s*(\d+\.\d+),\s*(\d+\.\d+),\s*([^\)]+)\)$/i;
var REGEX_RGB = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/i;
var REGEX_RGB_2 = /^rgb\((\d+\.\d+),\s*(\d+\.\d+),\s*(\d+\.\d+)\)$/i;
var REGEX_NUM = /^\#([0-9a-f]{6})$/i;
var Color = (function () {
    function Color() {
        this._r = null;
        this._g = null;
        this._b = null;
        this._a = null;
        this._colorString = null;
        this._colorVec3Cache = null;
        this._colorVec4Cache = null;
        this._colorArr3Cache = null;
        this._colorArr4Cache = null;
    }
    Color_1 = Color;
    Color.create = function (colorVal) {
        var obj = new this();
        obj.initWhenCreate(colorVal);
        return obj;
    };
    Object.defineProperty(Color.prototype, "dirty", {
        set: function (dirty) {
            if (dirty) {
                this._clearCache();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "r", {
        get: function () {
            return this._r;
        },
        set: function (r) {
            if (this._r !== r) {
                this.dirty = true;
                this._r = r;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "g", {
        get: function () {
            return this._g;
        },
        set: function (g) {
            if (this._g !== g) {
                this.dirty = true;
                this._g = g;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "b", {
        get: function () {
            return this._b;
        },
        set: function (b) {
            if (this._b !== b) {
                this.dirty = true;
                this._b = b;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "a", {
        get: function () {
            return this._a;
        },
        set: function (a) {
            if (this._a !== a) {
                this.dirty = true;
                this._a = a;
            }
        },
        enumerable: true,
        configurable: true
    });
    Color.prototype.initWhenCreate = function (colorVal) {
        if (!colorVal) {
            return;
        }
        this._colorString = colorVal;
        this._setColor(colorVal);
    };
    Color.prototype.toVector3 = function () {
        return Vector3.create(this.r, this.g, this.b);
    };
    Color.prototype.toVector4 = function () {
        return Vector4.create(this.r, this.g, this.b, this.a);
    };
    Color.prototype.toArray3 = function () {
        return [this.r, this.g, this.b];
    };
    Color.prototype.toArray4 = function () {
        return [this.r, this.g, this.b, this.a];
    };
    Color.prototype.toString = function () {
        if (this._colorString !== null) {
            return this._colorString;
        }
        return "#" + ("000000" + this._getHex().toString(16)).slice(-6);
    };
    Color.prototype._getHex = function () {
        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
    };
    Color.prototype.clone = function () {
        return Color_1.create(this._colorString);
    };
    Color.prototype.isEqual = function (color) {
        return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
    };
    Color.prototype.setColorByNum = function (colorVal) {
        var color = null;
        this._colorString = colorVal;
        color = REGEX_NUM.exec(colorVal);
        this._setHex(parseInt(color[1], 16));
        return this;
    };
    Color.prototype._setColor = function (colorVal) {
        var color = null;
        if (REGEX_RGBA.test(colorVal)) {
            color = REGEX_RGBA.exec(colorVal);
            this.r = this._getColorValue(color, 1);
            this.g = this._getColorValue(color, 2);
            this.b = this._getColorValue(color, 3);
            this.a = Number(color[4]);
            return this;
        }
        if (REGEX_RGBA_2.test(colorVal)) {
            color = REGEX_RGBA_2.exec(colorVal);
            this.r = parseFloat(color[1]);
            this.g = parseFloat(color[2]);
            this.b = parseFloat(color[3]);
            this.a = Number(color[4]);
            return this;
        }
        if (REGEX_RGB.test(colorVal)) {
            color = REGEX_RGB.exec(colorVal);
            this.r = this._getColorValue(color, 1);
            this.g = this._getColorValue(color, 2);
            this.b = this._getColorValue(color, 3);
            this.a = 1;
            return this;
        }
        if (REGEX_RGB_2.test(colorVal)) {
            color = REGEX_RGB_2.exec(colorVal);
            this.r = parseFloat(color[1]);
            this.g = parseFloat(color[2]);
            this.b = parseFloat(color[3]);
            this.a = 1;
            return this;
        }
        if (REGEX_NUM.test(colorVal)) {
            return this.setColorByNum(colorVal);
        }
    };
    Color.prototype._getColorValue = function (color, index, num) {
        if (num === void 0) { num = 255; }
        return Math.min(num, parseInt(color[index], 10)) / num;
    };
    Color.prototype._setHex = function (hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        this.a = 1;
        return this;
    };
    Color.prototype._clearCache = function () {
        this._colorVec3Cache = null;
        this._colorVec4Cache = null;
        this._colorArr3Cache = null;
        this._colorArr4Cache = null;
    };
    __decorate([
        ensureGetter$1(function (r) {
            it$$1("r should >= 0", function () {
                wdet_1(r).gte(0);
            });
        })
    ], Color.prototype, "r", null);
    __decorate([
        ensureGetter$1(function (g) {
            it$$1("g should >= 0", function () {
                wdet_1(g).gte(0);
            });
        })
    ], Color.prototype, "g", null);
    __decorate([
        ensureGetter$1(function (b) {
            it$$1("b should >= 0", function () {
                wdet_1(b).gte(0);
            });
        })
    ], Color.prototype, "b", null);
    __decorate([
        ensureGetter$1(function (a) {
            it$$1("a should >= 0", function () {
                wdet_1(a).gte(0);
            });
        })
    ], Color.prototype, "a", null);
    __decorate([
        cache(function () {
            return this._colorVec3Cache !== null;
        }, function () {
            return this._colorVec3Cache;
        }, function (result) {
            this._colorVec3Cache = result;
        })
    ], Color.prototype, "toVector3", null);
    __decorate([
        cache(function () {
            return this._colorVec4Cache !== null;
        }, function () {
            return this._colorVec4Cache;
        }, function (result) {
            this._colorVec4Cache = result;
        })
    ], Color.prototype, "toVector4", null);
    __decorate([
        cache(function () {
            return this._colorArr3Cache !== null;
        }, function () {
            return this._colorArr3Cache;
        }, function (result) {
            this._colorArr3Cache = result;
        })
    ], Color.prototype, "toArray3", null);
    __decorate([
        cache(function () {
            return this._colorArr4Cache !== null;
        }, function () {
            return this._colorArr4Cache;
        }, function (result) {
            this._colorArr4Cache = result;
        })
    ], Color.prototype, "toArray4", null);
    __decorate([
        requireCheck$1(function (colorVal) {
            it$$1("color should be #xxxxxx", function () {
                wdet_1(REGEX_NUM.test(colorVal)).true;
            });
        })
    ], Color.prototype, "setColorByNum", null);
    Color = Color_1 = __decorate([
        registerClass$1("Color")
    ], Color);
    return Color;
    var Color_1;
}());

var MaterialData = (function () {
    function MaterialData() {
    }
    MaterialData.buffer = null;
    MaterialData.shaderIndices = null;
    MaterialData.colors = null;
    MaterialData.opacities = null;
    MaterialData.alphaTests = null;
    MaterialData.defaultShaderIndex = null;
    MaterialData.defaultColorArr = null;
    MaterialData.defaultOpacity = null;
    MaterialData.defaultAlphaTest = null;
    MaterialData.gameObjectMap = null;
    MaterialData.materialMap = null;
    MaterialData.workerInitList = null;
    return MaterialData;
}());

var getColorArr3$1 = function (index, DataFromSystem) {
    return getColorArr3Data(index, DataFromSystem.colors);
};
var getColorArr3Data = function (index, colors) {
    var size = 3, i = index * size;
    return [colors[i], colors[i + 1], colors[i + 2]];
};
var getSingleSizeData = function (index, datas) {
    return datas[index];
};

var initNoMaterialShaders = function (state, material_config, shaderLib_generator, initNoMaterialShader, initShaderDataMap) {
    var shaders = material_config.shaders.noMaterialShaders;
    for (var shaderName in shaders) {
        if (shaders.hasOwnProperty(shaderName)) {
            initNoMaterialShader(state, shaderName, shaders[shaderName], material_config, shaderLib_generator, initShaderDataMap);
        }
    }
};
var setShaderIndex = function (materialIndex, shaderIndex, MaterialDataFromSystem) {
    setTypeArrayValue(MaterialDataFromSystem.shaderIndices, materialIndex, shaderIndex);
};
var useShader$1 = function (index, shaderName, state, material_config, shaderLib_generator, initMaterialShader, initShaderDataMap) {
    var shaderIndex = initMaterialShader(state, index, shaderName, material_config, shaderLib_generator, initShaderDataMap);
    setShaderIndex(index, shaderIndex, initShaderDataMap.MaterialDataFromSystem);
    return shaderIndex;
};
var getOpacity$1 = function (materialIndex, MaterialDataFromSystem) {
    return getSingleSizeData(materialIndex, MaterialDataFromSystem.opacities);
};
var getAlphaTest$1 = function (materialIndex, MaterialDataFromSystem) {
    return getSingleSizeData(materialIndex, MaterialDataFromSystem.alphaTests);
};
var isTestAlpha$1 = function (alphaTest) {
    return alphaTest >= 0;
};
var getShaderIndexDataSize = function () { return 1; };
var getColorDataSize = function () { return 3; };
var getOpacityDataSize = function () { return 1; };
var getAlphaTestDataSize = function () { return 1; };
var createTypeArrays = function (buffer, count, MaterialDataFromSystem) {
    var offset = 0;
    MaterialDataFromSystem.shaderIndices = new Uint32Array(buffer, offset, count * getShaderIndexDataSize());
    offset += count * Uint32Array.BYTES_PER_ELEMENT * getShaderIndexDataSize();
    MaterialDataFromSystem.colors = new Float32Array(buffer, offset, count * getColorDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getColorDataSize();
    MaterialDataFromSystem.opacities = new Float32Array(buffer, offset, count * getOpacityDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getOpacityDataSize();
    MaterialDataFromSystem.alphaTests = new Float32Array(buffer, offset, count * getAlphaTestDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getAlphaTestDataSize();
    return offset;
};
var buildInitShaderDataMap = function (DeviceManagerDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, ShaderDataFromSystem, MapManagerDataFromSystem, MaterialDataFromSystem, BasicMaterialDataFromSystem, LightMaterialDataFromSystem, AmbientLightDataFromSystem, DirectionLightDataFromSystem, PointLightDataFromSystem, GPUDetectDataFromSystem, VaoDataFromSystem) {
    return {
        GPUDetectDataFromSystem: GPUDetectDataFromSystem,
        DeviceManagerDataFromSystem: DeviceManagerDataFromSystem,
        ProgramDataFromSystem: ProgramDataFromSystem,
        LocationDataFromSystem: LocationDataFromSystem,
        GLSLSenderDataFromSystem: GLSLSenderDataFromSystem,
        ShaderDataFromSystem: ShaderDataFromSystem,
        MapManagerDataFromSystem: MapManagerDataFromSystem,
        MaterialDataFromSystem: MaterialDataFromSystem,
        BasicMaterialDataFromSystem: BasicMaterialDataFromSystem,
        LightMaterialDataFromSystem: LightMaterialDataFromSystem,
        AmbientLightDataFromSystem: AmbientLightDataFromSystem,
        DirectionLightDataFromSystem: DirectionLightDataFromSystem,
        PointLightDataFromSystem: PointLightDataFromSystem,
        VaoDataFromSystem: VaoDataFromSystem
    };
};

var use$2 = requireCheckFunc(function (gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem) {
    it$$1("program should exist", function () {
        wdet_1(getProgram(shaderIndex, ProgramDataFromSystem)).exist;
    });
}, function (gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem) {
    var program = getProgram(shaderIndex, ProgramDataFromSystem);
    if (ProgramDataFromSystem.lastUsedProgram === program) {
        return program;
    }
    ProgramDataFromSystem.lastUsedProgram = program;
    gl.useProgram(program);
    disableVertexAttribArray(gl, GLSLSenderDataFromSystem);
    ProgramDataFromSystem.lastBindedArrayBuffer = null;
    ProgramDataFromSystem.lastBindedIndexBuffer = null;
    return program;
});
var disableVertexAttribArray = requireCheckFunc(function (gl, GLSLSenderDataFromSystem) {
    it$$1("vertexAttribHistory should has not hole", function () {
        forEach(GLSLSenderDataFromSystem.vertexAttribHistory, function (isEnable) {
            wdet_1(isEnable).exist;
            wdet_1(isEnable).be.a("boolean");
        });
    });
}, function (gl, GLSLSenderDataFromSystem) {
    var vertexAttribHistory = GLSLSenderDataFromSystem.vertexAttribHistory;
    for (var i = 0, len = vertexAttribHistory.length; i < len; i++) {
        var isEnable = vertexAttribHistory[i];
        if (isEnable === false || i > gl.VERTEX_ATTRIB_ARRAY_ENABLED) {
            continue;
        }
        gl.disableVertexAttribArray(i);
    }
    GLSLSenderDataFromSystem.vertexAttribHistory = [];
});
var getProgram = ensureFunc$$1(function (program) {
}, function (shaderIndex, ProgramDataFromSystem) {
    return ProgramDataFromSystem.programMap[shaderIndex];
});
var initData$14 = function (ProgramDataFromSystem) {
    ProgramDataFromSystem.programMap = createMap();
};

var use$1 = function (gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem) {
    return use$2(gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
};
var getVao = function (geometryIndex, vaoMap) {
    return vaoMap[geometryIndex];
};
var isVaoExist = function (vao) { return isValidVal(vao); };
var createAndInitArrayBuffer = requireCheckFunc(function (gl, data, location, size) {
    it$$1("location should be defined", function () {
        wdet_1(location).exist;
    });
}, function (gl, data, location, size) {
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    gl.vertexAttribPointer(location, size, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(location);
    return buffer;
});
var createAndInitIndexBuffer = function (gl, data) {
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
    return buffer;
};

var create$7 = function (ShaderData) {
    ShaderData.count += 1;
};
var use$$1 = null;
if (!isSupportRenderWorkerAndSharedArrayBuffer()) {
    use$$1 = use$1;
}

var getColor3Data = function (index, colors) {
    var color = Color.create(), size = 3, i = index * size;
    color.r = colors[i];
    color.g = colors[i + 1];
    color.b = colors[i + 2];
    return color;
};
var setColor3Data = function (index, color, colors) {
    var r = color.r, g = color.g, b = color.b, size = 3, index = index * size;
    setTypeArrayValue(colors, index, r);
    setTypeArrayValue(colors, index + 1, g);
    setTypeArrayValue(colors, index + 2, b);
};

var ETextureWrapMode;
(function (ETextureWrapMode) {
    ETextureWrapMode["REPEAT"] = "REPEAT";
    ETextureWrapMode["MIRRORED_REPEAT"] = "MIRRORED_REPEAT";
    ETextureWrapMode["CLAMP_TO_EDGE"] = "CLAMP_TO_EDGE";
})(ETextureWrapMode || (ETextureWrapMode = {}));

var ETextureFilterMode;
(function (ETextureFilterMode) {
    ETextureFilterMode["NEAREST"] = "NEAREST";
    ETextureFilterMode["NEAREST_MIPMAP_MEAREST"] = "NEAREST_MIPMAP_MEAREST";
    ETextureFilterMode["NEAREST_MIPMAP_LINEAR"] = "NEAREST_MIPMAP_LINEAR";
    ETextureFilterMode["LINEAR"] = "LINEAR";
    ETextureFilterMode["LINEAR_MIPMAP_NEAREST"] = "LINEAR_MIPMAP_NEAREST";
    ETextureFilterMode["LINEAR_MIPMAP_LINEAR"] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilterMode || (ETextureFilterMode = {}));

var ETextureTarget;
(function (ETextureTarget) {
    ETextureTarget["TEXTURE_2D"] = "TEXTURE_2D";
})(ETextureTarget || (ETextureTarget = {}));

var EVariableType;
(function (EVariableType) {
    EVariableType["INT"] = "int";
    EVariableType["FLOAT"] = "float";
    EVariableType["FLOAT3"] = "float3";
    EVariableType["VEC3"] = "vec3";
    EVariableType["MAT3"] = "mat3";
    EVariableType["MAT4"] = "mat4";
    EVariableType["SAMPLER_2D"] = "sampler2D";
})(EVariableType || (EVariableType = {}));

var getBufferDataSize = function () { return 1; };
var createTypeArrays$2 = function (buffer, count, TextureDataFromSystem) {
    var offset = 0;
    TextureDataFromSystem.widths = new Float32Array(buffer, offset, count * getBufferDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getBufferDataSize();
    TextureDataFromSystem.heights = new Float32Array(buffer, offset, count * getBufferDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getBufferDataSize();
    TextureDataFromSystem.isNeedUpdates = new Uint8Array(buffer, offset, count * getBufferDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getBufferDataSize();
    return offset;
};
var getSource$1 = function (textureIndex, TextureDataFromSystem) {
    return TextureDataFromSystem.sourceMap[textureIndex];
};
var getWidth$2 = function (textureIndex, TextureDataFromSystem) {
    var width = getSingleSizeData(textureIndex, TextureDataFromSystem.widths);
    if (width === 0) {
        var source = getSource$1(textureIndex, TextureDataFromSystem);
        if (_isSourceValueExist(source)) {
            return source.width;
        }
    }
    return width;
};
var getHeight$2 = function (textureIndex, TextureDataFromSystem) {
    var height = getSingleSizeData(textureIndex, TextureDataFromSystem.heights);
    if (height === 0) {
        var source = getSource$1(textureIndex, TextureDataFromSystem);
        if (_isSourceValueExist(source)) {
            return source.height;
        }
    }
    return height;
};
var getWrapS = function (textureIndex, TextureData) {
    return ETextureWrapMode.CLAMP_TO_EDGE;
};
var getWrapT = function (textureIndex, TextureData) {
    return ETextureWrapMode.CLAMP_TO_EDGE;
};
var getMagFilter = function (textureIndex, TextureData) {
    return ETextureFilterMode.LINEAR;
};
var getMinFilter = function (textureIndex, TextureData) {
    return ETextureFilterMode.NEAREST;
};
var getFormat = function (textureIndex, TextureData) {
    return ETextureFormat.RGBA;
};
var getType = function (textureIndex, TextureData) {
    return ETextureType.UNSIGNED_BYTE;
};
var getFlipY = function (textureIndex, TextureData) {
    return true;
};
var getIsNeedUpdate$1 = function (textureIndex, TextureDataFromSystem) {
    return getSingleSizeData(textureIndex, TextureDataFromSystem.isNeedUpdates);
};
var setIsNeedUpdate$1 = function (textureIndex, value, TextureDataFromSystem) {
    setTypeArrayValue(TextureDataFromSystem.isNeedUpdates, textureIndex, value);
};
var initTextures$1 = function (gl, TextureDataFromSystem) {
    for (var i = 0; i < TextureDataFromSystem.index; i++) {
        initTexture$2(gl, i, TextureDataFromSystem);
    }
};
var initTexture$2 = function (gl, textureIndex, TextureDataFromSystem) {
    _createWebglTexture(gl, textureIndex, TextureDataFromSystem);
};
var _createWebglTexture = function (gl, textureIndex, TextureDataFromSystem) {
    var glTexture = _getWebglTexture(textureIndex, TextureDataFromSystem);
    if (_isGLTextureExist(glTexture)) {
        return;
    }
    TextureDataFromSystem.glTextures[textureIndex] = gl.createTexture();
};
var _isGLTextureExist = function (glTexture) { return isValidVal(glTexture); };
var _isSourceExist = function (textureIndex, TextureDataFromSystem) { return _isSourceValueExist(TextureDataFromSystem.sourceMap[textureIndex]); };
var _isSourceValueExist = function (source) { return isValidVal(source); };
var getBufferCount$1 = function () { return DataBufferConfig.textureDataBufferCount; };
var needUpdate$1 = function (textureIndex, TextureDataFromSystem) {
    return getIsNeedUpdate$1(textureIndex, TextureDataFromSystem) === 0;
};
var markNeedUpdate$1 = function (textureIndex, value, TextureDataFromSystem) {
    if (value === false) {
        setIsNeedUpdate$1(textureIndex, 1, TextureDataFromSystem);
    }
    else {
        setIsNeedUpdate$1(textureIndex, 0, TextureDataFromSystem);
    }
};
var update$3 = function (gl, textureIndex, setFlipY, TextureDataFromSystem) {
    if (!_isSourceExist(textureIndex, TextureDataFromSystem)) {
        return;
    }
    var width = getWidth$2(textureIndex, TextureDataFromSystem), height = getHeight$2(textureIndex, TextureDataFromSystem), wrapS = getWrapS(textureIndex, TextureDataFromSystem), wrapT = getWrapT(textureIndex, TextureDataFromSystem), magFilter = getMagFilter(textureIndex, TextureDataFromSystem), minFilter = getMinFilter(textureIndex, TextureDataFromSystem), format = getFormat(textureIndex, TextureDataFromSystem), type = getType(textureIndex, TextureDataFromSystem), flipY = getFlipY(textureIndex, TextureDataFromSystem), source = TextureDataFromSystem.sourceMap[textureIndex], target = ETextureTarget.TEXTURE_2D, isSourcePowerOfTwo = _isSourcePowerOfTwo(width, height);
    setFlipY(gl, flipY);
    _setTextureParameters(gl, gl[target], isSourcePowerOfTwo, wrapS, wrapT, magFilter, minFilter);
    _allocateSourceToTexture(gl, source, format, type);
    markNeedUpdate$1(textureIndex, false, TextureDataFromSystem);
};
var _setTextureParameters = function (gl, textureType, isSourcePowerOfTwo, wrapS, wrapT, magFilter, minFilter) {
    if (isSourcePowerOfTwo) {
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, gl[wrapS]);
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, gl[wrapT]);
        gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, gl[magFilter]);
        gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, gl[minFilter]);
    }
    else {
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, gl[_filterFallback(magFilter)]);
        gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, gl[_filterFallback(minFilter)]);
    }
};
var _filterFallback = function (filter$$1) {
    if (filter$$1 === ETextureFilterMode.NEAREST || filter$$1 === ETextureFilterMode.NEAREST_MIPMAP_MEAREST || filter$$1 === ETextureFilterMode.NEAREST_MIPMAP_LINEAR) {
        return ETextureFilterMode.NEAREST;
    }
    return ETextureFilterMode.LINEAR;
};
var _allocateSourceToTexture = function (gl, source, format, type) {
    _drawNoMipmapTwoDTexture(gl, source, format, type);
};
var _drawNoMipmapTwoDTexture = function (gl, source, format, type) {
    _drawTexture(gl, gl.TEXTURE_2D, 0, source, format, type);
};
var _drawTexture = function (gl, glTarget, index, source, format, type) {
    gl.texImage2D(glTarget, index, gl[format], gl[format], gl[type], source);
};
var _isSourcePowerOfTwo = function (width, height) {
    return _isPowerOfTwo(width) && _isPowerOfTwo(height);
};
var _isPowerOfTwo = function (value) {
    return (value & (value - 1)) === 0 && value !== 0;
};
var bindToUnit$1 = function (gl, unitIndex, textureIndex, TextureCacheDataFromSystem, TextureDataFromSystem, GPUDetectDataFromSystem, isCached, addActiveTexture) {
    var target = ETextureTarget.TEXTURE_2D;
    if (isCached(unitIndex, textureIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem)) {
        return;
    }
    addActiveTexture(unitIndex, textureIndex, TextureCacheDataFromSystem, GPUDetectDataFromSystem);
    gl.activeTexture(gl["TEXTURE" + unitIndex]);
    gl.bindTexture(gl[target], _getWebglTexture(textureIndex, TextureDataFromSystem));
};
var sendData$1 = function (gl, mapCount, shaderIndex, textureIndex, unitIndex, program, glslSenderData, uniformLocationMap, uniformCacheMap, directlySendUniformData, TextureDataFromSystem) {
    directlySendUniformData(gl, _getUniformSamplerName(textureIndex, TextureDataFromSystem), shaderIndex, program, _getSamplerType(_getTarget()), unitIndex, glslSenderData, uniformLocationMap, uniformCacheMap);
};
var _getSamplerType = function (target) {
    var type = null;
    switch (target) {
        case ETextureTarget.TEXTURE_2D:
            type = EVariableType.SAMPLER_2D;
            break;
        default:
            break;
    }
    return type;
};
var _getTarget = function () {
    return ETextureTarget.TEXTURE_2D;
};
var _getUniformSamplerName = function (index, TextureDataFromSystem) {
    return TextureDataFromSystem.uniformSamplerNameMap[index];
};
var disposeSourceMap = function (sourceIndex, lastComponentIndex, TextureDataFromSystem) {
    deleteBySwap(sourceIndex, lastComponentIndex, TextureDataFromSystem.sourceMap);
};
var disposeGLTexture = function (gl, sourceIndex, lastComponentIndex, TextureCacheDataFromSystem, TextureDataFromSystem, GPUDetectDataFromSystem) {
    var glTexture = _getWebglTexture(sourceIndex, TextureDataFromSystem);
    gl.deleteTexture(glTexture);
    _unBindAllUnit(gl, TextureCacheDataFromSystem, GPUDetectDataFromSystem);
    deleteBySwap(sourceIndex, lastComponentIndex, TextureDataFromSystem.glTextures);
};
var _unBindAllUnit = function (gl, TextureCacheDataFromSystem, GPUDetectData) {
    var maxTextureUnit = getMaxTextureUnit(GPUDetectData);
    for (var channel = 0; channel < maxTextureUnit; channel++) {
        gl.activeTexture(gl["TEXTURE" + channel]);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    clearAllBindTextureUnitCache$1(TextureCacheDataFromSystem);
};
var _getWebglTexture = function (textureIndex, TextureDataFromSystem) {
    return TextureDataFromSystem.glTextures[textureIndex];
};

var getMaterialBufferSize = function () {
    return Float32Array.BYTES_PER_ELEMENT * (getShaderIndexDataSize() + getColorDataSize() + getOpacityDataSize() + getAlphaTestDataSize());
};
var getBasicMaterialBufferStartIndex = function () { return 0; };
var getLightMaterialBufferStartIndex = function () { return DataBufferConfig.basicMaterialDataBufferCount; };

var getShadingDataSize = function () { return 1; };
var getLightModelDataSize = function () { return 1; };
var getShininessDataSize = function () { return 1; };
var getMapSize = function () { return 1; };
var getSpecularColorArr3 = function (index, LightMaterialDataFromSystem) {
    return getColorArr3Data(index, LightMaterialDataFromSystem.specularColors);
};
var getEmissionColorArr3 = function (index, LightMaterialDataFromSystem) {
    return getColorArr3Data(index, LightMaterialDataFromSystem.emissionColors);
};
var getShininess = function (index, LightMaterialDataFromSystem) {
    return getSingleSizeData(index, LightMaterialDataFromSystem.shininess);
};
var getShading = function (index, LightMaterialDataFromSystem) {
    return getSingleSizeData(index, LightMaterialDataFromSystem.shadings);
};
var getLightModel = function (index, LightMaterialDataFromSystem) {
    return getSingleSizeData(index, LightMaterialDataFromSystem.lightModels);
};
var hasDiffuseMap = function (index, LightMaterialDataFromSystem) {
    return _hasMap(index, LightMaterialDataFromSystem.hasDiffuseMaps);
};
var hasSpecularMap = function (index, LightMaterialDataFromSystem) {
    return _hasMap(index, LightMaterialDataFromSystem.hasSpecularMaps);
};
var markHasMap = function (index, hasMapTypArray) {
    setTypeArrayValue(hasMapTypArray, computeLightBufferIndex(index), 1);
};
var markNotHasMap = function (index, hasMapTypArray) {
    setTypeArrayValue(hasMapTypArray, computeLightBufferIndex(index), getNotHasMapValue());
};
var getNotHasMapValue = function () { return 0; };
var _hasMap = function (index, hasMapTypArray) {
    return getSingleSizeData(index, hasMapTypArray) !== getNotHasMapValue();
};
var computeLightBufferIndex = function (index) { return index - getLightMaterialBufferStartIndex(); };
var createTypeArrays$3 = function (buffer, offset, count, LightMaterialDataFromSystem) {
    LightMaterialDataFromSystem.specularColors = new Float32Array(buffer, offset, count * getColorDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getColorDataSize();
    LightMaterialDataFromSystem.emissionColors = new Float32Array(buffer, offset, count * getColorDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getColorDataSize();
    LightMaterialDataFromSystem.shininess = new Float32Array(buffer, offset, count * getShininessDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getShininessDataSize();
    LightMaterialDataFromSystem.shadings = new Uint8Array(buffer, offset, count * getShadingDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getShadingDataSize();
    LightMaterialDataFromSystem.lightModels = new Uint8Array(buffer, offset, count * getLightModelDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getLightModelDataSize();
    LightMaterialDataFromSystem.hasDiffuseMaps = new Uint8Array(buffer, offset, count * getMapSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getMapSize();
    LightMaterialDataFromSystem.hasSpecularMaps = new Uint8Array(buffer, offset, count * getMapSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getMapSize();
    return offset;
};
var getClassName = function () { return "LightMaterial"; };

var getBasicMaterialBufferCount = function () {
    return DataBufferConfig.basicMaterialDataBufferCount;
};
var getBasicMaterialBufferSize = function () {
    return getMaterialBufferSize();
};
var getLightMaterialBufferCount = function () {
    return DataBufferConfig.lightMaterialDataBufferCount;
};
var getBufferLength = function () {
    return getBasicMaterialBufferCount() * getBasicMaterialBufferSize() + getLightMaterialBufferCount() * getLightMaterialBufferSize();
};
var getLightMaterialBufferSize = function () {
    return getMaterialBufferSize() + Uint8Array.BYTES_PER_ELEMENT * (getShaderIndexDataSize() + getLightModelDataSize() + getMapSize() * 2) + Float32Array.BYTES_PER_ELEMENT * (getColorDataSize() * 2 + getShininessDataSize());
};
var getBufferTotalCount = function () {
    return getBasicMaterialBufferCount() + getLightMaterialBufferCount();
};

var getTextureIndexDataSize = function () { return 1; };
var getTextureCountDataSize = function () { return 1; };
var bindAndUpdate$1 = requireCheckFunc(function (gl, mapCount, startTextureIndex, definedStartTextureUnitIndex, TextureCacheDataFromSystem, TextureDataFromSystem, MapManagerDataFromSystem, GPUDetectDataFromSystem, bindToUnit, needUpdate, update) {
    it$$1("mapCount should >= 0", function () {
        wdet_1(mapCount).gte(0);
    });
    it$$1("startTextureIndex should >= 0", function () {
        wdet_1(startTextureIndex).gte(0);
    });
    it$$1("definedStartTextureUnitIndex should >= 0", function () {
        wdet_1(definedStartTextureUnitIndex).gte(0);
    });
}, function (gl, mapCount, startTextureIndex, definedStartTextureUnitIndex, TextureCacheDataFromSystem, TextureDataFromSystem, MapManagerDataFromSystem, GPUDetectDataFromSystem, bindToUnit, needUpdate, update) {
    var textureIndices = MapManagerDataFromSystem.textureIndices;
    for (var i = startTextureIndex, count = mapCount + startTextureIndex; i < count; i++) {
        var textureIndex = textureIndices[i], unitIndex = _getUnitIndex(i, startTextureIndex, definedStartTextureUnitIndex);
        bindToUnit(gl, unitIndex, textureIndex, TextureCacheDataFromSystem, TextureDataFromSystem, GPUDetectDataFromSystem);
        if (needUpdate(textureIndex, TextureDataFromSystem)) {
            update(gl, textureIndex, TextureDataFromSystem);
        }
    }
});
var sendData$$1 = function (gl, mapCount, startTextureIndex, definedStartTextureUnitIndex, shaderIndex, program, glslSenderData, uniformLocationMap, uniformCacheMap, directlySendUniformData, TextureData, MapManagerData) {
    var textureIndices = MapManagerData.textureIndices;
    for (var i = startTextureIndex, count = mapCount + startTextureIndex; i < count; i++) {
        var textureIndex = textureIndices[i], unitIndex = _getUnitIndex(i, startTextureIndex, definedStartTextureUnitIndex);
        sendData$1(gl, mapCount, shaderIndex, textureIndex, unitIndex, program, glslSenderData, uniformLocationMap, uniformCacheMap, directlySendUniformData, TextureData);
    }
};
var _getUnitIndex = function (index, startTextureIndex, definedStartTextureUnitIndex) { return index - startTextureIndex + definedStartTextureUnitIndex; };
var getMapCount$1 = function (materialIndex, MapManagerDataFromSystem) {
    return MapManagerDataFromSystem.textureCounts[materialIndex];
};
var getMaterialTextures = function (materialIndex, MapManagerDataFromSystem) {
    return MapManagerDataFromSystem.materialTextureList[materialIndex];
};
var getBufferCount = function () { return getBufferTotalCount() * getMaxTextureCount(); };
var getMaxTextureCount = function () { return 16; };
var createTypeArrays$1 = function (buffer, count, MapManagerDataFromSystem) {
    var offset = 0;
    MapManagerDataFromSystem.textureIndices = new Uint32Array(buffer, offset, count * getTextureIndexDataSize());
    offset += count * Uint32Array.BYTES_PER_ELEMENT * getTextureIndexDataSize();
    MapManagerDataFromSystem.textureCounts = new Uint8Array(buffer, offset, count * getTextureCountDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getTextureCountDataSize();
    return offset;
};
var getStartTextureIndex = ensureFunc$$1(function (textureIndex) {
    it$$1("startTextureIndex should >= 0", function () {
        wdet_1(textureIndex).gte(0);
    });
}, function (materialIndex) {
    return getMaxTextureCount() * materialIndex;
});

var isNotExist = function (val) { return isUndefined(val); };

var initMapManagers = function (gl, TextureData) {
    initTextures$$1(gl, TextureData);
};
var initMapManager = function (gl, materialIndex, MapManagerData, TextureData) {
    forEach(getMaterialTextures(materialIndex, MapManagerData), function (textureIndex) {
        initTexture$$1(gl, textureIndex, TextureData);
    });
};
var setMap = ensureFunc$$1(function (returnVal, materialIndex, map, uniformSamplerName, MapManagerData, TextureData) {
    it$$1("map count shouldn't exceed max count", function () {
        wdet_1(getMapCount$$1(materialIndex, MapManagerData)).lte(getMaxTextureCount());
    });
}, function (materialIndex, map, uniformSamplerName, MapManagerData, TextureData) {
    var textureIndex = map.index, textureOffsetMap = MapManagerData.textureOffsetMap, textureIndices = MapManagerData.textureIndices, textureCounts = MapManagerData.textureCounts, count = getMapCount$$1(materialIndex, MapManagerData), offset = _getTextureOffset(materialIndex, uniformSamplerName, textureOffsetMap);
    if (_isSetMapBefore(offset)) {
        offset = count;
        _setTextureOffset(materialIndex, uniformSamplerName, offset, textureOffsetMap);
        textureCounts[materialIndex] = count + 1;
        _addTextureToMaterialTextureList(materialIndex, textureIndex, MapManagerData);
        setUniformSamplerName(textureIndex, uniformSamplerName, TextureData);
    }
    else {
        var oldMapIndex = _getMap(materialIndex, offset, textureIndices);
        _setTextureOffset(materialIndex, uniformSamplerName, offset, textureOffsetMap);
        _replaceTextureInMaterialTextureList(materialIndex, oldMapIndex, textureIndex, MapManagerData);
        setUniformSamplerName(textureIndex, uniformSamplerName, TextureData);
    }
    _setMapInTextureIndices(materialIndex, offset, textureIndex, textureIndices);
});
var _setMapInTextureIndices = function (materialIndex, offset, textureIndex, textureIndices) {
    textureIndices[getStartTextureIndex(materialIndex) + offset] = textureIndex;
};
var _getTextureOffset = function (materialIndex, uniformSamplerName, textureOffsetMap) {
    var map = textureOffsetMap[materialIndex];
    if (isNotExist(map)) {
        return void 0;
    }
    return map[uniformSamplerName];
};
var _setTextureOffset = requireCheckFunc(function (materialIndex, uniformSamplerName, offset, textureOffsetMap) {
    it$$1("offset should >= 0", function () {
        wdet_1(offset).gte(0);
    });
}, function (materialIndex, uniformSamplerName, offset, textureOffsetMap) {
    var map = textureOffsetMap[materialIndex];
    if (isNotExist(map)) {
        var m = {};
        m[uniformSamplerName] = offset;
        textureOffsetMap[materialIndex] = m;
        return;
    }
    map[uniformSamplerName] = offset;
});
var _isSetMapBefore = function (offset) { return isNotExist(offset); };
var _getMap = function (materialIndex, offset, textureIndices) {
    return textureIndices[getStartTextureIndex(materialIndex) + offset];
};
var _replaceTextureInMaterialTextureList = requireCheckFunc(function (materialIndex, oldTextureIndex, newTextureIndex, MapManagerData) {
    it$$1("MapManagerData.materialTextureList[materialIndex] should be array", function () {
        wdet_1(MapManagerData.materialTextureList[materialIndex]).exist;
        wdet_1(MapManagerData.materialTextureList[materialIndex]).be.a("array");
    });
}, function (materialIndex, oldTextureIndex, newTextureIndex, MapManagerData) {
    replaceItem(MapManagerData.materialTextureList[materialIndex], oldTextureIndex, newTextureIndex);
});
var _addTextureToMaterialTextureList = function (materialIndex, textureIndex, MapManagerData) {
    var map = MapManagerData.materialTextureList[materialIndex];
    if (map === void 0) {
        map = [textureIndex];
        MapManagerData.materialTextureList[materialIndex] = map;
        return;
    }
    map.push(textureIndex);
};
var getMaterialTextureList = function (MapManagerData) { return MapManagerData.materialTextureList; };
var getMapCount$$1 = getMapCount$1;
var bindAndUpdate$$1 = function (gl, mapCount, startTextureIndex, definedStartTextureUnitIndex, TextureCacheData, TextureData, MapManagerData, GPUDetectData) {
    bindAndUpdate$1(gl, mapCount, startTextureIndex, definedStartTextureUnitIndex, TextureCacheData, TextureData, MapManagerData, GPUDetectData, bindToUnit$$1, needUpdate$$1, update$$1);
};
var dispose$2 = function (materialSourceIndex, materialLastComponentIndex, MapManagerData) {
    deleteSingleValueBySwapAndReset(materialSourceIndex, materialLastComponentIndex, MapManagerData.textureCounts, 0);
    deleteBySwap$1(materialSourceIndex, materialLastComponentIndex, MapManagerData.materialTextureList);
    deleteBySwap$1(materialSourceIndex, materialLastComponentIndex, MapManagerData.textureOffsetMap);
};
var initData$15 = function (TextureCacheData, TextureData, MapManagerData) {
    initData$1(TextureCacheData, TextureData);
    _initBufferData$3(MapManagerData);
    MapManagerData.materialTextureList = [];
    MapManagerData.textureOffsetMap = createMap();
};
var _initBufferData$3 = function (MapManagerData) {
    var buffer = null, count = getBufferCount(), size = Uint32Array.BYTES_PER_ELEMENT + Uint8Array.BYTES_PER_ELEMENT, offset = null;
    buffer = createSharedArrayBufferOrArrayBuffer(computeBufferLength(count, size));
    offset = createTypeArrays$1(buffer, count, MapManagerData);
    MapManagerData.buffer = buffer;
};

var useShader$2 = useShader$1;
var getColorArr3$2 = getColorArr3$1;
var getOpacity$2 = getOpacity$1;

var create$6 = function (index, material, ShaderData, MaterialData$$1) {
    MaterialData$$1.materialMap[index] = material;
    create$7(ShaderData);
    return material;
};
var useShader$$1 = useShader$1;
var initMaterial = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    initMaterial = function (index, state, className, MaterialData$$1) {
        MaterialData$$1.workerInitList.push(_buildWorkerInitData_1(index, className));
    };
    var _buildWorkerInitData_1 = function (index, className) {
        return {
            index: index,
            className: className
        };
    };
}
else {
    initMaterial = function (index, state, className, MaterialData$$1) {
    };
}
var clearWorkerInitList = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    clearWorkerInitList = function (MaterialData$$1) {
        MaterialData$$1.workerInitList = [];
    };
}
else {
    clearWorkerInitList = function (MaterialData$$1) {
    };
}
var hasNewInitedMaterial = function (MaterialData$$1) {
    return MaterialData$$1.workerInitList.length > 0;
};
var getShaderIndex = function (materialIndex, MaterialData$$1) {
    return MaterialData$$1.shaderIndices[materialIndex];
};
var getColor = function (materialIndex, MaterialData$$1) {
    return getColor3Data(materialIndex, MaterialData$$1.colors);
};
var getColorArr3$$1 = getColorArr3$2;
var setColor = function (materialIndex, color, MaterialData$$1) {
    setColorData(materialIndex, color, MaterialData$$1.colors);
};
var setColorData = function (materialIndex, color, colors) {
    setColor3Data(materialIndex, color, colors);
};
var getOpacity$$1 = getOpacity$1;
var setOpacity = requireCheckFunc(function (materialIndex, opacity, MaterialData$$1) {
    it$$1("opacity should be number", function () {
        wdet_1(opacity).be.a("number");
    });
    it$$1("opacity should <= 1 && >= 0", function () {
        wdet_1(opacity).lte(1);
        wdet_1(opacity).gte(0);
    });
}, function (materialIndex, opacity, MaterialData$$1) {
    var size = getOpacityDataSize(), index = materialIndex * size;
    setTypeArrayValue(MaterialData$$1.opacities, index, opacity);
});
var getAlphaTest$$1 = getAlphaTest$1;
var setAlphaTest = requireCheckFunc(function (materialIndex, alphaTest, MaterialData$$1) {
    it$$1("alphaTest should be number", function () {
        wdet_1(alphaTest).be.a("number");
    });
}, function (materialIndex, alphaTest, MaterialData$$1) {
    var size = getAlphaTestDataSize(), index = materialIndex * size;
    setTypeArrayValue(MaterialData$$1.alphaTests, index, alphaTest);
});
var addComponent$5 = function (component, gameObject, MaterialData$$1) {
    addComponentToGameObjectMap(MaterialData$$1.gameObjectMap, component.index, gameObject);
};
var disposeComponent$5 = requireCheckFunc(function (sourceIndex, lastComponentIndex, MapManagerData, MaterialData$$1) {
    _checkDisposeComponentWorker(sourceIndex);
}, function (sourceIndex, lastComponentIndex, MapManagerData, MaterialData$$1) {
    var colorDataSize = getColorDataSize(), opacityDataSize = getOpacityDataSize(), alphaTestDataSize = getAlphaTestDataSize();
    deleteBySwapAndNotReset(sourceIndex, lastComponentIndex, MaterialData$$1.shaderIndices);
    deleteBySwapAndReset(sourceIndex * colorDataSize, lastComponentIndex * colorDataSize, MaterialData$$1.colors, colorDataSize, MaterialData$$1.defaultColorArr);
    deleteOneItemBySwapAndReset(sourceIndex * opacityDataSize, lastComponentIndex * opacityDataSize, MaterialData$$1.opacities, MaterialData$$1.defaultOpacity);
    deleteOneItemBySwapAndReset(sourceIndex * alphaTestDataSize, lastComponentIndex * alphaTestDataSize, MaterialData$$1.alphaTests, MaterialData$$1.defaultAlphaTest);
    deleteBySwap(sourceIndex, lastComponentIndex, MaterialData$$1.gameObjectMap);
    deleteComponentBySwapArray(sourceIndex, lastComponentIndex, MaterialData$$1.materialMap);
    dispose$2(sourceIndex, lastComponentIndex, MapManagerData);
});
var _checkDisposeComponentWorker = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    _checkDisposeComponentWorker = function (materialIndex) {
        it$$1("should not dispose the material which is inited in the same frame", function () {
            for (var _i = 0, _a = MaterialData.workerInitList; _i < _a.length; _i++) {
                var index = _a[_i].index;
                wdet_1(materialIndex).not.equal(index);
            }
        });
    };
}
else {
    _checkDisposeComponentWorker = function (index) { };
}
var getGameObject$4 = function (index, MaterialData$$1) {
    return getComponentGameObject(MaterialData$$1.gameObjectMap, index);
};
var isTestAlpha$$1 = isTestAlpha$1;
var createDefaultColor = function () {
    var color = Color.create();
    return color.setColorByNum("#ffffff");
};

var Material = (function (_super) {
    __extends(Material, _super);
    function Material() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Material = __decorate([
        registerClass$1("Material")
    ], Material);
    return Material;
}(Component));
var getMaterialGameObject = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (component) {
    return getGameObject$4(component.index, MaterialData);
});
var checkShouldAlive$1 = function (material) {
    checkComponentShouldAlive(material, null, function (material) {
        return isComponentIndexNotRemoved(material);
    });
};

var create$2 = ensureFunc$$1(function (gameObject, transform, GameObjectData) {
    it$$1("componentMap should has data", function () {
        wdet_1(_getComponentData(gameObject.uid, GameObjectData)).exist;
    });
}, function (transform, GameObjectData) {
    var gameObject = new GameObject(), uid = _buildUId(GameObjectData);
    gameObject.uid = uid;
    GameObjectData.aliveUIdArray.push(uid);
    if (!transform) {
        _setComponentData(uid, {}, GameObjectData);
    }
    else {
        addComponent$1(gameObject, transform, GameObjectData);
    }
    return gameObject;
});
var _buildUId = function (GameObjectData) {
    return GameObjectData.uid++;
};
var isAlive = function (entity, GameObjectData) {
    return isValidMapValue(_getComponentData(entity.uid, GameObjectData));
};
var isNotAlive = function (entity, GameObjectData) {
    return !isAlive(entity, GameObjectData);
};
var initGameObject = function (gameObject, state, GameObjectData) {
    var uid = gameObject.uid, componentData = _getComponentData(uid, GameObjectData);
    for (var componentId in componentData) {
        if (componentData.hasOwnProperty(componentId)) {
            var component = componentData[componentId];
            execInitHandle(getTypeIdFromComponent(component), component.index, state);
        }
    }
};
var dispose$1 = function (entity, ThreeDTransformData, GameObjectData) {
    _diposeAllDatas(entity, GameObjectData);
    GameObjectData.disposeCount += 1;
    if (isDisposeTooManyComponents(GameObjectData.disposeCount)) {
        reAllocateGameObject(GameObjectData);
        GameObjectData.disposeCount = 0;
    }
};
var _removeFromChildrenMap = function (parentUId, childUId, GameObjectData) {
    removeChildEntity(getChildren(parentUId, GameObjectData), childUId);
};
var _diposeAllDatas = function (gameObject, GameObjectData) {
    var uid = gameObject.uid, children = getChildren(uid, GameObjectData);
    _disposeAllComponents(gameObject, GameObjectData);
    _disposeMapDatas(uid, GameObjectData);
    if (_isChildrenExist(children)) {
        forEach(children, function (child) {
            if (isNotAlive(child, GameObjectData)) {
                return;
            }
            _diposeAllDatas(child, GameObjectData);
        });
    }
};
var _disposeMapDatas = function (uid, GameObjectData) {
    deleteVal$1(uid, GameObjectData.childrenMap);
    deleteVal$1(uid, GameObjectData.componentMap);
};
var _disposeAllComponents = function (gameObject, GameObjectData) {
    var components = _getComponentData(gameObject.uid, GameObjectData);
    for (var typeId in components) {
        if (components.hasOwnProperty(typeId)) {
            var component = components[typeId];
            execHandle(component, "disposeHandleMap");
        }
    }
};
var addComponent$1 = requireCheckFunc(function (gameObject, component, GameObjectData) {
    it$$1("component should exist", function () {
        wdet_1(component).exist;
    });
    it$$1("should not has this type of component, please dispose it", function () {
        wdet_1(hasComponent(gameObject, getComponentIdFromComponent(component), GameObjectData)).false;
    });
}, function (gameObject, component, GameObjectData) {
    var uid = gameObject.uid, componentId = getComponentIdFromComponent(component), data = _getComponentData(uid, GameObjectData);
    execHandle(component, "addComponentHandleMap", [component, gameObject]);
    if (!data) {
        var d = {};
        d[componentId] = component;
        _setComponentData(uid, d, GameObjectData);
        return;
    }
    data[componentId] = component;
});
var _removeComponent = function (componentId, uid, GameObjectData) {
    var data = _getComponentData(uid, GameObjectData);
    if (isValidMapValue(data)) {
        deleteVal$1(componentId, data);
    }
};
var disposeComponent$1 = function (uid, component, GameObjectData) {
    var componentId = getComponentIdFromComponent(component);
    _removeComponent(componentId, uid, GameObjectData);
    execHandle(component, "disposeHandleMap");
};
var getComponent = function (uid, componentId, GameObjectData) {
    var data = _getComponentData(uid, GameObjectData);
    if (isValidMapValue(data)) {
        var component = data[componentId];
        return isValidMapValue(component) ? component : null;
    }
    return null;
};
var getAllComponents = function (uid, GameObjectData) {
    return _getComponentData(uid, GameObjectData);
};
var _getComponentData = function (uid, GameObjectData) { return GameObjectData.componentMap[uid]; };
var _setComponentData = function (uid, data, GameObjectData) { return GameObjectData.componentMap[uid] = data; };
var hasComponent = function (gameObject, componentId, GameObjectData) {
    return getComponent(gameObject.uid, componentId, GameObjectData) !== null;
};
var getTransform = function (uid, GameObjectData) {
    return getComponent(uid, getComponentIdFromClass(ThreeDTransform), GameObjectData);
};
var getGeometry = function (uid, GameObjectData) {
    return getComponent(uid, getComponentIdFromClass(Geometry), GameObjectData);
};
var getMaterial = function (uid, GameObjectData) {
    return getComponent(uid, getComponentIdFromClass(Material), GameObjectData);
};
var getMeshRenderer = function (uid, GameObjectData) {
    return getComponent(uid, getComponentIdFromClass(MeshRenderer), GameObjectData);
};
var _isParentExist = function (parent) { return isNotUndefined(parent); };
var _isChildrenExist = function (children) { return isNotUndefined(children); };
var _isComponentExist = function (component) { return component !== null; };
var _isGameObjectEqual = function (gameObject1, gameObject2) { return gameObject1.uid === gameObject2.uid; };
var getParent = function (uid, GameObjectData) { return GameObjectData.parentMap[uid]; };
var setParent$$1 = function (parent, child, ThreeDTransformData, GameObjectData) {
    var parentUId = parent.uid, childUId = child.uid, transform = getTransform(parentUId, GameObjectData), childOriginParent = getParent(childUId, GameObjectData);
    if (_isParentExist(childOriginParent)) {
        removeChildWithoutDisposeMeshRenderer(childOriginParent.uid, childUId, ThreeDTransformData, GameObjectData);
    }
    _setParent(childUId, parent, GameObjectData);
    if (_isComponentExist(transform)) {
        setParent$1(transform, getTransform(childUId, GameObjectData), ThreeDTransformData);
    }
    _addChild(parentUId, child, GameObjectData);
};
var _setParent = function (uid, parent, GameObjectData) {
    GameObjectData.parentMap[uid] = parent;
};
var getChildren = function (uid, GameObjectData) {
    return GameObjectData.childrenMap[uid];
};
var setChildren = function (uid, children, GameObjectData) {
    GameObjectData.childrenMap[uid] = children;
};
var getAliveChildren = function (uid, GameObjectData) {
    return filter(getChildren(uid, GameObjectData), function (gameObject) {
        return isAlive(gameObject, GameObjectData);
    });
};
var _addChild = function (uid, child, GameObjectData) {
    var children = getChildren(uid, GameObjectData);
    if (isValidMapValue(children)) {
        children.push(child);
    }
    else {
        setChildren(uid, [child], GameObjectData);
    }
};
var addChild = requireCheckFunc(function (gameObject, child, ThreeDTransformData, GameObjectData) {
}, function (gameObject, child, ThreeDTransformData, GameObjectData) {
    setParent$$1(gameObject, child, ThreeDTransformData, GameObjectData);
});
var addRemovedChild = function (gameObject, child, MeshRendererData, ThreeDTransformData, GameObjectData) {
    setParent$$1(gameObject, child, ThreeDTransformData, GameObjectData);
    addComponent$1(child, create$1(MeshRendererData), GameObjectData);
};
var removeChild = function (parentUId, childUId, ThreeDTransformData, GameObjectData) {
    var meshRenderer = getMeshRenderer(childUId, GameObjectData);
    if (_isComponentExist(meshRenderer)) {
        disposeComponent$1(childUId, getMeshRenderer(childUId, GameObjectData), GameObjectData);
    }
    _removeChildWithoutDisposeMeshRenderer(parentUId, childUId, ThreeDTransformData, GameObjectData);
};
var removeChildWithoutDisposeMeshRenderer = function (parentUId, childUId, ThreeDTransformData, GameObjectData) {
    _removeChildWithoutDisposeMeshRenderer(parentUId, childUId, ThreeDTransformData, GameObjectData);
};
var _removeChildWithoutDisposeMeshRenderer = requireCheckFunc(function (parentUId, childUId, ThreeDTransformData, GameObjectData) {
    it$$1("child should has transform component", function () {
        wdet_1(getTransform(childUId, GameObjectData)).exist;
    });
}, function (parentUId, childUId, ThreeDTransformData, GameObjectData) {
    deleteVal$1(childUId, GameObjectData.parentMap);
    setParent$1(null, getTransform(childUId, GameObjectData), ThreeDTransformData);
    _removeFromChildrenMap(parentUId, childUId, GameObjectData);
});
var hasChild = function (gameObject, child, GameObjectData) {
    if (isNotAlive(gameObject, GameObjectData) || isNotAlive(child, GameObjectData)) {
        return false;
    }
    var parent = getParent(child.uid, GameObjectData);
    if (!_isParentExist(parent) || isNotAlive(parent, GameObjectData)) {
        return false;
    }
    return _isGameObjectEqual(parent, gameObject);
};
var initData$10 = function (GameObjectData) {
    GameObjectData.uid = 0;
    GameObjectData.componentMap = createMap();
    GameObjectData.parentMap = createMap();
    GameObjectData.childrenMap = createMap();
    GameObjectData.disposeCount = 0;
    GameObjectData.aliveUIdArray = [];
};

var createTypeArrays$4 = function (buffer, DataBufferConfig, BasicRenderCommandBufferDataFromSystem) {
    var mat4Length = getMatrix4DataSize(), count = DataBufferConfig.renderCommandBufferCount, offset = 0;
    BasicRenderCommandBufferDataFromSystem.mMatrices = new Float32Array(buffer, offset, count * mat4Length);
    offset += count * Float32Array.BYTES_PER_ELEMENT * mat4Length;
    BasicRenderCommandBufferDataFromSystem.materialIndices = new Uint32Array(buffer, offset, count);
    offset += count * Uint32Array.BYTES_PER_ELEMENT;
    BasicRenderCommandBufferDataFromSystem.geometryIndices = new Uint32Array(buffer, offset, count);
    offset += count * Uint32Array.BYTES_PER_ELEMENT;
    BasicRenderCommandBufferDataFromSystem.vMatrix = new Float32Array(buffer, offset, mat4Length);
    offset += Float32Array.BYTES_PER_ELEMENT * mat4Length;
    BasicRenderCommandBufferDataFromSystem.pMatrix = new Float32Array(buffer, offset, mat4Length);
    offset += Float32Array.BYTES_PER_ELEMENT * mat4Length;
};
var buildRenderCommandBufferForDrawData = function (count, materialIndices, geometryIndices, mMatrices) {
    return {
        renderCommandBufferData: {
            materialIndices: materialIndices,
            geometryIndices: geometryIndices,
            mMatrices: mMatrices
        },
        count: count
    };
};

var createRenderCommandBufferData$2 = requireCheckFunc(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, buildRenderCommandBufferForDrawData$$1) {
    it$$1("renderGameObject should be basic material gameObject", function () {
        for (var _i = 0, renderGameObjectArray_1 = renderGameObjectArray; _i < renderGameObjectArray_1.length; _i++) {
            var gameObject = renderGameObjectArray_1[_i];
            wdet_1(ClassUtils.getClassNameByInstance(getMaterial(gameObject.uid, GameObjectData))).equal("BasicMaterial");
        }
    });
}, function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, buildRenderCommandBufferForDrawData$$1) {
    var count = renderGameObjectArray.length, buffer = RenderCommandBufferData.buffer, mMatrices = RenderCommandBufferData.mMatrices, materialIndices = RenderCommandBufferData.materialIndices, geometryIndices = RenderCommandBufferData.geometryIndices, mat4Length = getMatrix4DataSize();
    for (var i = 0; i < count; i++) {
        var matIndex = mat4Length * i, gameObject = renderGameObjectArray[i], uid = gameObject.uid, geometry = getGeometry(uid, GameObjectData), material = getMaterial(uid, GameObjectData), transform = getTransform(uid, GameObjectData), materialIndex = material.index;
        setMatrices(mMatrices, getLocalToWorldMatrix(transform, getTempLocalToWorldMatrix(transform, ThreeDTransformData), ThreeDTransformData), matIndex);
        materialIndices[i] = materialIndex;
        geometryIndices[i] = geometry.index;
    }
    return buildRenderCommandBufferForDrawData$$1(count, buffer, materialIndices, geometryIndices, mMatrices);
});
var initData$16 = function (DataBufferConfig, RenderCommandBufferData) {
    var mat4Length = getMatrix4DataSize(), size = Float32Array.BYTES_PER_ELEMENT * mat4Length + Uint32Array.BYTES_PER_ELEMENT * 2, buffer = null, count = DataBufferConfig.renderCommandBufferCount;
    buffer = createSharedArrayBufferOrArrayBuffer(count * size + Float32Array.BYTES_PER_ELEMENT * (mat4Length * 2));
    createTypeArrays$4(buffer, DataBufferConfig, RenderCommandBufferData);
    RenderCommandBufferData.buffer = buffer;
};

var createRenderCommandBufferData$1 = requireCheckFunc(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    it$$1("renderGameObject should be basic material gameObject", function () {
        for (var _i = 0, renderGameObjectArray_1 = renderGameObjectArray; _i < renderGameObjectArray_1.length; _i++) {
            var gameObject = renderGameObjectArray_1[_i];
            wdet_1(ClassUtils.getClassNameByInstance(getMaterial(gameObject.uid, GameObjectData))).equal("BasicMaterial");
        }
    });
}, function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    return createRenderCommandBufferData$2(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, function (count, buffer, materialIndices, geometryIndices, mMatrices) {
        return buildRenderCommandBufferForDrawData(count, materialIndices, geometryIndices, mMatrices);
    });
});

var createTypeArrays$5 = function (buffer, DataBufferConfig, RenderCommandBufferDataFromSystem) {
    var mat3Length = getMatrix3DataSize(), mat4Length = getMatrix4DataSize(), cameraPositionLength = getVector3DataSize(), count = DataBufferConfig.renderCommandBufferCount, offset = 0;
    RenderCommandBufferDataFromSystem.mMatrices = new Float32Array(buffer, offset, count * mat4Length);
    offset += count * Float32Array.BYTES_PER_ELEMENT * mat4Length;
    RenderCommandBufferDataFromSystem.materialIndices = new Uint32Array(buffer, offset, count);
    offset += count * Uint32Array.BYTES_PER_ELEMENT;
    RenderCommandBufferDataFromSystem.geometryIndices = new Uint32Array(buffer, offset, count);
    offset += count * Uint32Array.BYTES_PER_ELEMENT;
    RenderCommandBufferDataFromSystem.vMatrices = new Float32Array(buffer, offset, mat4Length);
    offset += Float32Array.BYTES_PER_ELEMENT * mat4Length;
    RenderCommandBufferDataFromSystem.pMatrices = new Float32Array(buffer, offset, mat4Length);
    offset += Float32Array.BYTES_PER_ELEMENT * mat4Length;
    RenderCommandBufferDataFromSystem.cameraPositions = new Float32Array(buffer, offset, cameraPositionLength);
    offset += Float32Array.BYTES_PER_ELEMENT * cameraPositionLength;
    RenderCommandBufferDataFromSystem.normalMatrices = new Float32Array(buffer, offset, mat3Length);
    offset += Float32Array.BYTES_PER_ELEMENT * mat3Length;
};
var buildRenderCommandBufferForDrawData$1 = function (count, materialIndices, geometryIndices, mMatrices) {
    return {
        renderCommandBufferData: {
            materialIndices: materialIndices,
            geometryIndices: geometryIndices,
            mMatrices: mMatrices
        },
        count: count
    };
};

var updateProjectionMatrix$1 = requireCheckFunc(function (index, PerspectiveCameraData, CameraData) {
    it$$1("fovy should exist", function () {
        wdet_1(isValidMapValue(PerspectiveCameraData.fovyMap[index])).true;
    });
    it$$1("aspect should exist", function () {
        wdet_1(isValidMapValue(PerspectiveCameraData.aspectMap[index])).true;
    });
    it$$1("near should exist", function () {
        wdet_1(isValidMapValue(CameraData.nearMap[index])).true;
    });
    it$$1("far should exist", function () {
        wdet_1(isValidMapValue(CameraData.farMap[index])).true;
    });
}, function (index, PerspectiveCameraData, CameraData) {
    setPMatrix(index, _getOrCreatePMatrix(index, CameraData).setPerspective(PerspectiveCameraData.fovyMap[index], PerspectiveCameraData.aspectMap[index], CameraData.nearMap[index], CameraData.farMap[index]), CameraData);
});
var _getOrCreatePMatrix = function (index, CameraData) {
    var mat = CameraData.pMatrixMap[index];
    if (isValidMapValue(mat)) {
        return mat;
    }
    return Matrix4.create();
};
var getFovy = function (index, PerspectiveCameraData) {
    return PerspectiveCameraData.fovyMap[index];
};
var setFovy = function (index, fovy, PerspectiveCameraData, CameraControllerData) {
    PerspectiveCameraData.fovyMap[index] = fovy;
    addToDirtyList$1(index, CameraControllerData);
};
var getAspect = function (index, PerspectiveCameraData) {
    return PerspectiveCameraData.aspectMap[index];
};
var setAspect = function (index, aspect, PerspectiveCameraData, CameraControllerData) {
    PerspectiveCameraData.aspectMap[index] = aspect;
    addToDirtyList$1(index, CameraControllerData);
};
var dispose$4 = function (index, PerspectiveCameraData) {
    deleteVal$1(index, PerspectiveCameraData.fovyMap);
    deleteVal$1(index, PerspectiveCameraData.aspectMap);
};
var initData$22 = function (PerspectiveCameraData) {
    PerspectiveCameraData.fovyMap = createMap();
    PerspectiveCameraData.aspectMap = createMap();
};

var init$4 = function (state, index, PerspectiveCameraData, CameraData) {
    updateProjectionMatrix$$1(index, PerspectiveCameraData, CameraData);
};
var updateProjectionMatrix$$1 = function (index, PerspectiveCameraData, CameraData) {
    updateProjectionMatrix$1(index, PerspectiveCameraData, CameraData);
};
var getWorldToCameraMatrix$1 = function (index, ThreeDTransformData, GameObjectData, CameraControllerData, CameraData) {
    return _getCameraToWorldMatrix(index, ThreeDTransformData, GameObjectData, CameraControllerData, CameraData).clone().invert();
};
var _getCameraToWorldMatrix = function (index, ThreeDTransformData, GameObjectData, CameraControllerData, CameraData) {
    var transform = getTransform(getGameObject$5(index, CameraControllerData).uid, GameObjectData);
    return getLocalToWorldMatrix(transform, getTempLocalToWorldMatrix(transform, ThreeDTransformData), ThreeDTransformData);
};
var getPMatrix$1 = function (index, CameraData) {
    return CameraData.pMatrixMap[index];
};
var setPMatrix = function (index, pMatrix, CameraData) {
    CameraData.pMatrixMap[index] = pMatrix;
};
var getNear = function (index, CameraData) {
    return CameraData.nearMap[index];
};
var setNear = function (index, near, CameraControllerData, CameraData) {
    CameraData.nearMap[index] = near;
    addToDirtyList$1(index, CameraControllerData);
};
var getFar = function (index, CameraData) {
    return CameraData.farMap[index];
};
var setFar = function (index, far, CameraControllerData, CameraData) {
    CameraData.farMap[index] = far;
    addToDirtyList$1(index, CameraControllerData);
};
var dispose$3 = function (index, PerspectiveCameraData, CameraData) {
    deleteVal$1(index, CameraData.nearMap);
    deleteVal$1(index, CameraData.farMap);
    deleteVal$1(index, CameraData.worldToCameraMatrixMap);
    deleteVal$1(index, CameraData.pMatrixMap);
    dispose$4(index, PerspectiveCameraData);
};
var initData$21 = function (PerspectiveCameraData, CameraData) {
    CameraData.nearMap = createMap();
    CameraData.farMap = createMap();
    CameraData.worldToCameraMatrixMap = createMap();
    CameraData.pMatrixMap = createMap();
    initData$22(PerspectiveCameraData);
};

var CameraControllerData = (function () {
    function CameraControllerData() {
    }
    CameraControllerData.index = null;
    CameraControllerData.count = null;
    CameraControllerData.dirtyIndexArray = null;
    CameraControllerData.gameObjectMap = null;
    CameraControllerData.worldToCameraMatrixCacheMap = null;
    return CameraControllerData;
}());

var PerspectiveCameraData = (function () {
    function PerspectiveCameraData() {
    }
    PerspectiveCameraData.fovyMap = null;
    PerspectiveCameraData.aspectMap = null;
    return PerspectiveCameraData;
}());

var CameraData = (function () {
    function CameraData() {
    }
    CameraData.nearMap = null;
    CameraData.farMap = null;
    CameraData.worldToCameraMatrixMap = null;
    CameraData.pMatrixMap = null;
    return CameraData;
}());

var addAddComponentHandle$5 = function (_class) {
    addAddComponentHandle(_class, addComponent$6);
};
var addDisposeHandle$4 = function (_class) {
    addDisposeHandle(_class, disposeComponent$6);
};
var create$9 = requireCheckFunc(function (CameraControllerData$$1) {
    checkIndexShouldEqualCount(CameraControllerData$$1);
}, function (CameraControllerData$$1) {
    var controller = new CameraController(), index = generateComponentIndex(CameraControllerData$$1);
    controller.index = index;
    CameraControllerData$$1.count += 1;
    addToDirtyList$1(index, CameraControllerData$$1);
    return controller;
});
var addToDirtyList$1 = ensureFunc$$1(function (index, CameraControllerData$$1) {
}, function (index, CameraControllerData$$1) {
    CameraControllerData$$1.dirtyIndexArray.push(index);
});
var init$3 = function (PerspectiveCameraData$$1, CameraData$$1, CameraControllerData$$1, state) {
    _forEachDirtyList(CameraControllerData$$1.dirtyIndexArray, function (dirtyIndex) {
        initCameraController(state, dirtyIndex, PerspectiveCameraData$$1, CameraData$$1);
    });
    _clearDirtyList(CameraControllerData$$1);
    return state;
};
var initCameraController = function (state, index, PerspectiveCameraData$$1, CameraData$$1) {
    init$4(state, index, PerspectiveCameraData$$1, CameraData$$1);
};
var _forEachDirtyList = function (dirtyIndexArray, func) {
    var arr = removeDuplicateItems(dirtyIndexArray);
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var dirtyIndex = arr_1[_i];
        func(dirtyIndex);
    }
};
var _clearDirtyList = function (CameraControllerData$$1) {
    CameraControllerData$$1.dirtyIndexArray = [];
};
var update$4 = function (PerspectiveCameraData$$1, CameraData$$1, CameraControllerData$$1, state) {
    _forEachDirtyList(CameraControllerData$$1.dirtyIndexArray, function (dirtyIndex) {
        updateProjectionMatrix$$1(dirtyIndex, PerspectiveCameraData$$1, CameraData$$1);
    });
    _clearDirtyList(CameraControllerData$$1);
    _clearCache(CameraControllerData$$1);
    return state;
};
var addComponent$6 = function (component, gameObject) {
    addComponentToGameObjectMap(CameraControllerData.gameObjectMap, component.index, gameObject);
};
var disposeComponent$6 = function (component) {
    var index = component.index;
    deleteVal$1(index, CameraControllerData.gameObjectMap);
    deleteVal$1(index, CameraControllerData.worldToCameraMatrixCacheMap);
    CameraControllerData.count -= 1;
    CameraControllerData.dirtyIndexArray = removeItem(CameraControllerData.dirtyIndexArray, index);
    dispose$3(index, PerspectiveCameraData, CameraData);
};
var getGameObject$5 = function (index, CameraControllerData$$1) {
    return getComponentGameObject(CameraControllerData$$1.gameObjectMap, index);
};
var getWorldToCameraMatrix$$1 = cacheFunc(function (index, ThreeDTransformData, GameObjectData, CameraControllerData$$1, CameraData$$1) {
    return isValidMapValue(CameraControllerData$$1.worldToCameraMatrixCacheMap[index]);
}, function (index, ThreeDTransformData, GameObjectData, CameraControllerData$$1, CameraData$$1) {
    return CameraControllerData$$1.worldToCameraMatrixCacheMap[index];
}, function (index, ThreeDTransformData, GameObjectData, CameraControllerData$$1, CameraData$$1, worldToCamraMatrix) {
    CameraControllerData$$1.worldToCameraMatrixCacheMap[index] = worldToCamraMatrix;
}, function (index, ThreeDTransformData, GameObjectData, CameraControllerData$$1, CameraData$$1) {
    return getWorldToCameraMatrix$1(index, ThreeDTransformData, GameObjectData, CameraControllerData$$1, CameraData$$1);
});
var getPMatrix$$1 = function (index, CameraData$$1) {
    return getPMatrix$1(index, CameraData$$1);
};
var _clearCache = function (CameraControllerData$$1) {
    CameraControllerData$$1.worldToCameraMatrixCacheMap = {};
};
var initData$20 = function (CameraControllerData$$1, PerspectiveCameraData$$1, CameraData$$1) {
    CameraControllerData$$1.index = 0;
    CameraControllerData$$1.count = 0;
    CameraControllerData$$1.gameObjectMap = createMap();
    CameraControllerData$$1.dirtyIndexArray = [];
    CameraControllerData$$1.worldToCameraMatrixCacheMap = createMap();
    initData$21(PerspectiveCameraData$$1, CameraData$$1);
};

var CameraController = (function (_super) {
    __extends(CameraController, _super);
    function CameraController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CameraController = __decorate([
        registerClass$1("CameraController")
    ], CameraController);
    return CameraController;
}(Component));
var createCameraController = function () {
    return create$9(CameraControllerData);
};
var getCameraControllerGameObject = function (component) {
    return getGameObject$5(component.index, CameraControllerData);
};

var create$8 = function (GameObjectData) {
    return create$2(null, GameObjectData);
};
var addChild$1 = function (scene, child, ThreeDTransformData, GameObjectData, SceneData) {
    if (_isCamera(child, GameObjectData)) {
        SceneData.cameraArray.push(child);
    }
    addChild(scene, child, ThreeDTransformData, GameObjectData);
};
var removeChild$1 = function (parentUId, childUId, ThreeDTransformData, GameObjectData) {
    removeChild(parentUId, childUId, ThreeDTransformData, GameObjectData);
};
var _isCamera = function (gameObject, GameObjectData) {
    return hasComponent(gameObject, getComponentIdFromClass(CameraController), GameObjectData);
};
var getCurrentCamera = ensureFunc$$1(function (camera, SceneData) {
    it$$1("current camera should exist", function () {
        wdet_1(camera).exist;
    });
}, function (SceneData) {
    return SceneData.cameraArray[0];
});
var initData$19 = function (SceneData) {
    SceneData.cameraArray = [];
};

var createRenderCommandBufferData$4 = requireCheckFunc(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, buildRenderCommandBufferForDrawData) {
    it$$1("renderGameObject should be light material gameObject", function () {
        for (var _i = 0, renderGameObjectArray_1 = renderGameObjectArray; _i < renderGameObjectArray_1.length; _i++) {
            var gameObject = renderGameObjectArray_1[_i];
            wdet_1(ClassUtils.getClassNameByInstance(getMaterial(gameObject.uid, GameObjectData))).equal("LightMaterial");
        }
    });
}, function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, buildRenderCommandBufferForDrawData) {
    var count = renderGameObjectArray.length, buffer = RenderCommandBufferData.buffer, mMatrices = RenderCommandBufferData.mMatrices, vMatrices = RenderCommandBufferData.vMatrices, pMatrices = RenderCommandBufferData.pMatrices, cameraPositions = RenderCommandBufferData.cameraPositions, normalMatrices = RenderCommandBufferData.normalMatrices, materialIndices = RenderCommandBufferData.materialIndices, geometryIndices = RenderCommandBufferData.geometryIndices, currentCameraUId = getCurrentCamera(SceneData).uid, currentCameraComponent = getComponent(currentCameraUId, getComponentIdFromClass(CameraController), GameObjectData), currentCameraIndex = currentCameraComponent.index, currentCameraTransform = getTransform(currentCameraUId, GameObjectData), mat4Length = getMatrix4DataSize();
    setMatrices(vMatrices, getWorldToCameraMatrix$$1(currentCameraIndex, ThreeDTransformData, GameObjectData, CameraControllerData, CameraData), 0);
    setMatrices(pMatrices, getPMatrix$$1(currentCameraIndex, CameraData), 0);
    setVectors(cameraPositions, getPosition(currentCameraTransform, ThreeDTransformData), 0);
    setMatrices3(normalMatrices, getNormalMatrix(currentCameraTransform, GlobalTempData, ThreeDTransformData), 0);
    for (var i = 0; i < count; i++) {
        var matIndex = mat4Length * i, gameObject = renderGameObjectArray[i], uid = gameObject.uid, geometry = getGeometry(uid, GameObjectData), material = getMaterial(uid, GameObjectData), transform = getTransform(uid, GameObjectData), materialIndex = material.index;
        setMatrices(mMatrices, getLocalToWorldMatrix(transform, getTempLocalToWorldMatrix(transform, ThreeDTransformData), ThreeDTransformData), matIndex);
        materialIndices[i] = materialIndex;
        geometryIndices[i] = geometry.index;
    }
    return buildRenderCommandBufferForDrawData(count, buffer, materialIndices, geometryIndices, mMatrices, vMatrices, pMatrices, cameraPositions, normalMatrices);
});
var initData$18 = function (DataBufferConfig, RenderCommandBufferData) {
    var mat3Length = getMatrix3DataSize(), mat4Length = getMatrix4DataSize(), cameraPositionLength = getVector3DataSize(), size = Float32Array.BYTES_PER_ELEMENT * mat4Length + Uint32Array.BYTES_PER_ELEMENT * 2, buffer = null, count = DataBufferConfig.renderCommandBufferCount;
    buffer = createSharedArrayBufferOrArrayBuffer(count * size + Float32Array.BYTES_PER_ELEMENT * (mat3Length + mat4Length * 2 + cameraPositionLength));
    createTypeArrays$5(buffer, DataBufferConfig, RenderCommandBufferData);
    RenderCommandBufferData.buffer = buffer;
};

var createRenderCommandBufferData$3 = curry(requireCheckFunc(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    it$$1("renderGameObject should be light material gameObject", function () {
        for (var _i = 0, renderGameObjectArray_1 = renderGameObjectArray; _i < renderGameObjectArray_1.length; _i++) {
            var gameObject = renderGameObjectArray_1[_i];
            wdet_1(ClassUtils.getClassNameByInstance(getMaterial(gameObject.uid, GameObjectData))).equal("LightMaterial");
        }
    });
}, function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    return createRenderCommandBufferData$4(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, function (count, buffer, materialIndices, geometryIndices, mMatrices) {
        return buildRenderCommandBufferForDrawData$1(count, materialIndices, geometryIndices, mMatrices);
    });
}), 11);

var createRenderCommandBufferData$5 = requireCheckFunc(function (state, createBasicRenderCommandBufferData, createLightRenderCommandBufferData, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData, renderGameObjectArray) {
    it$$1("renderGameObjectArray.length should not exceed RenderCommandBufferData->buffer's count", function () {
        wdet_1(renderGameObjectArray.length).lte(DataBufferConfig.renderCommandBufferCount);
    });
}, function (state, createBasicRenderCommandBufferData, createLightRenderCommandBufferData, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData, renderGameObjectArray) {
    var basicMaterialGameObjectArr = [], lightMaterialGameObjectArr = [], vMatrix = null, pMatrix = null, cameraPosition = null, normalMatrix = null, currentCameraUId = getCurrentCamera(SceneData).uid, currentCameraComponent = getComponent(currentCameraUId, getComponentIdFromClass(CameraController), GameObjectData), currentCameraIndex = currentCameraComponent.index, currentCameraTransform = getTransform(currentCameraUId, GameObjectData);
    vMatrix = getWorldToCameraMatrix$$1(currentCameraIndex, ThreeDTransformData, GameObjectData, CameraControllerData, CameraData).values;
    pMatrix = getPMatrix$$1(currentCameraIndex, CameraData).values;
    cameraPosition = getPosition(currentCameraTransform, ThreeDTransformData).values;
    normalMatrix = getNormalMatrix(currentCameraTransform, GlobalTempData, ThreeDTransformData).values;
    for (var _i = 0, renderGameObjectArray_1 = renderGameObjectArray; _i < renderGameObjectArray_1.length; _i++) {
        var gameObject = renderGameObjectArray_1[_i];
        var material = getMaterial(gameObject.uid, GameObjectData);
        if (ClassUtils.getClassNameByInstance(material) === "BasicMaterial") {
            basicMaterialGameObjectArr.push(gameObject);
        }
        else {
            lightMaterialGameObjectArr.push(gameObject);
        }
    }
    return {
        cameraData: {
            vMatrix: vMatrix,
            pMatrix: pMatrix,
            cameraPosition: cameraPosition,
            normalMatrix: normalMatrix
        },
        basicData: createBasicRenderCommandBufferData(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, basicMaterialGameObjectArr),
        lightData: createLightRenderCommandBufferData(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, LightRenderCommandBufferData, lightMaterialGameObjectArr)
    };
});
var initData$23 = function (DataBufferConfig$$1, BasicRenderCommandBufferData, LightRenderCommandBufferData) {
    initData$16(DataBufferConfig$$1, BasicRenderCommandBufferData);
    initData$18(DataBufferConfig$$1, LightRenderCommandBufferData);
};

var createRenderCommandBufferData$$1 = curry(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData, renderGameObjectArray) {
    return createRenderCommandBufferData$5(state, createRenderCommandBufferData$1, createRenderCommandBufferData$3, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData, renderGameObjectArray);
}, 12);
var initData$8 = initData$23;

var EWorkerOperateType;
(function (EWorkerOperateType) {
    EWorkerOperateType[EWorkerOperateType["INIT_CONFIG"] = 0] = "INIT_CONFIG";
    EWorkerOperateType[EWorkerOperateType["INIT_DATA"] = 1] = "INIT_DATA";
    EWorkerOperateType[EWorkerOperateType["INIT_GL"] = 2] = "INIT_GL";
    EWorkerOperateType[EWorkerOperateType["INIT_VIEWPORT"] = 3] = "INIT_VIEWPORT";
    EWorkerOperateType[EWorkerOperateType["INIT_CLEARCOLOR"] = 4] = "INIT_CLEARCOLOR";
    EWorkerOperateType[EWorkerOperateType["INIT_MATERIAL_GEOMETRY_LIGHT_TEXTURE"] = 5] = "INIT_MATERIAL_GEOMETRY_LIGHT_TEXTURE";
    EWorkerOperateType[EWorkerOperateType["DRAW"] = 6] = "DRAW";
})(EWorkerOperateType || (EWorkerOperateType = {}));

var EGeometryWorkerDataOperateType;
(function (EGeometryWorkerDataOperateType) {
    EGeometryWorkerDataOperateType[EGeometryWorkerDataOperateType["ADD"] = 0] = "ADD";
    EGeometryWorkerDataOperateType[EGeometryWorkerDataOperateType["RESET"] = 1] = "RESET";
})(EGeometryWorkerDataOperateType || (EGeometryWorkerDataOperateType = {}));

var getRenderWorker = function (WorkerInstanceData) {
    return WorkerInstanceData.renderWorker;
};
var setRenderWorker = function (worker, WorkerInstanceData) {
    WorkerInstanceData.renderWorker = worker;
};
var createWorker = function (workerFilePath) {
    return new Worker(workerFilePath);
};
var initWorkInstances = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    initWorkInstances = function (WorkerInstanceData) {
        setRenderWorker(createWorker(getRenderWorkerFilePath()), WorkerInstanceData);
    };
}
else {
    initWorkInstances = function (WorkerInstanceData) {
    };
}

var Light = (function (_super) {
    __extends(Light, _super);
    function Light() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Light = __decorate([
        registerClass$1("Light")
    ], Light);
    return Light;
}(Component));
var checkLightShouldAlive = function (component) {
    checkComponentShouldAlive(component, null, function (component) {
        return isComponentIndexNotRemoved(component);
    });
};

var getColorDataSize$1 = function () { return 3; };
var getDirtyDataSize = function () { return 1; };
var isDirty = function (value) { return value === 0; };
var cleanDirty = function (index, isDirtys) {
    isDirtys[index] = 1;
};

var create$11 = requireCheckFunc(function (light, SpecifyLightData) {
    checkIndexShouldEqualCount(SpecifyLightData);
}, function (light, SpecifyLightData) {
    var index = generateComponentIndex(SpecifyLightData);
    light.index = index;
    SpecifyLightData.count += 1;
    SpecifyLightData.lightMap[index] = light;
    return light;
});
var addComponent$7 = function (component, gameObject, SpecifyLightData) {
    addComponentToGameObjectMap(SpecifyLightData.gameObjectMap, component.index, gameObject);
};
var setColor$2 = function (index, color, colors) {
    setColor3Data(index, color, colors);
};
var disposeComponent$8 = ensureFunc$$1(function (lastComponentIndex, sourceIndex, SpecifyLightData) {
    checkIndexShouldEqualCount(SpecifyLightData);
}, function (sourceIndex, SpecifyLightData) {
    var colorDataSize = getColorDataSize$1(), lastComponentIndex = null;
    SpecifyLightData.count -= 1;
    SpecifyLightData.index -= 1;
    lastComponentIndex = SpecifyLightData.count;
    deleteBySwap(sourceIndex, lastComponentIndex, SpecifyLightData.gameObjectMap);
    deleteComponentBySwapArray(sourceIndex, lastComponentIndex, SpecifyLightData.lightMap);
    deleteBySwapAndReset(sourceIndex * colorDataSize, lastComponentIndex * colorDataSize, SpecifyLightData.colors, colorDataSize, SpecifyLightData.defaultColorArr);
    return lastComponentIndex;
});
var initData$25 = function (buffer, SpecifyLightData) {
    SpecifyLightData.index = 0;
    SpecifyLightData.count = 0;
    SpecifyLightData.lightMap = [];
    SpecifyLightData.gameObjectMap = [];
    SpecifyLightData.defaultColorArr = createDefaultColor$1().toArray3();
    SpecifyLightData.defaultDirty = 0;
    SpecifyLightData.buffer = buffer;
};
var createDefaultColor$1 = function () {
    return Color.create().setColorByNum("#ffffff");
};
var getPosition$2 = function (index, ThreeDTransformData, GameObjectData, SpecifyLightData) {
    return getPosition(getTransform(getGameObject$6(index, SpecifyLightData).uid, GameObjectData), ThreeDTransformData);
};
var getGameObject$6 = function (index, SpecifyLightData) {
    return getComponentGameObject(SpecifyLightData.gameObjectMap, index);
};
var markDirty = function (index, isDirtys) {
    isDirtys[index] = 0;
};
var bindChangePositionEvent = function (SpecifyLightData, state) {
    var eventName = "changePosition";
    var _loop_1 = function (i, count) {
        var _markPositionDirty = function () {
            markDirty(i, SpecifyLightData.isPositionDirtys);
        };
        registerEvent(eventName, _markPositionDirty);
    };
    for (var i = 0, count = SpecifyLightData.count; i < count; i++) {
        _loop_1(i, count);
    }
    return state;
};

var SpecifyLightData = (function () {
    function SpecifyLightData() {
    }
    SpecifyLightData.index = null;
    SpecifyLightData.count = null;
    SpecifyLightData.buffer = null;
    SpecifyLightData.colors = null;
    SpecifyLightData.isColorDirtys = null;
    SpecifyLightData.gameObjectMap = null;
    SpecifyLightData.lightMap = null;
    SpecifyLightData.defaultColorArr = null;
    SpecifyLightData.defaultDirty = null;
    return SpecifyLightData;
}());

var DirectionLightData = (function (_super) {
    __extends(DirectionLightData, _super);
    function DirectionLightData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DirectionLightData.intensities = null;
    DirectionLightData.isPositionDirtys = null;
    DirectionLightData.isIntensityDirtys = null;
    DirectionLightData.defaultIntensity = null;
    return DirectionLightData;
}(SpecifyLightData));

var WebGL2DirectionLightData = (function (_super) {
    __extends(WebGL2DirectionLightData, _super);
    function WebGL2DirectionLightData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2DirectionLightData;
}(DirectionLightData));

var WebGL1DirectionLightData = (function (_super) {
    __extends(WebGL1DirectionLightData, _super);
    function WebGL1DirectionLightData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGL1DirectionLightData.lightGLSLDataStructureMemberNameArr = null;
    return WebGL1DirectionLightData;
}(DirectionLightData));

var WebGLDetectData = (function () {
    function WebGLDetectData() {
    }
    WebGLDetectData.version = null;
    return WebGLDetectData;
}());

var detect$1 = function (WebGLDetectData$$1) {
    if (typeof root$2.webglVersion !== "undefined") {
        if (root$2.webglVersion === 1) {
            WebGLDetectData$$1.version = EWebGLVersion.WEBGL1;
        }
        else {
            WebGLDetectData$$1.version = EWebGLVersion.WEBGL2;
        }
        return;
    }
    var canvas = DomQuery.create("<canvas></canvas>").get(0), options = {}, gl = getOnlyWebgl2Context(options, canvas);
    if (!gl) {
        gl = getOnlyWebgl1Context(options, canvas);
        if (!gl) {
            return null;
        }
        else {
            WebGLDetectData$$1.version = EWebGLVersion.WEBGL1;
        }
    }
    else {
        WebGLDetectData$$1.version = EWebGLVersion.WEBGL2;
    }
};
var isWebgl1$1 = function () { return isWebgl1(WebGLDetectData); };

var getVersion = function (WebGLDetectData$$1) { return WebGLDetectData$$1.version; };
detect$1(WebGLDetectData);

var DirectionLight = (function (_super) {
    __extends(DirectionLight, _super);
    function DirectionLight() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DirectionLight = __decorate([
        registerClass$1("DirectionLight")
    ], DirectionLight);
    return DirectionLight;
}(Light));
var createDirectionLight = null;
var getDirectionLightGameObject = null;
var getDirectionLightPosition = null;
var getDirectionLightColor = null;
var setDirectionLightColor = null;
var getDirectionLightIntensity = null;
var setDirectionLightIntensity = null;
if (isWebgl1$1()) {
    createDirectionLight = function () {
        return create$10(WebGL1DirectionLightData);
    };
    getDirectionLightGameObject = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getGameObject$6(component.index, WebGL1DirectionLightData);
    });
    getDirectionLightPosition = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getPosition$1(component.index, ThreeDTransformData, GameObjectData, WebGL1DirectionLightData);
    });
    getDirectionLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getColor$1(light.index, WebGL1DirectionLightData);
    });
    setDirectionLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, color) {
        setColor$1(light.index, color, WebGL1DirectionLightData);
    });
    getDirectionLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getIntensity$$1(light.index, WebGL1DirectionLightData);
    });
    setDirectionLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setIntensity(light.index, value, WebGL1DirectionLightData);
    });
}
else {
    createDirectionLight = function () {
        return create$10(WebGL2DirectionLightData);
    };
    getDirectionLightGameObject = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getGameObject$6(component.index, WebGL2DirectionLightData);
    });
    getDirectionLightPosition = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getPosition$1(component.index, ThreeDTransformData, GameObjectData, WebGL2DirectionLightData);
    });
    getDirectionLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getColor$1(light.index, WebGL2DirectionLightData);
    });
    setDirectionLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, color) {
        setColor$1(light.index, color, WebGL2DirectionLightData);
    });
    getDirectionLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getIntensity$$1(light.index, WebGL2DirectionLightData);
    });
    setDirectionLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setIntensity(light.index, value, WebGL2DirectionLightData);
    });
}

var getColorDataSize$2 = getColorDataSize$1;
var getIntensityDataSize = function () { return 1; };

var getColorArr3$4 = function (index, DirectionLightDataFromSystem) {
    return getColorArr3$1(index, DirectionLightDataFromSystem);
};
var getIntensity$1 = function (index, DirectionLightDataFromSystem) {
    return getSingleSizeData(index, DirectionLightDataFromSystem.intensities);
};
var createTypeArrays$6 = function (buffer, count, DirectionLightDataFromSystem) {
    var offset = 0;
    DirectionLightDataFromSystem.colors = new Float32Array(buffer, offset, count * getColorDataSize$2());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getColorDataSize$2();
    DirectionLightDataFromSystem.intensities = new Float32Array(buffer, offset, count * getIntensityDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getIntensityDataSize();
    DirectionLightDataFromSystem.isPositionDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
    DirectionLightDataFromSystem.isColorDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
    DirectionLightDataFromSystem.isIntensityDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
};
var isPositionDirty$1 = function (index, DirectionLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, DirectionLightDataFromSystem.isPositionDirtys));
};
var isColorDirty$1 = function (index, DirectionLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, DirectionLightDataFromSystem.isColorDirtys));
};
var isIntensityDirty$1 = function (index, DirectionLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, DirectionLightDataFromSystem.isIntensityDirtys));
};
var cleanPositionDirty$1 = function (index, DirectionLightDataFromSystem) {
    cleanDirty(index, DirectionLightDataFromSystem.isPositionDirtys);
};
var cleanColorDirty$1 = function (index, DirectionLightDataFromSystem) {
    cleanDirty(index, DirectionLightDataFromSystem.isColorDirtys);
};
var cleanIntensityDirty$1 = function (index, DirectionLightDataFromSystem) {
    cleanDirty(index, DirectionLightDataFromSystem.isIntensityDirtys);
};

var getAmbientLightBufferCount = function () {
    return DataBufferConfig.ambientLightDataBufferCount;
};
var getDirectionLightBufferCount = function () {
    return DataBufferConfig.directionLightDataBufferCount;
};
var getPointLightBufferCount = function () {
    return DataBufferConfig.pointLightDataBufferCount;
};

var create$10 = ensureFunc$$1(function (light, DirectionLightData) {
    it$$1("shouldn't create after Director->init", function () {
        wdet_1(isInit(DirectorData)).false;
    });
}, function (DirectionLightData) {
    var light = new DirectionLight();
    light = create$11(light, DirectionLightData);
    return light;
});
var getPosition$1 = function (index, ThreeDTransformData, GameObjectData, DirectionLightData) {
    return getPosition$2(index, ThreeDTransformData, GameObjectData, DirectionLightData);
};
var getAllPositionData = function (ThreeDTransformData, GameObjectData, DirectionLightData) {
    var positionArr = [];
    for (var i = 0, count = DirectionLightData.count; i < count; i++) {
        positionArr.push(getPosition$1(i, ThreeDTransformData, GameObjectData, DirectionLightData).values);
    }
    return positionArr;
};
var getColor$1 = function (index, DirectionLightData) {
    return getColor3Data(index, DirectionLightData.colors);
};
var getColorArr3$3 = getColorArr3$4;
var setColor$1 = function (index, color, DirectionLightData) {
    setColor$2(index, color, DirectionLightData.colors);
    markDirty(index, DirectionLightData.isColorDirtys);
};
var getIntensity$$1 = getIntensity$1;
var setIntensity = function (index, intensity, DirectionLightData) {
    var size = getIntensityDataSize(), i = index * size;
    setTypeArrayValue(DirectionLightData.intensities, i, intensity);
    markDirty(index, DirectionLightData.isIntensityDirtys);
};
var disposeComponent$7 = function (component, DirectionLightData) {
    var intensityDataSize = getIntensityDataSize(), dirtyDataSize = getDirtyDataSize(), sourceIndex = component.index, lastComponentIndex = null;
    lastComponentIndex = disposeComponent$8(sourceIndex, DirectionLightData);
    deleteOneItemBySwapAndReset(sourceIndex * intensityDataSize, lastComponentIndex * intensityDataSize, DirectionLightData.intensities, DirectionLightData.defaultIntensity);
    deleteOneItemBySwapAndReset(sourceIndex * dirtyDataSize, lastComponentIndex * dirtyDataSize, DirectionLightData.isPositionDirtys, DirectionLightData.defaultDirty);
    deleteOneItemBySwapAndReset(sourceIndex * dirtyDataSize, lastComponentIndex * dirtyDataSize, DirectionLightData.isColorDirtys, DirectionLightData.defaultDirty);
    deleteOneItemBySwapAndReset(sourceIndex * dirtyDataSize, lastComponentIndex * dirtyDataSize, DirectionLightData.isIntensityDirtys, DirectionLightData.defaultDirty);
};
var initDataHelper = function (DirectionLightData) {
    var count = getDirectionLightBufferCount(), size = Float32Array.BYTES_PER_ELEMENT * (getColorDataSize$2() + getIntensityDataSize()) + Uint8Array.BYTES_PER_ELEMENT + (getDirtyDataSize() * 3), buffer = null;
    buffer = createSharedArrayBufferOrArrayBuffer(count * size);
    initData$25(buffer, DirectionLightData);
    createTypeArrays$6(buffer, count, DirectionLightData);
    DirectionLightData.defaultIntensity = 1;
    _setDefaultTypeArrData$3(count, DirectionLightData);
};
var _setDefaultTypeArrData$3 = function (count, DirectionLightData) {
    var color = createDefaultColor$1(), intensity = DirectionLightData.defaultIntensity;
    for (var i = 0; i < count; i++) {
        setColor$1(i, color, DirectionLightData);
        setIntensity(i, intensity, DirectionLightData);
    }
};
var init$5 = function (DirectionLightData, state) {
    return bindChangePositionEvent(DirectionLightData, state);
};
var isPositionDirty$$1 = isPositionDirty$1;
var isColorDirty$$1 = isColorDirty$1;
var isIntensityDirty$$1 = isIntensityDirty$1;
var cleanPositionDirty$$1 = cleanPositionDirty$1;
var cleanColorDirty$$1 = cleanColorDirty$1;
var cleanIntensityDirty$$1 = cleanIntensityDirty$1;

var PointLightData = (function (_super) {
    __extends(PointLightData, _super);
    function PointLightData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PointLightData.intensities = null;
    PointLightData.constants = null;
    PointLightData.linears = null;
    PointLightData.quadratics = null;
    PointLightData.ranges = null;
    PointLightData.isPositionDirtys = null;
    PointLightData.isIntensityDirtys = null;
    PointLightData.isAttenuationDirtys = null;
    PointLightData.defaultIntensity = null;
    PointLightData.defaultConstant = null;
    PointLightData.defaultLinear = null;
    PointLightData.defaultQuadratic = null;
    PointLightData.defaultRange = null;
    return PointLightData;
}(SpecifyLightData));

var WebGL1PointLightData = (function (_super) {
    __extends(WebGL1PointLightData, _super);
    function WebGL1PointLightData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGL1PointLightData.lightGLSLDataStructureMemberNameArr = null;
    return WebGL1PointLightData;
}(PointLightData));

var WebGL2PointLightData = (function (_super) {
    __extends(WebGL2PointLightData, _super);
    function WebGL2PointLightData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2PointLightData;
}(PointLightData));

var PointLight = (function (_super) {
    __extends(PointLight, _super);
    function PointLight() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PointLight = __decorate([
        registerClass$1("PointLight")
    ], PointLight);
    return PointLight;
}(Light));
var createPointLight = null;
var getPointLightGameObject = null;
var getPointLightPosition = null;
var getPointLightColor = null;
var setPointLightColor = null;
var getPointLightIntensity = null;
var setPointLightIntensity = null;
var getPointLightConstant = null;
var setPointLightConstant = null;
var getPointLightLinear = null;
var setPointLightLinear = null;
var getPointLightQuadratic = null;
var setPointLightQuadratic = null;
var getPointLightRange = null;
var setPointLightRange = null;
var setPointLightRangeLevel = null;
if (isWebgl1$1()) {
    createPointLight = function () {
        return create$12(WebGL1PointLightData);
    };
    getPointLightGameObject = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getGameObject$6(component.index, WebGL1PointLightData);
    });
    getPointLightPosition = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getPosition$3(component.index, ThreeDTransformData, GameObjectData, WebGL1PointLightData);
    });
    getPointLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getColor$3(light.index, WebGL1PointLightData);
    });
    setPointLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, color) {
        setColor$3(light.index, color, WebGL1PointLightData);
    });
    getPointLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getIntensity$2(light.index, WebGL1PointLightData);
    });
    setPointLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setIntensity$1(light.index, value, WebGL1PointLightData);
    });
    getPointLightConstant = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getConstant$$1(light.index, WebGL1PointLightData);
    });
    setPointLightConstant = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setConstant(light.index, value, WebGL1PointLightData);
    });
    getPointLightLinear = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getLinear$$1(light.index, WebGL1PointLightData);
    });
    setPointLightLinear = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setLinear(light.index, value, WebGL1PointLightData);
    });
    getPointLightQuadratic = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getQuadratic$$1(light.index, WebGL1PointLightData);
    });
    setPointLightQuadratic = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setQuadratic(light.index, value, WebGL1PointLightData);
    });
    getPointLightRange = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getRange$$1(light.index, WebGL1PointLightData);
    });
    setPointLightRange = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setRange(light.index, value, WebGL1PointLightData);
    });
    setPointLightRangeLevel = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setRangeLevel(light.index, value, WebGL1PointLightData);
    });
}
else {
    createPointLight = function () {
        return create$12(WebGL2PointLightData);
    };
    getPointLightGameObject = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getGameObject$6(component.index, WebGL2PointLightData);
    });
    getPointLightPosition = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (component) {
        return getPosition$3(component.index, ThreeDTransformData, GameObjectData, WebGL2PointLightData);
    });
    getPointLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getColor$3(light.index, WebGL2PointLightData);
    });
    setPointLightColor = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, color) {
        setColor$3(light.index, color, WebGL2PointLightData);
    });
    getPointLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getIntensity$2(light.index, WebGL2PointLightData);
    });
    setPointLightIntensity = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setIntensity$1(light.index, value, WebGL2PointLightData);
    });
    getPointLightConstant = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getConstant$$1(light.index, WebGL2PointLightData);
    });
    setPointLightConstant = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setConstant(light.index, value, WebGL2PointLightData);
    });
    getPointLightLinear = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getLinear$$1(light.index, WebGL2PointLightData);
    });
    setPointLightLinear = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setLinear(light.index, value, WebGL2PointLightData);
    });
    getPointLightQuadratic = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getQuadratic$$1(light.index, WebGL2PointLightData);
    });
    setPointLightQuadratic = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setQuadratic(light.index, value, WebGL2PointLightData);
    });
    getPointLightRange = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light) {
        return getRange$$1(light.index, WebGL2PointLightData);
    });
    setPointLightRange = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setRange(light.index, value, WebGL2PointLightData);
    });
    setPointLightRangeLevel = requireCheckFunc(function (component) {
        checkLightShouldAlive(component);
    }, function (light, value) {
        setRangeLevel(light.index, value, WebGL2PointLightData);
    });
}

var getColorArr3$6 = function (index, PointLightDataFromSystem) {
    return getColorArr3$1(index, PointLightDataFromSystem);
};
var getIntensity$3 = function (index, PointLightDataFromSystem) {
    return getSingleSizeData(index, PointLightDataFromSystem.intensities);
};
var getConstant$1 = function (index, PointLightDataFromSystem) {
    return getSingleSizeData(index, PointLightDataFromSystem.constants);
};
var getLinear$1 = function (index, PointLightDataFromSystem) {
    return getSingleSizeData(index, PointLightDataFromSystem.linears);
};
var getQuadratic$1 = function (index, PointLightDataFromSystem) {
    return getSingleSizeData(index, PointLightDataFromSystem.quadratics);
};
var getRange$1 = function (index, PointLightDataFromSystem) {
    return getSingleSizeData(index, PointLightDataFromSystem.ranges);
};
var getColorDataSize$3 = getColorDataSize$1;
var getIntensityDataSize$1 = function () { return 1; };
var getConstantDataSize = function () { return 1; };
var getLinearDataSize = function () { return 1; };
var getQuadraticDataSize = function () { return 1; };
var getRangeDataSize = function () { return 1; };
var createTypeArrays$7 = function (buffer, count, PointLightDataFromSystem) {
    var offset = 0;
    PointLightDataFromSystem.colors = new Float32Array(buffer, offset, count * getColorDataSize$3());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getColorDataSize$3();
    PointLightDataFromSystem.intensities = new Float32Array(buffer, offset, count * getIntensityDataSize$1());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getIntensityDataSize$1();
    PointLightDataFromSystem.constants = new Float32Array(buffer, offset, count * getConstantDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getConstantDataSize();
    PointLightDataFromSystem.linears = new Float32Array(buffer, offset, count * getLinearDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getLinearDataSize();
    PointLightDataFromSystem.quadratics = new Float32Array(buffer, offset, count * getQuadraticDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getQuadraticDataSize();
    PointLightDataFromSystem.ranges = new Float32Array(buffer, offset, count * getRangeDataSize());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getRangeDataSize();
    PointLightDataFromSystem.isPositionDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
    PointLightDataFromSystem.isColorDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
    PointLightDataFromSystem.isIntensityDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
    PointLightDataFromSystem.isAttenuationDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
};
var isPositionDirty$3 = function (index, PointLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, PointLightDataFromSystem.isPositionDirtys));
};
var isColorDirty$3 = function (index, PointLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, PointLightDataFromSystem.isColorDirtys));
};
var isIntensityDirty$3 = function (index, PointLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, PointLightDataFromSystem.isIntensityDirtys));
};
var isAttenuationDirty$1 = function (index, PointLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, PointLightDataFromSystem.isAttenuationDirtys));
};
var cleanPositionDirty$3 = function (index, PointLightDataFromSystem) {
    cleanDirty(index, PointLightDataFromSystem.isPositionDirtys);
};
var cleanColorDirty$3 = function (index, PointLightDataFromSystem) {
    cleanDirty(index, PointLightDataFromSystem.isColorDirtys);
};
var cleanIntensityDirty$3 = function (index, PointLightDataFromSystem) {
    cleanDirty(index, PointLightDataFromSystem.isIntensityDirtys);
};
var cleanAttenuationDirty$1 = function (index, PointLightDataFromSystem) {
    cleanDirty(index, PointLightDataFromSystem.isAttenuationDirtys);
};

var create$12 = ensureFunc$$1(function (light, PointLightData) {
    it$$1("shouldn't create after Director->init", function () {
        wdet_1(isInit(DirectorData)).false;
    });
}, function (PointLightData) {
    var light = new PointLight();
    light = create$11(light, PointLightData);
    return light;
});
var getPosition$3 = function (index, ThreeDTransformData, GameObjectData, PointLightData) {
    return getPosition$2(index, ThreeDTransformData, GameObjectData, PointLightData);
};
var getAllPositionData$1 = function (ThreeDTransformData, GameObjectData, PointLightData) {
    var positionArr = [];
    for (var i = 0, count = PointLightData.count; i < count; i++) {
        positionArr.push(getPosition$3(i, ThreeDTransformData, GameObjectData, PointLightData).values);
    }
    return positionArr;
};
var getColor$3 = function (index, PointLightData) {
    return getColor3Data(index, PointLightData.colors);
};
var getColorArr3$5 = getColorArr3$6;
var setColor$3 = function (index, color, PointLightData) {
    setColor$2(index, color, PointLightData.colors);
    markDirty(index, PointLightData.isColorDirtys);
};
var getIntensity$2 = getIntensity$3;
var setIntensity$1 = function (index, value, PointLightData) {
    setSingleValue(PointLightData.intensities, index, value);
    markDirty(index, PointLightData.isIntensityDirtys);
};
var getConstant$$1 = getConstant$1;
var setConstant = function (index, value, PointLightData) {
    setSingleValue(PointLightData.constants, index, value);
    markDirty(index, PointLightData.isAttenuationDirtys);
};
var getLinear$$1 = getLinear$1;
var setLinear = function (index, value, PointLightData) {
    setSingleValue(PointLightData.linears, index, value);
    markDirty(index, PointLightData.isAttenuationDirtys);
};
var getQuadratic$$1 = getQuadratic$1;
var setQuadratic = function (index, value, PointLightData) {
    setSingleValue(PointLightData.quadratics, index, value);
    markDirty(index, PointLightData.isAttenuationDirtys);
};
var getRange$$1 = getRange$1;
var setRange = function (index, value, PointLightData) {
    setSingleValue(PointLightData.ranges, index, value);
    markDirty(index, PointLightData.isAttenuationDirtys);
};
var setRangeLevel = function (index, value, PointLightData) {
    switch (value) {
        case 0:
            setRange(index, 7, PointLightData);
            setLinear(index, 0.7, PointLightData);
            setQuadratic(index, 1.8, PointLightData);
            break;
        case 1:
            setRange(index, 13, PointLightData);
            setLinear(index, 0.35, PointLightData);
            setQuadratic(index, 0.44, PointLightData);
            break;
        case 2:
            setRange(index, 20, PointLightData);
            setLinear(index, 0.22, PointLightData);
            setQuadratic(index, 0.20, PointLightData);
            break;
        case 3:
            setRange(index, 32, PointLightData);
            setLinear(index, 0.14, PointLightData);
            setQuadratic(index, 0.07, PointLightData);
            break;
        case 4:
            setRange(index, 50, PointLightData);
            setLinear(index, 0.09, PointLightData);
            setQuadratic(index, 0.032, PointLightData);
            break;
        case 5:
            setRange(index, 65, PointLightData);
            setLinear(index, 0.07, PointLightData);
            setQuadratic(index, 0.017, PointLightData);
            break;
        case 6:
            setRange(index, 100, PointLightData);
            setLinear(index, 0.045, PointLightData);
            setQuadratic(index, 0.0075, PointLightData);
            break;
        case 7:
            setRange(index, 160, PointLightData);
            setLinear(index, 0.027, PointLightData);
            setQuadratic(index, 0.0028, PointLightData);
            break;
        case 8:
            setRange(index, 200, PointLightData);
            setLinear(index, 0.022, PointLightData);
            setQuadratic(index, 0.0019, PointLightData);
            break;
        case 9:
            setRange(index, 325, PointLightData);
            setLinear(index, 0.014, PointLightData);
            setQuadratic(index, 0.0007, PointLightData);
            break;
        case 10:
            setRange(index, 600, PointLightData);
            setLinear(index, 0.007, PointLightData);
            setQuadratic(index, 0.0002, PointLightData);
            break;
        case 11:
            setRange(index, 3250, PointLightData);
            setLinear(index, 0.0014, PointLightData);
            setQuadratic(index, 0.000007, PointLightData);
            break;
        default:
            Log$$1.error(true, "over point light range");
            break;
    }
    markDirty(index, PointLightData.isAttenuationDirtys);
};
var initDataHelper$1 = function (PointLightData) {
    var count = getPointLightBufferCount(), size = Float32Array.BYTES_PER_ELEMENT * (getColorDataSize$3() + getIntensityDataSize$1() + getConstantDataSize() + getLinearDataSize() + getQuadraticDataSize() + getRangeDataSize()) + Uint8Array.BYTES_PER_ELEMENT * (getDirtyDataSize() * 4), buffer = null;
    buffer = createSharedArrayBufferOrArrayBuffer(count * size);
    initData$25(buffer, PointLightData);
    createTypeArrays$7(buffer, count, PointLightData);
    PointLightData.defaultIntensity = 1;
    PointLightData.defaultConstant = 1;
    PointLightData.defaultLinear = 0.07;
    PointLightData.defaultQuadratic = 0.017;
    PointLightData.defaultRange = 65;
    _setDefaultTypeArrData$4(count, PointLightData);
};
var _setDefaultTypeArrData$4 = function (count, PointLightData) {
    var color = createDefaultColor$1(), intensity = PointLightData.defaultIntensity, constant = PointLightData.defaultConstant, linear = PointLightData.defaultLinear, quadratic = PointLightData.defaultQuadratic, range = PointLightData.defaultRange;
    for (var i = 0; i < count; i++) {
        setColor$3(i, color, PointLightData);
        setIntensity$1(i, intensity, PointLightData);
        setConstant(i, constant, PointLightData);
        setLinear(i, linear, PointLightData);
        setQuadratic(i, quadratic, PointLightData);
        setRange(i, range, PointLightData);
    }
};
var disposeComponent$9 = function (component, PointLightData) {
    var intensityDataSize = getIntensityDataSize$1(), constantDataSize = getConstantDataSize(), linearDataSize = getLinearDataSize(), quadraticDataSize = getQuadraticDataSize(), rangeDataSize = getRangeDataSize(), dirtyDataSize = getDirtyDataSize(), sourceIndex = component.index, lastComponentIndex = null;
    lastComponentIndex = disposeComponent$8(sourceIndex, PointLightData);
    deleteOneItemBySwapAndReset(sourceIndex * intensityDataSize, lastComponentIndex * intensityDataSize, PointLightData.intensities, PointLightData.defaultIntensity);
    deleteOneItemBySwapAndReset(sourceIndex * constantDataSize, lastComponentIndex * constantDataSize, PointLightData.constants, PointLightData.defaultConstant);
    deleteOneItemBySwapAndReset(sourceIndex * linearDataSize, lastComponentIndex * linearDataSize, PointLightData.linears, PointLightData.defaultLinear);
    deleteOneItemBySwapAndReset(sourceIndex * quadraticDataSize, lastComponentIndex * quadraticDataSize, PointLightData.quadratics, PointLightData.defaultQuadratic);
    deleteOneItemBySwapAndReset(sourceIndex * rangeDataSize, lastComponentIndex * rangeDataSize, PointLightData.ranges, PointLightData.defaultRange);
    deleteOneItemBySwapAndReset(sourceIndex * dirtyDataSize, lastComponentIndex * dirtyDataSize, PointLightData.isPositionDirtys, PointLightData.defaultDirty);
    deleteOneItemBySwapAndReset(sourceIndex * dirtyDataSize, lastComponentIndex * dirtyDataSize, PointLightData.isColorDirtys, PointLightData.defaultDirty);
    deleteOneItemBySwapAndReset(sourceIndex * dirtyDataSize, lastComponentIndex * dirtyDataSize, PointLightData.isIntensityDirtys, PointLightData.defaultDirty);
    deleteOneItemBySwapAndReset(sourceIndex * dirtyDataSize, lastComponentIndex * dirtyDataSize, PointLightData.isAttenuationDirtys, PointLightData.defaultDirty);
    return lastComponentIndex;
};
var init$6 = function (PointLightData, state) {
    return bindChangePositionEvent(PointLightData, state);
};
var isPositionDirty$2 = isPositionDirty$3;
var isColorDirty$2 = isColorDirty$3;
var isIntensityDirty$2 = isIntensityDirty$3;
var isAttenuationDirty$$1 = isAttenuationDirty$1;
var cleanPositionDirty$2 = cleanPositionDirty$3;
var cleanColorDirty$2 = cleanColorDirty$3;
var cleanIntensityDirty$2 = cleanIntensityDirty$3;
var cleanAttenuationDirty$$1 = cleanAttenuationDirty$1;

var ERenderWorkerState;
(function (ERenderWorkerState) {
    ERenderWorkerState[ERenderWorkerState["DEFAULT"] = 0] = "DEFAULT";
    ERenderWorkerState[ERenderWorkerState["INIT_COMPLETE"] = 1] = "INIT_COMPLETE";
    ERenderWorkerState[ERenderWorkerState["DRAW_WAIT"] = 2] = "DRAW_WAIT";
    ERenderWorkerState[ERenderWorkerState["DRAW_COMPLETE"] = 3] = "DRAW_COMPLETE";
})(ERenderWorkerState || (ERenderWorkerState = {}));

var sendDrawData = curry(function (DomQuery, WorkerInstanceData, MapManagerData, TextureData, MaterialData, GeometryData, ThreeDTransformData, GameObjectData, AmbientLightData, DirectionLightData, PointLightData, data) {
    var geometryData = null, geometryDisposeData = null, textureDisposeData = null, materialData = null, lightData = null, textureData = null, transferList = [];
    geometryData = _buildSendGeometryData(GeometryData);
    if (hasDisposedGeometryIndexArrayData(GeometryData)) {
        geometryDisposeData = {
            disposedGeometryIndexArray: getDisposedGeometryIndexArrayData(GeometryData)
        };
    }
    if (hasDisposedTextureDataMap(TextureData)) {
        textureDisposeData = {
            disposedTextureDataMap: getDisposedTextureDataMap(TextureData)
        };
    }
    if (hasNewInitedMaterial(MaterialData)) {
        materialData = {
            buffer: MaterialData.buffer,
            workerInitList: MaterialData.workerInitList
        };
    }
    lightData = _buildSendLightData(ThreeDTransformData, GameObjectData, DirectionLightData, PointLightData);
    if (hasNeedInitTextureDataArr(TextureData)) {
        textureData = _buildSendTextureData(DomQuery, MapManagerData, TextureData);
        transferList = transferList.concat(textureData.needAddedImageDataArr.map(function (_a) {
            var arrayBuffer = _a.arrayBuffer;
            return arrayBuffer;
        }));
    }
    getRenderWorker(WorkerInstanceData).postMessage({
        operateType: EWorkerOperateType.DRAW,
        renderCommandBufferData: data,
        materialData: materialData,
        geometryData: geometryData,
        lightData: lightData,
        textureData: textureData,
        disposeData: {
            geometryDisposeData: geometryDisposeData,
            textureDisposeData: textureDisposeData
        }
    }, transferList);
    _clearData(GeometryData, MaterialData, TextureData);
});
var _buildSendGeometryData = function (GeometryData) {
    if (hasNewPointData(GeometryData)) {
        return {
            buffer: GeometryData.buffer,
            type: EGeometryWorkerDataOperateType.ADD,
            verticesInfoList: GeometryData.verticesWorkerInfoList,
            normalsInfoList: GeometryData.normalsWorkerInfoList,
            texCoordsInfoList: GeometryData.texCoordsWorkerInfoList,
            indicesInfoList: GeometryData.indicesWorkerInfoList
        };
    }
    else if (isReallocate(GeometryData)) {
        return {
            buffer: GeometryData.buffer,
            type: EGeometryWorkerDataOperateType.RESET,
            verticesInfoList: GeometryData.verticesInfoList,
            normalsInfoList: GeometryData.normalsInfoList,
            texCoordsInfoList: GeometryData.texCoordsInfoList,
            indicesInfoList: GeometryData.indicesInfoList
        };
    }
    return null;
};
var _buildSendLightData = function (ThreeDTransformData, GameObjectData, DirectionLightData, PointLightData) {
    return {
        directionLightData: {
            positionArr: getAllPositionData(ThreeDTransformData, GameObjectData, DirectionLightData)
        },
        pointLightData: {
            positionArr: getAllPositionData$1(ThreeDTransformData, GameObjectData, PointLightData)
        }
    };
};
var _buildSendTextureData = function (DomQuery, MapManagerData, TextureData) {
    var needInitedTextureDataArr = getNeedInitedTextureDataArr(TextureData), needAddedImageDataArr = convertNeedInitedSourceMapToImageDataArr(getNeedAddedSourceArr(TextureData), needInitedTextureDataArr, DomQuery);
    return {
        index: TextureData.index,
        needAddedImageDataArr: needAddedImageDataArr,
        uniformSamplerNameMap: getUniformSamplerNameMap(TextureData),
        materialTextureList: getMaterialTextureList(MapManagerData),
        needInitedTextureIndexArr: needInitedTextureDataArr
    };
};
var _clearData = function (GeometryData, MaterialData, TextureData) {
    clearWorkerInfoList(GeometryData);
    clearDisposedGeometryIndexArray(GeometryData);
    clearDisposedTextureDataMap(TextureData);
    clearNeedInitTextureDataArr(TextureData);
    clearNeedAddedSourceArr(TextureData);
    clearWorkerInitList(MaterialData);
};
var initData$24 = function (SendDrawRenderCommandBufferData) {
    SendDrawRenderCommandBufferData.isInitComplete = false;
    SendDrawRenderCommandBufferData.state = ERenderWorkerState.DEFAULT;
};

var ArrayBufferData = (function () {
    function ArrayBufferData() {
    }
    ArrayBufferData.vertexBuffers = null;
    ArrayBufferData.normalBuffers = null;
    ArrayBufferData.texCoordBuffers = null;
    return ArrayBufferData;
}());

var IndexBufferData = (function () {
    function IndexBufferData() {
    }
    IndexBufferData.buffers = null;
    return IndexBufferData;
}());

var ELightModel;
(function (ELightModel) {
    ELightModel[ELightModel["BLINN"] = 1] = "BLINN";
    ELightModel[ELightModel["PHONG"] = 2] = "PHONG";
    ELightModel[ELightModel["CONSTANT"] = 3] = "CONSTANT";
})(ELightModel || (ELightModel = {}));

var render_config = {
    "clearColor": Color.create("#000000"),
    "defer": {
        "lightModel": ELightModel.PHONG
    }
};

var SceneData = (function () {
    function SceneData() {
    }
    SceneData.cameraArray = null;
    return SceneData;
}());

var SendDrawRenderCommandBufferData = (function () {
    function SendDrawRenderCommandBufferData() {
    }
    SendDrawRenderCommandBufferData.state = null;
    SendDrawRenderCommandBufferData.isInitComplete = null;
    return SendDrawRenderCommandBufferData;
}());

var WorkerInstanceData = (function () {
    function WorkerInstanceData() {
    }
    WorkerInstanceData.renderWorker = null;
    return WorkerInstanceData;
}());

var SpecifyMaterialData = (function () {
    function SpecifyMaterialData() {
    }
    SpecifyMaterialData.index = null;
    return SpecifyMaterialData;
}());

var BasicMaterialData = (function (_super) {
    __extends(BasicMaterialData, _super);
    function BasicMaterialData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return BasicMaterialData;
}(SpecifyMaterialData));

var LightMaterialData = (function (_super) {
    __extends(LightMaterialData, _super);
    function LightMaterialData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LightMaterialData.specularColors = null;
    LightMaterialData.emissionColors = null;
    LightMaterialData.shininess = null;
    LightMaterialData.shadings = null;
    LightMaterialData.lightModels = null;
    LightMaterialData.hasDiffuseMaps = null;
    LightMaterialData.hasSpecularMaps = null;
    LightMaterialData.defaultShininess = null;
    LightMaterialData.defaultShading = null;
    LightMaterialData.defaultLightModel = null;
    LightMaterialData.defaultHasMap = null;
    LightMaterialData.emptyColor = null;
    LightMaterialData.emptyColorArr = null;
    return LightMaterialData;
}(SpecifyMaterialData));

var AmbientLightData = (function (_super) {
    __extends(AmbientLightData, _super);
    function AmbientLightData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AmbientLightData;
}(SpecifyLightData));

var initState = function (state, getGL, setSide, DeviceManagerDataFromSystem) {
    var gl = getGL(DeviceManagerDataFromSystem, state);
    setSide(gl, ESide.FRONT, DeviceManagerDataFromSystem);
};

var MapManagerData = (function () {
    function MapManagerData() {
    }
    MapManagerData.buffer = null;
    MapManagerData.textureIndices = null;
    MapManagerData.textureCounts = null;
    MapManagerData.materialTextureList = null;
    MapManagerData.textureOffsetMap = null;
    return MapManagerData;
}());

var TextureCacheData = (function () {
    function TextureCacheData() {
    }
    TextureCacheData.bindTextureUnitCache = null;
    return TextureCacheData;
}());

var GBufferData = (function () {
    function GBufferData() {
    }
    GBufferData.gBuffer = null;
    GBufferData.positionTarget = null;
    GBufferData.normalTarget = null;
    GBufferData.colorTarget = null;
    GBufferData.depthTexture = null;
    return GBufferData;
}());

var isConfigDataExist = function (configData) {
    return isValueExist(configData);
};

var sendBuffer = function (gl, type, pos, buffer, geometryIndex, GLSLSenderDataFromSystem, ArrayBufferData) {
    var vertexAttribHistory = GLSLSenderDataFromSystem.vertexAttribHistory;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(pos, _getBufferSizeByType(type), gl[EBufferType.FLOAT], false, 0, 0);
    if (vertexAttribHistory[pos] !== true) {
        gl.enableVertexAttribArray(pos);
        vertexAttribHistory[pos] = true;
    }
};
var _getBufferSizeByType = function (type) {
    var size = null;
    switch (type) {
        case "vec2":
            size = 2;
            break;
        case "vec3":
            size = 3;
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_INVALID("type:" + type));
            break;
    }
    return size;
};
var sendMatrix3 = function (gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist) {
    _sendUniformData(gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, function (pos, data) {
        gl.uniformMatrix3fv(pos, false, data);
    });
};
var sendMatrix4 = function (gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist) {
    _sendUniformData(gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, function (pos, data) {
        gl.uniformMatrix4fv(pos, false, data);
    });
};
var sendVector3 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation, isUniformLocationNotExist) {
    var recordedData = _getUniformCache(shaderIndex, name, uniformCacheMap), x = data.x, y = data.y, z = data.z;
    if (recordedData && recordedData.x == x && recordedData.y == y && recordedData.z == z) {
        return;
    }
    _setUniformCache(shaderIndex, name, data, uniformCacheMap);
    _sendUniformData(gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, function (pos, data) {
        gl.uniform3f(pos, x, y, z);
    });
};
var sendInt = requireCheckFunc(function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, glFunc) {
    it$$1("data should be number", function () {
        wdet_1(data).be.a("number");
    });
}, function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, glFunc) {
    var recordedData = _getUniformCache(shaderIndex, name, uniformCacheMap);
    if (recordedData === data) {
        return;
    }
    _setUniformCache(shaderIndex, name, data, uniformCacheMap);
    _sendUniformData(gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, function (pos, data) {
        gl.uniform1i(pos, data);
    });
});
var sendFloat1 = requireCheckFunc(function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, glFunc) {
    it$$1("data should be number", function () {
        wdet_1(data).be.a("number");
    });
}, function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, glFunc) {
    var recordedData = _getUniformCache(shaderIndex, name, uniformCacheMap);
    if (recordedData === data) {
        return;
    }
    _setUniformCache(shaderIndex, name, data, uniformCacheMap);
    _sendUniformData(gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, function (pos, data) {
        gl.uniform1f(pos, data);
    });
});
var sendFloat3 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation, isUniformLocationNotExist) {
    var recordedData = _getUniformCache(shaderIndex, name, uniformCacheMap), x = data[0], y = data[1], z = data[2];
    if (recordedData && recordedData[0] == x && recordedData[1] == y && recordedData[2] == z) {
        return;
    }
    _setUniformCache(shaderIndex, name, data, uniformCacheMap);
    _sendUniformData(gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, function (pos, data) {
        gl.uniform3f(pos, x, y, z);
    });
};
var _getUniformCache = function (shaderIndex, name, uniformCacheMap) {
    var cache = uniformCacheMap[shaderIndex];
    if (_isCacheNotExist(cache)) {
        cache = {};
        uniformCacheMap[shaderIndex] = cache;
        return null;
    }
    return cache[name];
};
var _isCacheNotExist = function (cache) { return isNotValidMapValue(cache); };
var _setUniformCache = function (shaderIndex, name, data, uniformCacheMap) {
    uniformCacheMap[shaderIndex][name] = data;
};
var _sendUniformData = function (gl, program, name, data, uniformLocationMap, getUniformLocation, isUniformLocationNotExist, send) {
    var pos = getUniformLocation(gl, program, name, uniformLocationMap);
    if (isUniformLocationNotExist(pos)) {
        return;
    }
    send(pos, data);
};
var initData$29 = function (GLSLSenderDataFromSystem) {
    GLSLSenderDataFromSystem.vaoConfigMap = createMap();
    GLSLSenderDataFromSystem.sendUniformConfigMap = createMap();
    GLSLSenderDataFromSystem.sendUniformFuncConfigMap = createMap();
    GLSLSenderDataFromSystem.vertexAttribHistory = [];
    GLSLSenderDataFromSystem.uniformCacheMap = createMap();
};
var setVaoConfigData = requireCheckFunc(function (data, name, value) {
    it$$1("shouldn't exist duplicate data", function () {
        wdet_1(data[name]).not.exist;
    });
}, function (data, name, value) {
    data[name] = value;
});

var addSendUniformConfig = ensureFunc$$1(function (returnVal, shaderIndex, materialShaderLibNameArr, shaderLibData, GLSLSenderDataFromSystem) {
    it$$1("sendUniformConfigMap should not has duplicate attribute name", function () {
        wdet_1(hasDuplicateItems(GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex])).false;
    });
}, requireCheckFunc(function (shaderIndex, materialShaderLibNameArr, shaderLibData, GLSLSenderDataFromSystem) {
    it$$1("sendUniformConfigMap[shaderIndex] should not be defined", function () {
        wdet_1(GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex]).not.exist;
    });
}, function (shaderIndex, materialShaderLibNameArr, shaderLibData, GLSLSenderDataFromSystem) {
    var sendUniformDataArr = [], sendUniformFuncDataArr = [];
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send;
        if (isConfigDataExist(sendData)) {
            if (isConfigDataExist(sendData.uniform)) {
                sendUniformDataArr = sendUniformDataArr.concat(sendData.uniform);
            }
            if (isConfigDataExist(sendData.uniformFunc)) {
                sendUniformFuncDataArr = sendUniformFuncDataArr.concat(sendData.uniformFunc);
            }
        }
    });
    GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex] = sendUniformDataArr;
    GLSLSenderDataFromSystem.sendUniformFuncConfigMap[shaderIndex] = sendUniformFuncDataArr;
}));
var addVaoConfig = requireCheckFunc(function (shaderIndex, materialShaderLibNameArr, shaderLibData, vaoConfigMap) {
    it$$1("vaoConfigMap[shaderIndex] should not be defined", function () {
        wdet_1(vaoConfigMap[shaderIndex]).not.exist;
    });
}, function (shaderIndex, materialShaderLibNameArr, shaderLibData, vaoConfigMap, _a) {
    var getVertices = _a.getVertices, getNormals = _a.getNormals, getTexCoords = _a.getTexCoords, getIndices = _a.getIndices;
    var vaoConfigData = {};
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send;
        if (isConfigDataExist(sendData) && isConfigDataExist(sendData.attribute)) {
            forEach(sendData.attribute, function (_a) {
                var buffer = _a.buffer, location = _a.location;
                switch (buffer) {
                    case "vertex":
                        setVaoConfigData(vaoConfigData, "positionLocation", location);
                        setVaoConfigData(vaoConfigData, "getVertices", getVertices);
                        break;
                    case "normal":
                        setVaoConfigData(vaoConfigData, "normalLocation", location);
                        setVaoConfigData(vaoConfigData, "getNormals", getNormals);
                        break;
                    case "texCoord":
                        setVaoConfigData(vaoConfigData, "texCoordLocation", location);
                        setVaoConfigData(vaoConfigData, "getTexCoords", getTexCoords);
                        break;
                    default:
                        Log$$1.error(true, Log$$1.info.FUNC_INVALID("bufferName:" + buffer));
                        break;
                }
            });
        }
    });
    setVaoConfigData(vaoConfigData, "getIndices", getIndices);
    vaoConfigMap[shaderIndex] = vaoConfigData;
});
var getVaoConfig = function (shaderIndex, GLSLSenderDataFromSystem) { return GLSLSenderDataFromSystem.vaoConfigMap[shaderIndex]; };
var initData$28 = function (GLSLSenderDataFromSystem) {
    initData$29(GLSLSenderDataFromSystem);
    GLSLSenderDataFromSystem.uboBindingPoint = 0;
    GLSLSenderDataFromSystem.uboBindingPointMap = createMap();
    GLSLSenderDataFromSystem.oneUboDataList = [];
    GLSLSenderDataFromSystem.frameUboDataList = [];
    GLSLSenderDataFromSystem.ambientLightUboDataList = [];
    GLSLSenderDataFromSystem.directionLightUboDataList = [];
    GLSLSenderDataFromSystem.pointLightUboDataList = [];
};

var getPrecisionSource = function (lowp_fragment, mediump_fragment, highp_fragment, GPUDetectData) {
    var precision = getPrecision(GPUDetectData), result = null;
    switch (precision) {
        case EGPUPrecision.HIGHP:
            result = highp_fragment.top;
            break;
        case EGPUPrecision.MEDIUMP:
            result = mediump_fragment.top;
            break;
        case EGPUPrecision.LOWP:
            result = lowp_fragment.top;
            break;
        default:
            result = "";
            break;
    }
    return result;
};
var getMaterialShaderLibNameArr = function (materialShaderLibConfig, materialShaderLibGroup, materialIndex, initShaderFuncDataMap, initShaderDataMap) {
    var nameArr = [];
    forEach(materialShaderLibConfig, function (item) {
        if (isString(item)) {
            nameArr.push(item);
        }
        else {
            var i = item;
            switch (i.type) {
                case "group":
                    nameArr = nameArr.concat(materialShaderLibGroup[i.value]);
                    break;
                case "branch":
                    var shaderLibName = _execBranch(i, materialIndex, initShaderFuncDataMap, initShaderDataMap);
                    if (_isShaderLibNameExist(shaderLibName)) {
                        nameArr.push(shaderLibName);
                    }
            }
        }
    });
    return nameArr;
};
var _execBranch = requireCheckFunc(function (i, materialIndex, initShaderFuncDataMap, initShaderDataMap) {
    it$$1("branch should exist", function () {
        wdet_1(i.branch).exist;
    });
}, function (i, materialIndex, initShaderFuncDataMap, initShaderDataMap) {
    return i.branch(materialIndex, initShaderFuncDataMap, initShaderDataMap);
});
var _isShaderLibNameExist = function (name) { return !!name; };
var getEmptyFuncGLSLConfig = function () {
    return {
        "top": "",
        "varDeclare": "",
        "funcDeclare": "",
        "funcDefine": "",
        "body": "",
        "defineList": []
    };
};
var buildSourceDefine = function (defineList, initShaderDataMap) {
    var result = "";
    for (var _i = 0, defineList_1 = defineList; _i < defineList_1.length; _i++) {
        var item = defineList_1[_i];
        if (item.valueFunc === void 0) {
            result += "#define " + item.name + "\n";
        }
        else {
            result += "#define " + item.name + " " + item.valueFunc(initShaderDataMap) + "\n";
        }
    }
    return result;
};
var getGLSLPartData = function (glslConfig, partName) {
    var partConfig = glslConfig[partName];
    if (isConfigDataExist(partConfig)) {
        return partConfig;
    }
    else if (isConfigDataExist(glslConfig.source)) {
        return glslConfig.source[partName];
    }
    return "";
};
var getGLSLDefineListData = function (glslConfig) {
    var partConfig = glslConfig.defineList;
    if (isConfigDataExist(partConfig)) {
        return partConfig;
    }
    return [];
};
var getFuncGLSLPartData = function (glslConfig, partName) {
    return glslConfig[partName];
};
var getFuncGLSLDefineListData = function (glslConfig) {
    return glslConfig.defineList;
};
var _isInSource = function (key, source) {
    return source.indexOf(key) > -1;
};
var generateUniformSource = function (materialShaderLibNameArr, shaderLibData, sourceVarDeclare, sourceFuncDefine, sourceBody) {
    var result = "", generateFunc = compose(forEachArray(function (_a) {
        var name = _a.name, type = _a.type;
        result += "uniform " + _generateUniformSourceType(type) + " " + name + ";\n";
    }), filterArray(function (_a) {
        var name = _a.name;
        return _isInSource(name, sourceVarDeclare) || _isInSource(name, sourceFuncDefine) || _isInSource(name, sourceBody);
    }));
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send, uniform = null, uniformDefine = null;
        if (!isConfigDataExist(sendData)) {
            return;
        }
        uniform = sendData.uniform;
        uniformDefine = sendData.uniformDefine;
        if (isConfigDataExist(uniform)) {
            generateFunc(uniform);
        }
        if (isConfigDataExist(uniformDefine)) {
            generateFunc(uniformDefine);
        }
    });
    return result;
};
var _generateUniformSourceType = function (type) {
    var sourceType = null;
    switch (type) {
        case "float3":
            sourceType = "vec3";
            break;
        default:
            sourceType = type;
            break;
    }
    return sourceType;
};

var getMaterialShaderLibConfig = ensureFunc$$1(function (shaderLibConfig, shaderName, material_config) {
    it$$1("shaderLib config should be array", function () {
        wdet_1(shaderLibConfig).exist;
        wdet_1(shaderLibConfig).be.a("array");
    });
}, requireCheckFunc(function (shaderName, material_config) {
}, function (shaderName, material_config) {
    return material_config.shaders.materialShaders[shaderName];
}));

var initMaterialShader$2 = function (state, materialIndex, shaderName, material_config, shaderLib_generator, init, initShaderFuncDataMap, initShaderDataMap) {
    var ShaderDataFromSystem = initShaderDataMap.ShaderDataFromSystem, materialShaderLibNameArr = null, shaderIndex = null, key = ShaderDataFromSystem.shaderLibNameMap[materialIndex];
    if (!key) {
        materialShaderLibNameArr = getMaterialShaderLibNameArr(getMaterialShaderLibConfig(shaderName, material_config), material_config.shaderLibGroups, materialIndex, initShaderFuncDataMap, initShaderDataMap);
        key = _buildShaderIndexMapKey(materialShaderLibNameArr);
        ShaderDataFromSystem.shaderLibNameMap[materialIndex] = key;
    }
    shaderIndex = ShaderDataFromSystem.shaderIndexMap[key];
    if (_isShaderIndexExist(shaderIndex)) {
        return shaderIndex;
    }
    if (!materialShaderLibNameArr) {
        materialShaderLibNameArr = getMaterialShaderLibNameArr(getMaterialShaderLibConfig(shaderName, material_config), material_config.shaderLibGroups, materialIndex, initShaderFuncDataMap, initShaderDataMap);
    }
    shaderIndex = init(state, materialIndex, materialShaderLibNameArr, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap);
    ShaderDataFromSystem.shaderIndexMap[key] = shaderIndex;
    return shaderIndex;
};
var initNoMaterialShader$2 = function (state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, init, initShaderFuncDataMap, initShaderDataMap) {
    var ShaderDataFromSystem = initShaderDataMap.ShaderDataFromSystem, materialShaderLibNameArr = null, shaderIndex = null, key = ShaderDataFromSystem.shaderIndexByShaderNameMap[shaderName];
    if (!key) {
        materialShaderLibNameArr = getMaterialShaderLibNameArr(materialShaderLibConfig, material_config.shaderLibGroups, null, initShaderFuncDataMap, initShaderDataMap);
        key = _buildShaderIndexMapKey(materialShaderLibNameArr);
        ShaderDataFromSystem.shaderIndexByShaderNameMap[shaderName] = key;
    }
    shaderIndex = ShaderDataFromSystem.shaderIndexMap[key];
    if (_isShaderIndexExist(shaderIndex)) {
        return shaderIndex;
    }
    if (!materialShaderLibNameArr) {
        materialShaderLibNameArr = getMaterialShaderLibNameArr(materialShaderLibConfig, material_config.shaderLibGroups, null, initShaderFuncDataMap, initShaderDataMap);
    }
    shaderIndex = init(state, null, materialShaderLibNameArr, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap);
    ShaderDataFromSystem.shaderIndexMap[key] = shaderIndex;
    return shaderIndex;
};
var _buildShaderIndexMapKey = function (materialShaderLibNameArr) { return materialShaderLibNameArr.join(""); };
var _isShaderIndexExist = function (shaderIndex) { return isNotUndefined(shaderIndex); };
var genereateShaderIndex = function (ShaderDataFromSystem) {
    var index = ShaderDataFromSystem.index;
    ShaderDataFromSystem.index += 1;
    return index;
};

var registerProgram = function (shaderIndex, ProgramDataFromSystem, program) {
    ProgramDataFromSystem.programMap[shaderIndex] = program;
};

var initShader = function (program, vsSource, fsSource, gl) {
    var vs = _compileShader(gl, vsSource, gl.createShader(gl.VERTEX_SHADER)), fs = _compileShader(gl, fsSource, gl.createShader(gl.FRAGMENT_SHADER));
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.bindAttribLocation(program, 0, "a_position");
    _linkProgram(gl, program);
    gl.deleteShader(vs);
    gl.deleteShader(fs);
};
var _linkProgram = ensureFunc$$1(function (returnVal, gl, program) {
    it$$1("link program error:" + gl.getProgramInfoLog(program), function () {
        wdet_1(gl.getProgramParameter(program, gl.LINK_STATUS)).true;
    });
}, function (gl, program) {
    gl.linkProgram(program);
});
var _compileShader = function (gl, glslSource, shader) {
    gl.shaderSource(shader, glslSource);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        return shader;
    }
    else {
        Log$$1.log(gl.getShaderInfoLog(shader));
        Log$$1.log("source:\n", glslSource);
    }
};

var bindUniformBlock = function (gl, program, blockName, bindingPoint) {
    var uniformLocation = gl.getUniformBlockIndex(program, blockName);
    gl.uniformBlockBinding(program, uniformLocation, bindingPoint);
};
var bindUniformBufferBase = function (gl, buffer, bindingPoint) {
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPoint, buffer);
};
var bufferStaticData = function (gl, data) {
    gl.bufferData(gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW);
};
var bufferDynamicData = function (gl, data) {
    gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
};
var bufferSubDynamicData = function (gl, offset, data) {
    gl.bufferSubData(gl.UNIFORM_BUFFER, offset, data);
};

var detect$2 = function (getGL, DeviceManagerDataFromSystem, GPUDetectDataFromSystem, state) {
    var gl = getGL(DeviceManagerDataFromSystem, state);
    _detectExtension(state, gl, GPUDetectDataFromSystem);
    _detectCapabilty(state, gl, GPUDetectDataFromSystem);
    return state;
};
var _detectExtension = function (state, gl, GPUDetectDataFromSystem) {
    detectExtension(state, gl, GPUDetectDataFromSystem);
    GPUDetectDataFromSystem.extensionColorBufferFloat = getExtension("EXT_color_buffer_float", state, gl);
};
var _detectCapabilty = function (state, gl, GPUDetectDataFromSystem) {
    detectCapabilty(state, gl, GPUDetectDataFromSystem);
    GPUDetectDataFromSystem.maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
};
var getMaxUniformBufferBindings = function (GPUDetectDataFromSystem) { return GPUDetectDataFromSystem.maxUniformBufferBindings; };
var hasExtensionColorBufferFloat = function (GPUDetectDataFromSystem) { return !!GPUDetectDataFromSystem.extensionColorBufferFloat; };
var initData$30 = function (GPUDetectDataFromSystem) {
    GPUDetectDataFromSystem.maxTextureUnit = null;
    GPUDetectDataFromSystem.maxTextureSize = null;
    GPUDetectDataFromSystem.maxCubemapTextureSize = null;
    GPUDetectDataFromSystem.maxAnisotropy = null;
    GPUDetectDataFromSystem.maxBoneCount = null;
    GPUDetectDataFromSystem.maxUniformBufferBindings = null;
    GPUDetectDataFromSystem.extensionCompressedTextureS3TC = null;
    GPUDetectDataFromSystem.extensionTextureFilterAnisotropic = null;
    GPUDetectDataFromSystem.extensionInstancedArrays = null;
    GPUDetectDataFromSystem.extensionUintIndices = null;
    GPUDetectDataFromSystem.extensionDepthTexture = null;
    GPUDetectDataFromSystem.extensionVao = null;
    GPUDetectDataFromSystem.extensionStandardDerivatives = null;
    GPUDetectDataFromSystem.extensionColorBufferFloat = null;
    GPUDetectDataFromSystem.precision = null;
};

var init$7 = function (gl, render_config, _a) {
    var oneUboDataList = _a.oneUboDataList, uboBindingPointMap = _a.uboBindingPointMap;
    _bindOneUboData(gl, render_config, oneUboDataList, uboBindingPointMap);
};
var _bindOneUboData = function (gl, render_config, oneUboDataList, uboBindingPointMap) {
    _bindSingleBufferUboData(gl, render_config, oneUboDataList, null, uboBindingPointMap);
};
var _buildUboDataMap = function (uniformBlockBinding, buffer, typeArray) {
    return {
        uniformBlockBinding: uniformBlockBinding,
        buffer: buffer,
        typeArray: typeArray
    };
};
var _buildUboFuncMap = function (bindUniformBufferBase$$1, bufferStaticData$$1, bufferDynamicData$$1, bufferSubDynamicData$$1, set$$1) {
    return {
        bindUniformBufferBase: bindUniformBufferBase$$1,
        bufferStaticData: bufferStaticData$$1,
        bufferDynamicData: bufferDynamicData$$1,
        bufferSubDynamicData: bufferSubDynamicData$$1,
        set: set$$1
    };
};
var _buildGlobalRenderDataMap = function (render_config) {
    return {
        render_config: render_config
    };
};
var bindFrameUboData = function (gl, render_config, cameraData, _a) {
    var frameUboDataList = _a.frameUboDataList, uboBindingPointMap = _a.uboBindingPointMap;
    _bindSingleBufferUboData(gl, render_config, frameUboDataList, cameraData, uboBindingPointMap);
};
var bindAmbientLightUboData = function (gl, ambientLightIndex, sendUniformDataAmbientLightDataMap, ambientLightValueMap, drawDataMap, _a) {
    var ambientLightUboDataList = _a.ambientLightUboDataList, uboBindingPointMap = _a.uboBindingPointMap;
    _bindLightUboData(gl, ambientLightIndex, sendUniformDataAmbientLightDataMap, ambientLightValueMap, drawDataMap, ambientLightUboDataList, uboBindingPointMap);
};
var bindDirectionLightUboData = function (gl, directionLightIndex, sendUniformDataDirectionLightDataMap, directionLightValueMap, drawDataMap, _a) {
    var directionLightUboDataList = _a.directionLightUboDataList, uboBindingPointMap = _a.uboBindingPointMap;
    _bindLightUboData(gl, directionLightIndex, sendUniformDataDirectionLightDataMap, directionLightValueMap, drawDataMap, directionLightUboDataList, uboBindingPointMap);
};
var bindPointLightUboData = function (gl, pointLightIndex, sendUniformDataPointLightDataMap, pointLightValueMap, drawDataMap, _a) {
    var pointLightUboDataList = _a.pointLightUboDataList, uboBindingPointMap = _a.uboBindingPointMap;
    _bindLightUboData(gl, pointLightIndex, sendUniformDataPointLightDataMap, pointLightValueMap, drawDataMap, pointLightUboDataList, uboBindingPointMap);
};
var _bindLightUboData = function (gl, lightIndex, sendUniformDataLightDataMap, lightValueMap, drawDataMap, lightUboDataList, uboBindingPointMap) {
    var uboFuncMap = _buildUboFuncMap(bindUniformBufferBase, bufferStaticData, bufferDynamicData, bufferSubDynamicData, set);
    forEach(lightUboDataList, function (_a) {
        var name = _a.name, typeArrays = _a.typeArrays, buffers = _a.buffers, setBufferDataFunc = _a.setBufferDataFunc;
        var bindingPoint = uboBindingPointMap[name], typeArray = typeArrays[lightIndex], buffer = buffers[lightIndex], uboDataMap = _buildUboDataMap(bindingPoint, buffer, typeArray);
        setBufferDataFunc(gl, lightIndex, uboDataMap, uboFuncMap, sendUniformDataLightDataMap, lightValueMap);
    });
};
var _bindSingleBufferUboData = function (gl, render_config, singleBufferUboDataList, cameraData, uboBindingPointMap) {
    var uboFuncMap = _buildUboFuncMap(bindUniformBufferBase, bufferStaticData, bufferDynamicData, bufferSubDynamicData, set), globalRenderDataMap = _buildGlobalRenderDataMap(render_config);
    forEach(singleBufferUboDataList, function (_a) {
        var name = _a.name, typeArray = _a.typeArray, buffer = _a.buffer, setBufferDataFunc = _a.setBufferDataFunc;
        var bindingPoint = uboBindingPointMap[name], uboDataMap = _buildUboDataMap(bindingPoint, buffer, typeArray);
        setBufferDataFunc(gl, uboDataMap, uboFuncMap, cameraData, globalRenderDataMap);
    });
};
var handleUboConfig = function (gl, shaderIndex, program, materialShaderLibNameArr, shaderLibData, initShaderDataMap, GLSLSenderDataFromSystem, GPUDetectDataFromSystem) {
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send;
        if (isConfigDataExist(sendData)) {
            if (isConfigDataExist(sendData.uniformUbo)) {
                forEach(sendData.uniformUbo, function (data) {
                    var name = data.name, bindingPoint = null, uboBindingPointMap = GLSLSenderDataFromSystem.uboBindingPointMap, uboBindingPoint = uboBindingPointMap[name];
                    if (isValidMapValue(uboBindingPoint)) {
                        return;
                    }
                    bindingPoint = _setUniqueBindingPoint(name, GLSLSenderDataFromSystem, GPUDetectDataFromSystem);
                    bindUniformBlock(gl, program, name, bindingPoint);
                    _addInitedUboFuncConfig(gl, data, initShaderDataMap, GLSLSenderDataFromSystem);
                });
            }
        }
    });
};
var _setUniqueBindingPoint = ensureFunc$$1(function (uboBindingPoint, name, GLSLSenderDataFromSystem, GPUDetectDataFromSystem) {
    it$$1("uboBindingPoint shouldn't exceed maxUniformBufferBindings", function () {
        wdet_1(uboBindingPoint).lte(getMaxUniformBufferBindings(GPUDetectDataFromSystem));
    });
}, function (name, GLSLSenderDataFromSystem, GPUDetectDataFromSystem) {
    var uboBindingPointMap = GLSLSenderDataFromSystem.uboBindingPointMap, uboBindingPoint = GLSLSenderDataFromSystem.uboBindingPoint;
    uboBindingPointMap[name] = uboBindingPoint;
    GLSLSenderDataFromSystem.uboBindingPoint += 1;
    return uboBindingPoint;
});
var _addInitedUboFuncConfig = ensureFunc$$1(function (list) {
    it$$1("list shouldn't has duplicate ubo data", function () {
        wdet_1(hasDuplicateItems(list)).false;
    });
}, function (gl, _a, _b, GLSLSenderDataFromSystem) {
    var name = _a.name, typeArray = _a.typeArray, setBufferDataFunc = _a.setBufferDataFunc, frequence = _a.frequence;
    var AmbientLightDataFromSystem = _b.AmbientLightDataFromSystem, DirectionLightDataFromSystem = _b.DirectionLightDataFromSystem, PointLightDataFromSystem = _b.PointLightDataFromSystem;
    var list = null;
    switch (frequence) {
        case "one":
            list = GLSLSenderDataFromSystem.oneUboDataList;
            list.push(_createSingleBufferData(gl, name, typeArray, setBufferDataFunc));
            break;
        case "frame":
            list = GLSLSenderDataFromSystem.frameUboDataList;
            list.push(_createSingleBufferData(gl, name, typeArray, setBufferDataFunc));
            break;
        case "ambientLight":
            list = _addLightInitedUboFuncConfig(gl, GLSLSenderDataFromSystem.ambientLightUboDataList, typeArray, AmbientLightDataFromSystem.count, name, setBufferDataFunc);
            break;
        case "directionLight":
            list = _addLightInitedUboFuncConfig(gl, GLSLSenderDataFromSystem.directionLightUboDataList, typeArray, DirectionLightDataFromSystem.count, name, setBufferDataFunc);
            break;
        case "pointLight":
            list = _addLightInitedUboFuncConfig(gl, GLSLSenderDataFromSystem.pointLightUboDataList, typeArray, PointLightDataFromSystem.count, name, setBufferDataFunc);
            break;
        default:
            Log$$1.error(Log$$1.info.FUNC_UNKNOW("frequence: " + frequence));
            break;
    }
    return list;
});
var _addLightInitedUboFuncConfig = function (gl, list, typeArray, lightCount, name, setBufferDataFunc) {
    var buffers = [], typeArrays = [];
    for (var i = 0; i < lightCount; i++) {
        typeArrays.push(_createTypeArray(typeArray));
        buffers.push(gl.createBuffer());
    }
    list.push({
        name: name,
        typeArrays: typeArrays,
        buffers: buffers,
        setBufferDataFunc: setBufferDataFunc
    });
    return list;
};
var _createSingleBufferData = function (gl, name, typeArray, setBufferDataFunc) {
    return {
        name: name,
        typeArray: _createTypeArray(typeArray),
        buffer: gl.createBuffer(),
        setBufferDataFunc: setBufferDataFunc
    };
};
var _createTypeArray = function (_a) {
    var length = _a.length;
    return new Float32Array(length);
};

var removeVao = function (gl, index, vaoMap, vboArrayMap) {
    var vboArray = vboArrayMap[index];
    deleteVal$1(index, vaoMap);
    deleteVal$1(index, vboArrayMap);
    if (isNotValidVal(vboArray)) {
        return;
    }
    for (var _i = 0, vboArray_1 = vboArray; _i < vboArray_1.length; _i++) {
        var vbo = vboArray_1[_i];
        gl.deleteBuffer(vbo);
    }
};
var initData$31 = function (VaoDataFromSystem) {
    VaoDataFromSystem.vaoMap = createMap();
    VaoDataFromSystem.vboArrayMap = createMap();
};

var createVao = function (gl) {
    return gl.createVertexArray();
};
var bindVao$1 = function (gl, vao) {
    gl.bindVertexArray(vao);
};
var unbindVao = function (gl) {
    gl.bindVertexArray(null);
};
var disposeVao = function (gl, geometryIndex, vaoMap, vboArrayMap) {
    gl.deleteVertexArray(vaoMap[geometryIndex]);
    removeVao(gl, geometryIndex, vaoMap, vboArrayMap);
};

var setEmptyLocationMap = function (shaderIndex, LocationDataFromSystem) {
    LocationDataFromSystem.uniformLocationMap[shaderIndex] = createMap();
};
var initData$32 = function (LocationDataFromSystem) {
    LocationDataFromSystem.uniformLocationMap = createMap();
};

var getNoMaterialShaderIndex = function (shaderName, ShaderDataFromSystem) {
    return ShaderDataFromSystem.shaderIndexByShaderNameMap[shaderName];
};
var initNoMaterialShader$1 = function (state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap) {
    var shaderIndex = initNoMaterialShader$2(state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, _init, initShaderFuncDataMap, initShaderDataMap);
    initShaderDataMap.ShaderDataFromSystem.shaderIndexByShaderNameMap[shaderName] = shaderIndex;
    return shaderIndex;
};
var initMaterialShader$1 = function (state, materialIndex, shaderName, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap) {
    return initMaterialShader$2(state, materialIndex, shaderName, material_config, shaderLib_generator, _init, initShaderFuncDataMap, initShaderDataMap);
};
var _init = function (state, materialIndex, materialShaderLibNameArr, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap) {
    var ShaderDataFromSystem = initShaderDataMap.ShaderDataFromSystem, DeviceManagerDataFromSystem = initShaderDataMap.DeviceManagerDataFromSystem, ProgramDataFromSystem = initShaderDataMap.ProgramDataFromSystem, LocationDataFromSystem = initShaderDataMap.LocationDataFromSystem, GLSLSenderDataFromSystem = initShaderDataMap.GLSLSenderDataFromSystem, GPUDetectDataFromSystem = initShaderDataMap.GPUDetectDataFromSystem, buildGLSLSource = initShaderFuncDataMap.buildGLSLSource, getGL = initShaderFuncDataMap.getGL, shaderIndex = genereateShaderIndex(ShaderDataFromSystem), program = getProgram(shaderIndex, ProgramDataFromSystem), shaderLibDataFromSystem = null, gl = null;
    shaderLibDataFromSystem = shaderLib_generator.shaderLibs;
    var _a = buildGLSLSource(materialIndex, materialShaderLibNameArr, shaderLibDataFromSystem, initShaderDataMap), vsSource = _a.vsSource, fsSource = _a.fsSource;
    gl = getGL(DeviceManagerDataFromSystem, state);
    program = gl.createProgram();
    registerProgram(shaderIndex, ProgramDataFromSystem, program);
    initShader(program, vsSource, fsSource, gl);
    setEmptyLocationMap(shaderIndex, LocationDataFromSystem);
    addVaoConfig(shaderIndex, materialShaderLibNameArr, shaderLibDataFromSystem, GLSLSenderDataFromSystem.vaoConfigMap, initShaderFuncDataMap);
    addSendUniformConfig(shaderIndex, materialShaderLibNameArr, shaderLibDataFromSystem, GLSLSenderDataFromSystem);
    handleUboConfig(gl, shaderIndex, program, materialShaderLibNameArr, shaderLibDataFromSystem, initShaderDataMap, GLSLSenderDataFromSystem, GPUDetectDataFromSystem);
    return shaderIndex;
};
var bindVao$$1 = function (gl, vao, ProgramDataFromSystem) {
    if (ProgramDataFromSystem.lastBindedVao === vao) {
        return;
    }
    ProgramDataFromSystem.lastBindedVao = vao;
    bindVao$1(gl, vao);
};
var createAndInitVao = function (gl, geometryIndex, vaoMap, vboArrayMap, _a, GeometryDataFromSystem) {
    var positionLocation = _a.positionLocation, normalLocation = _a.normalLocation, texCoordLocation = _a.texCoordLocation, getVertices = _a.getVertices, getNormals = _a.getNormals, getTexCoords = _a.getTexCoords, getIndices = _a.getIndices;
    var vao = createVao(gl), buffers = [];
    vaoMap[geometryIndex] = vao;
    bindVao$1(gl, vao);
    if (!!getVertices) {
        buffers.push(createAndInitArrayBuffer(gl, getVertices(geometryIndex, GeometryDataFromSystem), positionLocation, 3));
    }
    if (!!getNormals) {
        buffers.push(createAndInitArrayBuffer(gl, getNormals(geometryIndex, GeometryDataFromSystem), normalLocation, 3));
    }
    if (!!getTexCoords) {
        buffers.push(createAndInitArrayBuffer(gl, getTexCoords(geometryIndex, GeometryDataFromSystem), texCoordLocation, 2));
    }
    buffers.push(createAndInitIndexBuffer(gl, getIndices(geometryIndex, GeometryDataFromSystem)));
    unbindVao(gl);
    vboArrayMap[geometryIndex] = buffers;
    return vao;
};
var initData$27 = function (ShaderDataFromSystem) {
    ShaderDataFromSystem.index = 0;
    ShaderDataFromSystem.count = 0;
    ShaderDataFromSystem.shaderIndexMap = createMap();
    ShaderDataFromSystem.shaderIndexByShaderNameMap = createMap();
    ShaderDataFromSystem.shaderLibNameMap = createMap();
};

var webgl2_main_begin = "void main(void){\n";
var webgl2_main_end = "}\n";
var webgl2_setPos_mvp = "gl_Position = cameraUbo.pMatrix * cameraUbo.vMatrix * mMatrix * vec4(a_position, 1.0);\n";

var empty$1 = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var NULL = -1.0;
var common_define = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var common_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var common_function = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "mat2 transpose(mat2 m) {\n  return mat2(  m[0][0], m[1][0],   // new col 0\n                m[0][1], m[1][1]    // new col 1\n             );\n  }\nmat3 transpose(mat3 m) {\n  return mat3(  m[0][0], m[1][0], m[2][0],  // new col 0\n                m[0][1], m[1][1], m[2][1],  // new col 1\n                m[0][2], m[1][2], m[2][2]   // new col 1\n             );\n  }\n\n//bool isRenderListEmpty(int isRenderListEmpty){\n//  return isRenderListEmpty == 1;\n//}\n", body: "" };
var common_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var highp_fragment = { top: "precision highp float;\nprecision highp int;\n", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var lowp_fragment = { top: "precision lowp float;\nprecision lowp int;\n", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var mediump_fragment = { top: "precision mediump float;\nprecision mediump int;\n", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var modelMatrix_noInstance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "mat4 getModelMatrix(){\n    return u_mMatrix;\n}\n", body: "mat4 mMatrix = getModelMatrix();\n" };
var webgl1_noShadowMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getShadowVisibility() {\n        return vec3(1.0);\n    }\n", body: "" };
var webgl1_basic_end_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_FragColor = vec4(totalColor.rgb, totalColor.a * u_opacity);\n" };
var webgl1_basic_materialColor_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "vec4 totalColor = vec4(u_color, 1.0);\n" };
var frontLight_common = { top: "", define: "", varDeclare: "", funcDeclare: "vec3 getDirectionLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition);\n", funcDefine: "vec3 getDirectionLightDirByLightPos(vec3 lightPos){\n    return lightPos - vec3(0.0);\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos){\n    return lightPos - v_worldPosition;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition){\n    return lightPos - worldPosition;\n}\n", body: "" };
var frontLight_common_fragment = { top: "", define: "", varDeclare: "varying vec3 v_worldPosition;\n#if POINT_LIGHTS_COUNT > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\nstruct DirectionLight {\n    vec3 position;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n", funcDeclare: "", funcDefine: "", body: "" };
var frontLight_common_vertex = { top: "", define: "", varDeclare: "varying vec3 v_worldPosition;\n#if POINT_LIGHTS_COUNT > 0\n    struct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\n    struct DirectionLight {\n    vec3 position;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n", funcDeclare: "", funcDefine: "", body: "" };
var frontLight_end_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_FragColor = totalColor;\n" };
var frontLight_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float getBlinnShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 halfAngle = normalize(lightDir + viewDir);\n        float blinnTerm = dot(normal, halfAngle);\n\n        blinnTerm = clamp(blinnTerm, 0.0, 1.0);\n        blinnTerm = dotResultBetweenNormAndLight != 0.0 ? blinnTerm : 0.0;\n        blinnTerm = pow(blinnTerm, shininess);\n\n        return blinnTerm;\n}\n\nfloat getPhongShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float phongTerm = dot(viewDir, reflectDir);\n\n        phongTerm = clamp(phongTerm, 0.0, 1.0);\n        phongTerm = dotResultBetweenNormAndLight != 0.0 ? phongTerm : 0.0;\n        phongTerm = pow(phongTerm, shininess);\n\n        return phongTerm;\n}\n\nvec3 calcLight(vec3 lightDir, vec3 color, float intensity, float attenuation, vec3 normal, vec3 viewDir)\n{\n        vec3 materialLight = getMaterialLight();\n        vec3 materialDiffuse = getMaterialDiffuse();\n        vec3 materialSpecular = u_specular;\n        vec3 materialEmission = getMaterialEmission();\n\n        float specularStrength = getSpecularStrength();\n\n        float dotResultBetweenNormAndLight = dot(normal, lightDir);\n        float diff = max(dotResultBetweenNormAndLight, 0.0);\n\n        vec3 emissionColor = materialEmission;\n\n        vec3 ambientColor = (u_ambient + materialLight) * materialDiffuse.rgb;\n\n\n        if(u_lightModel == 3){\n            return emissionColor + ambientColor;\n        }\n\n//        vec4 diffuseColor = vec4(color * materialDiffuse.rgb * diff * intensity, materialDiffuse.a);\n        vec3 diffuseColor = color * materialDiffuse.rgb * diff * intensity;\n\n        float spec = 0.0;\n\n        if(u_lightModel == 2){\n                spec = getPhongShininess(u_shininess, normal, lightDir, viewDir, diff);\n        }\n        else if(u_lightModel == 1){\n                spec = getBlinnShininess(u_shininess, normal, lightDir, viewDir, diff);\n        }\n\n        vec3 specularColor = spec * materialSpecular * specularStrength * intensity;\n\n//        return vec4(emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor), diffuseColor.a);\n        return emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor);\n}\n\n\n\n\n#if POINT_LIGHTS_COUNT > 0\n        vec3 calcPointLight(vec3 lightDir, PointLight light, vec3 normal, vec3 viewDir)\n{\n        //lightDir is not normalize computing distance\n        float distance = length(lightDir);\n\n        float attenuation = 0.0;\n\n        if(distance < light.range)\n        {\n            attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n        }\n\n        lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\n        vec3 calcDirectionLight(vec3 lightDir, DirectionLight light, vec3 normal, vec3 viewDir)\n{\n        float attenuation = 1.0;\n\n        lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\nvec4 calcTotalLight(vec3 norm, vec3 viewDir){\n    vec4 totalLight = vec4(0.0, 0.0, 0.0, 1.0);\n\n    #if POINT_LIGHTS_COUNT > 0\n                for(int i = 0; i < POINT_LIGHTS_COUNT; i++){\n                totalLight += vec4(calcPointLight(getPointLightDir(i), u_pointLights[i], norm, viewDir), 0.0);\n        }\n    #endif\n\n    #if DIRECTION_LIGHTS_COUNT > 0\n                for(int i = 0; i < DIRECTION_LIGHTS_COUNT; i++){\n                totalLight += vec4(calcDirectionLight(getDirectionLightDir(i), u_directionLights[i], norm, viewDir), 0.0);\n        }\n    #endif\n\n        return totalLight;\n}\n", body: "vec3 normal = normalize(getNormal());\n\n#ifdef BOTH_SIdE\nnormal = normal * (-1.0 + 2.0 * float(gl_FrontFacing));\n#endif\n\nvec3 viewDir = normalize(getViewDir());\n\nvec4 totalColor = calcTotalLight(normal, viewDir);\n\ntotalColor.a *= u_opacity;\n\ntotalColor.rgb = totalColor.rgb * getShadowVisibility();\n" };
var frontLight_setWorldPosition_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "v_worldPosition = vec3(mMatrix * vec4(a_position, 1.0));\n" };
var frontLight_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "gl_Position = u_pMatrix * u_vMatrix * vec4(v_worldPosition, 1.0);\n" };
var webgl1_normalMatrix_noInstance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat3 normalMatrix = u_normalMatrix;\n" };
var webgl1_basic_map_fragment = { top: "", define: "", varDeclare: "varying vec2 v_mapCoord0;\n", funcDeclare: "", funcDefine: "", body: "totalColor *= texture2D(u_sampler2D, v_mapCoord0);\n" };
var webgl1_basic_map_vertex = { top: "", define: "", varDeclare: "varying vec2 v_mapCoord0;\n", funcDeclare: "", funcDefine: "", body: "//    vec2 sourceTexCoord0 = a_texCoord * u_map0SourceRegion.zw + u_map0SourceRegion.xy;\n//\n//    v_mapCoord0 = sourceTexCoord0 * u_map0RepeatRegion.zw + u_map0RepeatRegion.xy;\n\n    v_mapCoord0 = a_texCoord;\n" };
var webgl1_diffuseMap_fragment = { top: "", define: "", varDeclare: "varying vec2 v_diffuseMapTexCoord;\n", funcDeclare: "", funcDefine: "vec3 getMaterialDiffuse() {\n        return texture2D(u_diffuseMapSampler, v_diffuseMapTexCoord).rgb;\n    }\n", body: "" };
var webgl1_diffuseMap_vertex = { top: "", define: "", varDeclare: "varying vec2 v_diffuseMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "//todo optimize(combine, reduce compute numbers)\n    //todo BasicTexture extract textureMatrix\n//    vec2 sourceTexCoord = a_texCoord * u_diffuseMapSourceRegion.zw + u_diffuseMapSourceRegion.xy;\n//    v_diffuseMapTexCoord = sourceTexCoord * u_diffuseMapRepeatRegion.zw + u_diffuseMapRepeatRegion.xy;\n\n    v_diffuseMapTexCoord = a_texCoord;\n" };
var webgl1_noDiffuseMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialDiffuse() {\n        return u_diffuse;\n    }\n", body: "" };
var webgl1_noEmissionMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialEmission() {\n        return u_emission;\n    }\n", body: "" };
var webgl1_noLightMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialLight() {\n        return vec3(0.0);\n    }\n", body: "" };
var webgl1_noNormalMap_fragment = { top: "", define: "", varDeclare: "varying vec3 v_normal;\n", funcDeclare: "vec3 getNormal();\n\n", funcDefine: "vec3 getNormal(){\n    return v_normal;\n}\n\n#if POINT_LIGHTS_COUNT > 0\nvec3 getPointLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getPointLightDirByLightPos(u_pointLights[x].position);\n        }\n    }\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvec3 getDirectionLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getDirectionLightDirByLightPos(u_directionLights[x].position);\n        }\n    }\n\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n\nvec3 getViewDir(){\n    return normalize(u_cameraPos - v_worldPosition);\n}\n", body: "" };
var webgl1_noNormalMap_vertex = { top: "", define: "", varDeclare: "varying vec3 v_normal;\n", funcDeclare: "", funcDefine: "", body: "v_normal = normalize(normalMatrix * a_normal);\n" };
var webgl1_noSpecularMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float getSpecularStrength() {\n        return 1.0;\n    }\n", body: "" };
var webgl1_specularMap_fragment = { top: "", define: "", varDeclare: "varying vec2 v_specularMapTexCoord;\n", funcDeclare: "", funcDefine: "float getSpecularStrength() {\n        return texture2D(u_specularMapSampler, v_specularMapTexCoord).r;\n    }\n", body: "" };
var webgl1_specularMap_vertex = { top: "", define: "", varDeclare: "varying vec2 v_specularMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "v_specularMapTexCoord = a_texCoord;\n" };
var webgl2_deferLightPass_directionLight_noNormalMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getDirectionLightDir(){\n    return getDirectionLightDirByLightPos(directionLightUbo.lightPosition.xyz);\n}\n", body: "" };
var webgl2_deferLightPass_pointLight_noNormalMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getPointLightDir(vec3 worldPosition){\n    return getPointLightDirByLightPos(pointLightUbo.lightPosition.xyz, worldPosition);\n}\n", body: "" };
var webgl2_noShadowMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getShadowVisibility() {\n        return vec3(1.0);\n    }\n", body: "" };
var webgl2_basic_end_fragment = { top: "", define: "", varDeclare: "out vec4 fragColor;\n", funcDeclare: "", funcDefine: "", body: "fragColor = vec4(totalColor.rgb, totalColor.a * u_opacity);\n" };
var webgl2_basic_materialColor_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "vec4 totalColor = vec4(u_color, 1.0);\n" };
var webgl2_basic_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var ubo_light = { top: "", define: "", varDeclare: "layout(std140) uniform LightUbo {\n/*! vec4(lightModel, 0.0, 0.0, 0.0) */\n    vec4 lightModel;\n} lightUbo;\n", funcDeclare: "", funcDefine: "", body: "" };
var ubo_camera = { top: "", define: "", varDeclare: "layout(std140) uniform CameraUbo {\n    mat4 vMatrix;\n    mat4 pMatrix;\n    vec4 cameraPos;\n    vec4 normalMatrixCol1;\n    vec4 normalMatrixCol2;\n    vec4 normalMatrixCol3;\n} cameraUbo;\n", funcDeclare: "", funcDefine: "", body: "" };
var version = { top: "#version 300 es\n", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var webgl2_common_define = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var webgl2_common_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var webgl2_common_function = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var webgl2_common_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var webgl2_basic_map_fragment = { top: "", define: "", varDeclare: "in vec2 v_mapCoord0;\n", funcDeclare: "", funcDefine: "", body: "totalColor *= texture(u_sampler2D, v_mapCoord0);\n" };
var webgl2_basic_map_vertex = { top: "", define: "", varDeclare: "out vec2 v_mapCoord0;\n", funcDeclare: "", funcDefine: "", body: "//    vec2 sourceTexCoord0 = a_texCoord * u_map0SourceRegion.zw + u_map0SourceRegion.xy;\n//\n//    v_mapCoord0 = sourceTexCoord0 * u_map0RepeatRegion.zw + u_map0RepeatRegion.xy;\n\n    v_mapCoord0 = a_texCoord;\n" };
var gbuffer_common_fragment = { top: "", define: "", varDeclare: "in vec3 v_worldPosition;\n", funcDeclare: "", funcDefine: "", body: "" };
var gbuffer_common_vertex = { top: "", define: "", varDeclare: "out vec3 v_worldPosition;\n", funcDeclare: "", funcDefine: "", body: "" };
var gbuffer_end_fragment = { top: "", define: "", varDeclare: "layout(location=0) out vec4 gbufferPosition;\nlayout(location=1) out vec4 gbufferNormal;\nlayout(location=2) out vec4 gbufferColor;\n", funcDeclare: "", funcDefine: "", body: "gbufferPosition.xyz = v_worldPosition;\n    gbufferPosition.w = u_shininess;\n    gbufferNormal.xyz = getNormal();\n    gbufferNormal.w = 1.0;\n    gbufferColor.xyz = getMaterialDiffuse();\n    gbufferColor.w = getSpecularStrength();\n" };
var gbuffer_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "" };
var gbuffer_setWorldPosition_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "v_worldPosition = vec3(mMatrix * vec4(a_position, 1.0));\n" };
var gbuffer_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "//todo use u_vpMatrix\n    gl_Position = cameraUbo.pMatrix * cameraUbo.vMatrix * vec4(v_worldPosition, 1.0);\n//    gl_Position = u_vpMatrix * vec4(v_worldPosition, 1.0);\n" };
var deferLightPass_common = { top: "", define: "", varDeclare: "in vec2 v_texcoord;\n", funcDeclare: "", funcDefine: "", body: "vec4 colorData = texture(u_colorBuffer, v_texcoord);\n\n            vec3 diffuseColor = colorData.xyz;\n" };
var deferLightPass_directionLight_pointLight_common = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float getBlinnShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 halfAngle = normalize(lightDir + viewDir);\n        float blinnTerm = dot(normal, halfAngle);\n\n        blinnTerm = clamp(blinnTerm, 0.0, 1.0);\n        blinnTerm = dotResultBetweenNormAndLight != 0.0 ? blinnTerm : 0.0;\n        blinnTerm = pow(blinnTerm, shininess);\n\n        return blinnTerm;\n}\n\nfloat getPhongShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float phongTerm = dot(viewDir, reflectDir);\n\n        phongTerm = clamp(phongTerm, 0.0, 1.0);\n        phongTerm = dotResultBetweenNormAndLight != 0.0 ? phongTerm : 0.0;\n        phongTerm = pow(phongTerm, shininess);\n\n        return phongTerm;\n}\n\n\n//todo optimize specular color\nvec3 getSpecularColor(vec3 diffuseColor)\n{\n    return diffuseColor;\n}\n\n", body: "vec4 positionData = texture(u_positionBuffer,\nv_texcoord);\n\n            vec3 position = positionData.xyz;\n            float shininess = positionData.w;\n\n\n            vec3 normal = normalize(texture(u_normalBuffer, v_texcoord).rgb);\n\n            float specularStrength  = colorData.w;\n\n\n\nvec3 viewDir = normalize(getViewDir(position));\n" };
var deferLightPass_end_fragment = { top: "", define: "", varDeclare: "out vec4 fragColor;\n", funcDeclare: "", funcDefine: "", body: "fragColor = totalColor;\n" };
var deferLightPass_vertex = { top: "", define: "", varDeclare: "out vec2 v_texcoord;\n", funcDeclare: "", funcDefine: "", body: "\n        v_texcoord = a_texCoord * 0.5 + vec2(0.5);\n\n    gl_Position = vec4(a_position, 1.0);\n" };
var webgl2_normalMatrix_noInstance_vertex = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "", body: "mat3 normalMatrix = mat3(\nvec3(cameraUbo.normalMatrixCol1),\nvec3(cameraUbo.normalMatrixCol2),\nvec3(cameraUbo.normalMatrixCol3)\n);\n" };
var webgl2_diffuseMap_fragment = { top: "", define: "", varDeclare: "in vec2 v_diffuseMapTexCoord;\n", funcDeclare: "", funcDefine: "vec3 getMaterialDiffuse() {\n        return texture(u_diffuseMapSampler, v_diffuseMapTexCoord).rgb;\n    }\n", body: "" };
var webgl2_diffuseMap_vertex = { top: "", define: "", varDeclare: "//	varying vec2 v_diffuseMapTexCoord;\n	out vec2 v_diffuseMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "//todo optimize(combine, reduce compute numbers)\n    //todo BasicTexture extract textureMatrix\n//    vec2 sourceTexCoord = a_texCoord * u_diffuseMapSourceRegion.zw + u_diffuseMapSourceRegion.xy;\n//    v_diffuseMapTexCoord = sourceTexCoord * u_diffuseMapRepeatRegion.zw + u_diffuseMapRepeatRegion.xy;\n\n    v_diffuseMapTexCoord = a_texCoord;\n" };
var webgl2_gbuffer_noNormalMap_fragment = { top: "", define: "", varDeclare: "in vec3 v_normal;\n", funcDeclare: "vec3 getNormal();\n\n", funcDefine: "vec3 getNormal(){\n    return v_normal;\n}\n\n", body: "" };
var webgl2_gbuffer_noNormalMap_vertex = { top: "", define: "", varDeclare: "out vec3 v_normal;\n", funcDeclare: "", funcDefine: "", body: "v_normal = normalize(normalMatrix * a_normal);\n" };
var webgl2_noDiffuseMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialDiffuse() {\n        return u_diffuse;\n    }\n", body: "" };
var webgl2_noSpecularMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "float getSpecularStrength() {\n        return 1.0;\n    }\n", body: "" };
var webgl2_specularMap_fragment = { top: "", define: "", varDeclare: "in vec2 v_specularMapTexCoord;\n", funcDeclare: "", funcDefine: "float getSpecularStrength() {\n        return texture(u_specularMapSampler, v_specularMapTexCoord).r;\n    }\n", body: "" };
var webgl2_specularMap_vertex = { top: "", define: "", varDeclare: "out vec2 v_specularMapTexCoord;\n", funcDeclare: "", funcDefine: "", body: "v_specularMapTexCoord = a_texCoord;\n" };
var deferLightPass_ambientLight_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 calcLight(vec3 materialDiffuse)\n{\n    vec3 materialLight = getMaterialLight();\n    return (ambientLightUbo.lightColorData.xyz + materialLight) * materialDiffuse;\n}\n\nvec3 calcAmbientLight(vec3 diffuseColor)\n{\n    return calcLight(diffuseColor);\n}\n\nvec4 calcTotalLight(vec3 diffuseColor){\n    return vec4(calcAmbientLight(diffuseColor), 1.0);\n}\n", body: "vec4 totalColor = calcTotalLight(diffuseColor);\n" };
var ubo_ambientLight = { top: "", define: "", varDeclare: "layout(std140) uniform AmbientLightUbo {\n/*! vec4(colorVec3, 0.0) */\nvec4 lightColorData;\n} ambientLightUbo;\n", funcDeclare: "", funcDefine: "", body: "" };
var deferLightPass_directionLight_common = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getDirectionLightDirByLightPos(vec3 lightPos){\n    return lightPos - vec3(0.0);\n}\n", body: "" };
var deferLightPass_directionLight_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 calcLight(vec3 lightDir, vec3 color, float intensity, vec3 normal, vec3 viewDir, vec3 materialDiffuse, float specularStrength, float shininess)\n{\n        vec3 materialLight = getMaterialLight();\n        vec3 materialSpecular = getSpecularColor(materialDiffuse);\n\n        vec3 materialEmission = getMaterialEmission();\n\n        float dotResultBetweenNormAndLight = dot(normal, lightDir);\n        float diff = max(dotResultBetweenNormAndLight, 0.0);\n\n        vec3 emissionColor = materialEmission;\n\n//        vec3 ambientColor = (u_ambient + materialLight) * materialDiffuse;\n//        vec3 ambientColor = vec3(0.0);\n\n        float lightModel = lightUbo.lightModel.x;\n\n        if(lightModel == 3.0){\n//            return emissionColor + ambientColor;\n            return emissionColor;\n        }\n\n        vec3 diffuseColor = color * materialDiffuse * diff * intensity;\n\n        float spec = 0.0;\n\n        if(lightModel == 2.0){\n                spec = getPhongShininess(shininess, normal, lightDir, viewDir, diff);\n        }\n        else if(lightModel == 1.0){\n                spec = getBlinnShininess(shininess, normal, lightDir, viewDir, diff);\n        }\n\n        vec3 specularColor = spec * materialSpecular * specularStrength * intensity;\n\n//        return emissionColor + ambientColor + attenuation * (diffuseColor + specularColor);\n        return emissionColor + diffuseColor + specularColor;\n}\n\n\n\n        vec3 calcDirectionLight(vec3 lightDir, vec3 normal, vec3 viewDir, vec3 diffuseColor, float specularStrength, float shininess)\n{\n        //lightDir is not normalize computing distance\n        float distance = length(lightDir);\n\n        lightDir = normalize(lightDir);\n\n        vec4 lightColorData = directionLightUbo.lightColorData;\n\n        return calcLight(lightDir, lightColorData.xyz, lightColorData.w, normal, viewDir, diffuseColor, specularStrength, shininess);\n}\n\nvec4 calcTotalLight(vec3 normal, vec3 viewDir, vec3 diffuseColor, float specularStrength, float shininess){\n    vec4 totalLight = vec4(0.0, 0.0, 0.0, 1.0);\n\n                totalLight += vec4(calcDirectionLight(getDirectionLightDir(), normal, viewDir, diffuseColor, specularStrength, shininess), 0.0);\n\n        return totalLight;\n}\n", body: "vec4 totalColor = calcTotalLight(normal, viewDir, diffuseColor, specularStrength, shininess);\n" };
var ubo_directionLight = { top: "", define: "", varDeclare: "layout(std140) uniform DirectionLightUbo {\nvec4 lightPosition;\n/*! vec4(colorVec3, intensity) */\nvec4 lightColorData;\n} directionLightUbo;\n", funcDeclare: "", funcDefine: "", body: "" };
var deferLightPass_pointLight_common = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition){\n    return lightPos - worldPosition;\n}\n", body: "" };
var deferLightPass_pointLight_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 calcLight(vec3 lightDir, vec3 color, float intensity, float attenuation, vec3 normal, vec3 viewDir, vec3 materialDiffuse, float specularStrength, float shininess)\n{\n        vec3 materialLight = getMaterialLight();\n        vec3 materialSpecular = getSpecularColor(materialDiffuse);\n\n        vec3 materialEmission = getMaterialEmission();\n\n        float dotResultBetweenNormAndLight = dot(normal, lightDir);\n        float diff = max(dotResultBetweenNormAndLight, 0.0);\n\n        vec3 emissionColor = materialEmission;\n\n//        vec3 ambientColor = (u_ambient + materialLight) * materialDiffuse;\n//        vec3 ambientColor = vec3(0.0);\n\n        float lightModel = lightUbo.lightModel.x;\n\n        if(lightModel == 3.0){\n//            return emissionColor + ambientColor;\n            return emissionColor;\n        }\n\n        vec3 diffuseColor = color * materialDiffuse * diff * intensity;\n\n        float spec = 0.0;\n\n        if(lightModel == 2.0){\n                spec = getPhongShininess(shininess, normal, lightDir, viewDir, diff);\n        }\n        else if(lightModel == 1.0){\n                spec = getBlinnShininess(shininess, normal, lightDir, viewDir, diff);\n        }\n\n        vec3 specularColor = spec * materialSpecular * specularStrength * intensity;\n\n//        return emissionColor + ambientColor + attenuation * (diffuseColor + specularColor);\n        return emissionColor + attenuation * (diffuseColor + specularColor);\n}\n\n\n\n        vec3 calcPointLight(vec3 lightDir, vec3 normal, vec3 viewDir, vec3 diffuseColor, float specularStrength, float shininess)\n{\n        //lightDir is not normalize computing distance\n        float distance = length(lightDir);\n\n        float attenuation = 0.0;\n\n        vec4 lightData = pointLightUbo.lightData;\n\n//        mat3 normalMatrix = cameraUbo.normalMatrix;\n\n//        if(normalMatrix[0][3] == 0.0){\n//            return vec3(0.5);\n//        }\n\n        if(distance >= lightData.w){\n            return vec3(0.0);\n        }\n\n        attenuation = 1.0 / (lightData.x + lightData.y * distance + lightData.z * (distance * distance));\n\n        lightDir = normalize(lightDir);\n\n        vec4 lightColorData = pointLightUbo.lightColorData;\n\n        return calcLight(lightDir, lightColorData.xyz, lightColorData.w, attenuation, normal, viewDir, diffuseColor, specularStrength, shininess);\n}\n\nvec4 calcTotalLight(vec3 normal, vec3 position, vec3 viewDir, vec3 diffuseColor, float specularStrength, float shininess){\n    vec4 totalLight = vec4(0.0, 0.0, 0.0, 1.0);\n\n                totalLight += vec4(calcPointLight(getPointLightDir(position), normal, viewDir, diffuseColor, specularStrength, shininess), 0.0);\n\n        return totalLight;\n}\n", body: "vec4 totalColor = calcTotalLight(normal, position, viewDir, diffuseColor, specularStrength, shininess);\n" };
var ubo_pointLight = { top: "", define: "", varDeclare: "layout(std140) uniform PointLightUbo {\nvec4 lightPosition;\n/*! vec4(colorVec3, intensity) */\nvec4 lightColorData;\n/*! vec4(constant, linear, quadratic, radius) */\nvec4 lightData;\n} pointLightUbo;\n", funcDeclare: "", funcDefine: "", body: "" };
var webgl2_deferLightPass_noNormalMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getViewDir(vec3 worldPosition){\n    return normalize(cameraUbo.cameraPos.xyz - worldPosition);\n}\n", body: "" };
var webgl2_noEmissionMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialEmission() {\n    //todo support emission color\n//        return u_emission;\n        return vec3(0.0);\n    }\n", body: "" };
var webgl2_noLightMap_fragment = { top: "", define: "", varDeclare: "", funcDeclare: "", funcDefine: "vec3 getMaterialLight() {\n        return vec3(0.0);\n    }\n", body: "" };

var buildGLSLSource$1 = requireCheckFunc(function (materialIndex, materialShaderLibNameArr, shaderLibData, funcDataMap, initShaderDataMap) {
    it$$1("shaderLib should be defined", function () {
        forEach(materialShaderLibNameArr, function (shaderLibName) {
            wdet_1(shaderLibData[shaderLibName]).exist;
        });
    });
}, function (materialIndex, materialShaderLibNameArr, shaderLibData, funcDataMap, initShaderDataMap) {
    var vsTop = "", vsDefine = "", vsVarDeclare = "", vsFuncDeclare = "", vsFuncDefine = "", vsBody = "", fsTop = "", fsDefine = "", fsVarDeclare = "", fsFuncDeclare = "", fsFuncDefine = "", fsBody = "";
    var _setVs = function (getGLSLPartData$$1, getGLSLDefineListData$$1, vs) {
        vsTop += getGLSLPartData$$1(vs, "top");
        vsDefine += buildSourceDefine(getGLSLDefineListData$$1(vs), initShaderDataMap) + getGLSLPartData$$1(vs, "define");
        vsVarDeclare += getGLSLPartData$$1(vs, "varDeclare");
        vsFuncDeclare += getGLSLPartData$$1(vs, "funcDeclare");
        vsFuncDefine += getGLSLPartData$$1(vs, "funcDefine");
        vsBody += getGLSLPartData$$1(vs, "body");
    }, _setFs = function (getGLSLPartData$$1, getGLSLDefineListData$$1, fs) {
        fsTop += getGLSLPartData$$1(fs, "top");
        fsDefine += buildSourceDefine(getGLSLDefineListData$$1(fs), initShaderDataMap) + getGLSLPartData$$1(fs, "define");
        fsVarDeclare += getGLSLPartData$$1(fs, "varDeclare");
        fsFuncDeclare += getGLSLPartData$$1(fs, "funcDeclare");
        fsFuncDefine += getGLSLPartData$$1(fs, "funcDefine");
        fsBody += getGLSLPartData$$1(fs, "body");
    };
    vsBody += webgl2_main_begin;
    fsBody += webgl2_main_begin;
    vsTop += version.top;
    fsTop += version.top;
    fsTop += getPrecisionSource(lowp_fragment, mediump_fragment, highp_fragment, initShaderDataMap.GPUDetectDataFromSystem);
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var glslData = shaderLibData[shaderLibName].glsl, vs = null, fs = null, func = null;
        if (!isConfigDataExist(glslData)) {
            return;
        }
        vs = glslData.vs;
        fs = glslData.fs;
        func = glslData.func;
        if (isConfigDataExist(vs)) {
            _setVs(getGLSLPartData, getGLSLDefineListData, vs);
        }
        if (isConfigDataExist(fs)) {
            _setFs(getGLSLPartData, getGLSLDefineListData, fs);
        }
        if (isConfigDataExist(func)) {
            var funcConfig = func(materialIndex, funcDataMap, initShaderDataMap);
            if (isConfigDataExist(funcConfig)) {
                var vs_1 = funcConfig.vs, fs_1 = funcConfig.fs;
                if (isConfigDataExist(vs_1)) {
                    vs_1 = ExtendUtils.extend(getEmptyFuncGLSLConfig(), vs_1);
                    _setVs(getFuncGLSLPartData, getFuncGLSLDefineListData, vs_1);
                }
                if (isConfigDataExist(fs_1)) {
                    fs_1 = ExtendUtils.extend(getEmptyFuncGLSLConfig(), fs_1);
                    _setFs(getFuncGLSLPartData, getFuncGLSLDefineListData, fs_1);
                }
            }
        }
    });
    vsBody += webgl2_main_end;
    fsBody += webgl2_main_end;
    vsTop += _generateAttributeSource(materialShaderLibNameArr, shaderLibData);
    vsTop += generateUniformSource(materialShaderLibNameArr, shaderLibData, vsVarDeclare, vsFuncDefine, vsBody);
    fsTop += generateUniformSource(materialShaderLibNameArr, shaderLibData, fsVarDeclare, fsFuncDefine, fsBody);
    return {
        vsSource: vsTop + vsDefine + vsVarDeclare + vsFuncDeclare + vsFuncDefine + vsBody,
        fsSource: fsTop + fsDefine + fsVarDeclare + fsFuncDeclare + fsFuncDefine + fsBody
    };
});
var _generateAttributeSource = function (materialShaderLibNameArr, shaderLibData) {
    var result = "";
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send, attributeData = null;
        if (!isConfigDataExist(sendData) || !isConfigDataExist(sendData.attribute)) {
            return;
        }
        attributeData = sendData.attribute;
        forEach(attributeData, function (_a) {
            var name = _a.name, type = _a.type, location = _a.location;
            result += "layout(location=" + location + ") in " + type + " " + name + ";\n";
        });
    });
    return result;
};

var buildGLSLSource$$1 = function (materialIndex, materialShaderLibNameArr, shaderLibData, MaterialDataMap) {
    return buildGLSLSource$1(materialIndex, materialShaderLibNameArr, shaderLibData, {
        getAlphaTest: getAlphaTest$$1,
        isTestAlpha: isTestAlpha$$1
    }, MaterialDataMap);
};

var WebGL1ShaderDataCommon = (function () {
    function WebGL1ShaderDataCommon() {
    }
    WebGL1ShaderDataCommon.index = null;
    WebGL1ShaderDataCommon.count = null;
    WebGL1ShaderDataCommon.shaderIndexMap = null;
    WebGL1ShaderDataCommon.shaderLibNameMap = null;
    return WebGL1ShaderDataCommon;
}());

var WebGL1ShaderData = (function (_super) {
    __extends(WebGL1ShaderData, _super);
    function WebGL1ShaderData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1ShaderData;
}(WebGL1ShaderDataCommon));

var WebGL2ShaderDataCommon = (function () {
    function WebGL2ShaderDataCommon() {
    }
    WebGL2ShaderDataCommon.index = null;
    WebGL2ShaderDataCommon.count = null;
    WebGL2ShaderDataCommon.shaderIndexMap = null;
    WebGL2ShaderDataCommon.shaderIndexByShaderNameMap = null;
    WebGL2ShaderDataCommon.shaderLibNameMap = null;
    return WebGL2ShaderDataCommon;
}());

var WebGL2ShaderData = (function (_super) {
    __extends(WebGL2ShaderData, _super);
    function WebGL2ShaderData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2ShaderData;
}(WebGL2ShaderDataCommon));

var LightMaterial = (function (_super) {
    __extends(LightMaterial, _super);
    function LightMaterial() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LightMaterial = __decorate([
        registerClass$1("LightMaterial")
    ], LightMaterial);
    return LightMaterial;
}(Material));
var createLightMaterial = null;
if (isWebgl1$1()) {
    createLightMaterial = function () {
        return create$13(WebGL1ShaderData, MaterialData, LightMaterialData);
    };
}
else {
    createLightMaterial = function () {
        return create$13(WebGL2ShaderData, MaterialData, LightMaterialData);
    };
}
var initLightMaterial = function (material) {
    initMaterial$2(material.index, getState(DirectorData));
};
var getLightMaterialColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getColor(material.index, MaterialData);
});
var setLightMaterialColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, color) {
    setColor(material.index, color, MaterialData);
});
var getLightMaterialOpacity = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getOpacity$$1(material.index, MaterialData);
});
var setLightMaterialOpacity = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, opacity) {
    setOpacity(material.index, opacity, MaterialData);
});
var getLightMaterialAlphaTest = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getAlphaTest$$1(material.index, MaterialData);
});
var setLightMaterialAlphaTest = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, alphaTest) {
    setAlphaTest(material.index, alphaTest, MaterialData);
});
var getLightMaterialSpecularColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getSpecularColor(material.index, LightMaterialData);
});
var setLightMaterialSpecularColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, color) {
    setSpecularColor(material.index, color, LightMaterialData);
});
var getLightMaterialEmissionColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getEmissionColor(material.index, LightMaterialData);
});
var setLightMaterialEmissionColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, color) {
    setEmissionColor(material.index, color, LightMaterialData);
});
var getLightMaterialShininess = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getShininess$1(material.index, LightMaterialData);
});
var setLightMaterialShininess = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, shininess) {
    setShininess(material.index, shininess, LightMaterialData);
});
var getLightMaterialShading = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getShading$1(material.index, LightMaterialData);
});
var setLightMaterialShading = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, shading) {
    setShading(material.index, shading, LightMaterialData);
});
var getLightMaterialLightModel = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getLightModel$1(material.index, LightMaterialData);
});
var setLightMaterialLightModel = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, lightModel) {
    setLightModel(material.index, lightModel, LightMaterialData);
});
var setLightMaterialDiffuseMap = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, map) {
    setDiffuseMap(material.index, map, MapManagerData, TextureData);
});
var setLightMaterialSpecularMap = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, map) {
    setSpecularMap(material.index, map, MapManagerData, TextureData);
});

var initData$34 = function (startIndex, SpecifyMaterialData) {
    SpecifyMaterialData.index = startIndex;
};

var create$13 = ensureFunc$$1(function (component) {
    it$$1("index should <= max count", function () {
        wdet_1(component.index).lte(getLightMaterialBufferStartIndex() + getLightMaterialBufferCount());
    });
}, function (ShaderData, MaterialData$$1, LightMaterialData$$1) {
    var material = new LightMaterial(), index = generateComponentIndex(LightMaterialData$$1);
    material.index = index;
    material = create$6(index, material, ShaderData, MaterialData$$1);
    return material;
});
var getSpecularColor = function (index, LightMaterialData$$1) {
    return getColor3Data(computeLightBufferIndex(index), LightMaterialData$$1.specularColors);
};
var getSpecularColorArr3$1 = function (index, LightMaterialData$$1) {
    return getSpecularColorArr3(computeLightBufferIndex(index), LightMaterialData$$1);
};
var setSpecularColor = function (index, color, LightMaterialData$$1) {
    setColorData(computeLightBufferIndex(index), color, LightMaterialData$$1.specularColors);
};
var setDiffuseMap = function (index, map, MapManagerData$$1, TextureData$$1) {
    setMap(index, map, "u_diffuseMapSampler", MapManagerData$$1, TextureData$$1);
    markHasMap(index, LightMaterialData.hasDiffuseMaps);
};
var setSpecularMap = function (index, map, MapManagerData$$1, TextureData$$1) {
    setMap(index, map, "u_specularMapSampler", MapManagerData$$1, TextureData$$1);
    markHasMap(index, LightMaterialData.hasSpecularMaps);
};
var getEmissionColor = function (index, LightMaterialData$$1) {
    return getColor3Data(computeLightBufferIndex(index), LightMaterialData$$1.emissionColors);
};
var getEmissionColorArr3$1 = function (index, LightMaterialData$$1) {
    return getEmissionColorArr3(computeLightBufferIndex(index), LightMaterialData$$1);
};
var setEmissionColor = function (index, color, LightMaterialData$$1) {
    setColorData(computeLightBufferIndex(index), color, LightMaterialData$$1.emissionColors);
};
var getShininess$1 = function (index, LightMaterialDataFromSystem) {
    return getShininess(computeLightBufferIndex(index), LightMaterialDataFromSystem);
};
var setShininess = function (index, shininess, LightMaterialData$$1) {
    setTypeArrayValue(LightMaterialData$$1.shininess, computeLightBufferIndex(index), shininess);
};
var getShading$1 = function (index, LightMaterialDataFromSystem) {
    return getShading(computeLightBufferIndex(index), LightMaterialDataFromSystem);
};
var setShading = function (index, shading, LightMaterialData$$1) {
    setTypeArrayValue(LightMaterialData$$1.shadings, computeLightBufferIndex(index), shading);
};
var getLightModel$1 = function (index, LightMaterialDataFromSystem) {
    return getLightModel(computeLightBufferIndex(index), LightMaterialDataFromSystem);
};
var setLightModel = function (index, lightModel, LightMaterialData$$1) {
    setTypeArrayValue(LightMaterialData$$1.lightModels, computeLightBufferIndex(index), lightModel);
};
var hasDiffuseMap$1 = function (index, LightMaterialData$$1) {
    return hasDiffuseMap(computeLightBufferIndex(index), LightMaterialData$$1);
};
var hasSpecularMap$1 = function (index, LightMaterialData$$1) {
    return hasSpecularMap(computeLightBufferIndex(index), LightMaterialData$$1);
};
var initMaterialWithoutInitMap = function (index, state) {
    initMaterial(index, state, getClassName(), MaterialData);
};
var initMaterial$2 = function (index, state) {
    initMaterial(index, state, getClassName(), MaterialData);
    initMapManager(getGL$$1(DeviceManagerData, state), index, MapManagerData, TextureData);
};
var addComponent$8 = function (component, gameObject) {
    addComponent$5(component, gameObject, MaterialData);
};
var disposeComponent$10 = function (component) {
    var sourceIndex = component.index, lightMaterialSourceIndex = computeLightBufferIndex(sourceIndex), lastComponentIndex = null, lightMaterialLastComponentIndex = null, colorDataSize = getColorDataSize(), shininessDataSize = getShininessDataSize(), shadingDataSize = getShadingDataSize(), lightModelDataSize = getLightModelDataSize(), mapSize = getMapSize();
    LightMaterialData.index -= 1;
    lastComponentIndex = LightMaterialData.index;
    lightMaterialLastComponentIndex = computeLightBufferIndex(lastComponentIndex);
    disposeComponent$5(sourceIndex, lastComponentIndex, MapManagerData, MaterialData);
    deleteBySwapAndReset(lightMaterialSourceIndex * colorDataSize, lightMaterialLastComponentIndex * colorDataSize, LightMaterialData.specularColors, colorDataSize, MaterialData.defaultColorArr);
    deleteBySwapAndReset(lightMaterialSourceIndex * colorDataSize, lightMaterialLastComponentIndex * colorDataSize, LightMaterialData.emissionColors, colorDataSize, LightMaterialData.emptyColorArr);
    deleteOneItemBySwapAndReset(lightMaterialSourceIndex * shadingDataSize, lightMaterialLastComponentIndex * shadingDataSize, LightMaterialData.shadings, LightMaterialData.defaultShading);
    deleteOneItemBySwapAndReset(lightMaterialSourceIndex * shininessDataSize, lightMaterialLastComponentIndex * shininessDataSize, LightMaterialData.shininess, LightMaterialData.defaultShininess);
    deleteOneItemBySwapAndReset(lightMaterialSourceIndex * lightModelDataSize, lightMaterialLastComponentIndex * lightModelDataSize, LightMaterialData.lightModels, LightMaterialData.defaultLightModel);
    deleteOneItemBySwapAndReset(lightMaterialSourceIndex * mapSize, lightMaterialLastComponentIndex * mapSize, LightMaterialData.hasDiffuseMaps, LightMaterialData.defaultHasMap);
    deleteOneItemBySwapAndReset(lightMaterialSourceIndex * mapSize, lightMaterialLastComponentIndex * mapSize, LightMaterialData.hasSpecularMaps, LightMaterialData.defaultHasMap);
};
var initData$33 = function (LightMaterialData$$1) {
    initData$34(getLightMaterialBufferStartIndex(), LightMaterialData$$1);
    LightMaterialData$$1.emptyColor = _createEmptyColor();
    LightMaterialData$$1.emptyColorArr = LightMaterialData$$1.emptyColor.toVector3().toArray();
};
var createTypeArrays$8 = function (buffer, offset, count, LightMaterialData$$1) {
    var returnedOffset = createTypeArrays$3(buffer, offset, count, LightMaterialData$$1);
    _setLightMaterialDefaultTypeArrData(count, LightMaterialData$$1);
    return returnedOffset;
};
var setDefaultData = function (LightMaterialData$$1) {
    LightMaterialData$$1.defaultShininess = 32;
    LightMaterialData$$1.defaultShading = 0;
    LightMaterialData$$1.defaultLightModel = ELightModel.PHONG;
    LightMaterialData$$1.defaultHasMap = getNotHasMapValue();
};
var _setLightMaterialDefaultTypeArrData = function (count, LightMaterialData$$1) {
    var startIndex = getLightMaterialBufferStartIndex(), color = createDefaultColor(), emptyColor = LightMaterialData$$1.emptyColor, shading = LightMaterialData$$1.defaultShading, lightModel = LightMaterialData$$1.defaultLightModel, shininess = LightMaterialData$$1.defaultShininess;
    count += startIndex;
    for (var i = startIndex; i < count; i++) {
        setSpecularColor(i, color, LightMaterialData$$1);
        setEmissionColor(i, emptyColor, LightMaterialData$$1);
        setShininess(i, shininess, LightMaterialData$$1);
        setShading(i, shading, LightMaterialData$$1);
        setLightModel(i, lightModel, LightMaterialData$$1);
        markNotHasMap(i, LightMaterialData$$1.hasDiffuseMaps);
        markNotHasMap(i, LightMaterialData$$1.hasSpecularMaps);
    }
};
var _createEmptyColor = function () {
    var color = Color.create("rgb(0,0,0)");
    return color;
};

var initNoMaterialShader$$1 = null;
var initMaterialShader$$1 = null;
if (!isSupportRenderWorkerAndSharedArrayBuffer()) {
    initNoMaterialShader$$1 = function (state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, initShaderDataMap) {
        initNoMaterialShader$1(state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, _buildInitShaderFuncDataMap_1(), initShaderDataMap);
    };
    initMaterialShader$$1 = function (state, materialIndex, shaderName, material_config, shaderLib_generator, initShaderDataMap) {
        return initMaterialShader$1(state, materialIndex, shaderName, material_config, shaderLib_generator, _buildInitShaderFuncDataMap_1(), initShaderDataMap);
    };
    var _buildInitShaderFuncDataMap_1 = function () {
        return {
            buildGLSLSource: buildGLSLSource$$1,
            getGL: getGL$$1,
            getMapCount: getMapCount$$1,
            hasSpecularMap: hasSpecularMap$1,
            hasDiffuseMap: hasDiffuseMap$1,
            getVertices: getVertices$1,
            getNormals: getNormals$1,
            getTexCoords: getTexCoords$1,
            getIndices: getIndices$1
        };
    };
}
var initData$26 = initData$27;

var webgl1_main_begin = "void main(void){\n";
var webgl1_main_end = "}\n";
var webgl1_setPos_mvp = "gl_Position = u_pMatrix * u_vMatrix * mMatrix * vec4(a_position, 1.0);\n";

var _lightDefineList = [
    {
        "name": "DIRECTION_LIGHTS_COUNT",
        "valueFunc": function (_a) {
            var DirectionLightDataFromSystem = _a.DirectionLightDataFromSystem;
            return DirectionLightDataFromSystem.count;
        }
    },
    {
        "name": "POINT_LIGHTS_COUNT",
        "valueFunc": function (_a) {
            var PointLightDataFromSystem = _a.PointLightDataFromSystem;
            return PointLightDataFromSystem.count;
        }
    }
];
var webgl1_shaderLib_generator = {
    "shaderLibs": {
        "CommonShaderLib": {
            "glsl": {
                "vs": {
                    "source": common_vertex,
                    "define": common_define.define + common_vertex.define,
                    "funcDefine": common_function.funcDefine + common_vertex.funcDefine
                },
                "fs": {
                    "source": common_fragment,
                    "define": common_define.define + common_fragment.define,
                    "funcDefine": common_function.funcDefine + common_fragment.funcDefine
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_vMatrix",
                        "field": "vMatrix",
                        "type": "mat4"
                    },
                    {
                        "name": "u_pMatrix",
                        "field": "pMatrix",
                        "type": "mat4"
                    }
                ]
            }
        },
        "ModelMatrixNoInstanceShaderLib": {
            "glsl": {
                "vs": {
                    "source": modelMatrix_noInstance_vertex,
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_mMatrix",
                        "field": "mMatrix",
                        "type": "mat4"
                    }
                ]
            }
        },
        "VerticeCommonShaderLib": {
            "send": {
                "attribute": [
                    {
                        "name": "a_position",
                        "buffer": "vertex",
                        "type": "vec3"
                    }
                ]
            }
        },
        "BasicMaterialColorShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl1_basic_materialColor_fragment
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_color",
                        "from": "basicMaterial",
                        "field": "color",
                        "type": "float3"
                    }
                ]
            }
        },
        "BasicShaderLib": {
            "glsl": {
                "vs": {
                    "body": webgl1_setPos_mvp
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_opacity",
                        "from": "basicMaterial",
                        "field": "opacity",
                        "type": "float"
                    }
                ]
            }
        },
        "BasicEndShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl1_basic_end_fragment
                },
                "func": function (materialIndex, _a, _b) {
                    var getAlphaTest = _a.getAlphaTest, isTestAlpha = _a.isTestAlpha;
                    var MaterialDataFromSystem = _b.MaterialDataFromSystem;
                    var alphaTest = getAlphaTest(materialIndex, MaterialDataFromSystem);
                    if (isTestAlpha(alphaTest)) {
                        return {
                            "fs": {
                                "body": "if (gl_FragColor.a < " + alphaTest + "){\n    discard;\n}\n" + webgl1_basic_end_fragment.body
                            }
                        };
                    }
                    return void 0;
                }
            }
        },
        "BasicMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl1_basic_map_vertex
                },
                "fs": {
                    "source": webgl1_basic_map_fragment
                }
            },
            "send": {
                "attribute": [
                    {
                        "name": "a_texCoord",
                        "buffer": "texCoord",
                        "type": "vec2"
                    }
                ],
                "uniformDefine": [
                    {
                        "name": "u_sampler2D",
                        "type": "sampler2D"
                    }
                ]
            }
        },
        "NormalMatrixNoInstanceShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl1_normalMatrix_noInstance_vertex
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_normalMatrix",
                        "field": "normalMatrix",
                        "type": "mat3"
                    }
                ]
            }
        },
        "NormalCommonShaderLib": {
            "send": {
                "attribute": [
                    {
                        "name": "a_normal",
                        "buffer": "normal",
                        "type": "vec3"
                    }
                ]
            }
        },
        "LightCommonShaderLib": {
            "glsl": {
                "vs": {
                    "source": frontLight_common_vertex,
                    "funcDeclare": frontLight_common.funcDeclare,
                    "funcDefine": frontLight_common.funcDefine
                },
                "fs": {
                    "source": frontLight_common_fragment,
                    "funcDeclare": frontLight_common.funcDeclare,
                    "funcDefine": frontLight_common.funcDefine
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_specular",
                        "from": "lightMaterial",
                        "field": "specularColor",
                        "type": "float3"
                    }
                ]
            }
        },
        "LightSetWorldPositionShaderLib": {
            "glsl": {
                "vs": {
                    "source": frontLight_setWorldPosition_vertex
                }
            }
        },
        "CommonLightMapShaderLib": {
            "send": {
                "attribute": [
                    {
                        "name": "a_texCoord",
                        "buffer": "texCoord",
                        "type": "vec2"
                    }
                ]
            }
        },
        "DiffuseMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl1_diffuseMap_vertex
                },
                "fs": {
                    "source": webgl1_diffuseMap_fragment
                }
            },
            "send": {
                "uniformDefine": [
                    {
                        "name": "u_diffuseMapSampler",
                        "type": "sampler2D"
                    }
                ]
            }
        },
        "NoDiffuseMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl1_noDiffuseMap_fragment
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_diffuse",
                        "from": "lightMaterial",
                        "field": "color",
                        "type": "float3"
                    }
                ]
            }
        },
        "SpecularMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl1_specularMap_vertex
                },
                "fs": {
                    "source": webgl1_specularMap_fragment
                }
            },
            "send": {
                "uniformDefine": [
                    {
                        "name": "u_specularMapSampler",
                        "type": "sampler2D"
                    }
                ]
            }
        },
        "NoSpecularMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl1_noSpecularMap_fragment
                }
            }
        },
        "NoLightMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl1_noLightMap_fragment
                }
            }
        },
        "NoEmissionMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl1_noEmissionMap_fragment
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_emission",
                        "from": "lightMaterial",
                        "field": "emissionColor",
                        "type": "float3"
                    }
                ]
            }
        },
        "NoNormalMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl1_noNormalMap_vertex
                },
                "fs": {
                    "source": webgl1_noNormalMap_fragment
                }
            }
        },
        "NoShadowMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl1_noShadowMap_fragment
                }
            }
        },
        "LightShaderLib": {
            "glsl": {
                "vs": {
                    "source": frontLight_vertex,
                    "defineList": _lightDefineList
                },
                "fs": {
                    "source": frontLight_fragment,
                    "defineList": _lightDefineList
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_shininess",
                        "from": "lightMaterial",
                        "field": "shininess",
                        "type": "float"
                    },
                    {
                        "name": "u_opacity",
                        "from": "lightMaterial",
                        "field": "opacity",
                        "type": "float"
                    },
                    {
                        "name": "u_lightModel",
                        "from": "lightMaterial",
                        "field": "lightModel",
                        "type": "int"
                    },
                    {
                        "name": "u_cameraPos",
                        "from": "cmd",
                        "field": "cameraPosition",
                        "type": "float3"
                    }
                ]
            }
        },
        "AmbientLightShaderLib": {
            "glsl": {
                "fs": {
                    "varDeclare": "uniform vec3 u_ambient;"
                }
            },
            "send": {
                "uniformFunc": function (gl, shaderIndex, program, _a, uniformLocationMap, uniformCacheMap) {
                    var sendFloat3 = _a.glslSenderData.sendFloat3, _b = _a.ambientLightData, getColorArr3 = _b.getColorArr3, isColorDirty = _b.isColorDirty, cleanColorDirty = _b.cleanColorDirty, AmbientLightDataFromSystem = _b.AmbientLightDataFromSystem;
                    for (var i = 0, count = AmbientLightDataFromSystem.count; i < count; i++) {
                        if (isColorDirty(i, AmbientLightDataFromSystem)) {
                            sendFloat3(gl, shaderIndex, program, "u_ambient", getColorArr3(i, AmbientLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanColorDirty(i, AmbientLightDataFromSystem);
                        }
                    }
                }
            }
        },
        "PointLightShaderLib": {
            "send": {
                "uniformFunc": function (gl, shaderIndex, program, _a, uniformLocationMap, uniformCacheMap) {
                    var _b = _a.glslSenderData, sendFloat1 = _b.sendFloat1, sendFloat3 = _b.sendFloat3, _c = _a.pointLightData, getColorArr3 = _c.getColorArr3, getIntensity = _c.getIntensity, getConstant = _c.getConstant, getLinear = _c.getLinear, getQuadratic = _c.getQuadratic, getRange = _c.getRange, getPosition = _c.getPosition, isPositionDirty = _c.isPositionDirty, isColorDirty = _c.isColorDirty, isIntensityDirty = _c.isIntensityDirty, isAttenuationDirty = _c.isAttenuationDirty, cleanPositionDirty = _c.cleanPositionDirty, cleanColorDirty = _c.cleanColorDirty, cleanIntensityDirty = _c.cleanIntensityDirty, cleanAttenuationDirty = _c.cleanAttenuationDirty, PointLightDataFromSystem = _c.PointLightDataFromSystem;
                    for (var i = 0, count = PointLightDataFromSystem.count; i < count; i++) {
                        if (isPositionDirty(i, PointLightDataFromSystem)) {
                            sendFloat3(gl, shaderIndex, program, PointLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].position, getPosition(i, PointLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanPositionDirty(i, PointLightDataFromSystem);
                        }
                        if (isColorDirty(i, PointLightDataFromSystem)) {
                            sendFloat3(gl, shaderIndex, program, PointLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].color, getColorArr3(i, PointLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanColorDirty(i, PointLightDataFromSystem);
                        }
                        if (isIntensityDirty(i, PointLightDataFromSystem)) {
                            sendFloat1(gl, shaderIndex, program, PointLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].intensity, getIntensity(i, PointLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanIntensityDirty(i, PointLightDataFromSystem);
                        }
                        if (isAttenuationDirty(i, PointLightDataFromSystem)) {
                            sendFloat1(gl, shaderIndex, program, PointLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].constant, getConstant(i, PointLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            sendFloat1(gl, shaderIndex, program, PointLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].linear, getLinear(i, PointLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            sendFloat1(gl, shaderIndex, program, PointLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].quadratic, getQuadratic(i, PointLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            sendFloat1(gl, shaderIndex, program, PointLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].range, getRange(i, PointLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanAttenuationDirty(i, PointLightDataFromSystem);
                        }
                    }
                }
            }
        },
        "DirectionLightShaderLib": {
            "send": {
                "uniformFunc": function (gl, shaderIndex, program, _a, uniformLocationMap, uniformCacheMap) {
                    var _b = _a.glslSenderData, sendFloat1 = _b.sendFloat1, sendFloat3 = _b.sendFloat3, _c = _a.directionLightData, getColorArr3 = _c.getColorArr3, getIntensity = _c.getIntensity, getPosition = _c.getPosition, isPositionDirty = _c.isPositionDirty, isColorDirty = _c.isColorDirty, isIntensityDirty = _c.isIntensityDirty, cleanPositionDirty = _c.cleanPositionDirty, cleanColorDirty = _c.cleanColorDirty, cleanIntensityDirty = _c.cleanIntensityDirty, DirectionLightDataFromSystem = _c.DirectionLightDataFromSystem;
                    for (var i = 0, count = DirectionLightDataFromSystem.count; i < count; i++) {
                        if (isPositionDirty(i, DirectionLightDataFromSystem)) {
                            sendFloat3(gl, shaderIndex, program, DirectionLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].position, getPosition(i, DirectionLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanPositionDirty(i, DirectionLightDataFromSystem);
                        }
                        if (isColorDirty(i, DirectionLightDataFromSystem)) {
                            sendFloat3(gl, shaderIndex, program, DirectionLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].color, getColorArr3(i, DirectionLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanColorDirty(i, DirectionLightDataFromSystem);
                        }
                        if (isIntensityDirty(i, DirectionLightDataFromSystem)) {
                            sendFloat1(gl, shaderIndex, program, DirectionLightDataFromSystem.lightGLSLDataStructureMemberNameArr[i].intensity, getIntensity(i, DirectionLightDataFromSystem), uniformCacheMap, uniformLocationMap);
                            cleanIntensityDirty(i, DirectionLightDataFromSystem);
                        }
                    }
                }
            }
        },
        "LightEndShaderLib": {
            "glsl": {
                "fs": {
                    "source": frontLight_end_fragment
                },
                "func": function (materialIndex, _a, _b) {
                    var getAlphaTest = _a.getAlphaTest, isTestAlpha = _a.isTestAlpha;
                    var MaterialDataFromSystem = _b.MaterialDataFromSystem;
                    var alphaTest = getAlphaTest(materialIndex, MaterialDataFromSystem);
                    if (isTestAlpha(alphaTest)) {
                        return {
                            "fs": {
                                "body": "if (gl_FragColor.a < " + alphaTest + "){\n    discard;\n}\n" + frontLight_end_fragment.body
                            }
                        };
                    }
                    return void 0;
                }
            }
        },
        "EndShaderLib": {}
    }
};

var webgl2_shaderLib_generator = {
    "shaderLibs": {
        "CommonShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl2_common_vertex,
                    "define": webgl2_common_define.define + webgl2_common_vertex.define,
                    "funcDefine": webgl2_common_function.funcDefine + webgl2_common_vertex.funcDefine
                },
                "fs": {
                    "source": webgl2_common_fragment,
                    "define": webgl2_common_define.define + webgl2_common_fragment.define,
                    "funcDefine": webgl2_common_function.funcDefine + webgl2_common_fragment.funcDefine
                }
            },
            "send": {}
        },
        "ModelMatrixNoInstanceShaderLib": {
            "glsl": {
                "vs": {
                    "source": modelMatrix_noInstance_vertex,
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_mMatrix",
                        "field": "mMatrix",
                        "type": "mat4"
                    }
                ]
            }
        },
        "VerticeCommonShaderLib": {
            "send": {
                "attribute": [
                    {
                        "name": "a_position",
                        "buffer": "vertex",
                        "type": "vec3",
                        "location": 0
                    }
                ]
            }
        },
        "CameraUboShaderLib": {
            "glsl": {
                "vs": {
                    "source": ubo_camera
                },
                "fs": {
                    "source": ubo_camera
                }
            },
            "send": {
                "uniformUbo": [
                    {
                        "name": "CameraUbo",
                        "typeArray": {
                            "type": "float32",
                            "length": 16 * 2 + 4 + 16
                        },
                        "setBufferDataFunc": function (gl, _a, _b, _c) {
                            var uniformBlockBinding = _a.uniformBlockBinding, buffer = _a.buffer, typeArray = _a.typeArray;
                            var bindUniformBufferBase = _b.bindUniformBufferBase, bufferDynamicData = _b.bufferDynamicData, set = _b.set;
                            var vMatrix = _c.vMatrix, pMatrix = _c.pMatrix, cameraPosition = _c.cameraPosition, normalMatrix = _c.normalMatrix;
                            bindUniformBufferBase(gl, buffer, uniformBlockBinding);
                            set(typeArray, vMatrix);
                            set(typeArray, pMatrix, 16);
                            set(typeArray, cameraPosition, 32);
                            set(typeArray, [normalMatrix[0], normalMatrix[1], normalMatrix[2], 0], 36);
                            set(typeArray, [normalMatrix[3], normalMatrix[4], normalMatrix[5], 0], 40);
                            set(typeArray, [normalMatrix[6], normalMatrix[7], normalMatrix[8], 0], 44);
                            bufferDynamicData(gl, typeArray);
                        },
                        "frequence": "frame",
                        "usage": "dynamic"
                    }
                ]
            }
        },
        "LightUboShaderLib": {
            "glsl": {
                "fs": {
                    "varDeclare": ubo_light.varDeclare
                }
            },
            "send": {
                "uniformUbo": [
                    {
                        "name": "LightUbo",
                        "typeArray": {
                            "type": "float32",
                            "length": 4
                        },
                        "setBufferDataFunc": function (gl, _a, _b, drawRenderCommandBufferDataMap, _c) {
                            var uniformBlockBinding = _a.uniformBlockBinding, buffer = _a.buffer, typeArray = _a.typeArray;
                            var bindUniformBufferBase = _b.bindUniformBufferBase, bufferStaticData = _b.bufferStaticData, set = _b.set;
                            var render_config = _c.render_config;
                            bindUniformBufferBase(gl, buffer, uniformBlockBinding);
                            set(typeArray, [render_config.defer.lightModel]);
                            bufferStaticData(gl, typeArray);
                        },
                        "frequence": "one",
                        "usage": "static"
                    }
                ]
            }
        },
        "AmbientLightUboShaderLib": {
            "glsl": {
                "fs": {
                    "source": ubo_ambientLight
                }
            },
            "send": {
                "uniformUbo": [
                    {
                        "name": "AmbientLightUbo",
                        "typeArray": {
                            "type": "float32",
                            "length": 4 * 1
                        },
                        "setBufferDataFunc": function (gl, ambientLightIndex, _a, _b, _c, _d) {
                            var uniformBlockBinding = _a.uniformBlockBinding, buffer = _a.buffer, typeArray = _a.typeArray;
                            var bindUniformBufferBase = _b.bindUniformBufferBase, bufferDynamicData = _b.bufferDynamicData, set = _b.set;
                            var cleanColorDirty = _c.cleanColorDirty, AmbientLightDataFromSystem = _c.AmbientLightDataFromSystem;
                            var colorArr3 = _d.colorArr3, isColorDirty = _d.isColorDirty;
                            var isDirtyFlag = false;
                            if (isColorDirty) {
                                isDirtyFlag = true;
                                set(typeArray, colorArr3, 0);
                                cleanColorDirty(ambientLightIndex, AmbientLightDataFromSystem);
                            }
                            bindUniformBufferBase(gl, buffer, uniformBlockBinding);
                            if (isDirtyFlag) {
                                bufferDynamicData(gl, typeArray);
                            }
                        },
                        "frequence": "ambientLight",
                        "usage": "dynamic"
                    }
                ]
            }
        },
        "DirectionLightUboShaderLib": {
            "glsl": {
                "fs": {
                    "source": ubo_directionLight
                }
            },
            "send": {
                "uniformUbo": [
                    {
                        "name": "DirectionLightUbo",
                        "typeArray": {
                            "type": "float32",
                            "length": 4 * 2
                        },
                        "setBufferDataFunc": function (gl, directionLightIndex, _a, _b, _c, _d) {
                            var uniformBlockBinding = _a.uniformBlockBinding, buffer = _a.buffer, typeArray = _a.typeArray;
                            var bindUniformBufferBase = _b.bindUniformBufferBase, bufferDynamicData = _b.bufferDynamicData, set = _b.set;
                            var cleanPositionDirty = _c.cleanPositionDirty, cleanColorDirty = _c.cleanColorDirty, cleanIntensityDirty = _c.cleanIntensityDirty, DirectionLightDataFromSystem = _c.DirectionLightDataFromSystem;
                            var position = _d.position, colorArr3 = _d.colorArr3, intensity = _d.intensity, isPositionDirty = _d.isPositionDirty, isColorDirty = _d.isColorDirty, isIntensityDirty = _d.isIntensityDirty;
                            var isDirtyFlag = false;
                            if (isPositionDirty) {
                                isDirtyFlag = true;
                                set(typeArray, position);
                                cleanPositionDirty(directionLightIndex, DirectionLightDataFromSystem);
                            }
                            if (isColorDirty) {
                                isDirtyFlag = true;
                                set(typeArray, colorArr3, 4);
                                cleanColorDirty(directionLightIndex, DirectionLightDataFromSystem);
                            }
                            if (isIntensityDirty) {
                                set(typeArray, [intensity], 7);
                                isDirtyFlag = true;
                                cleanIntensityDirty(directionLightIndex, DirectionLightDataFromSystem);
                            }
                            bindUniformBufferBase(gl, buffer, uniformBlockBinding);
                            if (isDirtyFlag) {
                                bufferDynamicData(gl, typeArray);
                            }
                        },
                        "frequence": "directionLight",
                        "usage": "dynamic"
                    }
                ]
            }
        },
        "PointLightUboShaderLib": {
            "glsl": {
                "fs": {
                    "source": ubo_pointLight
                }
            },
            "send": {
                "uniformUbo": [
                    {
                        "name": "PointLightUbo",
                        "typeArray": {
                            "type": "float32",
                            "length": 4 * 3
                        },
                        "setBufferDataFunc": function (gl, pointLightIndex, _a, _b, _c, _d) {
                            var uniformBlockBinding = _a.uniformBlockBinding, buffer = _a.buffer, typeArray = _a.typeArray;
                            var bindUniformBufferBase = _b.bindUniformBufferBase, bufferDynamicData = _b.bufferDynamicData, set = _b.set;
                            var cleanPositionDirty = _c.cleanPositionDirty, cleanColorDirty = _c.cleanColorDirty, cleanIntensityDirty = _c.cleanIntensityDirty, cleanAttenuationDirty = _c.cleanAttenuationDirty, PointLightDataFromSystem = _c.PointLightDataFromSystem;
                            var position = _d.position, colorArr3 = _d.colorArr3, intensity = _d.intensity, constant = _d.constant, linear = _d.linear, quadratic = _d.quadratic, radius = _d.radius, isIntensityDirty = _d.isIntensityDirty, isOtherValueDirty = _d.isOtherValueDirty;
                            var isDirtyFlag = false;
                            if (isIntensityDirty) {
                                set(typeArray, [intensity], 7);
                                isDirtyFlag = true;
                                cleanIntensityDirty(pointLightIndex, PointLightDataFromSystem);
                            }
                            if (isOtherValueDirty) {
                                isDirtyFlag = true;
                                set(typeArray, position);
                                set(typeArray, colorArr3, 4);
                                set(typeArray, [constant, linear, quadratic, radius], 8);
                                cleanPositionDirty(pointLightIndex, PointLightDataFromSystem);
                                cleanColorDirty(pointLightIndex, PointLightDataFromSystem);
                                cleanAttenuationDirty(pointLightIndex, PointLightDataFromSystem);
                            }
                            bindUniformBufferBase(gl, buffer, uniformBlockBinding);
                            if (isDirtyFlag) {
                                bufferDynamicData(gl, typeArray);
                            }
                        },
                        "frequence": "pointLight",
                        "usage": "dynamic"
                    }
                ]
            }
        },
        "BasicMaterialColorShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_basic_materialColor_fragment
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_color",
                        "from": "basicMaterial",
                        "field": "color",
                        "type": "float3"
                    }
                ]
            }
        },
        "BasicShaderLib": {
            "glsl": {
                "vs": {
                    "varDeclare": webgl2_basic_vertex.varDeclare,
                    "body": webgl2_setPos_mvp
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_opacity",
                        "from": "basicMaterial",
                        "field": "opacity",
                        "type": "float"
                    }
                ]
            }
        },
        "BasicEndShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_basic_end_fragment
                },
                "func": function (materialIndex, _a, _b) {
                    var getAlphaTest = _a.getAlphaTest, isTestAlpha = _a.isTestAlpha;
                    var MaterialDataFromSystem = _b.MaterialDataFromSystem;
                    var alphaTest = getAlphaTest(materialIndex, MaterialDataFromSystem);
                    if (isTestAlpha(alphaTest)) {
                        return {
                            "fs": {
                                "body": "if (gl_FragColor.a < " + alphaTest + "){\n    discard;\n}\n" + webgl2_basic_end_fragment.body
                            }
                        };
                    }
                    return void 0;
                }
            }
        },
        "BasicMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl2_basic_map_vertex
                },
                "fs": {
                    "source": webgl2_basic_map_fragment
                }
            },
            "send": {
                "attribute": [
                    {
                        "name": "a_texCoord",
                        "buffer": "texCoord",
                        "type": "vec2",
                        "location": 1
                    }
                ],
                "uniformDefine": [
                    {
                        "name": "u_sampler2D",
                        "type": "sampler2D"
                    }
                ]
            }
        },
        "NormalMatrixNoInstanceShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl2_normalMatrix_noInstance_vertex
                }
            },
            "send": {}
        },
        "NormalCommonShaderLib": {
            "send": {
                "attribute": [
                    {
                        "name": "a_normal",
                        "buffer": "normal",
                        "type": "vec3",
                        "location": 1
                    }
                ]
            }
        },
        "GBufferCommonShaderLib": {
            "glsl": {
                "vs": {
                    "source": gbuffer_common_vertex
                },
                "fs": {
                    "source": gbuffer_common_fragment
                }
            }
        },
        "GBufferSetWorldPositionShaderLib": {
            "glsl": {
                "vs": {
                    "source": gbuffer_setWorldPosition_vertex
                }
            }
        },
        "CommonLightMapShaderLib": {
            "send": {
                "attribute": [
                    {
                        "name": "a_texCoord",
                        "buffer": "texCoord",
                        "type": "vec2",
                        "location": 2
                    }
                ]
            }
        },
        "DiffuseMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl2_diffuseMap_vertex
                },
                "fs": {
                    "source": webgl2_diffuseMap_fragment
                }
            },
            "send": {
                "uniformDefine": [
                    {
                        "name": "u_diffuseMapSampler",
                        "type": "sampler2D"
                    }
                ]
            }
        },
        "NoDiffuseMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_noDiffuseMap_fragment
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_diffuse",
                        "from": "lightMaterial",
                        "field": "color",
                        "type": "float3"
                    }
                ]
            }
        },
        "SpecularMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl2_specularMap_vertex
                },
                "fs": {
                    "source": webgl2_specularMap_fragment
                }
            },
            "send": {
                "uniformDefine": [
                    {
                        "name": "u_specularMapSampler",
                        "type": "sampler2D"
                    }
                ]
            }
        },
        "NoSpecularMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_noSpecularMap_fragment
                }
            }
        },
        "GBufferNoNormalMapShaderLib": {
            "glsl": {
                "vs": {
                    "source": webgl2_gbuffer_noNormalMap_vertex
                },
                "fs": {
                    "source": webgl2_gbuffer_noNormalMap_fragment
                }
            }
        },
        "GBufferShaderLib": {
            "glsl": {
                "vs": {
                    "source": gbuffer_vertex
                },
                "fs": {
                    "source": gbuffer_fragment
                }
            },
            "send": {
                "uniform": [
                    {
                        "name": "u_shininess",
                        "from": "lightMaterial",
                        "field": "shininess",
                        "type": "float"
                    }
                ]
            }
        },
        "GBufferEndShaderLib": {
            "glsl": {
                "fs": {
                    "source": gbuffer_end_fragment
                },
            }
        },
        "DeferLightPassCommonShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_common
                }
            }
        },
        "NoLightMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_noLightMap_fragment
                }
            }
        },
        "NoEmissionMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_noEmissionMap_fragment
                }
            }
        },
        "NoShadowMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_noShadowMap_fragment
                }
            }
        },
        "DeferLightPassNoNormalMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_deferLightPass_noNormalMap_fragment
                }
            }
        },
        "DeferLightPassShaderLib": {
            "glsl": {
                "vs": {
                    "source": deferLightPass_vertex
                }
            },
            "send": {
                "attribute": [
                    {
                        "name": "a_position",
                        "buffer": "vertex",
                        "type": "vec3",
                        "location": 0
                    },
                    {
                        "name": "a_texCoord",
                        "buffer": "texCoord",
                        "type": "vec2",
                        "location": 1
                    }
                ],
                "uniformDefine": [
                    {
                        "name": "u_positionBuffer",
                        "type": "sampler2D"
                    },
                    {
                        "name": "u_normalBuffer",
                        "type": "sampler2D"
                    },
                    {
                        "name": "u_colorBuffer",
                        "type": "sampler2D"
                    }
                ]
            }
        },
        "DeferLightPassEndShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_end_fragment
                },
            }
        },
        "DeferAmbientLightPassShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_ambientLight_fragment
                }
            },
            "send": {}
        },
        "DeferDirectionLightPointLightPassCommonShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_directionLight_pointLight_common
                }
            }
        },
        "DeferDirectionLightPassCommonShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_directionLight_common
                }
            }
        },
        "DeferDirectionLightPassNoNormalMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_deferLightPass_directionLight_noNormalMap_fragment
                }
            }
        },
        "DeferDirectionLightPassShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_directionLight_fragment
                }
            },
            "send": {}
        },
        "DeferPointLightPassCommonShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_pointLight_common
                }
            }
        },
        "DeferPointLightPassNoNormalMapShaderLib": {
            "glsl": {
                "fs": {
                    "source": webgl2_deferLightPass_pointLight_noNormalMap_fragment
                }
            }
        },
        "DeferPointLightPassShaderLib": {
            "glsl": {
                "fs": {
                    "source": deferLightPass_pointLight_fragment
                }
            },
            "send": {}
        },
        "EndShaderLib": {}
    }
};

var webgl1_material_config = {
    "shaders": {
        "materialShaders": {
            "BasicRender": [
                { "type": "group", "value": "engineMaterialTop" },
                "BasicMaterialColorShaderLib",
                "BasicShaderLib",
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var getMapCount = _a.getMapCount;
                        var MapManagerDataFromSystem = _b.MapManagerDataFromSystem;
                        if (getMapCount(materialIndex, MapManagerDataFromSystem) === 1) {
                            return "BasicMapShaderLib";
                        }
                    }
                },
                "BasicEndShaderLib",
                { "type": "group", "value": "engineMaterialEnd" }
            ],
            "FrontRenderLight": [
                { "type": "group", "value": "engineMaterialTop" },
                "NormalMatrixNoInstanceShaderLib",
                "NormalCommonShaderLib",
                "LightCommonShaderLib",
                "LightSetWorldPositionShaderLib",
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasDiffuseMap = _a.hasDiffuseMap, hasSpecularMap = _a.hasSpecularMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasDiffuseMap(materialIndex, LightMaterialDataFromSystem)
                            || hasSpecularMap(materialIndex, LightMaterialDataFromSystem)) {
                            return "CommonLightMapShaderLib";
                        }
                    }
                },
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasDiffuseMap = _a.hasDiffuseMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasDiffuseMap(materialIndex, LightMaterialDataFromSystem)) {
                            return "DiffuseMapShaderLib";
                        }
                        return "NoDiffuseMapShaderLib";
                    }
                },
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasSpecularMap = _a.hasSpecularMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasSpecularMap(materialIndex, LightMaterialDataFromSystem)) {
                            return "SpecularMapShaderLib";
                        }
                        return "NoSpecularMapShaderLib";
                    }
                },
                "NoLightMapShaderLib",
                "NoEmissionMapShaderLib",
                "NoNormalMapShaderLib",
                "NoShadowMapShaderLib",
                "LightShaderLib",
                "AmbientLightShaderLib",
                "PointLightShaderLib",
                "DirectionLightShaderLib",
                "LightEndShaderLib",
                { "type": "group", "value": "engineMaterialEnd" }
            ]
        },
        "noMaterialShaders": {}
    },
    "shaderLibGroups": {
        "engineMaterialTop": [
            "CommonShaderLib",
            "ModelMatrixNoInstanceShaderLib",
            "VerticeCommonShaderLib"
        ],
        "engineMaterialEnd": [
            "EndShaderLib"
        ]
    }
};

var webgl2_material_config = {
    "shaders": {
        "materialShaders": {
            "BasicRender": [
                { "type": "group", "value": "engineMaterialTop" },
                "BasicMaterialColorShaderLib",
                "BasicShaderLib",
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var getMapCount = _a.getMapCount;
                        var MapManagerDataFromSystem = _b.MapManagerDataFromSystem;
                        if (getMapCount(materialIndex, MapManagerDataFromSystem) === 1) {
                            return "BasicMapShaderLib";
                        }
                    }
                },
                "BasicEndShaderLib",
                { "type": "group", "value": "engineMaterialEnd" }
            ],
            "FrontRenderLight": [
                { "type": "group", "value": "engineMaterialTop" },
                "NormalMatrixNoInstanceShaderLib",
                "NormalCommonShaderLib",
                "LightCommonShaderLib",
                "LightSetWorldPositionShaderLib",
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasDiffuseMap = _a.hasDiffuseMap, hasSpecularMap = _a.hasSpecularMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasDiffuseMap(LightMaterialDataFromSystem)
                            || hasSpecularMap(LightMaterialDataFromSystem)) {
                            return "CommonLightMapShaderLib";
                        }
                    }
                },
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasDiffuseMap = _a.hasDiffuseMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasDiffuseMap(LightMaterialDataFromSystem)) {
                            return "DiffuseMapShaderLib";
                        }
                        return "NoDiffuseMapShaderLib";
                    }
                },
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasSpecularMap = _a.hasSpecularMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasSpecularMap(LightMaterialDataFromSystem)) {
                            return "SpecularMapShaderLib";
                        }
                        return "NoSpecularMapShaderLib";
                    }
                },
                "NoLightMapShaderLib",
                "NoEmissionMapShaderLib",
                "NoNormalMapShaderLib",
                "NoShadowMapShaderLib",
                "LightShaderLib",
                "PointLightShaderLib",
                "LightEndShaderLib",
                { "type": "group", "value": "engineMaterialEnd" }
            ],
            "GBuffer": [
                { "type": "group", "value": "engineMaterialTop" },
                "NormalMatrixNoInstanceShaderLib",
                "NormalCommonShaderLib",
                "GBufferCommonShaderLib",
                "GBufferSetWorldPositionShaderLib",
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasDiffuseMap = _a.hasDiffuseMap, hasSpecularMap = _a.hasSpecularMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasDiffuseMap(materialIndex, LightMaterialDataFromSystem)
                            || hasSpecularMap(materialIndex, LightMaterialDataFromSystem)) {
                            return "CommonLightMapShaderLib";
                        }
                    }
                },
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasDiffuseMap = _a.hasDiffuseMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasDiffuseMap(materialIndex, LightMaterialDataFromSystem)) {
                            return "DiffuseMapShaderLib";
                        }
                        return "NoDiffuseMapShaderLib";
                    }
                },
                {
                    "type": "branch",
                    "branch": function (materialIndex, _a, _b) {
                        var hasSpecularMap = _a.hasSpecularMap;
                        var LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
                        if (hasSpecularMap(materialIndex, LightMaterialDataFromSystem)) {
                            return "SpecularMapShaderLib";
                        }
                        return "NoSpecularMapShaderLib";
                    }
                },
                "GBufferNoNormalMapShaderLib",
                "GBufferShaderLib",
                "GBufferEndShaderLib",
                { "type": "group", "value": "engineMaterialEnd" }
            ]
        },
        "noMaterialShaders": {
            "DeferAmbientLightPass": [
                { "type": "group", "value": "deferLightPassIndexZeroUbo" },
                "AmbientLightUboShaderLib",
                "DeferLightPassCommonShaderLib",
                "NoLightMapShaderLib",
                "DeferLightPassShaderLib",
                "DeferAmbientLightPassShaderLib",
                "DeferLightPassEndShaderLib"
            ],
            "DeferDirectionLightPass": [
                { "type": "group", "value": "deferLightPassIndexZeroUbo" },
                { "type": "group", "value": "deferLightPassUbo" },
                "DirectionLightUboShaderLib",
                "DeferLightPassCommonShaderLib",
                "DeferDirectionLightPointLightPassCommonShaderLib",
                "DeferDirectionLightPassCommonShaderLib",
                { "type": "group", "value": "deferLightPassLightMap" },
                "DeferDirectionLightPassNoNormalMapShaderLib",
                "DeferLightPassShaderLib",
                "DeferDirectionLightPassShaderLib",
                "DeferLightPassEndShaderLib"
            ],
            "DeferPointLightPass": [
                { "type": "group", "value": "deferLightPassIndexZeroUbo" },
                { "type": "group", "value": "deferLightPassUbo" },
                "PointLightUboShaderLib",
                "DeferLightPassCommonShaderLib",
                "DeferDirectionLightPointLightPassCommonShaderLib",
                "DeferPointLightPassCommonShaderLib",
                { "type": "group", "value": "deferLightPassLightMap" },
                "DeferPointLightPassNoNormalMapShaderLib",
                "DeferLightPassShaderLib",
                "DeferPointLightPassShaderLib",
                "DeferLightPassEndShaderLib"
            ]
        }
    },
    "shaderLibGroups": {
        "engineMaterialTop": [
            "CommonShaderLib",
            "ModelMatrixNoInstanceShaderLib",
            "VerticeCommonShaderLib",
            "CameraUboShaderLib"
        ],
        "deferLightPassIndexZeroUbo": [
            "CameraUboShaderLib"
        ],
        "deferLightPassUbo": [
            "LightUboShaderLib"
        ],
        "deferLightPassLightMap": [
            "DeferLightPassNoNormalMapShaderLib",
            "NoLightMapShaderLib",
            "NoEmissionMapShaderLib",
            "NoShadowMapShaderLib"
        ],
        "engineMaterialEnd": [
            "EndShaderLib"
        ]
    }
};

var getAttribLocation = ensureFunc$$1(function (pos, gl, program, name, attributeLocationMap) {
}, function (gl, program, name, attributeLocationMap) {
    var pos = null;
    pos = attributeLocationMap[name];
    if (isValidMapValue(pos)) {
        return pos;
    }
    pos = gl.getAttribLocation(program, name);
    attributeLocationMap[name] = pos;
    return pos;
});
var isAttributeLocationNotExist = function (pos) {
    return pos === -1;
};
var setEmptyLocationMap$1 = function (shaderIndex, LocationDataFromSystem) {
    LocationDataFromSystem.attributeLocationMap[shaderIndex] = createMap();
    LocationDataFromSystem.uniformLocationMap[shaderIndex] = createMap();
};
var initData$38 = function (LocationDataFromSystem) {
    LocationDataFromSystem.attributeLocationMap = createMap();
    LocationDataFromSystem.uniformLocationMap = createMap();
};

var addSendAttributeConfig = ensureFunc$$1(function (returnVal, shaderIndex, materialShaderLibNameArr, shaderLibData, sendAttributeConfigMap) {
    it$$1("sendAttributeConfigMap should not has duplicate attribute name", function () {
        wdet_1(hasDuplicateItems(sendAttributeConfigMap[shaderIndex])).false;
    });
}, requireCheckFunc(function (shaderIndex, materialShaderLibNameArr, shaderLibData, sendAttributeConfigMap) {
    it$$1("sendAttributeConfigMap[shaderIndex] should not be defined", function () {
        wdet_1(sendAttributeConfigMap[shaderIndex]).not.exist;
    });
}, function (shaderIndex, materialShaderLibNameArr, shaderLibData, sendAttributeConfigMap) {
    var sendDataArr = [];
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send;
        if (isConfigDataExist(sendData) && isConfigDataExist(sendData.attribute)) {
            sendDataArr = sendDataArr.concat(sendData.attribute);
        }
    });
    sendAttributeConfigMap[shaderIndex] = sendDataArr;
}));
var addSendUniformConfig$1 = ensureFunc$$1(function (returnVal, shaderIndex, materialShaderLibNameArr, shaderLibData, GLSLSenderDataFromSystem) {
    it$$1("sendUniformConfigMap should not has duplicate attribute name", function () {
        wdet_1(hasDuplicateItems(GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex])).false;
    });
}, requireCheckFunc(function (shaderIndex, materialShaderLibNameArr, shaderLibData, GLSLSenderDataFromSystem) {
    it$$1("sendUniformConfigMap[shaderIndex] should not be defined", function () {
        wdet_1(GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex]).not.exist;
    });
}, function (shaderIndex, materialShaderLibNameArr, shaderLibData, GLSLSenderDataFromSystem) {
    var sendUniformDataArr = [], sendUniformFuncDataArr = [];
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send;
        if (isConfigDataExist(sendData)) {
            if (isConfigDataExist(sendData.uniform)) {
                sendUniformDataArr = sendUniformDataArr.concat(sendData.uniform);
            }
            if (isConfigDataExist(sendData.uniformFunc)) {
                sendUniformFuncDataArr = sendUniformFuncDataArr.concat(sendData.uniformFunc);
            }
        }
    });
    GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex] = sendUniformDataArr;
    GLSLSenderDataFromSystem.sendUniformFuncConfigMap[shaderIndex] = sendUniformFuncDataArr;
}));
var addVaoConfig$1 = requireCheckFunc(function (gl, shaderIndex, program, materialShaderLibNameArr, shaderLibData, attributeLocationMap, vaoConfigMap) {
    it$$1("vaoConfigMap[shaderIndex] should not be defined", function () {
        wdet_1(vaoConfigMap[shaderIndex]).not.exist;
    });
}, function (gl, shaderIndex, program, materialShaderLibNameArr, shaderLibData, attributeLocationMap, vaoConfigMap, _a) {
    var getVertices = _a.getVertices, getNormals = _a.getNormals, getTexCoords = _a.getTexCoords, getIndices = _a.getIndices;
    var vaoConfigData = {};
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send;
        if (isConfigDataExist(sendData) && isConfigDataExist(sendData.attribute)) {
            forEach(sendData.attribute, function (_a) {
                var name = _a.name, buffer = _a.buffer;
                var location = getAttribLocation(gl, program, name, attributeLocationMap);
                switch (buffer) {
                    case "vertex":
                        setVaoConfigData(vaoConfigData, "positionLocation", location);
                        setVaoConfigData(vaoConfigData, "getVertices", getVertices);
                        break;
                    case "normal":
                        setVaoConfigData(vaoConfigData, "normalLocation", location);
                        setVaoConfigData(vaoConfigData, "getNormals", getNormals);
                        break;
                    case "texCoord":
                        setVaoConfigData(vaoConfigData, "texCoordLocation", location);
                        setVaoConfigData(vaoConfigData, "getTexCoords", getTexCoords);
                        break;
                    default:
                        Log$$1.error(true, Log$$1.info.FUNC_INVALID("bufferName:" + buffer));
                        break;
                }
            });
        }
    });
    setVaoConfigData(vaoConfigData, "getIndices", getIndices);
    vaoConfigMap[shaderIndex] = vaoConfigData;
});
var initData$37 = function (GLSLSenderDataFromSystem) {
    initData$29(GLSLSenderDataFromSystem);
    GLSLSenderDataFromSystem.sendAttributeConfigMap = createMap();
    GLSLSenderDataFromSystem.attributeLocationMap = createMap();
};

var isBufferExist = function (buffer) { return isValidVal(buffer); };
var disposeGeometryWorkerBuffers = requireCheckFunc(function (disposedIndexArray, GeometryDataFromSystem) {
    it$$1("should not add data twice in one frame", function () {
        wdet_1(GeometryDataFromSystem.disposedGeometryIndexArray.length).equal(0);
    });
}, function (disposedIndexArray, GeometryDataFromSystem) {
    GeometryDataFromSystem.disposedGeometryIndexArray = disposedIndexArray;
});

var getOrCreateBuffer = function (gl, geometryIndex, getIndices, GeometryWorkerData, IndexBufferDataFromSystem) {
    var buffers = IndexBufferDataFromSystem.buffers, buffer = buffers[geometryIndex];
    if (isBufferExist(buffer)) {
        return buffer;
    }
    buffer = gl.createBuffer();
    buffers[geometryIndex] = buffer;
    _initBuffer(gl, getIndices(geometryIndex, GeometryWorkerData), buffer, IndexBufferDataFromSystem);
    return buffer;
};
var _initBuffer = function (gl, data, buffer, IndexBufferDataFromSystem) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
    _resetBindedBuffer(gl, IndexBufferDataFromSystem);
};
var _resetBindedBuffer = function (gl, IndexBufferDataFromSystem) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};
var initData$39 = function (IndexBufferDataFromSystem) {
    IndexBufferDataFromSystem.buffers = [];
};

var createVao$1 = function (extension) {
    return extension.createVertexArrayOES();
};
var bindVao$3 = function (extension, vao) {
    extension.bindVertexArrayOES(vao);
};
var unbindVao$1 = function (extension) {
    extension.bindVertexArrayOES(null);
};
var disposeVao$1 = function (gl, extension, geometryIndex, vaoMap, vboArrayMap) {
    extension.deleteVertexArrayOES(vaoMap[geometryIndex]);
    removeVao(gl, geometryIndex, vaoMap, vboArrayMap);
};

var detect$3 = function (getGL, DeviceManagerDataFromSystem, GPUDetectDataFromSystem, state) {
    var gl = getGL(DeviceManagerDataFromSystem, state);
    _detectExtension$1(state, gl, GPUDetectDataFromSystem);
    detectCapabilty(state, gl, GPUDetectDataFromSystem);
    return state;
};
var _detectExtension$1 = function (state, gl, GPUDetectDataFromSystem) {
    detectExtension(state, gl, GPUDetectDataFromSystem);
};
var getExtensionVao = function (GPUDetectDataFromSystem) { return GPUDetectDataFromSystem.extensionVao; };
var initData$40 = function (GPUDetectDataFromSystem) {
    GPUDetectDataFromSystem.maxTextureUnit = null;
    GPUDetectDataFromSystem.maxTextureSize = null;
    GPUDetectDataFromSystem.maxCubemapTextureSize = null;
    GPUDetectDataFromSystem.maxAnisotropy = null;
    GPUDetectDataFromSystem.maxBoneCount = null;
    GPUDetectDataFromSystem.maxUniformBufferBindings = null;
    GPUDetectDataFromSystem.extensionCompressedTextureS3TC = null;
    GPUDetectDataFromSystem.extensionTextureFilterAnisotropic = null;
    GPUDetectDataFromSystem.extensionInstancedArrays = null;
    GPUDetectDataFromSystem.extensionUintIndices = null;
    GPUDetectDataFromSystem.extensionDepthTexture = null;
    GPUDetectDataFromSystem.extensionVao = null;
    GPUDetectDataFromSystem.extensionStandardDerivatives = null;
    GPUDetectDataFromSystem.extensionColorBufferFloat = null;
    GPUDetectDataFromSystem.precision = null;
};

var initNoMaterialShader$4 = function (state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap) {
    initNoMaterialShader$2(state, null, materialShaderLibConfig, material_config, shaderLib_generator, _init$1, initShaderFuncDataMap, initShaderDataMap);
};
var initMaterialShader$4 = function (state, materialIndex, shaderName, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap) {
    return initMaterialShader$2(state, materialIndex, shaderName, material_config, shaderLib_generator, _init$1, initShaderFuncDataMap, initShaderDataMap);
};
var _init$1 = function (state, materialIndex, materialShaderLibNameArr, material_config, shaderLib_generator, initShaderFuncDataMap, initShaderDataMap) {
    var ShaderDataFromSystem = initShaderDataMap.ShaderDataFromSystem, DeviceManagerDataFromSystem = initShaderDataMap.DeviceManagerDataFromSystem, ProgramDataFromSystem = initShaderDataMap.ProgramDataFromSystem, LocationDataFromSystem = initShaderDataMap.LocationDataFromSystem, GLSLSenderDataFromSystem = initShaderDataMap.GLSLSenderDataFromSystem, GPUDetectDataFromSystem = initShaderDataMap.GPUDetectDataFromSystem, shaderIndex = genereateShaderIndex(ShaderDataFromSystem), program = getProgram(shaderIndex, ProgramDataFromSystem), shaderLibDataFromSystem = null, gl = null;
    shaderLibDataFromSystem = shaderLib_generator.shaderLibs;
    var _a = initShaderFuncDataMap.buildGLSLSource(materialIndex, materialShaderLibNameArr, shaderLibDataFromSystem, initShaderDataMap), vsSource = _a.vsSource, fsSource = _a.fsSource;
    gl = initShaderFuncDataMap.getGL(DeviceManagerDataFromSystem, state);
    program = gl.createProgram();
    registerProgram(shaderIndex, ProgramDataFromSystem, program);
    initShader(program, vsSource, fsSource, gl);
    setEmptyLocationMap$1(shaderIndex, LocationDataFromSystem);
    if (hasExtension(getExtensionVao(GPUDetectDataFromSystem))) {
        addVaoConfig$1(gl, shaderIndex, program, materialShaderLibNameArr, shaderLibDataFromSystem, GLSLSenderDataFromSystem.attributeLocationMap, GLSLSenderDataFromSystem.vaoConfigMap, initShaderFuncDataMap);
    }
    else {
        addSendAttributeConfig(shaderIndex, materialShaderLibNameArr, shaderLibDataFromSystem, GLSLSenderDataFromSystem.sendAttributeConfigMap);
    }
    addSendUniformConfig$1(shaderIndex, materialShaderLibNameArr, shaderLibDataFromSystem, GLSLSenderDataFromSystem);
    return shaderIndex;
};
var bindIndexBuffer$1 = function (gl, geometryIndex, getIndicesFunc, ProgramDataFromSystem, GeometryDataFromSystem, IndexBufferDataFromSystem) {
    var buffer = getOrCreateBuffer(gl, geometryIndex, getIndicesFunc, GeometryDataFromSystem, IndexBufferDataFromSystem);
    if (ProgramDataFromSystem.lastBindedIndexBuffer === buffer) {
        return;
    }
    ProgramDataFromSystem.lastBindedIndexBuffer = buffer;
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
};
var bindVao$2 = function (extension, vao, ProgramDataFromSystem) {
    if (ProgramDataFromSystem.lastBindedVao === vao) {
        return;
    }
    ProgramDataFromSystem.lastBindedVao = vao;
    bindVao$3(extension, vao);
};
var createAndInitVao$1 = function (gl, extension, geometryIndex, vaoMap, vboArrayMap, _a, GeometryDataFromSystem) {
    var positionLocation = _a.positionLocation, normalLocation = _a.normalLocation, texCoordLocation = _a.texCoordLocation, getVertices = _a.getVertices, getNormals = _a.getNormals, getTexCoords = _a.getTexCoords, getIndices = _a.getIndices;
    var vao = createVao$1(extension), buffers = [];
    vaoMap[geometryIndex] = vao;
    bindVao$3(extension, vao);
    if (!!getVertices) {
        buffers.push(createAndInitArrayBuffer(gl, getVertices(geometryIndex, GeometryDataFromSystem), positionLocation, 3));
    }
    if (!!getNormals) {
        buffers.push(createAndInitArrayBuffer(gl, getNormals(geometryIndex, GeometryDataFromSystem), normalLocation, 3));
    }
    if (!!getTexCoords) {
        buffers.push(createAndInitArrayBuffer(gl, getTexCoords(geometryIndex, GeometryDataFromSystem), texCoordLocation, 2));
    }
    buffers.push(createAndInitIndexBuffer(gl, getIndices(geometryIndex, GeometryDataFromSystem)));
    unbindVao$1(extension);
    vboArrayMap[geometryIndex] = buffers;
    return vao;
};
var initData$36 = function (ShaderDataFromSystem) {
    ShaderDataFromSystem.index = 0;
    ShaderDataFromSystem.count = 0;
    ShaderDataFromSystem.shaderIndexMap = createMap();
    ShaderDataFromSystem.shaderLibNameMap = createMap();
};

var buildGLSLSource$3 = requireCheckFunc(function (materialIndex, materialShaderLibNameArr, shaderLibData, funcDataMap, initShaderDataMap) {
    it$$1("shaderLib should be defined", function () {
        forEach(materialShaderLibNameArr, function (shaderLibName) {
            wdet_1(shaderLibData[shaderLibName]).exist;
        });
    });
}, function (materialIndex, materialShaderLibNameArr, shaderLibData, funcDataMap, initShaderDataMap) {
    var vsTop = "", vsDefine = "", vsVarDeclare = "", vsFuncDeclare = "", vsFuncDefine = "", vsBody = "", fsTop = "", fsDefine = "", fsVarDeclare = "", fsFuncDeclare = "", fsFuncDefine = "", fsBody = "";
    var _setVs = function (getGLSLPartData$$1, getGLSLDefineListData$$1, vs) {
        vsTop += getGLSLPartData$$1(vs, "top");
        vsDefine += buildSourceDefine(getGLSLDefineListData$$1(vs), initShaderDataMap) + getGLSLPartData$$1(vs, "define");
        vsVarDeclare += getGLSLPartData$$1(vs, "varDeclare");
        vsFuncDeclare += getGLSLPartData$$1(vs, "funcDeclare");
        vsFuncDefine += getGLSLPartData$$1(vs, "funcDefine");
        vsBody += getGLSLPartData$$1(vs, "body");
    }, _setFs = function (getGLSLPartData$$1, getGLSLDefineListData$$1, fs) {
        fsTop += getGLSLPartData$$1(fs, "top");
        fsDefine += buildSourceDefine(getGLSLDefineListData$$1(fs), initShaderDataMap) + getGLSLPartData$$1(fs, "define");
        fsVarDeclare += getGLSLPartData$$1(fs, "varDeclare");
        fsFuncDeclare += getGLSLPartData$$1(fs, "funcDeclare");
        fsFuncDefine += getGLSLPartData$$1(fs, "funcDefine");
        fsBody += getGLSLPartData$$1(fs, "body");
    };
    vsBody += webgl1_main_begin;
    fsBody += webgl1_main_begin;
    fsTop += getPrecisionSource(lowp_fragment, mediump_fragment, highp_fragment, initShaderDataMap.GPUDetectDataFromSystem);
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var glslData = shaderLibData[shaderLibName].glsl, vs = null, fs = null, func = null;
        if (!isConfigDataExist(glslData)) {
            return;
        }
        vs = glslData.vs;
        fs = glslData.fs;
        func = glslData.func;
        if (isConfigDataExist(vs)) {
            _setVs(getGLSLPartData, getGLSLDefineListData, vs);
        }
        if (isConfigDataExist(fs)) {
            _setFs(getGLSLPartData, getGLSLDefineListData, fs);
        }
        if (isConfigDataExist(func)) {
            var funcConfig = func(materialIndex, funcDataMap, initShaderDataMap);
            if (isConfigDataExist(funcConfig)) {
                var vs_1 = funcConfig.vs, fs_1 = funcConfig.fs;
                if (isConfigDataExist(vs_1)) {
                    vs_1 = ExtendUtils.extend(getEmptyFuncGLSLConfig(), vs_1);
                    _setVs(getFuncGLSLPartData, getFuncGLSLDefineListData, vs_1);
                }
                if (isConfigDataExist(fs_1)) {
                    fs_1 = ExtendUtils.extend(getEmptyFuncGLSLConfig(), fs_1);
                    _setFs(getFuncGLSLPartData, getFuncGLSLDefineListData, fs_1);
                }
            }
        }
    });
    vsBody += webgl1_main_end;
    fsBody += webgl1_main_end;
    vsTop += _generateAttributeSource$1(materialShaderLibNameArr, shaderLibData);
    vsTop += generateUniformSource(materialShaderLibNameArr, shaderLibData, vsVarDeclare, vsFuncDefine, vsBody);
    fsTop += generateUniformSource(materialShaderLibNameArr, shaderLibData, fsVarDeclare, fsFuncDefine, fsBody);
    return {
        vsSource: vsTop + vsDefine + vsVarDeclare + vsFuncDeclare + vsFuncDefine + vsBody,
        fsSource: fsTop + fsDefine + fsVarDeclare + fsFuncDeclare + fsFuncDefine + fsBody
    };
});
var _generateAttributeSource$1 = function (materialShaderLibNameArr, shaderLibData) {
    var result = "";
    forEach(materialShaderLibNameArr, function (shaderLibName) {
        var sendData = shaderLibData[shaderLibName].send, attributeData = null;
        if (!isConfigDataExist(sendData) || !isConfigDataExist(sendData.attribute)) {
            return;
        }
        attributeData = sendData.attribute;
        forEach(attributeData, function (data) {
            result += "attribute " + data.type + " " + data.name + ";\n";
        });
    });
    return result;
};

var buildGLSLSource$2 = function (materialIndex, materialShaderLibNameArr, shaderLibData, MaterialDataMap) {
    return buildGLSLSource$3(materialIndex, materialShaderLibNameArr, shaderLibData, {
        getAlphaTest: getAlphaTest$$1,
        isTestAlpha: isTestAlpha$$1
    }, MaterialDataMap);
};

var initNoMaterialShader$3 = null;
var initMaterialShader$3 = null;
var bindIndexBuffer$$1 = null;
if (!isSupportRenderWorkerAndSharedArrayBuffer()) {
    initNoMaterialShader$3 = function (state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, initShaderDataMap) {
        initNoMaterialShader$4(state, shaderName, materialShaderLibConfig, material_config, shaderLib_generator, _buildInitShaderFuncDataMap_1$1(), initShaderDataMap);
    };
    initMaterialShader$3 = function (state, materialIndex, shaderName, material_config, shaderLib_generator, initShaderDataMap) {
        return initMaterialShader$4(state, materialIndex, shaderName, material_config, shaderLib_generator, _buildInitShaderFuncDataMap_1$1(), initShaderDataMap);
    };
    bindIndexBuffer$$1 = function (gl, geometryIndex, ProgramData, GeometryData, IndexBufferData) {
        bindIndexBuffer$1(gl, geometryIndex, getIndices$1, ProgramData, GeometryData, IndexBufferData);
    };
    var _buildInitShaderFuncDataMap_1$1 = function () {
        return {
            buildGLSLSource: buildGLSLSource$2,
            getGL: getGL$$1,
            getMapCount: getMapCount$$1,
            hasSpecularMap: hasSpecularMap$1,
            hasDiffuseMap: hasDiffuseMap$1,
            getVertices: getVertices$1,
            getNormals: getNormals$1,
            getTexCoords: getTexCoords$1,
            getIndices: getIndices$1
        };
    };
}
var initData$35 = initData$36;

var buildDrawDataMap = function (GBufferDataFromSystem, DeferAmbientLightPassDataFromSystem, DeferDirectionLightPassDataFromSystem, DeferPointLightPassDataFromSystem) {
    return {
        GBufferDataFromSystem: GBufferDataFromSystem,
        DeferAmbientLightPassDataFromSystem: DeferAmbientLightPassDataFromSystem,
        DeferDirectionLightPassDataFromSystem: DeferDirectionLightPassDataFromSystem,
        DeferPointLightPassDataFromSystem: DeferPointLightPassDataFromSystem,
    };
};
var buildDrawFuncDataMap = function (sendAttributeData, sendUniformData, directlySendUniformData, use, hasIndices, getIndicesCount, getIndexType, getIndexTypeSize, getVerticesCount, bindAndUpdate, getMapCount, getStartTextureIndex, useShader, bindGBuffer, unbindGBuffer, getNewTextureUnitIndex) {
    return {
        sendAttributeData: sendAttributeData,
        sendUniformData: sendUniformData,
        directlySendUniformData: directlySendUniformData,
        use: use,
        hasIndices: hasIndices,
        getIndicesCount: getIndicesCount,
        getIndexType: getIndexType,
        getIndexTypeSize: getIndexTypeSize,
        getVerticesCount: getVerticesCount,
        bindAndUpdate: bindAndUpdate,
        getMapCount: getMapCount,
        getStartTextureIndex: getStartTextureIndex,
        useShader: useShader,
        bindGBuffer: bindGBuffer,
        unbindGBuffer: unbindGBuffer,
        getNewTextureUnitIndex: getNewTextureUnitIndex
    };
};

var BasicMaterial = (function (_super) {
    __extends(BasicMaterial, _super);
    function BasicMaterial() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BasicMaterial = __decorate([
        registerClass$1("BasicMaterial")
    ], BasicMaterial);
    return BasicMaterial;
}(Material));
var createBasicMaterial = null;
if (isWebgl1$1()) {
    createBasicMaterial = function () {
        return create$14(WebGL1ShaderData, MaterialData, BasicMaterialData);
    };
}
else {
    createBasicMaterial = function () {
        return create$14(WebGL2ShaderData, MaterialData, BasicMaterialData);
    };
}
var initBasicMaterial = function (material) {
    initMaterial$3(material.index, getState(DirectorData));
};
var getBasicMaterialColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getColor(material.index, MaterialData);
});
var setBasicMaterialColor = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, color) {
    setColor(material.index, color, MaterialData);
});
var getBasicMaterialOpacity = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getOpacity$$1(material.index, MaterialData);
});
var setBasicMaterialOpacity = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, opacity) {
    setOpacity(material.index, opacity, MaterialData);
});
var getBasicMaterialAlphaTest = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material) {
    return getAlphaTest$$1(material.index, MaterialData);
});
var setBasicMaterialAlphaTest = requireCheckFunc(function (material) {
    checkShouldAlive$1(material);
}, function (material, alphaTest) {
    setAlphaTest(material.index, alphaTest, MaterialData);
});
var setBasicMaterialMap = requireCheckFunc(function (material, map) {
    checkShouldAlive$1(material);
}, function (material, map) {
    setMap$1(material.index, map, MapManagerData, TextureData);
});

var createTypeArrays$10 = function (buffer, offset, count, BasicMaterialDataFromSystem) {
    return offset;
};
var getClassName$1 = function () { return "BasicMaterial"; };

var create$14 = ensureFunc$$1(function (component) {
    it$$1("index should <= max count", function () {
        wdet_1(component.index).lte(getBasicMaterialBufferStartIndex() + getBasicMaterialBufferCount());
    });
}, function (ShaderData, MaterialData$$1, BasicMaterialData$$1) {
    var material = new BasicMaterial(), index = generateComponentIndex(BasicMaterialData$$1);
    material.index = index;
    material = create$6(index, material, ShaderData, MaterialData$$1);
    return material;
});
var initMaterialWithoutInitMap$1 = function (index, state) {
    initMaterial(index, state, getClassName$1(), MaterialData);
};
var initMaterial$3 = function (index, state) {
    initMaterial(index, state, getClassName$1(), MaterialData);
    initMapManager(getGL$$1(DeviceManagerData, state), index, MapManagerData, TextureData);
};
var setMap$1 = function (materialIndex, map, MapManagerData$$1, TextureData$$1) {
    setMap(materialIndex, map, _buildMapUniformSamplerName(), MapManagerData$$1, TextureData$$1);
};
var _buildMapUniformSamplerName = function () { return "u_sampler2D"; };
var addComponent$9 = function (component, gameObject) {
    addComponent$5(component, gameObject, MaterialData);
};
var disposeComponent$11 = function (component) {
    var sourceIndex = component.index, lastComponentIndex = null;
    BasicMaterialData.index -= 1;
    lastComponentIndex = BasicMaterialData.index;
    disposeComponent$5(sourceIndex, lastComponentIndex, MapManagerData, MaterialData);
};
var createTypeArrays$9 = function (buffer, offset, count, BasicMaterialData$$1) {
    return createTypeArrays$10(buffer, offset, count, BasicMaterialData$$1);
};
var initData$42 = function (BasicMaterialData$$1) {
    initData$34(getBasicMaterialBufferStartIndex(), BasicMaterialData$$1);
};

var init$9 = function (state, gl, material_config, shaderLib_generator, initNoMaterialShader, TextureData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, DirectionLightData, PointLightData, GPUDetectData, GLSLSenderData, ProgramData, VaoData, LocationData, ShaderData) {
    initNoMaterialShaders(state, material_config, shaderLib_generator, initNoMaterialShader, buildInitShaderDataMap(DeviceManagerData, ProgramData, LocationData, GLSLSenderData, ShaderData, MapManagerData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, DirectionLightData, PointLightData, GPUDetectData, VaoData));
    _initMaterials(state, getBasicMaterialBufferStartIndex(), initMaterialWithoutInitMap$1, BasicMaterialData);
    _initMaterials(state, getLightMaterialBufferStartIndex(), initMaterialWithoutInitMap, LightMaterialData);
    initMapManagers(gl, TextureData);
};
var _initMaterials = function (state, startIndex, initSpecifyMaterialWithoutInitMap, SpecifyMaterialData) {
    for (var i = startIndex; i < SpecifyMaterialData.index; i++) {
        initSpecifyMaterialWithoutInitMap(i, state);
    }
};
var initData$41 = function (TextureCacheData, TextureData, MapManagerData$$1, MaterialData, BasicMaterialData, LightMaterialData) {
    MaterialData.materialMap = [];
    MaterialData.gameObjectMap = [];
    MaterialData.workerInitList = [];
    _setMaterialDefaultData(MaterialData);
    initData$42(BasicMaterialData);
    initData$33(LightMaterialData);
    setDefaultData(LightMaterialData);
    _initBufferData$4(MaterialData, BasicMaterialData, LightMaterialData);
    initData$15(TextureCacheData, TextureData, MapManagerData$$1);
};
var _setMaterialDefaultData = function (MaterialData) {
    MaterialData.defaultShaderIndex = 0;
    MaterialData.defaultColorArr = createDefaultColor().toVector3().toArray();
    MaterialData.defaultOpacity = 1;
    MaterialData.defaultAlphaTest = -1;
};
var _initBufferData$4 = function (MaterialData, BasicMaterialData, LightMaterialData) {
    var buffer = null, count = getBufferTotalCount(), offset = null;
    buffer = createSharedArrayBufferOrArrayBuffer(getBufferLength());
    offset = createTypeArrays(buffer, count, MaterialData);
    _setMaterialDefaultTypeArrData(count, MaterialData);
    offset = createTypeArrays$9(buffer, offset, getBasicMaterialBufferCount(), BasicMaterialData);
    offset = createTypeArrays$8(buffer, offset, getLightMaterialBufferCount(), LightMaterialData);
    MaterialData.buffer = buffer;
};
var _setMaterialDefaultTypeArrData = function (count, MaterialData) {
    var shaderIndex = MaterialData.defaultShaderIndex, color = createDefaultColor(), opacity = MaterialData.defaultOpacity, alphaTest = MaterialData.defaultAlphaTest;
    for (var i = 0; i < count; i++) {
        setShaderIndex(i, shaderIndex, MaterialData);
        setColor(i, color, MaterialData);
        setOpacity(i, opacity, MaterialData);
        setAlphaTest(i, alphaTest, MaterialData);
    }
};
var addAddComponentHandle$6 = function (BasicMaterial, LightMaterial) {
    addAddComponentHandle(BasicMaterial, addComponent$9);
    addAddComponentHandle(LightMaterial, addComponent$8);
};
var addDisposeHandle$5 = function (BasicMaterial, LightMaterial) {
    addDisposeHandle(BasicMaterial, disposeComponent$11);
    addDisposeHandle(LightMaterial, disposeComponent$10);
};
var addInitHandle$2 = function (BasicMaterial, LightMaterial) {
    addInitHandle(BasicMaterial, initMaterial$3);
    addInitHandle(LightMaterial, initMaterial$2);
};

var init$8 = function (state, gl, material_config, shaderLib_generator, initNoMaterialShader, TextureData, MaterialData, BasicMaterialData, LightMaterialData, GPUDetectData, GLSLSenderData, ProgramData, VaoData, LocationData, ShaderData) {
    init$9(state, gl, material_config, shaderLib_generator, initNoMaterialShader, TextureData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, WebGL2DirectionLightData, WebGL2PointLightData, GPUDetectData, GLSLSenderData, ProgramData, VaoData, LocationData, ShaderData);
};

var init$10 = function (state, gl, material_config, shaderLib_generator, initNoMaterialShader, TextureData, MaterialData, BasicMaterialData, LightMaterialData, GPUDetectData, GLSLSenderData, ProgramData, VaoData, LocationData, ShaderData) {
    init$9(state, gl, material_config, shaderLib_generator, initNoMaterialShader, TextureData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, WebGL1DirectionLightData, WebGL1PointLightData, GPUDetectData, GLSLSenderData, ProgramData, VaoData, LocationData, ShaderData);
};

var GPUDetectDataCommon = (function () {
    function GPUDetectDataCommon() {
    }
    GPUDetectDataCommon.maxTextureUnit = null;
    GPUDetectDataCommon.maxTextureSize = null;
    GPUDetectDataCommon.maxCubemapTextureSize = null;
    GPUDetectDataCommon.maxAnisotropy = null;
    GPUDetectDataCommon.maxBoneCount = null;
    GPUDetectDataCommon.maxUniformBufferBindings = null;
    GPUDetectDataCommon.extensionCompressedTextureS3TC = null;
    GPUDetectDataCommon.extensionTextureFilterAnisotropic = null;
    GPUDetectDataCommon.extensionInstancedArrays = null;
    GPUDetectDataCommon.extensionUintIndices = null;
    GPUDetectDataCommon.extensionDepthTexture = null;
    GPUDetectDataCommon.extensionVao = null;
    GPUDetectDataCommon.extensionStandardDerivatives = null;
    GPUDetectDataCommon.extensionColorBufferFloat = null;
    GPUDetectDataCommon.precision = null;
    return GPUDetectDataCommon;
}());

var GPUDetectData = (function (_super) {
    __extends(GPUDetectData, _super);
    function GPUDetectData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GPUDetectData;
}(GPUDetectDataCommon));

var BasicRenderCommandBufferData = (function () {
    function BasicRenderCommandBufferData() {
    }
    BasicRenderCommandBufferData.buffer = null;
    BasicRenderCommandBufferData.mMatrices = null;
    BasicRenderCommandBufferData.materialIndices = null;
    BasicRenderCommandBufferData.geometryIndices = null;
    return BasicRenderCommandBufferData;
}());

var LightRenderCommandBufferData = (function () {
    function LightRenderCommandBufferData() {
    }
    LightRenderCommandBufferData.buffer = null;
    LightRenderCommandBufferData.mMatrices = null;
    LightRenderCommandBufferData.materialIndices = null;
    LightRenderCommandBufferData.geometryIndices = null;
    return LightRenderCommandBufferData;
}());

var BasicDrawRenderCommandBufferData = (function () {
    function BasicDrawRenderCommandBufferData() {
    }
    BasicDrawRenderCommandBufferData.mMatrixFloatArrayForSend = null;
    return BasicDrawRenderCommandBufferData;
}());

var LightDrawRenderCommandBufferData = (function () {
    function LightDrawRenderCommandBufferData() {
    }
    LightDrawRenderCommandBufferData.mMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferData.vMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferData.pMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferData.normalMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferData.cameraPositionForSend = null;
    return LightDrawRenderCommandBufferData;
}());

var initData$45 = function (BasicDrawRenderCommandBufferDataFromSystem) {
    var mat4Length = getMatrix4DataSize();
    BasicDrawRenderCommandBufferDataFromSystem.mMatrixFloatArrayForSend = new Float32Array(mat4Length);
    BasicDrawRenderCommandBufferDataFromSystem.vMatrixFloatArrayForSend = new Float32Array(mat4Length);
    BasicDrawRenderCommandBufferDataFromSystem.pMatrixFloatArrayForSend = new Float32Array(mat4Length);
};
var buildRenderCommandUniformData = function (mMatrices, vMatrices, pMatrices) {
    return {
        mMatrix: mMatrices,
        vMatrix: vMatrices,
        pMatrix: pMatrices
    };
};

var initData$46 = function (LightDrawRenderCommandBufferDataFromSystem) {
    var mat3Length = getMatrix3DataSize(), mat4Length = getMatrix4DataSize(), cameraPositionLength = getVector3DataSize();
    LightDrawRenderCommandBufferDataFromSystem.mMatrixFloatArrayForSend = new Float32Array(mat4Length);
    LightDrawRenderCommandBufferDataFromSystem.vMatrixFloatArrayForSend = new Float32Array(mat4Length);
    LightDrawRenderCommandBufferDataFromSystem.pMatrixFloatArrayForSend = new Float32Array(mat4Length);
    LightDrawRenderCommandBufferDataFromSystem.cameraPositionForSend = new Float32Array(cameraPositionLength);
    LightDrawRenderCommandBufferDataFromSystem.normalMatrixFloatArrayForSend = new Float32Array(mat3Length);
};
var buildRenderCommandUniformData$1 = function (mMatrices, vMatrix, pMatrix, cameraPosition, normalMatrix) {
    return {
        mMatrix: mMatrices,
        vMatrix: vMatrix,
        pMatrix: pMatrix,
        cameraPosition: cameraPosition,
        normalMatrix: normalMatrix
    };
};

var clearColor$1 = function (gl, render_config, DeviceManagerDataFromSystem) {
    setClearColor$1(gl, render_config.clearColor, DeviceManagerDataFromSystem);
};
var initData$44 = function (BasicDrawRenderCommandBufferDataFromSystem, LightDrawRenderCommandBufferDataFromSystem) {
    initData$45(BasicDrawRenderCommandBufferDataFromSystem);
    initData$46(LightDrawRenderCommandBufferDataFromSystem);
};

var clearColor$$1 = curry(function (state, render_config, DeviceManagerData, data) {
    clearColor$1(getGL$$1(DeviceManagerData, state), render_config, DeviceManagerData);
    return data;
});
var initData$43 = initData$44;

var createRenderCommandBufferData$7 = requireCheckFunc(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    it$$1("renderGameObject should be basic material gameObject", function () {
        for (var _i = 0, renderGameObjectArray_1 = renderGameObjectArray; _i < renderGameObjectArray_1.length; _i++) {
            var gameObject = renderGameObjectArray_1[_i];
            wdet_1(ClassUtils.getClassNameByInstance(getMaterial(gameObject.uid, GameObjectData))).equal("BasicMaterial");
        }
    });
}, function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    return createRenderCommandBufferData$2(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, function (count, buffer, materialIndices, geometryIndices, mMatrices, vMatrices, pMatrices) {
        return {
            buffer: buffer,
            count: count
        };
    });
});

var createRenderCommandBufferData$8 = curry(requireCheckFunc(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    it$$1("renderGameObject should be light material gameObject", function () {
        for (var _i = 0, renderGameObjectArray_1 = renderGameObjectArray; _i < renderGameObjectArray_1.length; _i++) {
            var gameObject = renderGameObjectArray_1[_i];
            wdet_1(ClassUtils.getClassNameByInstance(getMaterial(gameObject.uid, GameObjectData))).equal("LightMaterial");
        }
    });
}, function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray) {
    return createRenderCommandBufferData$4(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, RenderCommandBufferData, renderGameObjectArray, function (count, buffer, materialIndices, geometryIndices, mMatrices, vMatrices, pMatrices, cameraPositions, normalMatrices) {
        return {
            buffer: buffer,
            count: count
        };
    });
}), 11);

var createRenderCommandBufferData$6 = curry(function (state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData, renderGameObjectArray) {
    return createRenderCommandBufferData$5(state, createRenderCommandBufferData$7, createRenderCommandBufferData$8, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData, renderGameObjectArray);
}, 12);

var init$14 = function (gl, GBufferData) {
    var gBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, gBuffer);
    var positionTarget = _createPositionTarget(gl), normalTarget = _createNormalTarget(gl), colortarget = _createColorTarget(gl), depthTexture = _createDepthTexture(gl);
    gl.drawBuffers([
        gl.COLOR_ATTACHMENT0,
        gl.COLOR_ATTACHMENT1,
        gl.COLOR_ATTACHMENT2
    ]);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    GBufferData.gBuffer = gBuffer;
    GBufferData.positionTarget = positionTarget;
    GBufferData.normalTarget = normalTarget;
    GBufferData.colorTarget = colortarget;
    GBufferData.depthTexture = depthTexture;
};
var _createPositionTarget = function (gl) {
    var positionTarget = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, positionTarget);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA16F, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, positionTarget, 0);
    return positionTarget;
};
var _createNormalTarget = function (gl) {
    var normalTarget = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, normalTarget);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA16F, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, normalTarget, 0);
    return normalTarget;
};
var _createColorTarget = function (gl) {
    var colorTarget = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, colorTarget);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA16F, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT2, gl.TEXTURE_2D, colorTarget, 0);
    return colorTarget;
};
var _createDepthTexture = function (gl) {
    var depthTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, depthTexture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.DEPTH_COMPONENT16, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
    return depthTexture;
};
var bindGBufferTargets = function (gl, GBufferData) {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, GBufferData.positionTarget);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, GBufferData.normalTarget);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, GBufferData.colorTarget);
    gl.activeTexture(gl.TEXTURE3);
};
var sendGBufferTargetData = function (gl, lightPassProgram) {
    var positionBufferLocation = gl.getUniformLocation(lightPassProgram, "u_positionBuffer"), normalBufferLocation = gl.getUniformLocation(lightPassProgram, "u_normalBuffer"), colorBufferLocation = gl.getUniformLocation(lightPassProgram, "u_colorBuffer");
    gl.uniform1i(positionBufferLocation, 0);
    gl.uniform1i(normalBufferLocation, 1);
    gl.uniform1i(colorBufferLocation, 2);
};
var bindGBuffer = function (gl, GBufferData) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, GBufferData.gBuffer);
};
var unbindGBuffer = function (gl) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};
var getNewTextureUnitIndex = function () { return 3; };

var init$15 = function (gl, shaderIndex, GLSLSenderDataFromSystem, DeferLightPassDataFromSystem) {
    _setFullScreenQuadVaoData(gl, shaderIndex, GLSLSenderDataFromSystem, DeferLightPassDataFromSystem);
};
var _setFullScreenQuadVaoData = requireCheckFunc(function (gl, shaderIndex, GLSLSenderDataFromSystem, DeferLightPassDataFromSystem) {
    it$$1("positionLocation, texCoordLocation should be defined in vaoConfig data", function () {
        var vaoConfig = getVaoConfig(shaderIndex, GLSLSenderDataFromSystem);
        wdet_1(vaoConfig.positionLocation).be.a("number");
        wdet_1(vaoConfig.texCoordLocation).be.a("number");
    });
}, function (gl, shaderIndex, GLSLSenderDataFromSystem, DeferLightPassDataFromSystem) {
    var fullScreenQuadVertexArray = createVao(gl), fullScreenQuadData = _createFullScreenQuadData(), _a = getVaoConfig(shaderIndex, GLSLSenderDataFromSystem), positionLocation = _a.positionLocation, texCoordLocation = _a.texCoordLocation;
    bindVao$1(gl, fullScreenQuadVertexArray);
    createAndInitArrayBuffer(gl, fullScreenQuadData.positions, positionLocation, _getPositionSize());
    createAndInitArrayBuffer(gl, fullScreenQuadData.texCoords, texCoordLocation, _getTexCoordSize());
    createAndInitIndexBuffer(gl, fullScreenQuadData.indices);
    unbindVao(gl);
    DeferLightPassDataFromSystem.fullScreenQuadVertexArray = fullScreenQuadVertexArray;
    DeferLightPassDataFromSystem.fullScreenQuadIndicesCount = fullScreenQuadData.indices.length;
});
var _getPositionSize = function () { return 3; };
var _getTexCoordSize = function () { return 2; };
var _createFullScreenQuadData = function () {
    var positions = new Float32Array([-1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]), indices = new Uint16Array([0, 1, 2, 0, 2, 3]), texCoords = new Float32Array([-1, 1, -1, -1, 1, -1, 1, 1]);
    return {
        positions: positions,
        texCoords: texCoords,
        indices: indices
    };
};
var initData$50 = function (DeferAmbientLightPassDataFromSystem, DeferDirectionLightPassDataFromSystem, DeferPointLightPassDataFromSystem) {
    DeferPointLightPassDataFromSystem.scissorRegionArrayCacheMap = createMap();
};

var sendAttributeData$2 = function (gl, ProgramDataFromSystem, _a) {
    var fullScreenQuadVertexArray = _a.fullScreenQuadVertexArray;
    bindVao$$1(gl, fullScreenQuadVertexArray, ProgramDataFromSystem);
};
var drawFullScreenQuad = function (gl, _a) {
    var fullScreenQuadIndicesCount = _a.fullScreenQuadIndicesCount;
    gl.drawElements(gl.TRIANGLES, fullScreenQuadIndicesCount, gl.UNSIGNED_SHORT, 0);
};
var getScissorRegionArrayCache = ensureFunc$$1(function (scissorRegionArray) {
    it$$1("scissorRegionArray shouldn't be undefined", function () {
        wdet_1(scissorRegionArray !== void 0).true;
    });
}, function (pointLightIndex, DeferPointLightPassDataFromSystem) { return DeferPointLightPassDataFromSystem.scissorRegionArrayCacheMap[pointLightIndex]; });
var setScissorRegionArrayCache = function (pointLightIndex, DeferPointLightPassDataFromSystem, scissorRegionArrayCache) { return DeferPointLightPassDataFromSystem.scissorRegionArrayCacheMap[pointLightIndex] = scissorRegionArrayCache; };

var EBlendEquation;
(function (EBlendEquation) {
    EBlendEquation["ADD"] = "FUNC_ADD";
    EBlendEquation["SUBTRACT"] = "FUNC_SUBTRACT";
    EBlendEquation["REVERSE_SUBTRAC"] = "FUNC_REVERSE_SUBTRACT";
})(EBlendEquation || (EBlendEquation = {}));

var EBlendFunc;
(function (EBlendFunc) {
    EBlendFunc["ZERO"] = "ZEOR";
    EBlendFunc["ONE"] = "ONE";
    EBlendFunc["SRC_COLOR"] = "SRC_COLOR";
    EBlendFunc["ONE_MINUS_SRC_COLOR"] = "ONE_MINUS_SRC_COLOR";
    EBlendFunc["DST_COLOR"] = "DST_COLOR";
    EBlendFunc["ONE_MINUS_DST_COLOR"] = "ONE_MINUS_DST_COLOR";
    EBlendFunc["SRC_ALPHA"] = "SRC_ALPHA";
    EBlendFunc["SRC_ALPHA_SATURATE"] = "SRC_ALPHA_SATURATE";
    EBlendFunc["ONE_MINUS_SRC_ALPHA"] = "ONE_MINUS_SRC_ALPHA";
    EBlendFunc["DST_ALPHA"] = "DST_ALPHA";
    EBlendFunc["ONE_MINUS_DST_ALPH"] = "ONE_MINUS_DST_ALPHA";
})(EBlendFunc || (EBlendFunc = {}));

var drawPointLightPass = function (gl, state, use, drawDataMap, pointLightData, pointLightCount, vMatrix, pMatrix, DeferPointLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem) {
    var _a = getViewport$1(state), x = _a.x, y = _a.y, width = _a.width, height = _a.height, DeviceManagerDataFromSystem = drawDataMap.DeviceManagerDataFromSystem, PointLightDataFromSystem = drawDataMap.PointLightDataFromSystem, shaderIndex = null, getPosition = pointLightData.getPosition, getColorArr3 = pointLightData.getColorArr3, getIntensity = pointLightData.getIntensity, getConstant = pointLightData.getConstant, getLinear = pointLightData.getLinear, getQuadratic = pointLightData.getQuadratic, computeRadius = pointLightData.computeRadius, isPositionDirty = pointLightData.isPositionDirty, isColorDirty = pointLightData.isColorDirty, isIntensityDirty = pointLightData.isIntensityDirty, isAttenuationDirty = pointLightData.isAttenuationDirty, PointLightDataFromSystem = pointLightData.PointLightDataFromSystem, position = null, colorArr3 = null, intensity = null, constant = null, linear = null, quadratic = null, radius = null, sc = null, isScDirtyFlag = null;
    _setState(gl, DeviceManagerDataFromSystem);
    sendAttributeData$2(gl, ProgramDataFromSystem, DeferPointLightPassDataFromSystem);
    shaderIndex = getNoMaterialShaderIndex("DeferPointLightPass", ShaderDataFromSystem);
    use(gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    for (var i = 0; i < pointLightCount; i++) {
        var isIntensityDirtyFlag = isIntensityDirty(i, PointLightDataFromSystem), isPositionDirtyFlag = isPositionDirty(i, PointLightDataFromSystem), isColorDirtyFlag = isColorDirty(i, PointLightDataFromSystem), isAttenuationDirtyFlag = isAttenuationDirty(i, PointLightDataFromSystem);
        if (!isPositionDirtyFlag && !isColorDirtyFlag && !isAttenuationDirtyFlag) {
            isScDirtyFlag = false;
        }
        else {
            isScDirtyFlag = true;
        }
        if (!isScDirtyFlag) {
            sc = getScissorRegionArrayCache(i, DeferPointLightPassDataFromSystem);
        }
        else {
            position = getPosition(i, PointLightDataFromSystem);
            colorArr3 = getColorArr3(i, PointLightDataFromSystem);
            constant = getConstant(i, PointLightDataFromSystem);
            linear = getLinear(i, PointLightDataFromSystem);
            quadratic = getQuadratic(i, PointLightDataFromSystem);
            radius = computeRadius(colorArr3, constant, linear, quadratic);
            sc = _getScissorForLight(vMatrix, pMatrix, position, radius, width, height);
            setScissorRegionArrayCache(i, DeferPointLightPassDataFromSystem, sc);
        }
        if (sc === _getNotInScreenVal()) {
            continue;
        }
        else if (sc === _getFullScreenVal()) {
            gl.scissor(x, y, width, height);
        }
        else {
            gl.scissor(sc[0], sc[1], sc[2], sc[3]);
        }
        if (isIntensityDirtyFlag) {
            intensity = getIntensity(i, PointLightDataFromSystem);
        }
        bindPointLightUboData(gl, i, pointLightData, _buildPointLightValueDataMap(position, colorArr3, intensity, constant, linear, quadratic, radius, isIntensityDirtyFlag, isScDirtyFlag), drawDataMap, GLSLSenderDataFromSystem);
        drawFullScreenQuad(gl, DeferPointLightPassDataFromSystem);
    }
    _restoreState(gl, DeviceManagerDataFromSystem);
};
var _setState = function (gl, DeviceManagerDataFromSystem) {
    setScissorTest(gl, true, DeviceManagerDataFromSystem);
};
var _restoreState = function (gl, DeviceManagerDataFromSystem) {
    setScissorTest(gl, false, DeviceManagerDataFromSystem);
};
var _getFullScreenVal = function () { return 1; };
var _getNotInScreenVal = function () { return 2; };
var _getBoxMinPointInScreenCoordinate = function (lightPosition, vMatrix, pMatrix, radius) {
    lightPosition.applyMatrix4(vMatrix, true);
    lightPosition.x -= radius;
    lightPosition.y -= radius;
    lightPosition.z += radius;
    lightPosition.applyMatrix4(pMatrix, true);
    lightPosition.divideScalar(lightPosition.w);
    return lightPosition;
};
var _getBoxMaxPointInScreenCoordinate = function (lightPosition, vMatrix, pMatrix, radius) {
    lightPosition.applyMatrix4(vMatrix, true);
    lightPosition.x += radius;
    lightPosition.y += radius;
    lightPosition.z += radius;
    lightPosition.applyMatrix4(pMatrix, true);
    lightPosition.divideScalar(lightPosition.w);
    return lightPosition;
};
var _getScissorForLight = function (vMatrix, pMatrix, position, radius, width, height) {
    var a = Vector4.create(position[0], position[1], position[2], 1), b = Vector4.create(position[0], position[1], position[2], 1), minpt = null, maxpt = null, ret = [];
    a = _getBoxMinPointInScreenCoordinate(a, vMatrix, pMatrix, radius);
    b = _getBoxMaxPointInScreenCoordinate(b, vMatrix, pMatrix, radius);
    if (a.x > 1 && a.y > 1 && b.x < -1 && b.y < -1) {
        return _getFullScreenVal();
    }
    minpt = Vector2.create(a.x, a.y);
    maxpt = Vector2.create(b.x, b.y);
    minpt.addScalar(1.0);
    minpt.multiplyScalar(0.5);
    maxpt.addScalar(1.0);
    maxpt.multiplyScalar(0.5);
    var x = minpt.x, y = minpt.y, ptWidth = maxpt.x - x, ptHeight = maxpt.y - y;
    if (ptWidth < 0 || ptHeight < 0 || (x + ptWidth) < 0 || (y + ptHeight) < 0) {
        return _getNotInScreenVal();
    }
    ret[0] = Math.round(width * x);
    ret[1] = Math.round(height * y);
    ret[2] = Math.round(width * ptWidth);
    ret[3] = Math.round(height * ptHeight);
    return ret;
};
var _buildPointLightValueDataMap = function (position, colorArr3, intensity, constant, linear, quadratic, radius, isIntensityDirty, isOtherValueDirty) {
    return {
        position: position,
        colorArr3: colorArr3,
        intensity: intensity,
        constant: constant,
        linear: linear,
        quadratic: quadratic,
        radius: radius,
        isIntensityDirty: isIntensityDirty,
        isOtherValueDirty: isOtherValueDirty
    };
};

var drawLightPass = function (gl, render_config, _a, drawDataMap, _b, initShaderDataMap, sendDataMap, vMatrix, pMatrix, state) {
    var use = _a.use, unbindGBuffer = _a.unbindGBuffer;
    var DeferAmbientLightPassDataFromSystem = _b.DeferAmbientLightPassDataFromSystem, DeferDirectionLightPassDataFromSystem = _b.DeferDirectionLightPassDataFromSystem, DeferPointLightPassDataFromSystem = _b.DeferPointLightPassDataFromSystem;
    var ShaderDataFromSystem = initShaderDataMap.ShaderDataFromSystem, DeviceManagerDataFromSystem = drawDataMap.DeviceManagerDataFromSystem, AmbientLightDataFromSystem = drawDataMap.AmbientLightDataFromSystem, DirectionLightDataFromSystem = drawDataMap.DirectionLightDataFromSystem, PointLightDataFromSystem = drawDataMap.PointLightDataFromSystem, ProgramDataFromSystem = drawDataMap.ProgramDataFromSystem, LocationDataFromSystem = drawDataMap.LocationDataFromSystem, GLSLSenderDataFromSystem = drawDataMap.GLSLSenderDataFromSystem, ambientLightCount = AmbientLightDataFromSystem.count, directionLightCount = DirectionLightDataFromSystem.count, pointLightCount = PointLightDataFromSystem.count;
    unbindGBuffer(gl);
    setDepthWrite(gl, false, DeviceManagerDataFromSystem);
    setDepthTest(gl, false, DeviceManagerDataFromSystem);
    setBlend(gl, true, DeviceManagerDataFromSystem);
    setBlendEquation(gl, EBlendEquation.ADD, DeviceManagerDataFromSystem);
    setBlendFunc(gl, EBlendFunc.ONE, EBlendFunc.ONE, DeviceManagerDataFromSystem);
    if (_hasLight(ambientLightCount)) {
        _drawAmbientLightPass(gl, use, drawDataMap, sendDataMap.ambientLightData, ambientLightCount, DeferAmbientLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    }
    if (_hasLight(directionLightCount)) {
        _drawDirectionLightPass(gl, use, drawDataMap, sendDataMap.directionLightData, directionLightCount, DeferDirectionLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    }
    if (_hasLight(pointLightCount)) {
        drawPointLightPass(gl, state, use, drawDataMap, sendDataMap.pointLightData, pointLightCount, vMatrix, pMatrix, DeferPointLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    }
    unbindVao(gl);
};
var _hasLight = function (count) { return count > 0; };
var _drawAmbientLightPass = function (gl, use, drawDataMap, ambientLightData, ambientLightCount, DeferAmbientLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem) {
    var shaderIndex = null;
    sendAttributeData$2(gl, ProgramDataFromSystem, DeferAmbientLightPassDataFromSystem);
    shaderIndex = getNoMaterialShaderIndex("DeferAmbientLightPass", ShaderDataFromSystem);
    use(gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    var getColorArr3 = ambientLightData.getColorArr3, isColorDirty = ambientLightData.isColorDirty, AmbientLightDataFromSystem = ambientLightData.AmbientLightDataFromSystem;
    for (var i = 0; i < ambientLightCount; i++) {
        var colorArr3 = null, isColorDirtyFlag = isColorDirty(i, AmbientLightDataFromSystem);
        if (isColorDirtyFlag) {
            colorArr3 = getColorArr3(i, AmbientLightDataFromSystem);
        }
        bindAmbientLightUboData(gl, i, ambientLightData, _buildAmbientLightValueDataMap(colorArr3, isColorDirtyFlag), drawDataMap, GLSLSenderDataFromSystem);
        drawFullScreenQuad(gl, DeferAmbientLightPassDataFromSystem);
    }
};
var _buildAmbientLightValueDataMap = function (colorArr3, isColorDirty) {
    return {
        colorArr3: colorArr3,
        isColorDirty: isColorDirty
    };
};
var _drawDirectionLightPass = function (gl, use, drawDataMap, directionLightData, directionLightCount, DeferDirectionLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem) {
    var shaderIndex = null;
    sendAttributeData$2(gl, ProgramDataFromSystem, DeferDirectionLightPassDataFromSystem);
    shaderIndex = getNoMaterialShaderIndex("DeferDirectionLightPass", ShaderDataFromSystem);
    use(gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    var getPosition = directionLightData.getPosition, getColorArr3 = directionLightData.getColorArr3, getIntensity = directionLightData.getIntensity, isPositionDirty = directionLightData.isPositionDirty, isColorDirty = directionLightData.isColorDirty, isIntensityDirty = directionLightData.isIntensityDirty, DirectionLightDataFromSystem = directionLightData.DirectionLightDataFromSystem;
    for (var i = 0; i < directionLightCount; i++) {
        var position = null, colorArr3 = null, intensity = null, isIntensityDirtyFlag = isIntensityDirty(i, DirectionLightDataFromSystem), isPositionDirtyFlag = isPositionDirty(i, DirectionLightDataFromSystem), isColorDirtyFlag = isColorDirty(i, DirectionLightDataFromSystem);
        if (isPositionDirtyFlag) {
            position = getPosition(i, DirectionLightDataFromSystem);
        }
        if (isColorDirtyFlag) {
            colorArr3 = getColorArr3(i, DirectionLightDataFromSystem);
        }
        if (isIntensityDirtyFlag) {
            intensity = getIntensity(i, DirectionLightDataFromSystem);
        }
        bindDirectionLightUboData(gl, i, directionLightData, _buildDirectionLightValueDataMap(position, colorArr3, intensity, isPositionDirtyFlag, isColorDirtyFlag, isIntensityDirtyFlag), drawDataMap, GLSLSenderDataFromSystem);
        drawFullScreenQuad(gl, DeferDirectionLightPassDataFromSystem);
    }
};
var _buildDirectionLightValueDataMap = function (position, colorArr3, intensity, isPositionDirty, isColorDirty, isIntensityDirty) {
    return {
        position: position,
        colorArr3: colorArr3,
        intensity: intensity,
        isPositionDirty: isPositionDirty,
        isColorDirty: isColorDirty,
        isIntensityDirty: isIntensityDirty
    };
};

var updateSendMatrixFloat32ArrayData = function (sourceMatrices, matStartIndex, matEndIndex, targetMatrices) {
    for (var i = matStartIndex; i < matEndIndex; i++) {
        targetMatrices[i - matStartIndex] = sourceMatrices[i];
    }
    return targetMatrices;
};
var drawElements = function (gl, geometryIndex, drawMode, getIndicesCount, getIndexType, getIndexTypeSize, GeometryDataFromSystem) {
    var startOffset = 0, count = getIndicesCount(geometryIndex, GeometryDataFromSystem), type = getIndexType(GeometryDataFromSystem), typeSize = getIndexTypeSize(GeometryDataFromSystem);
    gl.drawElements(gl[drawMode], count, gl[type], typeSize * startOffset);
};
var drawArray = function (gl, geometryIndex, drawMode, getVerticesCount, GeometryDataFromSystem) {
    var startOffset = 0, count = getVerticesCount(geometryIndex, GeometryDataFromSystem);
    gl.drawArrays(gl[drawMode], startOffset, count);
};

var drawGameObjects = function (gl, state, material_config, shaderLib_generator, DataBufferConfig, definedStartTextureUnitIndex, useShaderName, initMaterialShader, drawFuncDataMap, drawDataMap, initShaderDataMap, sendDataMap, renderCommandUniformData, _a) {
    var _b = _a.renderCommandBufferData, mMatrices = _b.mMatrices, materialIndices = _b.materialIndices, geometryIndices = _b.geometryIndices, count = _a.count;
    var TextureDataFromSystem = drawDataMap.TextureDataFromSystem, TextureCacheDataFromSystem = drawDataMap.TextureCacheDataFromSystem, MapManagerDataFromSystem = drawDataMap.MapManagerDataFromSystem, ProgramDataFromSystem = drawDataMap.ProgramDataFromSystem, LocationDataFromSystem = drawDataMap.LocationDataFromSystem, GLSLSenderDataFromSystem = drawDataMap.GLSLSenderDataFromSystem, GeometryDataFromSystem = drawDataMap.GeometryDataFromSystem, sendAttributeData = drawFuncDataMap.sendAttributeData, sendUniformData = drawFuncDataMap.sendUniformData, directlySendUniformData = drawFuncDataMap.directlySendUniformData, use = drawFuncDataMap.use, hasIndices = drawFuncDataMap.hasIndices, getIndicesCount = drawFuncDataMap.getIndicesCount, getIndexType = drawFuncDataMap.getIndexType, getIndexTypeSize = drawFuncDataMap.getIndexTypeSize, getVerticesCount = drawFuncDataMap.getVerticesCount, getMapCount = drawFuncDataMap.getMapCount, getStartTextureIndex$$1 = drawFuncDataMap.getStartTextureIndex, bindAndUpdate = drawFuncDataMap.bindAndUpdate, useShader = drawFuncDataMap.useShader, GPUDetectDataFromSystem = initShaderDataMap.GPUDetectDataFromSystem, VaoDataFromSystem = initShaderDataMap.VaoDataFromSystem, mMatrixFloatArrayForSend = renderCommandUniformData.mMatrix, program = null;
    for (var i = 0; i < count; i++) {
        var matStartIndex = 16 * i, matEndIndex = matStartIndex + 16, geometryIndex = geometryIndices[i], materialIndex = materialIndices[i], mapCount = getMapCount(materialIndex, MapManagerDataFromSystem), startTextureUnitIndex = getStartTextureIndex$$1(materialIndex), drawMode = EDrawMode.TRIANGLES;
        var shaderIndex = useShader(materialIndex, useShaderName, state, material_config, shaderLib_generator, initMaterialShader, initShaderDataMap);
        program = use(gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
        sendAttributeData(gl, shaderIndex, geometryIndex, ProgramDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, VaoDataFromSystem);
        updateSendMatrixFloat32ArrayData(mMatrices, matStartIndex, matEndIndex, mMatrixFloatArrayForSend);
        var uniformLocationMap = LocationDataFromSystem.uniformLocationMap[shaderIndex], uniformCacheMap = GLSLSenderDataFromSystem.uniformCacheMap;
        sendUniformData(gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap);
        bindAndUpdate(gl, mapCount, startTextureUnitIndex, definedStartTextureUnitIndex, TextureCacheDataFromSystem, TextureDataFromSystem, MapManagerDataFromSystem, GPUDetectDataFromSystem);
        sendData$$1(gl, mapCount, startTextureUnitIndex, definedStartTextureUnitIndex, shaderIndex, program, sendDataMap.glslSenderData, uniformLocationMap, uniformCacheMap, directlySendUniformData, TextureDataFromSystem, MapManagerDataFromSystem);
        if (hasIndices(geometryIndex, GeometryDataFromSystem)) {
            drawElements(gl, geometryIndex, drawMode, getIndicesCount, getIndexType, getIndexTypeSize, GeometryDataFromSystem);
        }
        else {
            drawArray(gl, geometryIndex, drawMode, getVerticesCount, GeometryDataFromSystem);
        }
    }
};

var drawGBufferPass = function (gl, state, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, _a, initShaderDataMap, sendDataMap, renderCommandUniformData, bufferData) {
    var GBufferDataFromSystem = _a.GBufferDataFromSystem;
    var DeviceManagerDataFromSystem = drawDataMap.DeviceManagerDataFromSystem;
    setDepthWrite(gl, true, DeviceManagerDataFromSystem);
    drawFuncDataMap.bindGBuffer(gl, GBufferDataFromSystem);
    clear$1(gl, drawDataMap.DeviceManagerDataFromSystem);
    setDepthTest(gl, true, DeviceManagerDataFromSystem);
    setBlend(gl, false, DeviceManagerDataFromSystem);
    drawGameObjects(gl, state, material_config, shaderLib_generator, DataBufferConfig, getNewTextureUnitIndex(), "GBuffer", initMaterialShader, drawFuncDataMap, drawDataMap, initShaderDataMap, sendDataMap, renderCommandUniformData, bufferData);
};

var draw = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, deferDrawDataMap, sendDataMap, initShaderDataMap, bufferData, _a) {
    var vMatrix = _a.vMatrix, pMatrix = _a.pMatrix, cameraPosition = _a.cameraPosition, normalMatrix = _a.normalMatrix;
    var LightDrawRenderCommandBufferDataFromSystem = drawDataMap.LightDrawRenderCommandBufferDataFromSystem, mMatrixFloatArrayForSend = LightDrawRenderCommandBufferDataFromSystem.mMatrixFloatArrayForSend;
    drawGBufferPass(gl, state, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, deferDrawDataMap, initShaderDataMap, sendDataMap, buildRenderCommandUniformData$1(mMatrixFloatArrayForSend, vMatrix, pMatrix, cameraPosition, normalMatrix), bufferData);
    drawLightPass(gl, render_config, drawFuncDataMap, drawDataMap, deferDrawDataMap, initShaderDataMap, sendDataMap, vMatrix, pMatrix, state);
};

var init$13 = function (gl, DataBufferConfig, GBufferDataFromSystem, DeferAmbientLightPassDataFromSystem, DeferDirectionLightPassDataFromSystem, DeferPointLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem) {
    init$14(gl, GBufferDataFromSystem);
    bindGBufferTargets(gl, GBufferDataFromSystem);
    _initDeferLightPass(gl, "DeferAmbientLightPass", ShaderDataFromSystem, GLSLSenderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, DeferAmbientLightPassDataFromSystem);
    _initDeferLightPass(gl, "DeferDirectionLightPass", ShaderDataFromSystem, GLSLSenderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, DeferDirectionLightPassDataFromSystem);
    _initDeferLightPass(gl, "DeferPointLightPass", ShaderDataFromSystem, GLSLSenderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, DeferPointLightPassDataFromSystem);
};
var _initDeferLightPass = function (gl, shaderName, ShaderDataFromSystem, GLSLSenderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, DeferLightPassDataFromSystem) {
    var program = null, shaderIndex = null;
    shaderIndex = getNoMaterialShaderIndex(shaderName, ShaderDataFromSystem);
    init$15(gl, shaderIndex, GLSLSenderDataFromSystem, DeferLightPassDataFromSystem);
    program = use$1(gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    sendGBufferTargetData(gl, program);
};
var render$4 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, deferDrawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData) {
    draw(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, deferDrawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData);
};
var buildSendUniformDataDataMap = function (sendFloat1, sendFloat3, sendMatrix4, sendVector3, sendInt, sendMatrix3, getAmbientLightColorArr3, isAmbientLightColorDirty, cleanAmbientLightColorDirty, getDirectionLightPosition, getDirectionLightColorArr3, getDirectionLightIntensity, isDirectionLightPositionDirty, isDirectionLightColorDirty, isDirectionLightIntensityDirty, cleanDirectionLightPositionDirty, cleanDirectionLightColorDirty, cleanDirectionLightIntensityDirty, getPointLightPosition, getPointLightColorArr3, getConstant, getPointLightIntensity, getLinear, getQuadratic, getRange, computeRadius, isPositionDirty, isColorDirty, isIntensityDirty, isAttenuationDirty, cleanPositionDirty, cleanColorDirty, cleanIntensityDirty, cleanAttenuationDirty, drawDataMap) {
    return {
        glslSenderData: {
            sendMatrix3: sendMatrix3,
            sendMatrix4: sendMatrix4,
            sendVector3: sendVector3,
            sendInt: sendInt,
            sendFloat1: sendFloat1,
            sendFloat3: sendFloat3,
            GLSLSenderDataFromSystem: drawDataMap.GLSLSenderDataFromSystem
        },
        ambientLightData: {
            getColorArr3: getAmbientLightColorArr3,
            isColorDirty: isAmbientLightColorDirty,
            cleanColorDirty: cleanAmbientLightColorDirty,
            AmbientLightDataFromSystem: drawDataMap.AmbientLightDataFromSystem
        },
        directionLightData: {
            getPosition: getDirectionLightPosition,
            getColorArr3: getDirectionLightColorArr3,
            getIntensity: getDirectionLightIntensity,
            isPositionDirty: isDirectionLightPositionDirty,
            isColorDirty: isDirectionLightColorDirty,
            isIntensityDirty: isDirectionLightIntensityDirty,
            cleanPositionDirty: cleanDirectionLightPositionDirty,
            cleanColorDirty: cleanDirectionLightColorDirty,
            cleanIntensityDirty: cleanDirectionLightIntensityDirty,
            DirectionLightDataFromSystem: drawDataMap.DirectionLightDataFromSystem
        },
        pointLightData: {
            getPosition: getPointLightPosition,
            getColorArr3: getPointLightColorArr3,
            getIntensity: getPointLightIntensity,
            getConstant: getConstant,
            getLinear: getLinear,
            getQuadratic: getQuadratic,
            getRange: getRange,
            computeRadius: computeRadius,
            isPositionDirty: isPositionDirty,
            isColorDirty: isColorDirty,
            isIntensityDirty: isIntensityDirty,
            isAttenuationDirty: isAttenuationDirty,
            cleanPositionDirty: cleanPositionDirty,
            cleanColorDirty: cleanColorDirty,
            cleanIntensityDirty: cleanIntensityDirty,
            cleanAttenuationDirty: cleanAttenuationDirty,
            PointLightDataFromSystem: drawDataMap.PointLightDataFromSystem
        }
    };
};

var init$12 = function (gl, render_config, DataBufferConfig, GBufferDataFromSystem, DeferAmbientLightPassDataFromSystem, DeferDirectionLightPassDataFromSystem, DeferPointLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, GPUDetectDataFromSystem) {
    if (!hasExtensionColorBufferFloat(GPUDetectDataFromSystem)) {
        Log$$1.warn("defer shading need support extensionColorBufferFloat extension");
    }
    else {
        init$13(gl, DataBufferConfig, GBufferDataFromSystem, DeferAmbientLightPassDataFromSystem, DeferDirectionLightPassDataFromSystem, DeferPointLightPassDataFromSystem, ShaderDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
    }
    init$7(gl, render_config, GLSLSenderDataFromSystem);
};
var render$3 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, basicRender, deferRender, drawDataMap, deferDrawDataMap, initShaderDataMap, _a) {
    var cameraData = _a.cameraData, basicData = _a.basicData, lightData = _a.lightData;
    var DeviceManagerDataFromSystem = drawDataMap.DeviceManagerDataFromSystem, GLSLSenderDataFromSystem = drawDataMap.GLSLSenderDataFromSystem;
    clear$1(gl, DeviceManagerDataFromSystem);
    bindFrameUboData(gl, render_config, cameraData, GLSLSenderDataFromSystem);
    if (basicData.count > 0) {
        basicRender(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, initShaderDataMap, basicData, cameraData);
    }
    if (lightData.count > 0) {
        deferRender(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, deferDrawDataMap, initShaderDataMap, lightData, cameraData);
    }
};
var sendAttributeData$1 = function (gl, shaderIndex, geometryIndex, ProgramDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, VaoDataFromSystem) {
    _bindVao(gl, shaderIndex, geometryIndex, ProgramDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, VaoDataFromSystem);
};
var buildDrawDataMap$1 = function (DeviceManagerDataFromSystem, TextureDataFromSystem, TextureCacheDataFromSystem, MapManagerDataFromSystem, MaterialDataFromSystem, BasicMaterialDataFromSystem, LightMaterialDataFromSystem, AmbientLightDataFromSystem, DirectionLightDataFromSystem, PointLightDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, BasicDrawRenderCommandBufferDataFromSystem, LightDrawRenderCommandBufferDataFromSystem) {
    return {
        DeviceManagerDataFromSystem: DeviceManagerDataFromSystem,
        TextureDataFromSystem: TextureDataFromSystem,
        TextureCacheDataFromSystem: TextureCacheDataFromSystem,
        MapManagerDataFromSystem: MapManagerDataFromSystem,
        MaterialDataFromSystem: MaterialDataFromSystem,
        BasicMaterialDataFromSystem: BasicMaterialDataFromSystem,
        LightMaterialDataFromSystem: LightMaterialDataFromSystem,
        AmbientLightDataFromSystem: AmbientLightDataFromSystem,
        DirectionLightDataFromSystem: DirectionLightDataFromSystem,
        PointLightDataFromSystem: PointLightDataFromSystem,
        ProgramDataFromSystem: ProgramDataFromSystem,
        LocationDataFromSystem: LocationDataFromSystem,
        GLSLSenderDataFromSystem: GLSLSenderDataFromSystem,
        GeometryDataFromSystem: GeometryDataFromSystem,
        BasicDrawRenderCommandBufferDataFromSystem: BasicDrawRenderCommandBufferDataFromSystem,
        LightDrawRenderCommandBufferDataFromSystem: LightDrawRenderCommandBufferDataFromSystem
    };
};
var _bindVao = function (gl, shaderIndex, geometryIndex, ProgramDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, _a) {
    var vaoMap = _a.vaoMap, vboArrayMap = _a.vboArrayMap;
    var vaoConfigData = GLSLSenderDataFromSystem.vaoConfigMap[shaderIndex], vao = getVao(geometryIndex, vaoMap);
    if (!isVaoExist(vao)) {
        vao = createAndInitVao(gl, geometryIndex, vaoMap, vboArrayMap, vaoConfigData, GeometryDataFromSystem);
    }
    bindVao$$1(gl, vao, ProgramDataFromSystem);
};

var getUniformLocation$1 = ensureFunc$$1(function (pos, gl, name, uniformLocationMap) {
}, function (gl, program, name, uniformLocationMap) {
    var pos = null;
    pos = uniformLocationMap[name];
    if (isValidMapValue(pos)) {
        return pos;
    }
    pos = gl.getUniformLocation(program, name);
    uniformLocationMap[name] = pos;
    return pos;
});
var isUniformLocationNotExist$1 = function (pos) {
    return pos === null;
};

var getUniformLocation$$1 = getUniformLocation$1;
var isUniformLocationNotExist$$1 = isUniformLocationNotExist$1;

var sendBuffer$1 = sendBuffer;
var sendMatrix3$1 = function (gl, program, name, data, uniformLocationMap) {
    sendMatrix3(gl, program, name, data, uniformLocationMap, getUniformLocation$$1, isUniformLocationNotExist$$1);
};
var sendMatrix4$1 = function (gl, program, name, data, uniformLocationMap) {
    sendMatrix4(gl, program, name, data, uniformLocationMap, getUniformLocation$$1, isUniformLocationNotExist$$1);
};
var sendVector3$1 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendVector3(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$$1, isUniformLocationNotExist$$1);
};
var sendInt$1 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendInt(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$$1, isUniformLocationNotExist$$1);
};
var sendFloat1$1 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendFloat1(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$$1, isUniformLocationNotExist$$1);
};
var sendFloat3$1 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendFloat3(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$$1, isUniformLocationNotExist$$1);
};

var directlySendUniformData = function (gl, name, shaderIndex, program, type, data, _a, uniformLocationMap, uniformCacheMap) {
    var sendMatrix3 = _a.sendMatrix3, sendMatrix4 = _a.sendMatrix4, sendVector3 = _a.sendVector3, sendInt = _a.sendInt, sendFloat1 = _a.sendFloat1, sendFloat3 = _a.sendFloat3;
    switch (type) {
        case EVariableType.MAT3:
            sendMatrix3(gl, program, name, data, uniformLocationMap);
            break;
        case EVariableType.MAT4:
            sendMatrix4(gl, program, name, data, uniformLocationMap);
            break;
        case EVariableType.VEC3:
            sendVector3(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap);
            break;
        case EVariableType.INT:
        case EVariableType.SAMPLER_2D:
            sendInt(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap);
            break;
        case EVariableType.FLOAT:
            sendFloat1(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap);
            break;
        case EVariableType.FLOAT3:
            sendFloat3(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap);
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_INVALID("EVariableType:", type));
            break;
    }
};

var buildDrawFuncDataMap$1 = function (sendAttributeData, sendUniformData, directlySendUniformData, use, hasIndices, getIndicesCount, getIndexType, getIndexTypeSize, getVerticesCount, bindAndUpdate, getMapCount, getStartTextureIndex, useShader) {
    return {
        sendAttributeData: sendAttributeData,
        sendUniformData: sendUniformData,
        directlySendUniformData: directlySendUniformData,
        use: use,
        hasIndices: hasIndices,
        getIndicesCount: getIndicesCount,
        getIndexType: getIndexType,
        getIndexTypeSize: getIndexTypeSize,
        getVerticesCount: getVerticesCount,
        bindAndUpdate: bindAndUpdate,
        getMapCount: getMapCount,
        getStartTextureIndex: getStartTextureIndex,
        useShader: useShader,
    };
};

var draw$1 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, _a) {
    var vMatrix = _a.vMatrix, pMatrix = _a.pMatrix;
    var BasicDrawRenderCommandBufferDataFromSystem = drawDataMap.BasicDrawRenderCommandBufferDataFromSystem, mMatrixFloatArrayForSend = BasicDrawRenderCommandBufferDataFromSystem.mMatrixFloatArrayForSend;
    drawGameObjects(gl, state, material_config, shaderLib_generator, DataBufferConfig, 0, "BasicRender", initMaterialShader, drawFuncDataMap, drawDataMap, initShaderDataMap, sendDataMap, buildRenderCommandUniformData(mMatrixFloatArrayForSend, vMatrix, pMatrix), bufferData);
    return state;
};

var render$6 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData) {
    draw$1(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData);
};

var sendUniformData = function (gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap, materialData, basicMaterialData) {
    _sendUniformData$2(gl, materialIndex, shaderIndex, program, sendDataMap.glslSenderData, uniformLocationMap, uniformCacheMap, renderCommandUniformData, materialData, basicMaterialData);
    _sendUniformFuncData(gl, shaderIndex, program, sendDataMap, drawDataMap, uniformLocationMap, uniformCacheMap);
};
var _sendUniformData$2 = function (gl, materialIndex, shaderIndex, program, glslSenderData, uniformLocationMap, uniformCacheMap, renderCommandUniformData, materialData, basicMaterialData) {
    var sendUniformDataArr = glslSenderData.GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex];
    for (var i = 0, len = sendUniformDataArr.length; i < len; i++) {
        var sendData = sendUniformDataArr[i], name = sendData.name, field = sendData.field, type = sendData.type, from = sendData.from || "cmd", data = _getUniformData(materialIndex, field, from, renderCommandUniformData, materialData, basicMaterialData);
        directlySendUniformData(gl, name, shaderIndex, program, type, data, glslSenderData, uniformLocationMap, uniformCacheMap);
    }
};
var _sendUniformFuncData = function (gl, shaderIndex, program, sendDataMap, drawDataMap, uniformLocationMap, uniformCacheMap) {
    var sendUniformFuncDataArr = drawDataMap.GLSLSenderDataFromSystem.sendUniformFuncConfigMap[shaderIndex];
    for (var i = 0, len = sendUniformFuncDataArr.length; i < len; i++) {
        var sendFunc = sendUniformFuncDataArr[i];
        sendFunc(gl, shaderIndex, program, sendDataMap, uniformLocationMap, uniformCacheMap);
    }
};
var _getUniformData = function (materialIndex, field, from, renderCommandUniformData, materialData, basicMaterialData) {
    var data = null;
    switch (from) {
        case "cmd":
            data = renderCommandUniformData[field];
            break;
        case "basicMaterial":
            data = _getUnifromDataFromBasicMaterial(field, materialIndex, materialData, basicMaterialData);
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_UNKNOW("from:" + from));
            break;
    }
    return data;
};
var _getUnifromDataFromBasicMaterial = function (field, index, _a, _b) {
    var getColorArr3 = _a.getColorArr3, getOpacity = _a.getOpacity, MaterialDataFromSystem = _a.MaterialDataFromSystem;
    var data = null;
    switch (field) {
        case "color":
            data = getColorArr3(index, MaterialDataFromSystem);
            break;
        case "opacity":
            data = getOpacity(index, MaterialDataFromSystem);
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_UNKNOW("field:" + field));
            break;
    }
    return data;
};
var buildSendUniformDataDataMap$1 = function (sendFloat1, sendFloat3, sendMatrix4, sendVector3, sendInt, sendMatrix3, drawDataMap) {
    return {
        glslSenderData: {
            sendMatrix3: sendMatrix3,
            sendMatrix4: sendMatrix4,
            sendVector3: sendVector3,
            sendInt: sendInt,
            sendFloat1: sendFloat1,
            sendFloat3: sendFloat3,
            GLSLSenderDataFromSystem: drawDataMap.GLSLSenderDataFromSystem
        }
    };
};
var buildMaterialDataForGetUniformData = function (getColorArr3, getOpacity, MaterialDataFromSystem) {
    return {
        getColorArr3: getColorArr3,
        getOpacity: getOpacity,
        MaterialDataFromSystem: MaterialDataFromSystem
    };
};
var buildBasicMaterialDataForGetUniformData = function (BasicMaterialDataFromSystem) {
    return {
        BasicMaterialDataFromSystem: BasicMaterialDataFromSystem
    };
};

var render$5 = curry(function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, initShaderDataMap, bufferData, cameraData) {
    render$6(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, buildDrawFuncDataMap$1(sendAttributeData$$1, _sendUniformData$1, directlySendUniformData, use$$1, hasIndices$$1, getIndicesCount$$1, getIndexType$$1, getIndexTypeSize$$1, getVerticesCount$$1, bindAndUpdate$$1, getMapCount$$1, getStartTextureIndex, useShader$$1), drawDataMap, buildSendUniformDataDataMap$1(sendFloat1$1, sendFloat3$1, sendMatrix4$1, sendVector3$1, sendInt$1, sendMatrix3$1, drawDataMap), initShaderDataMap, bufferData, cameraData);
});
var _sendUniformData$1 = function (gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap) {
    sendUniformData(gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap, buildMaterialDataForGetUniformData(getColorArr3$$1, getOpacity$$1, drawDataMap.MaterialDataFromSystem), buildBasicMaterialDataForGetUniformData(drawDataMap.BasicMaterialDataFromSystem));
};

var AmbientLight = (function (_super) {
    __extends(AmbientLight, _super);
    function AmbientLight() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AmbientLight = __decorate([
        registerClass$1("AmbientLight")
    ], AmbientLight);
    return AmbientLight;
}(Light));
var createAmbientLight = function () {
    return create$15(AmbientLightData);
};
var getAmbientLightGameObject = requireCheckFunc(function (component) {
    checkLightShouldAlive(component);
}, function (component) {
    return getGameObject$6(component.index, AmbientLightData);
});
var getAmbientLightColor = function (light) {
    return getColor$5(light.index, AmbientLightData);
};
var setAmbientLightColor = function (light, color) {
    setColor$4(light.index, color, AmbientLightData);
};

var getColorArr3$8 = function (index, AmbientLightDataFromSystem) {
    return getColorArr3$1(index, AmbientLightDataFromSystem);
};
var getColorDataSize$4 = getColorDataSize$1;
var createTypeArrays$11 = function (buffer, count, AmbientLightDataFromSystem) {
    var offset = 0;
    AmbientLightDataFromSystem.colors = new Float32Array(buffer, 0, count * getColorDataSize$4());
    offset += count * Float32Array.BYTES_PER_ELEMENT * getColorDataSize$4();
    AmbientLightDataFromSystem.isColorDirtys = new Uint8Array(buffer, offset, count * getDirtyDataSize());
    offset += count * Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize();
};
var isColorDirty$5 = function (index, AmbientLightDataFromSystem) {
    return isDirty(getSingleSizeData(index, AmbientLightDataFromSystem.isColorDirtys));
};
var cleanColorDirty$5 = function (index, AmbientLightDataFromSystem) {
    cleanDirty(index, AmbientLightDataFromSystem.isColorDirtys);
};

var getColor$6 = function (index, AmbientLightDataFromSystem) {
    return getColor3Data(index, AmbientLightDataFromSystem.colors);
};

var create$15 = ensureFunc$$1(function (light, AmbientLightData$$1) {
    it$$1("shouldn't create after Director->init", function () {
        wdet_1(isInit(DirectorData)).false;
    });
}, function (AmbientLightData$$1) {
    var light = new AmbientLight();
    light = create$11(light, AmbientLightData$$1);
    return light;
});
var getColor$5 = getColor$6;
var getColorArr3$7 = getColorArr3$8;
var setColor$4 = function (index, color, AmbientLightData$$1) {
    setColor$2(index, color, AmbientLightData$$1.colors);
    markDirty(index, AmbientLightData$$1.isColorDirtys);
};
var addComponent$10 = function (component, gameObject) {
    addComponent$7(component, gameObject, AmbientLightData);
};
var disposeComponent$12 = requireCheckFunc(function () {
    it$$1("should only has 1 ambient light", function () {
        wdet_1(AmbientLightData.count).equal(1);
    });
}, function (component) {
    disposeComponent$8(component.index, AmbientLightData);
    AmbientLightData.isColorDirtys[0] = AmbientLightData.defaultDirty;
});
var initData$51 = function (AmbientLightData$$1) {
    var count = getAmbientLightBufferCount(), size = Float32Array.BYTES_PER_ELEMENT * getColorDataSize$4() + Uint8Array.BYTES_PER_ELEMENT * getDirtyDataSize(), buffer = null;
    buffer = createSharedArrayBufferOrArrayBuffer(count * size);
    initData$25(buffer, AmbientLightData$$1);
    createTypeArrays$11(buffer, count, AmbientLightData$$1);
    _setDefaultTypeArrData$5(count, AmbientLightData$$1);
};
var _setDefaultTypeArrData$5 = function (count, AmbientLightData$$1) {
    var color = createDefaultColor$1();
    for (var i = 0; i < count; i++) {
        setColor$4(i, color, AmbientLightData$$1);
    }
};
var isColorDirty$4 = isColorDirty$5;
var cleanColorDirty$4 = cleanColorDirty$5;

var computeRadius$1 = function (color, constant, linear, quadratic) {
    var lightMax = Math.max(color[0], color[1], color[2]);
    return (-linear + Math.sqrt(Math.pow(linear, 2) - 4 * quadratic * (constant - (256.0 / 5.0) * lightMax)))
        / (2 * quadratic);
};

var computeRadius$$1 = computeRadius$1;
var initData$52 = function (PointLightData) {
    initDataHelper$1(PointLightData);
};

var sendUniformData$2 = function (gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap, materialData, lightMaterialData) {
    _sendUniformData$3(gl, materialIndex, shaderIndex, program, sendDataMap.glslSenderData, uniformLocationMap, uniformCacheMap, renderCommandUniformData, materialData, lightMaterialData);
    _sendUniformFuncData$1(gl, shaderIndex, program, sendDataMap, drawDataMap, uniformLocationMap, uniformCacheMap);
};
var _sendUniformData$3 = function (gl, materialIndex, shaderIndex, program, glslSenderData, uniformLocationMap, uniformCacheMap, renderCommandUniformData, materialData, lightMaterialData) {
    var sendUniformDataArr = glslSenderData.GLSLSenderDataFromSystem.sendUniformConfigMap[shaderIndex];
    for (var i = 0, len = sendUniformDataArr.length; i < len; i++) {
        var sendData = sendUniformDataArr[i], name = sendData.name, field = sendData.field, type = sendData.type, from = sendData.from || "cmd", data = _getUniformData$1(materialIndex, field, from, renderCommandUniformData, materialData, lightMaterialData);
        directlySendUniformData(gl, name, shaderIndex, program, type, data, glslSenderData, uniformLocationMap, uniformCacheMap);
    }
};
var _sendUniformFuncData$1 = function (gl, shaderIndex, program, sendDataMap, drawDataMap, uniformLocationMap, uniformCacheMap) {
    var sendUniformFuncDataArr = drawDataMap.GLSLSenderDataFromSystem.sendUniformFuncConfigMap[shaderIndex];
    for (var i = 0, len = sendUniformFuncDataArr.length; i < len; i++) {
        var sendFunc = sendUniformFuncDataArr[i];
        sendFunc(gl, shaderIndex, program, sendDataMap, uniformLocationMap, uniformCacheMap);
    }
};
var _getUniformData$1 = function (materialIndex, field, from, renderCommandUniformData, materialData, lightMaterialData) {
    var data = null;
    switch (from) {
        case "cmd":
            data = renderCommandUniformData[field];
            break;
        case "lightMaterial":
            data = _getUnifromDataFromLightMaterial(field, materialIndex, materialData, lightMaterialData);
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_UNKNOW("from:" + from));
            break;
    }
    return data;
};
var _getUnifromDataFromLightMaterial = function (field, index, _a, _b) {
    var getColorArr3 = _a.getColorArr3, getOpacity = _a.getOpacity, MaterialDataFromSystem = _a.MaterialDataFromSystem;
    var getEmissionColorArr3 = _b.getEmissionColorArr3, getSpecularColorArr3 = _b.getSpecularColorArr3, getShininess = _b.getShininess, getLightModel = _b.getLightModel, LightMaterialDataFromSystem = _b.LightMaterialDataFromSystem;
    var data = null;
    switch (field) {
        case "color":
            data = getColorArr3(index, MaterialDataFromSystem);
            break;
        case "emissionColor":
            data = getEmissionColorArr3(index, LightMaterialDataFromSystem);
            break;
        case "opacity":
            data = getOpacity(index, MaterialDataFromSystem);
            break;
        case "specularColor":
            data = getSpecularColorArr3(index, LightMaterialDataFromSystem);
            break;
        case "shininess":
            data = getShininess(index, LightMaterialDataFromSystem);
            break;
        case "lightModel":
            data = getLightModel(index, LightMaterialDataFromSystem);
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_UNKNOW("field:" + field));
            break;
    }
    return data;
};
var buildMaterialDataForGetUniformData$1 = function (getColorArr3, getOpacity, MaterialDataFromSystem) {
    return {
        getColorArr3: getColorArr3,
        getOpacity: getOpacity,
        MaterialDataFromSystem: MaterialDataFromSystem
    };
};
var buildLightMaterialDataForGetUniformData = function (getEmissionColorArr3, getSpecularColorArr3, getLightModel, getShininess, LightMaterialDataFromSystem) {
    return {
        getEmissionColorArr3: getEmissionColorArr3,
        getSpecularColorArr3: getSpecularColorArr3,
        getLightModel: getLightModel,
        getShininess: getShininess,
        LightMaterialDataFromSystem: LightMaterialDataFromSystem
    };
};

var sendUniformData$1 = function (gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap) {
    sendUniformData$2(gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap, buildMaterialDataForGetUniformData$1(getColorArr3$$1, getOpacity$$1, drawDataMap.MaterialDataFromSystem), buildLightMaterialDataForGetUniformData(getEmissionColorArr3$1, getSpecularColorArr3$1, getLightModel$1, getShininess$1, drawDataMap.LightMaterialDataFromSystem));
};

var render$7 = curry(function (ThreeDTransformData, GameObjectData, gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, deferDrawDataMap, initShaderDataMap, bufferData, cameraData) {
    render$4(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, buildDrawFuncDataMap(sendAttributeData$$1, sendUniformData$1, directlySendUniformData, use$$1, hasIndices$$1, getIndicesCount$$1, getIndexType$$1, getIndexTypeSize$$1, getVerticesCount$$1, bindAndUpdate$$1, getMapCount$$1, getStartTextureIndex, useShader$$1, bindGBuffer, unbindGBuffer, getNewTextureUnitIndex), drawDataMap, deferDrawDataMap, buildSendUniformDataDataMap(sendFloat1$1, sendFloat3$1, sendMatrix4$1, sendVector3$1, sendInt$1, sendMatrix3$1, getColorArr3$7, isColorDirty$4, cleanColorDirty$4, function (index, DirectionDataFromSystem) {
        return getPosition$1(index, ThreeDTransformData, GameObjectData, DirectionDataFromSystem).values;
    }, getColorArr3$3, getIntensity$$1, isPositionDirty$$1, isColorDirty$$1, isIntensityDirty$$1, cleanPositionDirty$$1, cleanColorDirty$$1, cleanIntensityDirty$$1, function (index, PointLightDataFromSystem) {
        return getPosition$3(index, ThreeDTransformData, GameObjectData, PointLightDataFromSystem).values;
    }, getColorArr3$5, getConstant$$1, getIntensity$2, getLinear$$1, getQuadratic$$1, getRange$$1, computeRadius$$1, isPositionDirty$2, isColorDirty$2, isIntensityDirty$2, isAttenuationDirty$$1, cleanPositionDirty$2, cleanColorDirty$2, cleanIntensityDirty$2, cleanAttenuationDirty$$1, drawDataMap), initShaderDataMap, bufferData, cameraData);
});

var init$11 = init$12;
var render$2 = curry(function (state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, deferDrawDataMap, initShaderDataMap, ThreeDTransformData, GameObjectData, renderCommandBufferForDrawData) {
    var DeviceManagerDataFromSystem = drawDataMap.DeviceManagerDataFromSystem, gl = getGL$$1(DeviceManagerDataFromSystem, state);
    render$3(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, render$5, render$7(ThreeDTransformData, GameObjectData), drawDataMap, deferDrawDataMap, initShaderDataMap, renderCommandBufferForDrawData);
    return state;
});
var sendAttributeData$$1 = function (gl, shaderIndex, geometryIndex, ProgramData, GLSLSenderData, GeometryData, VaoData) { return sendAttributeData$1(gl, shaderIndex, geometryIndex, ProgramData, GLSLSenderData, GeometryData, VaoData); };

var getOrCreateBuffer$1 = function (gl, geometryIndex, buffers, getDatas, GeometryDataFromSystem) {
    var buffer = buffers[geometryIndex];
    if (isBufferExist(buffer)) {
        return buffer;
    }
    buffer = gl.createBuffer();
    buffers[geometryIndex] = buffer;
    _initBuffer$1(gl, getDatas(geometryIndex, GeometryDataFromSystem), buffer);
    return buffer;
};
var _initBuffer$1 = function (gl, data, buffer) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    _resetBindedBuffer$1(gl);
};
var _resetBindedBuffer$1 = function (gl) {
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
};
var initData$53 = function (ArrayBufferDataFromSystemFromSystem) {
    ArrayBufferDataFromSystemFromSystem.vertexBuffers = [];
    ArrayBufferDataFromSystemFromSystem.normalBuffers = [];
    ArrayBufferDataFromSystemFromSystem.texCoordBuffers = [];
};

var sendAttributeData$4 = function (gl, shaderIndex, program, geometryIndex, getArrayBufferDataFuncMap, getAttribLocation, isAttributeLocationNotExist, sendBuffer, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, ArrayBufferDataFromSystem, GPUDetectDataFromSystem, VaoDataFromSystem) {
    var vaoExtension = getExtensionVao(GPUDetectDataFromSystem);
    if (hasExtension(vaoExtension)) {
        _bindVao$1(gl, vaoExtension, shaderIndex, geometryIndex, ProgramDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, VaoDataFromSystem);
    }
    else {
        _sendVbo(gl, shaderIndex, program, geometryIndex, getArrayBufferDataFuncMap, getAttribLocation, isAttributeLocationNotExist, sendBuffer, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, ArrayBufferDataFromSystem);
    }
};
var _sendVbo = function (gl, shaderIndex, program, geometryIndex, getArrayBufferDataFuncMap, getAttribLocation, isAttributeLocationNotExist, sendBuffer, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, ArrayBufferDataFromSystem) {
    var sendDataArr = GLSLSenderDataFromSystem.sendAttributeConfigMap[shaderIndex], attributeLocationMap = LocationDataFromSystem.attributeLocationMap[shaderIndex], lastBindedArrayBuffer = ProgramDataFromSystem.lastBindedArrayBuffer;
    for (var _i = 0, sendDataArr_1 = sendDataArr; _i < sendDataArr_1.length; _i++) {
        var sendData = sendDataArr_1[_i];
        var bufferName = sendData.buffer, buffer = _getOrCreateArrayBuffer(gl, geometryIndex, bufferName, getArrayBufferDataFuncMap, GeometryDataFromSystem, ArrayBufferDataFromSystem), pos = null;
        if (lastBindedArrayBuffer === buffer) {
            continue;
        }
        pos = getAttribLocation(gl, program, sendData.name, attributeLocationMap);
        if (isAttributeLocationNotExist(pos)) {
            continue;
        }
        lastBindedArrayBuffer = buffer;
        sendBuffer(gl, sendData.type, pos, buffer, geometryIndex, GLSLSenderDataFromSystem, ArrayBufferDataFromSystem);
    }
    ProgramDataFromSystem.lastBindedArrayBuffer = lastBindedArrayBuffer;
};
var _getOrCreateArrayBuffer = function (gl, geometryIndex, bufferName, _a, GeometryDataFromSystem, ArrayBufferDataFromSystem) {
    var getVertices = _a.getVertices, getNormals = _a.getNormals, getTexCoords = _a.getTexCoords;
    var buffer = null;
    switch (bufferName) {
        case "vertex":
            buffer = getOrCreateBuffer$1(gl, geometryIndex, ArrayBufferDataFromSystem.vertexBuffers, getVertices, GeometryDataFromSystem);
            break;
        case "normal":
            buffer = getOrCreateBuffer$1(gl, geometryIndex, ArrayBufferDataFromSystem.normalBuffers, getNormals, GeometryDataFromSystem);
            break;
        case "texCoord":
            buffer = getOrCreateBuffer$1(gl, geometryIndex, ArrayBufferDataFromSystem.texCoordBuffers, getTexCoords, GeometryDataFromSystem);
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_INVALID("bufferName:" + bufferName));
            break;
    }
    return buffer;
};
var buildDrawDataMap$2 = function (DeviceManagerDataFromSystem, TextureDataFromSystem, TextureCacheDataFromSystem, MapManagerDataFromSystem, MaterialDataFromSystem, BasicMaterialDataFromSystem, LightMaterialDataFromSystem, AmbientLightDataFromSystem, DirectionLightDataFromSystem, PointLightDataFromSystem, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, ArrayBufferDataFromSystem, IndexBufferDataFromSystem, BasicDrawRenderCommandBufferDataFromSystem, LightDrawRenderCommandBufferDataFromSystem) {
    return {
        DeviceManagerDataFromSystem: DeviceManagerDataFromSystem,
        TextureDataFromSystem: TextureDataFromSystem,
        TextureCacheDataFromSystem: TextureCacheDataFromSystem,
        MapManagerDataFromSystem: MapManagerDataFromSystem,
        MaterialDataFromSystem: MaterialDataFromSystem,
        BasicMaterialDataFromSystem: BasicMaterialDataFromSystem,
        LightMaterialDataFromSystem: LightMaterialDataFromSystem,
        AmbientLightDataFromSystem: AmbientLightDataFromSystem,
        DirectionLightDataFromSystem: DirectionLightDataFromSystem,
        PointLightDataFromSystem: PointLightDataFromSystem,
        ProgramDataFromSystem: ProgramDataFromSystem,
        LocationDataFromSystem: LocationDataFromSystem,
        GLSLSenderDataFromSystem: GLSLSenderDataFromSystem,
        GeometryDataFromSystem: GeometryDataFromSystem,
        ArrayBufferDataFromSystem: ArrayBufferDataFromSystem,
        IndexBufferDataFromSystem: IndexBufferDataFromSystem,
        BasicDrawRenderCommandBufferDataFromSystem: BasicDrawRenderCommandBufferDataFromSystem,
        LightDrawRenderCommandBufferDataFromSystem: LightDrawRenderCommandBufferDataFromSystem
    };
};
var _bindVao$1 = function (gl, extension, shaderIndex, geometryIndex, ProgramDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, _a) {
    var vaoMap = _a.vaoMap, vboArrayMap = _a.vboArrayMap;
    var vaoConfigData = GLSLSenderDataFromSystem.vaoConfigMap[shaderIndex], vao = getVao(geometryIndex, vaoMap);
    if (!isVaoExist(vao)) {
        vao = createAndInitVao$1(gl, extension, geometryIndex, vaoMap, vboArrayMap, vaoConfigData, GeometryDataFromSystem);
    }
    bindVao$2(extension, vao, ProgramDataFromSystem);
};

var buildDrawFuncDataMap$2 = function (bindIndexBuffer, sendAttributeData, sendUniformData, directlySendUniformData, use, hasIndices, getIndicesCount, getIndexType, getIndexTypeSize, getVerticesCount, bindAndUpdate, getMapCount, getStartTextureIndex$$1, useShader) {
    return {
        bindIndexBuffer: bindIndexBuffer,
        sendAttributeData: sendAttributeData,
        sendUniformData: sendUniformData,
        directlySendUniformData: directlySendUniformData,
        use: use,
        hasIndices: hasIndices,
        getIndicesCount: getIndicesCount,
        getIndexType: getIndexType,
        getIndexTypeSize: getIndexTypeSize,
        getVerticesCount: getVerticesCount,
        bindAndUpdate: bindAndUpdate,
        getMapCount: getMapCount,
        getStartTextureIndex: getStartTextureIndex$$1,
        useShader: useShader
    };
};
var drawGameObjects$1 = function (gl, state, material_config, shaderLib_generator, DataBufferConfig, definedStartTextureUnitIndex, useShaderName, initMaterialShader, drawFuncDataMap, drawDataMap, initShaderDataMap, sendDataMap, renderCommandUniformData, _a) {
    var _b = _a.renderCommandBufferData, mMatrices = _b.mMatrices, materialIndices = _b.materialIndices, geometryIndices = _b.geometryIndices, count = _a.count;
    var TextureDataFromSystem = drawDataMap.TextureDataFromSystem, TextureCacheDataFromSystem = drawDataMap.TextureCacheDataFromSystem, MapManagerDataFromSystem = drawDataMap.MapManagerDataFromSystem, ProgramDataFromSystem = drawDataMap.ProgramDataFromSystem, LocationDataFromSystem = drawDataMap.LocationDataFromSystem, GLSLSenderDataFromSystem = drawDataMap.GLSLSenderDataFromSystem, GeometryDataFromSystem = drawDataMap.GeometryDataFromSystem, ArrayBufferDataFromSystem = drawDataMap.ArrayBufferDataFromSystem, IndexBufferDataFromSystem = drawDataMap.IndexBufferDataFromSystem, bindIndexBuffer = drawFuncDataMap.bindIndexBuffer, sendAttributeData = drawFuncDataMap.sendAttributeData, sendUniformData = drawFuncDataMap.sendUniformData, directlySendUniformData = drawFuncDataMap.directlySendUniformData, use = drawFuncDataMap.use, hasIndices = drawFuncDataMap.hasIndices, getIndicesCount = drawFuncDataMap.getIndicesCount, getIndexType = drawFuncDataMap.getIndexType, getIndexTypeSize = drawFuncDataMap.getIndexTypeSize, getVerticesCount = drawFuncDataMap.getVerticesCount, getMapCount = drawFuncDataMap.getMapCount, getStartTextureIndex$$1 = drawFuncDataMap.getStartTextureIndex, bindAndUpdate = drawFuncDataMap.bindAndUpdate, useShader = drawFuncDataMap.useShader, GPUDetectDataFromSystem = initShaderDataMap.GPUDetectDataFromSystem, VaoDataFromSystem = initShaderDataMap.VaoDataFromSystem, mMatrixFloatArrayForSend = renderCommandUniformData.mMatrix, program = null;
    for (var i = 0; i < count; i++) {
        var matStartIndex = 16 * i, matEndIndex = matStartIndex + 16, geometryIndex = geometryIndices[i], materialIndex = materialIndices[i], mapCount = getMapCount(materialIndex, MapManagerDataFromSystem), startTextureUnitIndex = getStartTextureIndex$$1(materialIndex), drawMode = EDrawMode.TRIANGLES;
        var shaderIndex = useShader(materialIndex, useShaderName, state, material_config, shaderLib_generator, initMaterialShader, initShaderDataMap);
        program = use(gl, shaderIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem);
        sendAttributeData(gl, shaderIndex, program, geometryIndex, ProgramDataFromSystem, LocationDataFromSystem, GLSLSenderDataFromSystem, GeometryDataFromSystem, ArrayBufferDataFromSystem, GPUDetectDataFromSystem, VaoDataFromSystem);
        updateSendMatrixFloat32ArrayData(mMatrices, matStartIndex, matEndIndex, mMatrixFloatArrayForSend);
        var uniformLocationMap = LocationDataFromSystem.uniformLocationMap[shaderIndex], uniformCacheMap = GLSLSenderDataFromSystem.uniformCacheMap;
        sendUniformData(gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap);
        bindAndUpdate(gl, mapCount, startTextureUnitIndex, definedStartTextureUnitIndex, TextureCacheDataFromSystem, TextureDataFromSystem, MapManagerDataFromSystem, GPUDetectDataFromSystem);
        sendData$$1(gl, mapCount, startTextureUnitIndex, definedStartTextureUnitIndex, shaderIndex, program, sendDataMap.glslSenderData, uniformLocationMap, uniformCacheMap, directlySendUniformData, TextureDataFromSystem, MapManagerDataFromSystem);
        if (hasIndices(geometryIndex, GeometryDataFromSystem)) {
            if (!hasExtension(getExtensionVao(GPUDetectDataFromSystem))) {
                bindIndexBuffer(gl, geometryIndex, ProgramDataFromSystem, GeometryDataFromSystem, IndexBufferDataFromSystem);
            }
            drawElements(gl, geometryIndex, drawMode, getIndicesCount, getIndexType, getIndexTypeSize, GeometryDataFromSystem);
        }
        else {
            drawArray(gl, geometryIndex, drawMode, getVerticesCount, GeometryDataFromSystem);
        }
    }
};

var draw$2 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, _a) {
    var vMatrix = _a.vMatrix, pMatrix = _a.pMatrix, cameraPosition = _a.cameraPosition, normalMatrix = _a.normalMatrix;
    var LightDrawRenderCommandBufferDataFromSystem = drawDataMap.LightDrawRenderCommandBufferDataFromSystem, mMatrixFloatArrayForSend = LightDrawRenderCommandBufferDataFromSystem.mMatrixFloatArrayForSend;
    drawGameObjects$1(gl, state, material_config, shaderLib_generator, DataBufferConfig, 0, "FrontRenderLight", initMaterialShader, drawFuncDataMap, drawDataMap, initShaderDataMap, sendDataMap, buildRenderCommandUniformData$1(mMatrixFloatArrayForSend, vMatrix, pMatrix, cameraPosition, normalMatrix), bufferData);
    return state;
};

var render$10 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData) {
    draw$2(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData);
};
var buildSendUniformDataDataMap$2 = function (sendFloat1, sendFloat3, sendMatrix4, sendVector3, sendInt, sendMatrix3, getAmbientLightColorArr3, isAmbientLightColorDirty, cleanAmbientLightColorDirty, getDirectionLightPosition, getDirectionLightColorArr3, getDirectionLightIntensity, isDirectionLightPositionDirty, isDirectionLightColorDirty, isDirectionLightIntensityDirty, cleanDirectionLightPositionDirty, cleanDirectionLightColorDirty, cleanDirectionLightIntensityDirty, getPointLightPosition, getPointLightColorArr3, getConstant, getPointLightIntensity, getLinear, getQuadratic, getRange, isPointLightPositionDirty, isPointLightColorDirty, isPointLightIntensityDirty, isPointLightAttenuationDirty, cleanPointLightPositionDirty, cleanPointLightColorDirty, cleanPointLightIntensityDirty, cleanPointLightAttenuationDirty, drawDataMap) {
    return {
        glslSenderData: {
            sendMatrix3: sendMatrix3,
            sendMatrix4: sendMatrix4,
            sendVector3: sendVector3,
            sendInt: sendInt,
            sendFloat1: sendFloat1,
            sendFloat3: sendFloat3,
            GLSLSenderDataFromSystem: drawDataMap.GLSLSenderDataFromSystem
        },
        ambientLightData: {
            getColorArr3: getAmbientLightColorArr3,
            isColorDirty: isAmbientLightColorDirty,
            cleanColorDirty: cleanAmbientLightColorDirty,
            AmbientLightDataFromSystem: drawDataMap.AmbientLightDataFromSystem
        },
        directionLightData: {
            getPosition: getDirectionLightPosition,
            getColorArr3: getDirectionLightColorArr3,
            getIntensity: getDirectionLightIntensity,
            isPositionDirty: isDirectionLightPositionDirty,
            isColorDirty: isDirectionLightColorDirty,
            isIntensityDirty: isDirectionLightIntensityDirty,
            cleanPositionDirty: cleanDirectionLightPositionDirty,
            cleanColorDirty: cleanDirectionLightColorDirty,
            cleanIntensityDirty: cleanDirectionLightIntensityDirty,
            DirectionLightDataFromSystem: drawDataMap.DirectionLightDataFromSystem
        },
        pointLightData: {
            getPosition: getPointLightPosition,
            getColorArr3: getPointLightColorArr3,
            getIntensity: getPointLightIntensity,
            getConstant: getConstant,
            getLinear: getLinear,
            getQuadratic: getQuadratic,
            getRange: getRange,
            isPositionDirty: isPointLightPositionDirty,
            isColorDirty: isPointLightColorDirty,
            isIntensityDirty: isPointLightIntensityDirty,
            isAttenuationDirty: isPointLightAttenuationDirty,
            cleanPositionDirty: cleanPointLightPositionDirty,
            cleanColorDirty: cleanPointLightColorDirty,
            cleanIntensityDirty: cleanPointLightIntensityDirty,
            cleanAttenuationDirty: cleanPointLightAttenuationDirty,
            PointLightDataFromSystem: drawDataMap.PointLightDataFromSystem
        }
    };
};

var sendUniformData$3 = function (gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap) {
    sendUniformData$2(gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap, buildMaterialDataForGetUniformData$1(getColorArr3$$1, getOpacity$$1, drawDataMap.MaterialDataFromSystem), buildLightMaterialDataForGetUniformData(getEmissionColorArr3$1, getSpecularColorArr3$1, getLightModel$1, getShininess$1, drawDataMap.LightMaterialDataFromSystem));
};

var render$9 = curry(function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, initShaderDataMap, ThreeDTransformData, GameObjectData, bufferData, cameraData) {
    render$10(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, buildDrawFuncDataMap$2(bindIndexBuffer$$1, sendAttributeData$3, sendUniformData$3, directlySendUniformData, use$$1, hasIndices$$1, getIndicesCount$$1, getIndexType$$1, getIndexTypeSize$$1, getVerticesCount$$1, bindAndUpdate$$1, getMapCount$$1, getStartTextureIndex, useShader$$1), drawDataMap, buildSendUniformDataDataMap$2(sendFloat1$1, sendFloat3$1, sendMatrix4$1, sendVector3$1, sendInt$1, sendMatrix3$1, getColorArr3$7, isColorDirty$4, cleanColorDirty$4, function (index, DirectionLightDataFromSystem) {
        return getPosition$1(index, ThreeDTransformData, GameObjectData, DirectionLightDataFromSystem).values;
    }, getColorArr3$3, getIntensity$$1, isPositionDirty$$1, isColorDirty$$1, isIntensityDirty$$1, cleanPositionDirty$$1, cleanColorDirty$$1, cleanIntensityDirty$$1, function (index, PointLightDataFromSystem) {
        return getPosition$3(index, ThreeDTransformData, GameObjectData, PointLightDataFromSystem).values;
    }, getColorArr3$5, getConstant$$1, getIntensity$2, getLinear$$1, getQuadratic$$1, getRange$$1, isPositionDirty$2, isColorDirty$2, isIntensityDirty$2, isAttenuationDirty$$1, cleanPositionDirty$2, cleanColorDirty$2, cleanIntensityDirty$2, cleanAttenuationDirty$$1, drawDataMap), initShaderDataMap, bufferData, cameraData);
});

var draw$3 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, _a) {
    var vMatrix = _a.vMatrix, pMatrix = _a.pMatrix;
    var BasicDrawRenderCommandBufferDataFromSystem = drawDataMap.BasicDrawRenderCommandBufferDataFromSystem, mMatrixFloatArrayForSend = BasicDrawRenderCommandBufferDataFromSystem.mMatrixFloatArrayForSend;
    drawGameObjects$1(gl, state, material_config, shaderLib_generator, DataBufferConfig, 0, "BasicRender", initMaterialShader, drawFuncDataMap, drawDataMap, initShaderDataMap, sendDataMap, buildRenderCommandUniformData(mMatrixFloatArrayForSend, vMatrix, pMatrix), bufferData);
    return state;
};

var render$12 = function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData) {
    draw$3(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawFuncDataMap, drawDataMap, sendDataMap, initShaderDataMap, bufferData, cameraData);
};

var render$11 = curry(function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, initShaderDataMap, bufferData, cameraData) {
    render$12(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, buildDrawFuncDataMap$2(bindIndexBuffer$$1, sendAttributeData$3, _sendUniformData$4, directlySendUniformData, use$$1, hasIndices$$1, getIndicesCount$$1, getIndexType$$1, getIndexTypeSize$$1, getVerticesCount$$1, bindAndUpdate$$1, getMapCount$$1, getStartTextureIndex, useShader$$1), drawDataMap, buildSendUniformDataDataMap$1(sendFloat1$1, sendFloat3$1, sendMatrix4$1, sendVector3$1, sendInt$1, sendMatrix3$1, drawDataMap), initShaderDataMap, bufferData, cameraData);
});
var _sendUniformData$4 = function (gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap) {
    sendUniformData(gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap, buildMaterialDataForGetUniformData(getColorArr3$$1, getOpacity$$1, drawDataMap.MaterialDataFromSystem), buildBasicMaterialDataForGetUniformData(drawDataMap.BasicMaterialDataFromSystem));
};

var render$8 = curry(function (state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, initShaderDataMap, ThreeDTransformData, GameObjectData, _a) {
    var cameraData = _a.cameraData, basicData = _a.basicData, lightData = _a.lightData;
    var DeviceManagerDataFromSystem = drawDataMap.DeviceManagerDataFromSystem, gl = getGL$$1(DeviceManagerDataFromSystem, state);
    clear$$1(gl, DeviceManagerDataFromSystem);
    if (basicData.count > 0) {
        render$11(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, initShaderDataMap, basicData, cameraData);
    }
    if (lightData.count > 0) {
        render$9(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, initShaderDataMap, ThreeDTransformData, GameObjectData, lightData, cameraData);
    }
    return state;
});
var sendAttributeData$3 = function (gl, shaderIndex, program, geometryIndex, ProgramData, LocationData, GLSLSenderData, GeometryData, ArrayBufferData, GPUDetectData, VaoData) { return sendAttributeData$4(gl, shaderIndex, program, geometryIndex, {
    getVertices: getVertices$1,
    getNormals: getNormals$1,
    getTexCoords: getTexCoords$1
}, getAttribLocation, isAttributeLocationNotExist, sendBuffer$1, ProgramData, LocationData, GLSLSenderData, GeometryData, ArrayBufferData, GPUDetectData, VaoData); };

var WebGL2GLSLSenderDataCommon = (function () {
    function WebGL2GLSLSenderDataCommon() {
    }
    WebGL2GLSLSenderDataCommon.vaoConfigMap = null;
    WebGL2GLSLSenderDataCommon.uniformCacheMap = null;
    WebGL2GLSLSenderDataCommon.sendUniformConfigMap = null;
    WebGL2GLSLSenderDataCommon.sendUniformFuncConfigMap = null;
    WebGL2GLSLSenderDataCommon.vertexAttribHistory = null;
    WebGL2GLSLSenderDataCommon.uboBindingPoint = null;
    WebGL2GLSLSenderDataCommon.uboBindingPointMap = null;
    WebGL2GLSLSenderDataCommon.oneUboDataList = null;
    WebGL2GLSLSenderDataCommon.frameUboDataList = null;
    WebGL2GLSLSenderDataCommon.ambientLightUboDataList = null;
    WebGL2GLSLSenderDataCommon.directionLightUboDataList = null;
    WebGL2GLSLSenderDataCommon.pointLightUboDataList = null;
    return WebGL2GLSLSenderDataCommon;
}());

var WebGL2GLSLSenderData = (function (_super) {
    __extends(WebGL2GLSLSenderData, _super);
    function WebGL2GLSLSenderData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2GLSLSenderData;
}(WebGL2GLSLSenderDataCommon));

var WebGL1GLSLSenderDataCommon = (function () {
    function WebGL1GLSLSenderDataCommon() {
    }
    WebGL1GLSLSenderDataCommon.vaoConfigMap = null;
    WebGL1GLSLSenderDataCommon.uniformCacheMap = null;
    WebGL1GLSLSenderDataCommon.attributeLocationMap = null;
    WebGL1GLSLSenderDataCommon.sendAttributeConfigMap = null;
    WebGL1GLSLSenderDataCommon.sendUniformConfigMap = null;
    WebGL1GLSLSenderDataCommon.sendUniformFuncConfigMap = null;
    WebGL1GLSLSenderDataCommon.vertexAttribHistory = null;
    return WebGL1GLSLSenderDataCommon;
}());

var WebGL1GLSLSenderData = (function (_super) {
    __extends(WebGL1GLSLSenderData, _super);
    function WebGL1GLSLSenderData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1GLSLSenderData;
}(WebGL1GLSLSenderDataCommon));

var WebGL1ProgramDataCommon = (function () {
    function WebGL1ProgramDataCommon() {
    }
    WebGL1ProgramDataCommon.programMap = null;
    WebGL1ProgramDataCommon.lastUsedProgram = null;
    WebGL1ProgramDataCommon.lastBindedArrayBuffer = null;
    WebGL1ProgramDataCommon.lastBindedIndexBuffer = null;
    return WebGL1ProgramDataCommon;
}());

var WebGL1ProgramData = (function (_super) {
    __extends(WebGL1ProgramData, _super);
    function WebGL1ProgramData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1ProgramData;
}(WebGL1ProgramDataCommon));

var WebGL2ProgramDataCommon = (function () {
    function WebGL2ProgramDataCommon() {
    }
    WebGL2ProgramDataCommon.programMap = null;
    WebGL2ProgramDataCommon.lastUsedProgram = null;
    WebGL2ProgramDataCommon.lastBindedVao = null;
    return WebGL2ProgramDataCommon;
}());

var WebGL2ProgramData = (function (_super) {
    __extends(WebGL2ProgramData, _super);
    function WebGL2ProgramData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2ProgramData;
}(WebGL2ProgramDataCommon));

var VaoDataCommon = (function () {
    function VaoDataCommon() {
    }
    VaoDataCommon.vaoMap = null;
    VaoDataCommon.vboArrayMap = null;
    return VaoDataCommon;
}());

var VaoData = (function (_super) {
    __extends(VaoData, _super);
    function VaoData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return VaoData;
}(VaoDataCommon));

var WebGL1LocationDataCommon = (function () {
    function WebGL1LocationDataCommon() {
    }
    WebGL1LocationDataCommon.attributeLocationMap = null;
    WebGL1LocationDataCommon.uniformLocationMap = null;
    return WebGL1LocationDataCommon;
}());

var WebGL1LocationData = (function (_super) {
    __extends(WebGL1LocationData, _super);
    function WebGL1LocationData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1LocationData;
}(WebGL1LocationDataCommon));

var WebGL2LocationDataCommon = (function () {
    function WebGL2LocationDataCommon() {
    }
    WebGL2LocationDataCommon.uniformLocationMap = null;
    return WebGL2LocationDataCommon;
}());

var WebGL2LocationData = (function (_super) {
    __extends(WebGL2LocationData, _super);
    function WebGL2LocationData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2LocationData;
}(WebGL2LocationDataCommon));

var DeferDirectionLightPassDataCommon = (function () {
    function DeferDirectionLightPassDataCommon() {
    }
    DeferDirectionLightPassDataCommon.fullScreenQuadVertexArray = null;
    DeferDirectionLightPassDataCommon.fullScreenQuadIndicesCount = null;
    return DeferDirectionLightPassDataCommon;
}());

var DeferDirectionLightPassData = (function (_super) {
    __extends(DeferDirectionLightPassData, _super);
    function DeferDirectionLightPassData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeferDirectionLightPassData;
}(DeferDirectionLightPassDataCommon));

var DeferPointLightPassDataCommon = (function () {
    function DeferPointLightPassDataCommon() {
    }
    DeferPointLightPassDataCommon.fullScreenQuadVertexArray = null;
    DeferPointLightPassDataCommon.fullScreenQuadIndicesCount = null;
    DeferPointLightPassDataCommon.scissorRegionArrayCacheMap = null;
    return DeferPointLightPassDataCommon;
}());

var DeferPointLightPassData = (function (_super) {
    __extends(DeferPointLightPassData, _super);
    function DeferPointLightPassData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeferPointLightPassData;
}(DeferPointLightPassDataCommon));

var DeferAmbientLightPassDataCommon = (function () {
    function DeferAmbientLightPassDataCommon() {
    }
    DeferAmbientLightPassDataCommon.fullScreenQuadVertexArray = null;
    DeferAmbientLightPassDataCommon.fullScreenQuadIndicesCount = null;
    return DeferAmbientLightPassDataCommon;
}());

var DeferAmbientLightPassData = (function (_super) {
    __extends(DeferAmbientLightPassData, _super);
    function DeferAmbientLightPassData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeferAmbientLightPassData;
}(DeferAmbientLightPassDataCommon));

var _checkLightCount = requireCheckFunc(function (ambientLightCount, directionLightCount, pointLightCount, AmbientLightData$$1, DirectionLightData, PointLightData) {
    it$$1("count should <= max count", function () {
        wdet_1(AmbientLightData$$1.count).lte(ambientLightCount);
        wdet_1(DirectionLightData.count).lte(directionLightCount);
        wdet_1(PointLightData.count).lte(pointLightCount);
    });
}, function () {
});
var init$$1 = null;
var render$1 = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    if (isWebgl1$1()) {
        init$$1 = function (state) {
            _checkLightCount(DataBufferConfig.frontAmbientLightCount, DataBufferConfig.frontDirectionLightCount, DataBufferConfig.frontDirectionLightCount, AmbientLightData, WebGL1DirectionLightData, WebGL1PointLightData);
            return _init_1(state, {
                ambientLightData: {
                    buffer: AmbientLightData.buffer,
                    bufferCount: getAmbientLightBufferCount(),
                    lightCount: AmbientLightData.count
                },
                directionLightData: {
                    buffer: WebGL1DirectionLightData.buffer,
                    bufferCount: getDirectionLightBufferCount(),
                    lightCount: WebGL1DirectionLightData.count,
                    directionLightGLSLDataStructureMemberNameArr: WebGL1DirectionLightData.lightGLSLDataStructureMemberNameArr
                },
                pointLightData: {
                    buffer: WebGL1PointLightData.buffer,
                    bufferCount: getPointLightBufferCount(),
                    lightCount: WebGL1PointLightData.count,
                    pointLightGLSLDataStructureMemberNameArr: WebGL1PointLightData.lightGLSLDataStructureMemberNameArr
                }
            }, null);
        };
        render$1 = function (state) {
            _render_1(state, WebGL1DirectionLightData, WebGL1PointLightData);
        };
    }
    else {
        init$$1 = function (state) {
            _checkLightCount(DataBufferConfig.deferAmbientLightCount, DataBufferConfig.deferDirectionLightCount, DataBufferConfig.deferPointLightCount, AmbientLightData, WebGL2DirectionLightData, WebGL2PointLightData);
            return _init_1(state, {
                directionLightData: {
                    buffer: WebGL2DirectionLightData.buffer,
                    bufferCount: getDirectionLightBufferCount(),
                    lightCount: WebGL2DirectionLightData.count
                },
                pointLightData: {
                    buffer: WebGL2PointLightData.buffer,
                    bufferCount: getPointLightBufferCount(),
                    lightCount: WebGL2PointLightData.count
                },
            }, {
                deferShading: {
                    isInit: true
                }
            });
        };
        render$1 = function (state) {
            _render_1(state, WebGL2DirectionLightData, WebGL2PointLightData);
        };
    }
    var _init_1 = function (state, lightData, renderData) {
        initMapManagers(null, TextureData);
        var renderWorker = getRenderWorker(WorkerInstanceData), needAddedImageDataArr = convertAllSourceMapToImageDataArr(getNeedAddedSourceArr(TextureData), DomQuery), transferList = [];
        transferList = transferList.concat(needAddedImageDataArr.map(function (_a) {
            var arrayBuffer = _a.arrayBuffer;
            return arrayBuffer;
        }));
        renderWorker.postMessage({
            operateType: EWorkerOperateType.INIT_MATERIAL_GEOMETRY_LIGHT_TEXTURE,
            materialData: {
                buffer: MaterialData.buffer,
                basicMaterialData: {
                    startIndex: getBasicMaterialBufferStartIndex(),
                    index: BasicMaterialData.index
                },
                lightMaterialData: {
                    startIndex: getLightMaterialBufferStartIndex(),
                    index: LightMaterialData.index
                }
            },
            geometryData: {
                buffer: GeometryData.buffer,
                indexType: GeometryData.indexType,
                indexTypeSize: GeometryData.indexTypeSize,
                verticesInfoList: GeometryData.verticesInfoList,
                normalsInfoList: GeometryData.normalsInfoList,
                texCoordsInfoList: GeometryData.texCoordsInfoList,
                indicesInfoList: GeometryData.indicesInfoList
            },
            lightData: lightData,
            textureData: {
                mapManagerBuffer: MapManagerData.buffer,
                textureBuffer: TextureData.buffer,
                index: TextureData.index,
                needAddedImageDataArr: needAddedImageDataArr,
                uniformSamplerNameMap: getUniformSamplerNameMap(TextureData)
            },
            renderData: renderData
        }, transferList);
        clearNeedAddedSourceArr(TextureData);
        clearNeedInitTextureDataArr(TextureData);
        renderWorker.onmessage = function (e) {
            var data = e.data, state = data.state;
            SendDrawRenderCommandBufferData.state = state;
        };
        return state;
    };
    var _render_1 = function (state, DirectionLightData, PointLightData) {
        return compose(sendDrawData(DomQuery, WorkerInstanceData, MapManagerData, TextureData, MaterialData, GeometryData, ThreeDTransformData, GameObjectData, AmbientLightData, DirectionLightData, PointLightData), createRenderCommandBufferData$6(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData), getRenderList(state))(MeshRendererData);
    };
}
else {
    if (isWebgl1$1()) {
        init$$1 = function (state) {
            var gl = getGL$$1(DeviceManagerData, state);
            initState(state, getGL$$1, setSide$$1, DeviceManagerData);
            init$10(state, gl, webgl1_material_config, webgl1_shaderLib_generator, initNoMaterialShader$3, TextureData, MaterialData, BasicMaterialData, LightMaterialData, GPUDetectData, WebGL1GLSLSenderData, WebGL1ProgramData, VaoData, WebGL1LocationData, WebGL1ShaderData);
            _checkLightCount(DataBufferConfig.frontAmbientLightCount, DataBufferConfig.frontDirectionLightCount, DataBufferConfig.frontPointLightCount, AmbientLightData, WebGL1DirectionLightData, WebGL1PointLightData);
        };
        render$1 = function (state) {
            return compose(render$8(state, render_config, webgl1_material_config, webgl1_shaderLib_generator, DataBufferConfig, initMaterialShader$3, buildDrawDataMap$2(DeviceManagerData, TextureData, TextureCacheData, MapManagerData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, WebGL1DirectionLightData, WebGL1PointLightData, WebGL1ProgramData, WebGL1LocationData, WebGL1GLSLSenderData, GeometryData, ArrayBufferData, IndexBufferData, BasicDrawRenderCommandBufferData, LightDrawRenderCommandBufferData), buildInitShaderDataMap(DeviceManagerData, WebGL1ProgramData, WebGL1LocationData, WebGL1GLSLSenderData, WebGL1ShaderData, MapManagerData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, WebGL1DirectionLightData, WebGL1PointLightData, GPUDetectData, VaoData), ThreeDTransformData, GameObjectData), clearColor$$1(state, render_config, DeviceManagerData), createRenderCommandBufferData$$1(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData), getRenderList(state))(MeshRendererData);
        };
    }
    else {
        init$$1 = function (state) {
            var gl = getGL$$1(DeviceManagerData, state);
            initState(state, getGL$$1, setSide$$1, DeviceManagerData);
            init$8(state, gl, webgl2_material_config, webgl2_shaderLib_generator, initNoMaterialShader$$1, TextureData, MaterialData, BasicMaterialData, LightMaterialData, GPUDetectData, WebGL2GLSLSenderData, WebGL2ProgramData, VaoData, WebGL2LocationData, WebGL2ShaderData);
            init$11(gl, render_config, DataBufferConfig, GBufferData, DeferAmbientLightPassData, DeferDirectionLightPassData, DeferPointLightPassData, WebGL2ShaderData, WebGL2ProgramData, WebGL2LocationData, WebGL2GLSLSenderData, GPUDetectData);
            _checkLightCount(DataBufferConfig.deferAmbientLightCount, DataBufferConfig.deferDirectionLightCount, DataBufferConfig.deferPointLightCount, AmbientLightData, WebGL2DirectionLightData, WebGL2PointLightData);
        };
        render$1 = function (state) {
            return compose(render$2(state, render_config, webgl2_material_config, webgl2_shaderLib_generator, DataBufferConfig, initMaterialShader$$1, buildDrawDataMap$1(DeviceManagerData, TextureData, TextureCacheData, MapManagerData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, WebGL2DirectionLightData, WebGL2PointLightData, WebGL2ProgramData, WebGL2LocationData, WebGL2GLSLSenderData, GeometryData, BasicDrawRenderCommandBufferData, LightDrawRenderCommandBufferData), buildDrawDataMap(GBufferData, DeferAmbientLightPassData, DeferDirectionLightPassData, DeferPointLightPassData), buildInitShaderDataMap(DeviceManagerData, WebGL2ProgramData, WebGL2LocationData, WebGL2GLSLSenderData, WebGL2ShaderData, MapManagerData, MaterialData, BasicMaterialData, LightMaterialData, AmbientLightData, WebGL2DirectionLightData, WebGL2PointLightData, GPUDetectData, VaoData), ThreeDTransformData, GameObjectData), clearColor$$1(state, render_config, DeviceManagerData), createRenderCommandBufferData$$1(state, GlobalTempData, GameObjectData, ThreeDTransformData, CameraControllerData, CameraData, MaterialData, GeometryData, SceneData, BasicRenderCommandBufferData, LightRenderCommandBufferData), getRenderList(state))(MeshRendererData);
        };
    }
}

var getState = function (DirectorData) {
    return DirectorData.state;
};
var setState = function (state, DirectorData) {
    return IO.of(function () {
        DirectorData.state = state;
    });
};
var markIsInit = function (DirectorData) {
    DirectorData.isInit = true;
};
var isInit = function (DirectorData) {
    return DirectorData.isInit === true;
};
var run = null;
var render$$1 = null;
var _sync = function (elapsed, state, scheduler) {
    scheduler.update(elapsed);
    var resultState = updateSystem(elapsed, state);
    return resultState;
};
var updateSystem = function (elapsed, state) {
    var resultState = update$1(elapsed, GlobalTempData, ThreeDTransformData, state);
    resultState = update$4(PerspectiveCameraData, CameraData, CameraControllerData, state);
    return resultState;
};
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    run = function (elapsed, state, timeController, scheduler) {
        var resultState = state;
        if (SendDrawRenderCommandBufferData.state === ERenderWorkerState.INIT_COMPLETE) {
            SendDrawRenderCommandBufferData.isInitComplete = true;
            SendDrawRenderCommandBufferData.state = ERenderWorkerState.DEFAULT;
        }
        else if (!SendDrawRenderCommandBufferData.isInitComplete) {
            return resultState;
        }
        if (SendDrawRenderCommandBufferData.state === ERenderWorkerState.DRAW_COMPLETE) {
            timeController.tick(elapsed);
            SendDrawRenderCommandBufferData.state = ERenderWorkerState.DEFAULT;
            resultState = _sync(elapsed, state, scheduler);
        }
        else if (SendDrawRenderCommandBufferData.state !== ERenderWorkerState.DRAW_WAIT) {
            SendDrawRenderCommandBufferData.state = ERenderWorkerState.DRAW_WAIT;
            resultState = render$$1(resultState);
        }
        return resultState;
    };
    render$$1 = function (state) {
        var resultState = null;
        resultState = render$1(state);
        return resultState;
    };
}
else {
    run = function (elapsed, state, timeController, scheduler) {
        var resultState = state;
        timeController.tick(elapsed);
        resultState = _sync(elapsed, state, scheduler);
        resultState = render$$1(resultState);
        return resultState;
    };
    render$$1 = function (state) {
        var resultState = render$1(state);
        return resultState;
    };
}
var initData$6 = function (DirectorData) {
    DirectorData.isInit = false;
    DirectorData.state = createState();
};

var Texture = (function () {
    function Texture() {
        this.index = null;
    }
    return Texture;
}());
var createTexture = function () {
    return create(TextureData);
};
var initTexture$1 = function (texture) {
    initTexture$$1(getGL$$1(DeviceManagerData), texture.index, TextureData);
};
var disposeTexture = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture) {
    dispose(getGL$$1(DeviceManagerData, getState(DirectorData)), texture, TextureCacheData, TextureData, GPUDetectData);
});
var getTextureSource = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture) {
    return getSource$$1(texture.index, TextureData);
});
var setTextureSource = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture, source) {
    setSource(texture.index, source, TextureData);
});
var getTextureWidth = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture) {
    return getWidth$$1(texture.index, TextureData);
});
var setTextureWidth = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture, value) {
    setWidth(texture.index, value, TextureData);
});
var getTextureHeight = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture) {
    return getHeight$$1(texture.index, TextureData);
});
var setTextureHeight = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture, value) {
    setHeight(texture.index, value, TextureData);
});
var getTextureIsNeedUpdate = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture) {
    return getIsNeedUpdate$$1(texture.index, TextureData);
});
var setTextureIsNeedUpdate = requireCheckFunc(function (texture) {
    _checkShouldAlive(texture);
}, function (texture, value) {
    setIsNeedUpdate(texture.index, value, TextureData);
});
var _checkShouldAlive = function (texture) {
    checkComponentShouldAlive(texture, null, function (texture) {
        return isComponentIndexNotRemoved(texture);
    });
};

var getImageData = function (source, width, height, DomQuery) {
    var canvas = DomQuery.create("<canvas></canvas>").get(0), ctx = null;
    canvas.width = width;
    canvas.height = height;
    ctx = canvas.getContext("2d");
    ctx.drawImage(source, 0, 0);
    return ctx.getImageData(0, 0, width, height);
};

var create = ensureFunc$$1(function (component) {
    it$$1("index should <= max count", function () {
        wdet_1(component.index).lte(getBufferCount$1());
    });
}, function (TextureData) {
    var texture = new Texture(), index = generateComponentIndex(TextureData);
    texture.index = index;
    TextureData.textureMap[index] = texture;
    return texture;
});
var getSource$$1 = getSource$1;
var getWidth$$1 = getWidth$2;
var setWidth = function (textureIndex, value, TextureData) {
    setTypeArrayValue(TextureData.widths, textureIndex, value);
};
var getHeight$$1 = getHeight$2;
var setHeight = function (textureIndex, value, TextureData) {
    setTypeArrayValue(TextureData.heights, textureIndex, value);
};
var getIsNeedUpdate$$1 = getIsNeedUpdate$1;
var setIsNeedUpdate = function (textureIndex, value, TextureData) {
    setTypeArrayValue(TextureData.isNeedUpdates, textureIndex, value);
};
var markNeedUpdate$$1 = markNeedUpdate$1;
var setUniformSamplerName = function (index, name, TextureData) {
    TextureData.uniformSamplerNameMap[index] = name;
};
var bindToUnit$$1 = function (gl, unitIndex, textureIndex, TextureCacheData, TextureData, GPUDetectData) {
    bindToUnit$1(gl, unitIndex, textureIndex, TextureCacheData, TextureData, GPUDetectData, isCached$$1, addActiveTexture$$1);
};
var needUpdate$$1 = needUpdate$1;
var update$$1 = function (gl, textureIndex, TextureData) {
    update$3(gl, textureIndex, _setFlipY, TextureData);
};
var _setFlipY = function (gl, flipY) {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
};
var dispose = function (gl, texture, TextureCacheData, TextureData, GPUDetectData) {
    var bufferDataSize = getBufferDataSize(), sourceIndex = texture.index, lastComponentIndex = null;
    TextureData.index -= 1;
    lastComponentIndex = TextureData.index;
    deleteOneItemBySwapAndReset(sourceIndex * bufferDataSize, lastComponentIndex * bufferDataSize, TextureData.widths, TextureData.defaultWidth);
    deleteOneItemBySwapAndReset(sourceIndex * bufferDataSize, lastComponentIndex * bufferDataSize, TextureData.heights, TextureData.defaultHeight);
    deleteOneItemBySwapAndReset(sourceIndex * bufferDataSize, lastComponentIndex * bufferDataSize, TextureData.isNeedUpdates, TextureData.defaultIsNeedUpdate);
    disposeSourceMap(sourceIndex, lastComponentIndex, TextureData);
    deleteComponentBySwapArray(sourceIndex, lastComponentIndex, TextureData.textureMap);
    _disposeGLTexture(gl, sourceIndex, lastComponentIndex, TextureCacheData, TextureData, GPUDetectData);
    _addDisposeDataForWorker(sourceIndex, lastComponentIndex, TextureData);
};
var addNeedInitTextureIndexForWorker = null;
var initTextures$$1 = null;
var initTexture$$1 = null;
var setSource = null;
var _disposeGLTexture = null;
var _addDisposeDataForWorker = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    initTextures$$1 = function (gl, TextureDataFromSystem) {
        for (var i = 0; i < TextureDataFromSystem.index; i++) {
            initTexture$$1(gl, i, TextureDataFromSystem);
        }
    };
    initTexture$$1 = function (gl, textureIndex, TextureData) {
        addNeedInitTextureIndexForWorker(textureIndex, TextureData);
    };
    addNeedInitTextureIndexForWorker = function (textureIndex, TextureData) {
        TextureData.needInitedTextureIndexArr.push(textureIndex);
    };
    setSource = function (textureIndex, source, TextureData) {
        TextureData.sourceMap[textureIndex] = source;
        TextureData.needAddedSourceArr.push(source);
    };
    _disposeGLTexture = function () {
        
    };
    _addDisposeDataForWorker = function (sourceIndex, lastComponentIndex, TextureData) {
        TextureData.disposedTextureDataMap.push(_buildDisposedTextureData_1(sourceIndex, lastComponentIndex));
    };
    var _buildDisposedTextureData_1 = function (sourceIndex, lastComponentIndex) {
        return {
            sourceIndex: sourceIndex,
            lastComponentIndex: lastComponentIndex
        };
    };
}
else {
    initTextures$$1 = initTextures$1;
    initTexture$$1 = initTexture$2;
    addNeedInitTextureIndexForWorker = function () {
    };
    setSource = function (textureIndex, source, TextureData) {
        TextureData.sourceMap[textureIndex] = source;
    };
    _disposeGLTexture = function (gl, sourceIndex, lastComponentIndex, TextureCacheData, TextureData, GPUDetectData) {
        disposeGLTexture(gl, sourceIndex, lastComponentIndex, TextureCacheData, TextureData, GPUDetectData);
    };
    _addDisposeDataForWorker = function (sourceIndex, lastComponentIndex, TextureData) {
    };
}
var getDisposedTextureDataMap = function (TextureData) {
    return TextureData.disposedTextureDataMap;
};
var hasDisposedTextureDataMap = function (TextureData) {
    return TextureData.disposedTextureDataMap.length > 0;
};
var clearDisposedTextureDataMap = function (TextureData) {
    TextureData.disposedTextureDataMap = [];
};
var getNeedInitedTextureDataArr = function (TextureData) {
    return TextureData.needInitedTextureIndexArr;
};
var hasNeedInitTextureDataArr = function (TextureData) {
    return TextureData.needInitedTextureIndexArr.length > 0;
};
var clearNeedInitTextureDataArr = function (TextureData) {
    TextureData.needInitedTextureIndexArr = [];
};
var clearNeedAddedSourceArr = function (TextureData) {
    TextureData.needAddedSourceArr = [];
};
var getNeedAddedSourceArr = function (TextureData) {
    return TextureData.needAddedSourceArr;
};
var convertAllSourceMapToImageDataArr = function (sourceMap, DomQuery) {
    var arr = [];
    forEach(sourceMap, function (source, index) {
        if (_isSourceNotExist(source)) {
            return;
        }
        var width = source.width, height = source.height;
        arr.push({
            arrayBuffer: _getArrayBuffer(getImageData(source, width, height, DomQuery)),
            width: width,
            height: height,
            index: index
        });
    });
    return arr;
};
var convertNeedInitedSourceMapToImageDataArr = requireCheckFunc(function (sourceMap, needInitedTextureDataArr, DomQuery) {
    it$$1("needInitedTextureDataArr should corresponding to sourceMap", function () {
        wdet_1(needInitedTextureDataArr.length).equal(sourceMap.length);
    });
}, function (sourceMap, needInitedTextureDataArr, DomQuery) {
    var arr = [];
    forEach(sourceMap, function (source, index) {
        if (_isSourceNotExist(source)) {
            return;
        }
        var width = source.width, height = source.height;
        arr.push({
            arrayBuffer: _getArrayBuffer(getImageData(source, width, height, DomQuery)),
            width: width,
            height: height,
            index: needInitedTextureDataArr[index]
        });
    });
    return arr;
});
var _getArrayBuffer = function (imageData) { return imageData.data.buffer; };
var getUniformSamplerNameMap = function (TextureData) {
    return TextureData.uniformSamplerNameMap;
};
var _isSourceNotExist = function (source) { return isNotValidVal(source); };
var initData$1 = function (TextureCacheData, TextureData) {
    initData$2(TextureCacheData);
    TextureData.index = 0;
    TextureData.glTextures = [];
    TextureData.sourceMap = [];
    TextureData.textureMap = [];
    TextureData.uniformSamplerNameMap = [];
    TextureData.disposedTextureDataMap = [];
    TextureData.needInitedTextureIndexArr = [];
    TextureData.needAddedSourceArr = [];
    _setDefaultData(TextureData);
    _initBufferData(TextureData);
};
var _setDefaultData = function (TextureData) {
    TextureData.defaultWidth = 0;
    TextureData.defaultHeight = 0;
    TextureData.defaultIsNeedUpdate = 0;
};
var _initBufferData = function (TextureData) {
    var buffer = null, count = getBufferCount$1(), size = Float32Array.BYTES_PER_ELEMENT * (getBufferDataSize() * 2) + Uint8Array.BYTES_PER_ELEMENT * (getBufferDataSize()), offset = null;
    buffer = createSharedArrayBufferOrArrayBuffer(computeBufferLength(count, size));
    offset = createTypeArrays$2(buffer, count, TextureData);
    _setDefaultTypeArrData(count, TextureData);
    TextureData.buffer = buffer;
};
var _setDefaultTypeArrData = function (count, TextureData) {
    var width = TextureData.defaultWidth, height = TextureData.defaultHeight, isNeedUpdate = TextureData.defaultIsNeedUpdate;
    for (var i = 0; i < count; i++) {
        setWidth(i, width, TextureData);
        setHeight(i, height, TextureData);
        setIsNeedUpdate(i, isNeedUpdate, TextureData);
    }
};

var TextureAsset = (function () {
    function TextureAsset() {
        this._width = null;
        this._height = null;
        this.format = ETextureFormat.RGBA;
        this.source = null;
        this.type = ETextureType.UNSIGNED_BYTE;
        this.needUpdate = true;
    }
    Object.defineProperty(TextureAsset.prototype, "width", {
        get: function () {
            return this._width === null ? (this.source ? this.source.width : null) : this._width;
        },
        set: function (width) {
            this._width = width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureAsset.prototype, "height", {
        get: function () {
            return this._height === null ? (this.source ? this.source.height : null) : this._height;
        },
        set: function (height) {
            this._height = height;
        },
        enumerable: true,
        configurable: true
    });
    TextureAsset.prototype.cloneTo = function (textureIndex) {
        setSource(textureIndex, this.source, TextureData);
        setWidth(textureIndex, this.width, TextureData);
        setHeight(textureIndex, this.height, TextureData);
        markNeedUpdate$$1(textureIndex, this.needUpdate, TextureData);
    };
    __decorate([
        requireCheck$1(function (textureIndex) {
            it$$1("textureIndex should exist", function () {
                wdet_1(textureIndex).exist;
            });
        })
    ], TextureAsset.prototype, "cloneTo", null);
    return TextureAsset;
}());

var ImageTextureAsset = (function (_super) {
    __extends(ImageTextureAsset, _super);
    function ImageTextureAsset(source) {
        var _this = _super.call(this) || this;
        _this.source = source;
        return _this;
    }
    ImageTextureAsset.create = function (source) {
        var obj = new this(source);
        return obj;
    };
    ImageTextureAsset.prototype.toTexture = function () {
        var texture = create(TextureData);
        this.cloneTo(texture.index);
        return texture;
    };
    return ImageTextureAsset;
}(TextureAsset));

var load$2 = function (url, id, loadFunc, _a) {
    var container = _a.container;
    var data = null, stream = null;
    data = container.getChild(id);
    if (data) {
        stream = just(data);
    }
    else {
        stream = loadFunc(url, id)
            .do(function (data) {
            container.addChild(id, data);
        }, function (err) {
            _errorHandle(url, err);
        }, null);
    }
    return stream;
};
var _errorHandle = function (path, err) {
    Log$$1.log("load " + path + " asset fail:" + err);
};

var load$1 = function (url, id, AssetDatabaseData) {
    return load$2(url, id, _load$1, AssetDatabaseData);
};
var _load$1 = function (url, id) {
    var extname = null, stream = null;
    extname = PathUtils.extname(url).toLowerCase();
    switch (extname) {
        case ".jpg":
        case ".jpeg":
        case ".gif":
        case ".bmp":
        case ".png":
            stream = _loadImage(url)
                .map(function (image) {
                return createImageTextureAsset(image, extname);
            });
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_NOT_SUPPORT(extname));
            break;
    }
    return stream;
};
var _setTextureAssetByExtname = function (asset, extname) {
    switch (extname) {
        case ".jpg":
        case ".jpeg":
        case ".gif":
        case ".bmp":
            asset.format = ETextureFormat.RGB;
            break;
        case ".png":
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_NOT_SUPPORT(extname));
            break;
    }
    return asset;
};
var _loadImage = function (url) {
    return fromPromise(new Promise(function (resolve, reject) {
        var img = null;
        img = new root$2.Image();
        img.onload = function () {
            this.onload = null;
            resolve(img);
        };
        img.onerror = function () {
            reject("error");
        };
        img.src = url;
    }));
};
var createImageTextureAsset = function (source, extname) {
    return _setTextureAssetByExtname(ImageTextureAsset.create(source), extname);
};

var IdleTaskData = (function () {
    function IdleTaskData() {
    }
    IdleTaskData.taskList = null;
    IdleTaskData.taskHandleForCancel = null;
    IdleTaskData.totalTaskCount = null;
    IdleTaskData.currentTaskNumber = null;
    return IdleTaskData;
}());

var root$3 = window;
root$3.requestIdleCallback = root$3.requestIdleCallback || function (handler) {
    var startTime = Date.now();
    return setTimeout(function () {
        handler({
            didTimeout: false,
            timeRemaining: function () {
                return Math.max(0, 50.0 - (Date.now() - startTime));
            }
        });
    }, 1);
};
root$3.cancelIdleCallback = root$3.cancelIdleCallback || function (id) {
    clearTimeout(id);
};

var enqueueTaskReturnPromise = function (timeout$$1) {
    if (timeout$$1 === void 0) { timeout$$1 = 1000; }
    return fromPromise(new Promise(function (resolve, reject) {
        enqueueTask(_isIdle, resolve, timeout$$1);
    }))
        .ignoreElements();
};
var _isIdle = function (resolve) {
    resolve(true);
};
var enqueueTask = function (taskHandler, taskData, timeout$$1) {
    if (timeout$$1 === void 0) { timeout$$1 = 1000; }
    var taskList = IdleTaskData.taskList;
    var _runTaskQueue = function (deadline) {
        while ((deadline.timeRemaining() > 0 || deadline.didTimeout) && taskList.length > 0) {
            var task = taskList.shift();
            IdleTaskData.currentTaskNumber += 1;
            task.handler(task.data);
        }
        if (taskList.length > 0) {
            IdleTaskData.taskHandleForCancel = root$3.requestIdleCallback(_runTaskQueue, { timeout: timeout$$1 });
        }
        else {
            IdleTaskData.taskHandleForCancel = 0;
        }
    };
    taskList.push({
        handler: taskHandler,
        data: taskData
    });
    IdleTaskData.totalTaskCount += 1;
    IdleTaskData.taskHandleForCancel = root$3.requestIdleCallback(_runTaskQueue, { timeout: timeout$$1 });
};
var _initData = function (IdleTaskData$$1) {
    IdleTaskData$$1.taskList = [];
    IdleTaskData$$1.taskHandleForCancel = 0;
    IdleTaskData$$1.totalTaskCount = 0;
    IdleTaskData$$1.currentTaskNumber = 0;
};
_initData(IdleTaskData);

function load$$1() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return enqueueTaskReturnPromise(args[2])
        .concat(_load(args[0], args[1]));
}
function _load() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var AssetDatabaseData = args[1];
    if (!isArray(args[0])) {
        var _a = args[0], url = _a.url, id = _a.id;
        return _createLoadSingleAssetStream(url, id, AssetDatabaseData);
    }
    else {
        var assetArr = args[0];
        return fromArray(assetArr).concatMap(function (_a) {
            var url = _a.url, id = _a.id;
            return _createLoadSingleAssetStream(url, id, AssetDatabaseData);
        });
    }
}
var _createLoadSingleAssetStream = function (url, id, AssetDatabaseData) {
    if (!has(id, AssetDatabaseData)) {
        AssetDatabaseData.totalAssertCount += 1;
    }
    return _getLoadFunc(url)(url, id, AssetDatabaseData)
        .map(function () {
        AssetDatabaseData.currentLoadedCount += 1;
        return {
            currentLoadedCount: AssetDatabaseData.currentLoadedCount,
            totalAssetCount: AssetDatabaseData.totalAssertCount
        };
    });
};
var _getLoadFunc = function (url) {
    var extname = PathUtils.extname(url), load$$1 = null;
    switch (extname) {
        case ".jpg":
        case ".jpeg":
        case ".png":
        case ".gif":
        case ".bmp":
            load$$1 = load$1;
            break;
        default:
            Log$$1.error(true, Log$$1.info.FUNC_UNKNOW("extname:" + extname));
            break;
    }
    return load$$1;
};
var get = function (id, _a) {
    var container = _a.container;
    return container.getChild(id);
};
var setTextureAsset$1 = function (id, source, extname, AssetDatabaseData) {
    _set(id, createImageTextureAsset(source, extname), AssetDatabaseData);
};
var _set = function (id, asset, _a) {
    var container = _a.container;
    container.addChild(id, asset);
};
var has = function (id, _a) {
    var container = _a.container;
    return container.hasChild(id);
};
var initData = function (AssetDatabaseData) {
    AssetDatabaseData.container = Hash.create();
    AssetDatabaseData.totalAssertCount = 0;
    AssetDatabaseData.currentLoadedCount = 0;
};

var AssetDatabaseData = (function () {
    function AssetDatabaseData() {
    }
    AssetDatabaseData.container = null;
    AssetDatabaseData.totalAssertCount = null;
    AssetDatabaseData.currentLoadedCount = null;
    return AssetDatabaseData;
}());

function loadAsset() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return load$$1(args[0], AssetDatabaseData, args[1] || 100);
}
var getAsset = function (id) {
    return get(id, AssetDatabaseData);
};
function setTextureAsset$$1(id, source, extname) {
    setTextureAsset$1(id, source, extname, AssetDatabaseData);
}

var getCameraPMatrix = function (cameraController) {
    return getPMatrix$1(cameraController.index, CameraData);
};
var getCameraNear = function (cameraController) {
    return getNear(cameraController.index, CameraData);
};
var setCameraNear = function (cameraController, near) {
    setNear(cameraController.index, near, CameraControllerData, CameraData);
};
var getCameraFar = function (cameraController) {
    return getFar(cameraController.index, CameraData);
};
var setCameraFar = function (cameraController, far) {
    setFar(cameraController.index, far, CameraControllerData, CameraData);
};

var getPerspectiveCameraFovy = function (cameraController) {
    return getFovy(cameraController.index, PerspectiveCameraData);
};
var setPerspectiveCameraFovy = function (cameraController, fovy) {
    setFovy(cameraController.index, fovy, PerspectiveCameraData, CameraControllerData);
};
var getPerspectiveCameraAspect = function (cameraController) {
    return getAspect(cameraController.index, PerspectiveCameraData);
};
var setPerspectiveCameraAspect = function (cameraController, aspect) {
    setAspect(cameraController.index, aspect, PerspectiveCameraData, CameraControllerData);
};

var create$16 = function (GeometryData) {
    var geometry = new BoxGeometry(), index = null;
    geometry = create$5(geometry, GeometryData);
    index = geometry.index;
    setConfigData(index, {}, GeometryData);
    GeometryData.computeDataFuncMap[index] = _computeData;
    return geometry;
};
var _computeData = function (index, GeometryData) {
    var _a = _getConfigData(index, GeometryData), width = _a.width, height = _a.height, depth = _a.depth, widthSegments = _a.widthSegments, heightSegments = _a.heightSegments, depthSegments = _a.depthSegments, sides = {
        FRONT: 0,
        BACK: 1,
        TOP: 2,
        BOTTOM: 3,
        RIGHT: 4,
        LEFT: 5
    }, vertices = [], normals = [], texCoords = [], indices = [];
    var faceAxes = [
        [0, 1, 3],
        [4, 5, 7],
        [3, 2, 6],
        [1, 0, 4],
        [1, 4, 2],
        [5, 0, 6]
    ];
    var faceNormals = [
        [0, 0, 1],
        [0, 0, -1],
        [0, 1, 0],
        [0, -1, 0],
        [1, 0, 0],
        [-1, 0, 0]
    ];
    var corners = [
        Vector3.create(-width, -height, depth),
        Vector3.create(width, -height, depth),
        Vector3.create(width, height, depth),
        Vector3.create(-width, height, depth),
        Vector3.create(width, -height, -depth),
        Vector3.create(-width, -height, -depth),
        Vector3.create(-width, height, -depth),
        Vector3.create(width, height, -depth)
    ];
    function generateFace(side, uSegments, vSegments) {
        var x, y, z, u, v;
        var i, j;
        var offset = vertices.length / 3;
        for (i = 0; i <= uSegments; i++) {
            for (j = 0; j <= vSegments; j++) {
                var temp1 = GlobalTempData.vector3_1, temp2 = GlobalTempData.vector3_2, temp3 = GlobalTempData.vector3_3, r = GlobalTempData.vector3_4;
                temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
                temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
                temp3.sub2(temp2, corners[faceAxes[side][0]]);
                r.add2(temp1, temp3);
                u = i / uSegments;
                v = j / vSegments;
                vertices.push(r.x, r.y, r.z);
                normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
                texCoords.push(u, v);
                if ((i < uSegments) && (j < vSegments)) {
                    indices.push(offset + j + i * (uSegments + 1), offset + j + (i + 1) * (uSegments + 1), offset + j + i * (uSegments + 1) + 1);
                    indices.push(offset + j + (i + 1) * (uSegments + 1), offset + j + (i + 1) * (uSegments + 1) + 1, offset + j + i * (uSegments + 1) + 1);
                }
            }
        }
    }
    generateFace(sides.FRONT, widthSegments, heightSegments);
    generateFace(sides.BACK, widthSegments, heightSegments);
    generateFace(sides.TOP, widthSegments, depthSegments);
    generateFace(sides.BOTTOM, widthSegments, depthSegments);
    generateFace(sides.RIGHT, depthSegments, heightSegments);
    generateFace(sides.LEFT, depthSegments, heightSegments);
    return {
        vertices: vertices,
        normals: normals,
        texCoords: texCoords,
        indices: indices
    };
};
var _getConfigData = ensureFunc$$1(function (data) {
    it$$1("config data should be defined", function () {
        wdet_1(data).exist;
        wdet_1(data.width).exist;
        wdet_1(data.height).exist;
        wdet_1(data.depth).exist;
        wdet_1(data.widthSegments).exist;
        wdet_1(data.heightSegments).exist;
        wdet_1(data.depthSegments).exist;
    });
}, function (index, GeometryData) {
    return GeometryData.configDataMap[index];
});
var setConfigData = function (index, data, GeometryData) {
    GeometryData.configDataMap[index] = ExtendUtils.extend({
        width: 10,
        height: 10,
        depth: 10,
        widthSegments: 1,
        heightSegments: 1,
        depthSegments: 1
    }, data);
};

var BoxGeometry = (function (_super) {
    __extends(BoxGeometry, _super);
    function BoxGeometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BoxGeometry = __decorate([
        registerClass$1("BoxGeometry")
    ], BoxGeometry);
    return BoxGeometry;
}(Geometry));
var createBoxGeometry = function () {
    return create$16(GeometryData);
};
var setBoxGeometryConfigData = function (geometry, data) {
    setConfigData(geometry.index, data, GeometryData);
};

var create$17 = function (GeometryData) {
    return create$5(new CustomGeometry(), GeometryData);
};

var CustomGeometry = (function (_super) {
    __extends(CustomGeometry, _super);
    function CustomGeometry() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CustomGeometry = __decorate([
        registerClass$1("CustomGeometry")
    ], CustomGeometry);
    return CustomGeometry;
}(Geometry));
var createCustomGeometry = function () {
    return create$17(GeometryData);
};
var setCustomGeometryVertices = function (geometry, vertices) {
    return setVertices(geometry.index, vertices, GeometryData);
};
var setCustomGeometryNormals = function (geometry, normals) {
    return setNormals(geometry.index, normals, GeometryData);
};
var setCustomGeometryTexCoords = function (geometry, texCoords) {
    return setTexCoords(geometry.index, texCoords, GeometryData);
};
var setCustomGeometryIndices = function (geometry, indices) {
    return setIndices(geometry.index, indices, GeometryData);
};

var EShading;
(function (EShading) {
    EShading[EShading["FLAT"] = 0] = "FLAT";
    EShading[EShading["SMOOTH"] = 1] = "SMOOTH";
})(EShading || (EShading = {}));

var DebugConfig = {
    isTest: false,
    debugCollision: false,
    showDebugPanel: false
};

function singleton(isInitWhenCreate) {
    if (isInitWhenCreate === void 0) { isInitWhenCreate = false; }
    return function (target) {
        target._instance = null;
        if (isInitWhenCreate) {
            target.getInstance = function () {
                if (target._instance === null) {
                    var instance = new target();
                    target._instance = instance;
                    instance.initWhenCreate();
                }
                return target._instance;
            };
        }
        else {
            target.getInstance = function () {
                if (target._instance === null) {
                    target._instance = new target();
                }
                return target._instance;
            };
        }
    };
}

var TimeController = (function () {
    function TimeController() {
        this.elapsed = null;
        this.pauseElapsed = 0;
        this.pauseTime = null;
        this.startTime = null;
    }
    TimeController.prototype.start = function () {
        this.startTime = this.getNow();
        this.pauseElapsed = null;
    };
    TimeController.prototype.stop = function () {
        this.startTime = null;
    };
    TimeController.prototype.pause = function () {
        this.pauseTime = this.getNow();
    };
    TimeController.prototype.resume = function () {
        this.pauseElapsed += this.getNow() - this.pauseTime;
        this.pauseTime = null;
    };
    TimeController.prototype.computeElapseTime = function (time) {
        if (this.pauseElapsed) {
            this.elapsed = time - this.pauseElapsed - this.startTime;
        }
        else {
            this.elapsed = time - this.startTime;
        }
        if (this.elapsed < 0) {
            this.elapsed = 0;
        }
        return this.elapsed;
    };
    __decorate([
        ensure$1(function () {
            var _this = this;
            it$$1("elapsed should >= 0, but actual is " + this.elapsed, function () {
                wdet_1(_this.elapsed).gte(0);
            });
        })
    ], TimeController.prototype, "computeElapseTime", null);
    return TimeController;
}());

var STARTING_FPS = 60;
var GAMETIME_SCALE = 1000;
var DirectorTimeController = (function (_super) {
    __extends(DirectorTimeController, _super);
    function DirectorTimeController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.gameTime = null;
        _this.fps = null;
        _this.isTimeChange = false;
        _this.deltaTime = null;
        _this._lastTime = null;
        return _this;
    }
    DirectorTimeController.create = function () {
        var obj = new this();
        return obj;
    };
    DirectorTimeController.prototype.tick = function (time) {
        this.deltaTime = this._lastTime !== null ? time - this._lastTime : time;
        this._updateFps(this.deltaTime);
        this.gameTime = time / GAMETIME_SCALE;
        this._lastTime = time;
    };
    DirectorTimeController.prototype.start = function () {
        _super.prototype.start.call(this);
        this.isTimeChange = true;
        this.elapsed = 0;
    };
    DirectorTimeController.prototype.resume = function () {
        _super.prototype.resume.call(this);
        this.isTimeChange = true;
    };
    DirectorTimeController.prototype.getNow = function () {
        return root$2.performance.now();
    };
    DirectorTimeController.prototype._updateFps = function (deltaTime) {
        if (this._lastTime === null) {
            this.fps = STARTING_FPS;
        }
        else {
            this.fps = 1000 / deltaTime;
        }
    };
    DirectorTimeController = __decorate([
        registerClass$1("DirectorTimeController")
    ], DirectorTimeController);
    return DirectorTimeController;
}(TimeController));

var CommonTimeController = (function (_super) {
    __extends(CommonTimeController, _super);
    function CommonTimeController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CommonTimeController.create = function () {
        var obj = new this();
        return obj;
    };
    CommonTimeController.prototype.getNow = function () {
        if (Director.getInstance().isTimeChange) {
            return Director.getInstance().elapsed;
        }
        return root$2.performance.now();
    };
    CommonTimeController = __decorate([
        registerClass$1("CommonTimeController")
    ], CommonTimeController);
    return CommonTimeController;
}(TimeController));

var Scheduler$1 = (function () {
    function Scheduler() {
        this._scheduleCount = 0;
        this._schedules = Hash.create();
    }
    Scheduler.create = function () {
        var obj = new this();
        return obj;
    };
    Scheduler.prototype.update = function (elapsed) {
        var _this = this;
        this._schedules.forEach(function (scheduleItem, scheduleId) {
            if (scheduleItem.isStop || scheduleItem.isPause) {
                return;
            }
            scheduleItem.update(elapsed);
            if (scheduleItem.isFinish) {
                _this.remove(scheduleId);
            }
        });
    };
    Scheduler.prototype.scheduleLoop = function (task, args) {
        if (args === void 0) { args = []; }
        return this._schedule(LoopScheduleItem, Array.prototype.slice.call(arguments, 0));
    };
    Scheduler.prototype.scheduleFrame = function (task, frame, args) {
        if (frame === void 0) { frame = 1; }
        return this._schedule(FrameScheduleItem, Array.prototype.slice.call(arguments, 0));
    };
    Scheduler.prototype.scheduleInterval = function (task, time, args) {
        if (time === void 0) { time = 0; }
        return this._schedule(IntervalScheduleItem, Array.prototype.slice.call(arguments, 0));
    };
    Scheduler.prototype.scheduleTime = function (task, time, args) {
        if (time === void 0) { time = 0; }
        return this._schedule(TimeScheduleItem, Array.prototype.slice.call(arguments, 0));
    };
    Scheduler.prototype.pause = function (scheduleId) {
        if (arguments.length === 0) {
            var self_1 = this;
            this._schedules.forEach(function (scheduleItem, scheduleId) {
                self_1.pause(scheduleId);
            });
        }
        else if (arguments.length === 1) {
            var scheduleItem = this._schedules.getChild(arguments[0]);
            scheduleItem.pause();
        }
    };
    Scheduler.prototype.resume = function (scheduleId) {
        if (arguments.length === 0) {
            var self_2 = this;
            this._schedules.forEach(function (scheduleItem, scheduleId) {
                self_2.resume(scheduleId);
            });
        }
        else if (arguments.length === 1) {
            var scheduleItem = this._schedules.getChild(arguments[0]);
            scheduleItem.resume();
        }
    };
    Scheduler.prototype.start = function (scheduleId) {
        if (arguments.length === 0) {
            var self_3 = this;
            this._schedules.forEach(function (scheduleItem, scheduleId) {
                self_3.start(scheduleId);
            });
        }
        else if (arguments.length === 1) {
            var scheduleItem = this._schedules.getChild(arguments[0]);
            scheduleItem.start();
        }
    };
    Scheduler.prototype.stop = function (scheduleId) {
        if (arguments.length === 0) {
            var self_4 = this;
            this._schedules.forEach(function (scheduleItem, scheduleId) {
                self_4.stop(scheduleId);
            });
        }
        else if (arguments.length === 1) {
            var scheduleItem = this._schedules.getChild(arguments[0]);
            scheduleItem.stop();
        }
    };
    Scheduler.prototype.has = function (scheduleId) {
        return !!this._schedules.hasChild(scheduleId);
    };
    Scheduler.prototype.remove = function (scheduleId) {
        this._schedules.removeChild(scheduleId);
    };
    Scheduler.prototype.removeAll = function () {
        this._schedules.removeAllChildren();
    };
    Scheduler.prototype._schedule = function (_class, args) {
        var scheduleId = this._buildId();
        this._schedules.setValue(scheduleId, _class.create.apply(_class, args));
        return scheduleId;
    };
    Scheduler.prototype._buildId = function () {
        return 'Schedule_' + (this._scheduleCount++);
    };
    return Scheduler;
}());
var ScheduleItem = (function () {
    function ScheduleItem(task, args) {
        this.isPause = false;
        this.isStop = false;
        this.pauseTime = null;
        this.pauseElapsed = null;
        this.startTime = null;
        this.isFinish = false;
        this.task = null;
        this.args = null;
        this.timeController = CommonTimeController.create();
        this.task = task;
        this.args = args;
    }
    ScheduleItem.prototype.pause = function () {
        this.isPause = true;
        this.timeController.pause();
    };
    ScheduleItem.prototype.resume = function () {
        this.isPause = false;
        this.timeController.resume();
    };
    ScheduleItem.prototype.start = function () {
        this.isStop = false;
        this.timeController.start();
    };
    ScheduleItem.prototype.stop = function () {
        this.isStop = true;
        this.timeController.stop();
    };
    ScheduleItem.prototype.finish = function () {
        this.isFinish = true;
    };
    return ScheduleItem;
}());
var TimeScheduleItem = (function (_super) {
    __extends(TimeScheduleItem, _super);
    function TimeScheduleItem(task, time, args) {
        if (time === void 0) { time = 0; }
        if (args === void 0) { args = []; }
        var _this = _super.call(this, task, args) || this;
        _this._time = null;
        _this._time = time;
        return _this;
    }
    TimeScheduleItem.create = function (task, time, args) {
        if (time === void 0) { time = 0; }
        if (args === void 0) { args = []; }
        var obj = new this(task, time, args);
        return obj;
    };
    TimeScheduleItem.prototype.update = function (elapsed) {
        var elapsed = this.timeController.computeElapseTime(elapsed);
        if (elapsed >= this._time) {
            this.task.apply(this, this.args);
            this.finish();
        }
    };
    return TimeScheduleItem;
}(ScheduleItem));
var IntervalScheduleItem = (function (_super) {
    __extends(IntervalScheduleItem, _super);
    function IntervalScheduleItem(task, time, args) {
        if (time === void 0) { time = 0; }
        if (args === void 0) { args = []; }
        var _this = _super.call(this, task, args) || this;
        _this._intervalTime = null;
        _this._elapsed = 0;
        _this._intervalTime = time;
        return _this;
    }
    IntervalScheduleItem.create = function (task, time, args) {
        if (time === void 0) { time = 0; }
        if (args === void 0) { args = []; }
        var obj = new this(task, time, args);
        return obj;
    };
    IntervalScheduleItem.prototype.update = function (elapsed) {
        var elapsed = this.timeController.computeElapseTime(elapsed);
        if (elapsed - this._elapsed >= this._intervalTime) {
            this.task.apply(this, this.args);
            this._elapsed = elapsed;
        }
    };
    IntervalScheduleItem.prototype.start = function () {
        _super.prototype.start.call(this);
        this._elapsed = 0;
    };
    return IntervalScheduleItem;
}(ScheduleItem));
var LoopScheduleItem = (function (_super) {
    __extends(LoopScheduleItem, _super);
    function LoopScheduleItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LoopScheduleItem.create = function (task, args) {
        if (args === void 0) { args = []; }
        var obj = new this(task, args);
        return obj;
    };
    LoopScheduleItem.prototype.update = function (elapsed) {
        this.task.apply(this, this.args);
    };
    return LoopScheduleItem;
}(ScheduleItem));
var FrameScheduleItem = (function (_super) {
    __extends(FrameScheduleItem, _super);
    function FrameScheduleItem(task, frame, args) {
        if (frame === void 0) { frame = 1; }
        if (args === void 0) { args = []; }
        var _this = _super.call(this, task, args) || this;
        _this._frame = null;
        _this._frame = frame;
        return _this;
    }
    FrameScheduleItem.create = function (task, frame, args) {
        if (frame === void 0) { frame = 1; }
        if (args === void 0) { args = []; }
        var obj = new this(task, frame, args);
        return obj;
    };
    FrameScheduleItem.prototype.update = function (elapsed) {
        this._frame--;
        if (this._frame <= 0) {
            this.task.apply(this, this.args);
            this.finish();
        }
    };
    return FrameScheduleItem;
}(ScheduleItem));

var initData$55 = function (PointLightData) {
    initDataHelper$1(PointLightData);
    PointLightData.lightGLSLDataStructureMemberNameArr = [
        {
            position: "u_pointLights[0].position",
            color: "u_pointLights[0].color",
            intensity: "u_pointLights[0].intensity",
            constant: "u_pointLights[0].constant",
            linear: "u_pointLights[0].linear",
            quadratic: "u_pointLights[0].quadratic",
            range: "u_pointLights[0].range"
        }, {
            position: "u_pointLights[1].position",
            color: "u_pointLights[1].color",
            intensity: "u_pointLights[1].intensity",
            constant: "u_pointLights[1].constant",
            linear: "u_pointLights[1].linear",
            quadratic: "u_pointLights[1].quadratic",
            range: "u_pointLights[1].range"
        }, {
            position: "u_pointLights[2].position",
            color: "u_pointLights[2].color",
            intensity: "u_pointLights[2].intensity",
            constant: "u_pointLights[2].constant",
            linear: "u_pointLights[2].linear",
            quadratic: "u_pointLights[2].quadratic",
            range: "u_pointLights[2].range"
        }, {
            position: "u_pointLights[3].position",
            color: "u_pointLights[3].color",
            intensity: "u_pointLights[3].intensity",
            constant: "u_pointLights[3].constant",
            linear: "u_pointLights[3].linear",
            quadratic: "u_pointLights[3].quadratic",
            range: "u_pointLights[3].range"
        }
    ];
};

var initData$56 = function (DirectionLightData) {
    initDataHelper(DirectionLightData);
    DirectionLightData.lightGLSLDataStructureMemberNameArr = [
        {
            position: "u_directionLights[0].position",
            color: "u_directionLights[0].color",
            intensity: "u_directionLights[0].intensity"
        }, {
            position: "u_directionLights[1].position",
            color: "u_directionLights[1].color",
            intensity: "u_directionLights[1].intensity"
        }, {
            position: "u_directionLights[2].position",
            color: "u_directionLights[2].color",
            intensity: "u_directionLights[2].intensity"
        }, {
            position: "u_directionLights[3].position",
            color: "u_directionLights[3].color",
            intensity: "u_directionLights[3].intensity"
        }
    ];
};

var addComponent$11 = function (component, gameObject) {
    addComponent$7(component, gameObject, WebGL1DirectionLightData);
};
var disposeComponent$13 = function (component) {
    disposeComponent$7(component, WebGL1DirectionLightData);
};

var addComponent$12 = function (component, gameObject) {
    addComponent$7(component, gameObject, WebGL1PointLightData);
};
var disposeComponent$14 = function (component) {
    disposeComponent$9(component, WebGL1PointLightData);
};

var addAddComponentHandle$7 = function (AmbientLight, DirectionLight, PointLight) {
    addAddComponentHandle(AmbientLight, addComponent$10);
    addAddComponentHandle(DirectionLight, addComponent$11);
    addAddComponentHandle(PointLight, addComponent$12);
};
var addDisposeHandle$6 = function (AmbientLight, DirectionLight, PointLight) {
    addDisposeHandle(AmbientLight, disposeComponent$12);
    addDisposeHandle(DirectionLight, disposeComponent$13);
    addDisposeHandle(PointLight, disposeComponent$14);
};
var initData$54 = function (AmbientLightData, DirectionLightData, PointLightData) {
    initData$51(AmbientLightData);
    initData$56(DirectionLightData);
    initData$55(PointLightData);
};

var initData$58 = function (DirectionLightData) {
    initDataHelper(DirectionLightData);
};

var addComponent$13 = function (component, gameObject) {
    addComponent$7(component, gameObject, WebGL2PointLightData);
};
var disposeComponent$15 = function (component) {
    disposeComponent$9(component, WebGL2PointLightData);
};

var addComponent$14 = function (component, gameObject) {
    addComponent$7(component, gameObject, WebGL2DirectionLightData);
};
var disposeComponent$16 = function (component) {
    disposeComponent$7(component, WebGL2DirectionLightData);
};

var addAddComponentHandle$8 = function (AmbientLight, DirectionLight, PointLight) {
    addAddComponentHandle(AmbientLight, addComponent$10);
    addAddComponentHandle(DirectionLight, addComponent$14);
    addAddComponentHandle(PointLight, addComponent$13);
};
var addDisposeHandle$7 = function (AmbientLight, DirectionLight, PointLight) {
    addDisposeHandle(AmbientLight, disposeComponent$12);
    addDisposeHandle(DirectionLight, disposeComponent$16);
    addDisposeHandle(PointLight, disposeComponent$15);
};
var initData$57 = function (AmbientLightData, DirectionLightData, PointLightData) {
    initData$51(AmbientLightData);
    initData$58(DirectionLightData);
    initData$52(PointLightData);
};

var disposeGeometryVboBuffers = function (disposedIndexArray, ArrayBufferDataFromSystem, IndexBufferDataFromSystem, disposeArrayBuffer, disposeIndexBuffer) {
    for (var _i = 0, disposedIndexArray_1 = disposedIndexArray; _i < disposedIndexArray_1.length; _i++) {
        var index = disposedIndexArray_1[_i];
        disposeArrayBuffer(index, ArrayBufferDataFromSystem);
        disposeIndexBuffer(index, IndexBufferDataFromSystem);
    }
};

var disposeBuffers = function (disposedIndexArray, disposeArrayBuffer, disposeIndexBuffer, GPUDetectDataFromSystem, VaoDataFromSystem, ArrayBufferDataFromSystem, IndexBufferDataFromSystem, DeviceManagerDataFromSystem) {
    var extension = getExtensionVao(GPUDetectDataFromSystem);
    if (hasExtension(extension)) {
        disposeGeometryVaoBuffers(extension, disposedIndexArray, DeviceManagerDataFromSystem, VaoDataFromSystem);
    }
    else {
        disposeGeometryVboBuffers(disposedIndexArray, ArrayBufferDataFromSystem, IndexBufferDataFromSystem, disposeArrayBuffer, disposeIndexBuffer);
    }
};
var disposeGeometryVaoBuffers = function (extension, disposedIndexArray, DeviceManagerDataFromSystem, _a) {
    var vaoMap = _a.vaoMap, vboArrayMap = _a.vboArrayMap;
    var gl = getGL$1(DeviceManagerDataFromSystem, null);
    for (var _i = 0, disposedIndexArray_1 = disposedIndexArray; _i < disposedIndexArray_1.length; _i++) {
        var index = disposedIndexArray_1[_i];
        disposeVao$1(gl, extension, index, vaoMap, vboArrayMap);
    }
};

var disposeBuffer$1 = function (geometryIndex, buffers, getGL, DeviceManagerDataFromSystem) {
    var gl = getGL(DeviceManagerDataFromSystem, null), buffer = buffers[geometryIndex];
    if (isBufferExist(buffer)) {
        gl.deleteBuffer(buffers[geometryIndex]);
        deleteVal(geometryIndex, buffers);
    }
};

var disposeBuffer$$1 = function (geometryIndex, ArrayBufferData) {
    disposeBuffer$1(geometryIndex, ArrayBufferData.vertexBuffers, getGL$$1, DeviceManagerData);
    disposeBuffer$1(geometryIndex, ArrayBufferData.normalBuffers, getGL$$1, DeviceManagerData);
    disposeBuffer$1(geometryIndex, ArrayBufferData.texCoordBuffers, getGL$$1, DeviceManagerData);
};
var initData$59 = initData$53;

var initData$60 = initData$39;
var disposeBuffer$2 = function (geometryIndex, IndexBufferData) {
    disposeBuffer$1(geometryIndex, IndexBufferData.buffers, getGL$$1, DeviceManagerData);
};

var addDisposeHandle$8 = function (BoxGeometry, CustomGeometry) {
    addDisposeHandle(BoxGeometry, disposeComponent$17);
    addDisposeHandle(CustomGeometry, disposeComponent$17);
};
var disposeComponent$17 = function (component) {
    disposeComponent$4(component, _disposeBuffers);
};
var _disposeBuffers = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    _disposeBuffers = function (disposedIndexArray) {
        disposeGeometryWorkerBuffers(disposedIndexArray, GeometryData);
    };
}
else {
    _disposeBuffers = function (disposedIndexArray) {
        disposeBuffers(disposedIndexArray, disposeBuffer$$1, disposeBuffer$2, GPUDetectData, VaoData, ArrayBufferData, IndexBufferData, DeviceManagerData);
    };
}

var disposeBuffers$1 = function (disposedIndexArray, DeviceManagerDataFromSystem, VaoDataFromSystem) {
    disposeGeometryVaoBuffers$1(getGL$1(DeviceManagerDataFromSystem, null), disposedIndexArray, VaoDataFromSystem);
};
var disposeGeometryVaoBuffers$1 = function (gl, disposedIndexArray, _a) {
    var vaoMap = _a.vaoMap, vboArrayMap = _a.vboArrayMap;
    for (var _i = 0, disposedIndexArray_1 = disposedIndexArray; _i < disposedIndexArray_1.length; _i++) {
        var index = disposedIndexArray_1[_i];
        disposeVao(gl, index, vaoMap, vboArrayMap);
    }
};

var addDisposeHandle$9 = function (BoxGeometry, CustomGeometry) {
    addDisposeHandle(BoxGeometry, disposeComponent$18);
    addDisposeHandle(CustomGeometry, disposeComponent$18);
};
var disposeComponent$18 = function (component) {
    disposeComponent$4(component, _disposeBuffers$1);
};
var _disposeBuffers$1 = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    _disposeBuffers$1 = function (disposedIndexArray) {
        disposeGeometryWorkerBuffers(disposedIndexArray, GeometryData);
    };
}
else {
    _disposeBuffers$1 = function (disposedIndexArray) {
        disposeBuffers$1(disposedIndexArray, DeviceManagerData, VaoData);
    };
}

var Director = (function () {
    function Director() {
        this.scene = create$8(GameObjectData);
        this.scheduler = null;
        this._gameLoop = null;
        this._timeController = DirectorTimeController.create();
    }
    Director.getInstance = function () { };
    
    Director.prototype.initWhenCreate = function () {
        this.scheduler = Scheduler$1.create();
    };
    Director.prototype.start = function () {
        this._startLoop();
    };
    Director.prototype.init = function () {
        setState(this._init(getState(DirectorData)), DirectorData);
    };
    Director.prototype.loopBody = function (time) {
        setState(this._loopBody(time, getState(DirectorData)), DirectorData).run();
    };
    Director.prototype._startLoop = function () {
        var self = this;
        this._gameLoop = this._buildInitStream()
            .ignoreElements()
            .concat(this._buildLoopStream())
            .subscribe(function (time) {
            self.loopBody(time);
        });
    };
    Director.prototype._buildInitStream = function () {
        var _this = this;
        return callFunc(function () {
            _this.init();
        }, this);
    };
    Director.prototype._init = function (state) {
        var resultState = state;
        markIsInit(DirectorData);
        resultState = this._initSystem(resultState);
        resultState = this._initRenderer(resultState);
        this._timeController.start();
        this.scheduler.start();
        return resultState;
    };
    Director.prototype._initSystem = function (state) {
        var resultState = init$1(GlobalTempData, ThreeDTransformData, state);
        resultState = init$2(GeometryData, state);
        resultState = init$3(PerspectiveCameraData, CameraData, CameraControllerData, state);
        resultState = _initPointLight(state);
        resultState = _initDirectionLight(state);
        return resultState;
    };
    Director.prototype._initRenderer = function (state) {
        var resultState = init$$1(state);
        return resultState;
    };
    Director.prototype._buildLoopStream = function () {
        return intervalRequest();
    };
    Director.prototype._loopBody = function (time, state) {
        var elapsed = null;
        elapsed = this._timeController.computeElapseTime(time);
        return run(elapsed, state, this._timeController, this.scheduler);
    };
    Director = __decorate([
        singleton(true),
        registerClass$1("Director")
    ], Director);
    return Director;
}());
var isDirectorInit = function () {
    return isInit(DirectorData);
};
addAddComponentHandle$6(BasicMaterial, LightMaterial);
addDisposeHandle$5(BasicMaterial, LightMaterial);
addInitHandle$2(BasicMaterial, LightMaterial);
addAddComponentHandle$1(MeshRenderer);
addDisposeHandle$1(MeshRenderer);
addAddComponentHandle$3(Tag);
addDisposeHandle$3(Tag);
addAddComponentHandle$2(ThreeDTransform);
addDisposeHandle$2(ThreeDTransform);
addAddComponentHandle$5(CameraController);
addDisposeHandle$4(CameraController);
addAddComponentHandle$4(BoxGeometry, CustomGeometry);
addInitHandle$1(BoxGeometry, CustomGeometry);
var _initPointLight = null;
var _initDirectionLight = null;
if (isWebgl1$1()) {
    addAddComponentHandle$7(AmbientLight, DirectionLight, PointLight);
    addDisposeHandle$6(AmbientLight, DirectionLight, PointLight);
    addDisposeHandle$8(BoxGeometry, CustomGeometry);
    _initPointLight = function (state) {
        return init$6(WebGL1PointLightData, state);
    };
    _initDirectionLight = function (state) {
        return init$5(WebGL1DirectionLightData, state);
    };
}
else {
    addAddComponentHandle$8(AmbientLight, DirectionLight, PointLight);
    addDisposeHandle$7(AmbientLight, DirectionLight, PointLight);
    addDisposeHandle$9(BoxGeometry, CustomGeometry);
    _initPointLight = function (state) {
        return init$6(WebGL2PointLightData, state);
    };
    _initDirectionLight = function (state) {
        return init$5(WebGL2DirectionLightData, state);
    };
}

var Scene = (function (_super) {
    __extends(Scene, _super);
    function Scene() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Scene;
}(GameObject));
var addSceneChild = requireCheckFunc(function (scene, gameObject) {
    it$$1("scene should alive", function () {
        wdet_1(isAlive(scene, GameObjectData)).true;
    });
}, function (scene, gameObject) {
    addChild$1(scene, gameObject, ThreeDTransformData, GameObjectData, SceneData);
});
var removeSceneChild = requireCheckFunc(function (scene, gameObject) {
    it$$1("scene should alive", function () {
        wdet_1(isAlive(scene, GameObjectData)).true;
    });
}, function (scene, gameObject) {
    removeChild$1(scene.uid, gameObject.uid, ThreeDTransformData, GameObjectData);
});

var initData$62 = initData$14;

var createGL$1 = curry(function (canvas, renderWorker, contextConfig, viewportData) {
    return IO.of(function () {
        var offscreen = canvas.transferControlToOffscreen();
        renderWorker.postMessage({
            operateType: EWorkerOperateType.INIT_GL,
            canvas: offscreen,
            options: contextConfig.get("options").toObject(),
            viewportData: viewportData
        }, [offscreen]);
    });
});
var setContextConfig$2 = setContextConfig$1;
var getGL$2 = getGL$1;
var setGL$2 = setGL$1;
var setPixelRatio$2 = setPixelRatio$1;

var setViewportToState$2 = curry(function (viewportData, state) {
    if (viewportData === null) {
        return state;
    }
    return setViewportToState$1(viewportData.x, viewportData.y, viewportData.width, viewportData.height, state);
});
var getViewportData = function (screenData) {
    var x = screenData.x, y = screenData.y, width = screenData.width, height = screenData.height;
    return {
        x: x,
        y: y,
        width: width,
        height: height
    };
};
var setViewportOfGL$2 = curry(function (DeviceManagerWorkerData, data, state) {
    return setViewportOfGL$1(DeviceManagerWorkerData, state, data);
});
var setScreen$2 = curry(function (canvas, DeviceManagerWorkerData, DomQuery, state) {
    return setScreen$1(canvas, _setScreenData$1, DeviceManagerWorkerData, state, DomQuery);
});
var _setScreenData$1 = curry(function (DeviceManagerWorkerData, canvas, state, data) {
    var x = data.x, y = data.y, width = data.width, height = data.height, styleWidth = data.styleWidth, styleHeight = data.styleHeight;
    return IO.of(function () {
        compose(chain(setStyleWidth(styleWidth)), chain(setStyleHeight(styleHeight)), chain(setHeight$1(height)), chain(setWidth$1(width)), chain(setY(y)), setX(x))(canvas).run();
        return data;
    });
});
var setCanvasPixelRatio$2 = curry(function (useDevicePixelRatio, canvas) {
    return IO.of(function () {
        if (!useDevicePixelRatio) {
            return null;
        }
        return setCanvasPixelRatio$1(useDevicePixelRatio, canvas).run();
    });
});
var buildViewportData = function (x, y, width, height) {
    return {
        x: x,
        y: y,
        width: width,
        height: height
    };
};




var initData$63 = initData$5;

var initDevice = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    initDevice = curry(function (contextConfig, state, configState, detect$$1, DomQuery, canvas) {
        return IO.of(function () {
            var screenData = setScreen$2(canvas, null, DomQuery, state).run(), viewportData = getViewportData(screenData);
            createGL$1(canvas, getRenderWorker(WorkerInstanceData), contextConfig, viewportData).run();
            return compose(setCanvas(canvas), setContextConfig$2(contextConfig), setViewportToState$2(viewportData), setPixelRatio$2(setCanvasPixelRatio$2(configState.get("useDevicePixelRatio"), canvas).run()))(state);
        });
    });
}
else {
    initDevice = curry(function (contextConfig, state, configState, detect$$1, DomQuery, canvas) {
        return compose(map(detect$$1(getGL$$1, DeviceManagerData, GPUDetectData)), chain(setCanvasPixelRatio$$1(configState.get("useDevicePixelRatio"), canvas)), chain(setScreen$$1(canvas, DeviceManagerData, DomQuery)), createGL)(canvas, contextConfig, WebGLDetectData, DeviceManagerData, state);
    });
}
var createCanvas = curry(function (DomQuery, domId) {
    return IO.of(function () {
        if (domId !== "") {
            return DomQuery.create(_getCanvasId(domId)).get(0);
        }
        return DomQuery.create("<canvas></canvas>").prependTo("body").get(0);
    });
});
var _getCanvasId = ensureFunc$$1(function (id) {
    it$$1("dom id should be #string", function () {
        wdet_1(/#[^#]+/.test(id)).true;
    });
}, function (domId) {
    if (domId.indexOf('#') > -1) {
        return domId;
    }
    return "#" + domId;
});

var getIsTest$1 = function (InitConfigDataFromSystem) {
    return InitConfigDataFromSystem.isTest;
};
var setIsTest$1 = function (isTest, InitConfigDataFromSystem) {
    return IO.of(function () {
        InitConfigDataFromSystem.isTest = isTest;
    });
};

var setLibIsTest = function (isTest) {
    return IO.of(function () {
        Main.isTest = isTest;
    });
};
var getIsTest$$1 = getIsTest$1;
var setIsTest$$1 = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    setIsTest$$1 = function (isTest, InitConfigData, WorkerInstanceData) {
        return IO.of(function () {
            var renderWorker = getRenderWorker(WorkerInstanceData);
            renderWorker.postMessage({
                operateType: EWorkerOperateType.INIT_CONFIG,
                isTest: isTest
            });
            setIsTest$1(isTest, InitConfigData).run();
        });
    };
}
else {
    setIsTest$$1 = function (isTest, InitConfigData, WorkerInstanceData) {
        return setIsTest$1(isTest, InitConfigData);
    };
}

var detect$4 = curry(function (getGL, DeviceManagerData, GPUDetectData, state) {
    return detect$3(getGL, DeviceManagerData, GPUDetectData, state);
});
var initData$64 = initData$40;

var detect$5 = curry(function (getGL, DeviceManagerData, GPUDetectData, state) {
    return detect$2(getGL, DeviceManagerData, GPUDetectData, state);
});

var initData$65 = initData$30;

var initData$66 = initData$28;

var initData$67 = initData$37;

var initData$68 = initData$31;

var initData$69 = initData$38;

var initData$70 = initData$32;

var initData$71 = initData$50;

var setConfig = function (closeContractTest, InitConfigData, WorkerDetectData, WorkerInstanceData, WebGLDetectData, _a) {
    var _b = _a.canvasId, canvasId = _b === void 0 ? "" : _b, _c = _a.isTest, isTest = _c === void 0 ? DebugConfig.isTest : _c, _d = _a.screenSize, screenSize = _d === void 0 ? EScreenSize.FULL : _d, _e = _a.useDevicePixelRatio, useDevicePixelRatio = _e === void 0 ? false : _e, _f = _a.contextConfig, contextConfig = _f === void 0 ? {
        options: {
            alpha: true,
            depth: true,
            stencil: false,
            antialias: true,
            premultipliedAlpha: true,
            preserveDrawingBuffer: false
        }
    } : _f, _g = _a.workerConfig, workerConfig = _g === void 0 ? {
        renderWorkerFileDir: "/Wonder.js/dist/worker/"
    } : _g;
    return IO.of(function () {
        var _isTest = false;
        if (CompileConfig.closeContractTest) {
            _isTest = false;
            setLibIsTest(false).run();
        }
        else {
            _isTest = isTest;
            setLibIsTest(isTest).run();
        }
        setWorkerConfig(workerConfig, WorkerDetectData).run();
        initWorkInstances(WorkerInstanceData);
        setIsTest$$1(_isTest, InitConfigData, WorkerInstanceData).run();
        passDataToRenderWorker(WorkerInstanceData, WebGLDetectData).run();
        return immutable_1({
            Main: {
                screenSize: screenSize
            },
            config: {
                canvasId: canvasId,
                contextConfig: {
                    options: ExtendUtils.extend({
                        alpha: true,
                        depth: true,
                        stencil: false,
                        antialias: true,
                        premultipliedAlpha: true,
                        preserveDrawingBuffer: false
                    }, contextConfig.options)
                },
                useDevicePixelRatio: useDevicePixelRatio
            }
        });
    });
};
var initData$61 = null;
var passDataToRenderWorker = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    initData$61 = function () {
        _initData$1();
    };
    passDataToRenderWorker = function (WorkerInstanceData, WebGLDetectData) {
        return IO.of(function () {
            var renderWorker = getRenderWorker(WorkerInstanceData);
            renderWorker.postMessage({
                operateType: EWorkerOperateType.INIT_DATA,
                webglVersion: getVersion(WebGLDetectData)
            });
        });
    };
}
else {
    if (isWebgl1$1()) {
        initData$61 = function () {
            _initData$1();
            initData$35(WebGL1ShaderData);
            initData$62(WebGL1ProgramData);
            initData$69(WebGL1LocationData);
            initData$59(ArrayBufferData);
            initData$60(IndexBufferData);
            initData$43(BasicDrawRenderCommandBufferData, LightDrawRenderCommandBufferData);
            initData$67(WebGL1GLSLSenderData);
        };
    }
    else {
        initData$61 = function () {
            _initData$1();
            initData$26(WebGL2ShaderData);
            initData$62(WebGL2ProgramData);
            initData$70(WebGL2LocationData);
            initData$43(BasicDrawRenderCommandBufferData, LightDrawRenderCommandBufferData);
            initData$66(WebGL2GLSLSenderData);
        };
    }
    passDataToRenderWorker = function (WorkerInstanceData, WebGLDetectData) {
        return IO.of(function () {
        });
    };
}
var init$17 = null;
var _initData$1 = null;
if (isWebgl1$1()) {
    _initData$1 = function () {
        _initBothData();
        initData$54(AmbientLightData, WebGL1DirectionLightData, WebGL1PointLightData);
    };
    init$17 = requireCheckFunc(function (gameState, configState, DomQuery) {
        it$$1("should set config before", function () {
            wdet_1(configState.get("useDevicePixelRatio")).exist;
        });
    }, function (gameState, configState, DomQuery) {
        return compose(chain(initDevice(configState.get("contextConfig"), gameState, configState, detect$4, DomQuery)), createCanvas(DomQuery))(configState.get("canvasId"));
    });
}
else {
    _initData$1 = function () {
        _initBothData();
        initData$57(AmbientLightData, WebGL2DirectionLightData, WebGL2PointLightData);
        initData$71(DeferAmbientLightPassData, DeferDirectionLightPassData, DeferPointLightPassData);
    };
    init$17 = requireCheckFunc(function (gameState, configState, DomQuery) {
        it$$1("should set config before", function () {
            wdet_1(configState.get("useDevicePixelRatio")).exist;
        });
    }, function (gameState, configState, DomQuery) {
        return compose(chain(initDevice(configState.get("contextConfig"), gameState, configState, detect$5, DomQuery)), createCanvas(DomQuery))(configState.get("canvasId"));
    });
}
var _initBothData = function () {
    initData$13(DataBufferConfig, GeometryData, GPUDetectData);
    initData$41(TextureCacheData, TextureData, MapManagerData, MaterialData, BasicMaterialData, LightMaterialData);
    initData$7(MeshRendererData);
    initData$12(TagData);
    initData$11(GlobalTempData, ThreeDTransformData);
    initData$19(SceneData);
    initData$20(CameraControllerData, PerspectiveCameraData, CameraData);
    initData$10(GameObjectData);
    initData$8(DataBufferConfig, BasicRenderCommandBufferData, LightRenderCommandBufferData);
    initData$24(SendDrawRenderCommandBufferData);
    initData$68(VaoData);
    initData$4(DeviceManagerData);
    initData(AssetDatabaseData);
};

var Main$1 = (function () {
    function Main() {
    }
    Object.defineProperty(Main, "isTest", {
        get: function () {
            return getIsTest$$1(InitConfigData);
        },
        set: function (isTest) {
            setIsTest$$1(isTest, InitConfigData, WorkerInstanceData).run();
            setLibIsTest(isTest).run();
        },
        enumerable: true,
        configurable: true
    });
    Main.setConfig = function (configState) {
        initData$6(DirectorData);
        this._configState = setConfig(CompileConfig.closeContractTest, InitConfigData, WorkerDetectData, WorkerInstanceData, WebGLDetectData, configState).run();
        setState(getState(DirectorData).set("Main", this._configState.get("Main")), DirectorData).run();
        return this;
    };
    Main.init = function () {
        initData$61();
        setState(init$17(getState(DirectorData), this._configState.get("config"), DomQuery).run(), DirectorData).run();
        return this;
    };
    Main._configState = null;
    __decorate([
        requireCheck$1(function () {
            it$$1("configState should exist", function () {
                wdet_1(Main._configState).exist;
            });
        })
    ], Main, "init", null);
    return Main;
}());
var initAllData = function () {
    initData$6(DirectorData);
    initData$61();
};

function execOnlyOnce(flagName) {
    return function (target, name, descriptor) {
        var value = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (this[flagName]) {
                return;
            }
            this[flagName] = true;
            return value.apply(this, args);
        };
        return descriptor;
    };
}

function virtual(target, name, descriptor) {
    return descriptor;
}

var getDeviceManagerGL = function () {
    return getGL$$1(DeviceManagerData, getState(DirectorData));
};
var setDeviceManagerGL = function (gl) {
    return setGL$$1(gl, DeviceManagerData, getState(DirectorData));
};
var getDeviceManagerViewport = function () {
    return getViewport$$1(getState(DirectorData));
};
var getDeviceManagerClearColor = function () {
    return getClearColor(DeviceManagerData);
};
var setDeviceManagerViewport = null;
var setDeviceManagerClearColor = null;
if (isSupportRenderWorkerAndSharedArrayBuffer()) {
    setDeviceManagerViewport = function (x, y, width, height) {
        setState(setViewportToState$$1(x, y, width, height, getState(DirectorData)), DirectorData).run();
        getRenderWorker(WorkerInstanceData).postMessage({
            operateType: EWorkerOperateType.INIT_VIEWPORT,
            viewportData: buildViewportData(x, y, width, height)
        });
    };
    setDeviceManagerClearColor = function (color) {
        setClearColorData(color, DeviceManagerData);
        getRenderWorker(WorkerInstanceData).postMessage({
            operateType: EWorkerOperateType.INIT_CLEARCOLOR,
            clearColorArr4: color.toArray4()
        });
    };
}
else {
    setDeviceManagerViewport = function (x, y, width, height) {
        setState(setViewportOfGL$$1(DeviceManagerData, getState(DirectorData), {
            x: x,
            y: y,
            width: width,
            height: height
        }).run(), DirectorData).run();
    };
    setDeviceManagerClearColor = function (color) {
        setClearColor$$1(getGL$$1(DeviceManagerData, getState(DirectorData)), color, DeviceManagerData);
    };
}

var ELightWorkerDataOperateType;
(function (ELightWorkerDataOperateType) {
    ELightWorkerDataOperateType[ELightWorkerDataOperateType["ADD"] = 0] = "ADD";
    ELightWorkerDataOperateType[ELightWorkerDataOperateType["EDIT"] = 1] = "EDIT";
    ELightWorkerDataOperateType[ELightWorkerDataOperateType["DISPOSE"] = 2] = "DISPOSE";
})(ELightWorkerDataOperateType || (ELightWorkerDataOperateType = {}));

var DeviceManagerWorkerData = (function (_super) {
    __extends(DeviceManagerWorkerData, _super);
    function DeviceManagerWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeviceManagerWorkerData;
}(DeviceManagerDataCommon));

var ArrayBufferWorkerData = (function () {
    function ArrayBufferWorkerData() {
    }
    ArrayBufferWorkerData.vertexBuffers = null;
    ArrayBufferWorkerData.normalBuffers = null;
    ArrayBufferWorkerData.texCoordBuffers = null;
    return ArrayBufferWorkerData;
}());

var IndexBufferWorkerData = (function () {
    function IndexBufferWorkerData() {
    }
    IndexBufferWorkerData.buffers = null;
    return IndexBufferWorkerData;
}());

var BasicRenderCommandBufferWorkerData = (function () {
    function BasicRenderCommandBufferWorkerData() {
    }
    BasicRenderCommandBufferWorkerData.mMatrices = null;
    BasicRenderCommandBufferWorkerData.materialIndices = null;
    BasicRenderCommandBufferWorkerData.geometryIndices = null;
    return BasicRenderCommandBufferWorkerData;
}());

var LightRenderCommandBufferWorkerData = (function () {
    function LightRenderCommandBufferWorkerData() {
    }
    LightRenderCommandBufferWorkerData.mMatrices = null;
    LightRenderCommandBufferWorkerData.materialIndices = null;
    LightRenderCommandBufferWorkerData.geometryIndices = null;
    return LightRenderCommandBufferWorkerData;
}());

var GPUDetectWorkerData = (function (_super) {
    __extends(GPUDetectWorkerData, _super);
    function GPUDetectWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GPUDetectWorkerData;
}(GPUDetectDataCommon));

var WebGLDetectWorkerData = (function () {
    function WebGLDetectWorkerData() {
    }
    WebGLDetectWorkerData.version = null;
    return WebGLDetectWorkerData;
}());

var BasicDrawRenderCommandBufferWorkerData = (function () {
    function BasicDrawRenderCommandBufferWorkerData() {
    }
    BasicDrawRenderCommandBufferWorkerData.mMatrixFloatArrayForSend = null;
    return BasicDrawRenderCommandBufferWorkerData;
}());

var LightDrawRenderCommandBufferWorkerData = (function () {
    function LightDrawRenderCommandBufferWorkerData() {
    }
    LightDrawRenderCommandBufferWorkerData.mMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferWorkerData.vMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferWorkerData.pMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferWorkerData.normalMatrixFloatArrayForSend = null;
    LightDrawRenderCommandBufferWorkerData.cameraPositionForSend = null;
    return LightDrawRenderCommandBufferWorkerData;
}());

var GeometryWorkerData = (function () {
    function GeometryWorkerData() {
    }
    GeometryWorkerData.verticesCacheMap = null;
    GeometryWorkerData.normalsCacheMap = null;
    GeometryWorkerData.texCoordsCacheMap = null;
    GeometryWorkerData.indicesCacheMap = null;
    GeometryWorkerData.vertices = null;
    GeometryWorkerData.normals = null;
    GeometryWorkerData.texCoords = null;
    GeometryWorkerData.indices = null;
    return GeometryWorkerData;
}());

var initGL = function (data, detect, WebGLDetectWorkerData, GPUDetectWorkerData) {
    return compose(map(detect(getGL$2, DeviceManagerWorkerData, GPUDetectWorkerData)), chain(setViewportOfGL$2(DeviceManagerWorkerData, data.viewportData)), _createGL(data.canvas, data.options, WebGLDetectWorkerData, DeviceManagerWorkerData))(createState());
};
var _createGL = curry(function (canvas, options, WebGLDetectWorkerData, DeviceManagerWorkerData$$1, state) {
    return IO.of(function () {
        var gl = getOnlyGL(canvas, options, WebGLDetectWorkerData);
        if (!gl) {
            DomQuery.create("<p class='not-support-webgl'></p>").prependTo("body").text("Your device doesn't support WebGL");
        }
        return compose(setCanvas(canvas), setContextConfig$2(options), setGL$2(gl, DeviceManagerWorkerData$$1))(state);
    });
});

var SpecifyLightWorkerData = (function () {
    function SpecifyLightWorkerData() {
    }
    SpecifyLightWorkerData.count = null;
    SpecifyLightWorkerData.colors = null;
    SpecifyLightWorkerData.isColorDirtys = null;
    return SpecifyLightWorkerData;
}());

var AmbientLightWorkerData = (function (_super) {
    __extends(AmbientLightWorkerData, _super);
    function AmbientLightWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AmbientLightWorkerData;
}(SpecifyLightWorkerData));

var DirectionLightWorkerData = (function (_super) {
    __extends(DirectionLightWorkerData, _super);
    function DirectionLightWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DirectionLightWorkerData.intensities = null;
    DirectionLightWorkerData.isPositionDirtys = null;
    DirectionLightWorkerData.isIntensityDirtys = null;
    return DirectionLightWorkerData;
}(SpecifyLightWorkerData));

var PointLightWorkerData = (function (_super) {
    __extends(PointLightWorkerData, _super);
    function PointLightWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PointLightWorkerData.intensities = null;
    PointLightWorkerData.constants = null;
    PointLightWorkerData.linears = null;
    PointLightWorkerData.quadratics = null;
    PointLightWorkerData.ranges = null;
    PointLightWorkerData.isPositionDirtys = null;
    PointLightWorkerData.isIntensityDirtys = null;
    PointLightWorkerData.isAttenuationDirtys = null;
    return PointLightWorkerData;
}(SpecifyLightWorkerData));

var BasicMaterialWorkerData = (function () {
    function BasicMaterialWorkerData() {
    }
    return BasicMaterialWorkerData;
}());

var LightMaterialWorkerData = (function () {
    function LightMaterialWorkerData() {
    }
    LightMaterialWorkerData.specularColors = null;
    LightMaterialWorkerData.emissionColors = null;
    LightMaterialWorkerData.shininess = null;
    LightMaterialWorkerData.shadings = null;
    LightMaterialWorkerData.lightModels = null;
    LightMaterialWorkerData.hasDiffuseMaps = null;
    LightMaterialWorkerData.hasSpecularMaps = null;
    return LightMaterialWorkerData;
}());

var MaterialWorkerData = (function () {
    function MaterialWorkerData() {
    }
    MaterialWorkerData.shaderIndices = null;
    MaterialWorkerData.colors = null;
    MaterialWorkerData.opacities = null;
    MaterialWorkerData.alphaTests = null;
    return MaterialWorkerData;
}());

var StateWorkerData = (function () {
    function StateWorkerData() {
    }
    StateWorkerData.state = createState();
    return StateWorkerData;
}());

var getState$1 = function (StateWorkerData) {
    return StateWorkerData.state;
};
var setState$1 = function (state, StateWorkerData) {
    StateWorkerData.state = state;
};

var MapManagerWorkerData = (function () {
    function MapManagerWorkerData() {
    }
    MapManagerWorkerData.textureIndices = null;
    MapManagerWorkerData.textureCounts = null;
    MapManagerWorkerData.materialTextureList = null;
    return MapManagerWorkerData;
}());

var TextureCacheWorkerData = (function () {
    function TextureCacheWorkerData() {
    }
    TextureCacheWorkerData.bindTextureUnitCache = null;
    return TextureCacheWorkerData;
}());

var TextureWorkerData = (function () {
    function TextureWorkerData() {
    }
    TextureWorkerData.index = null;
    TextureWorkerData.glTextures = null;
    TextureWorkerData.sourceMap = null;
    TextureWorkerData.uniformSamplerNameMap = null;
    TextureWorkerData.widths = null;
    TextureWorkerData.heights = null;
    TextureWorkerData.isNeedUpdates = null;
    return TextureWorkerData;
}());

var VaoWorkerData = (function (_super) {
    __extends(VaoWorkerData, _super);
    function VaoWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return VaoWorkerData;
}(VaoDataCommon));

var WebGL1DirectionLightWorkerData = (function (_super) {
    __extends(WebGL1DirectionLightWorkerData, _super);
    function WebGL1DirectionLightWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGL1DirectionLightWorkerData.positionArr = null;
    WebGL1DirectionLightWorkerData.lightGLSLDataStructureMemberNameArr = null;
    return WebGL1DirectionLightWorkerData;
}(DirectionLightWorkerData));

var WebGL1PointLightWorkerData = (function (_super) {
    __extends(WebGL1PointLightWorkerData, _super);
    function WebGL1PointLightWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGL1PointLightWorkerData.positionArr = null;
    WebGL1PointLightWorkerData.lightGLSLDataStructureMemberNameArr = null;
    return WebGL1PointLightWorkerData;
}(PointLightWorkerData));

var WebGL1GLSLSenderWorkerData = (function (_super) {
    __extends(WebGL1GLSLSenderWorkerData, _super);
    function WebGL1GLSLSenderWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1GLSLSenderWorkerData;
}(WebGL1GLSLSenderDataCommon));

var WebGL1LocationWorkerData = (function (_super) {
    __extends(WebGL1LocationWorkerData, _super);
    function WebGL1LocationWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1LocationWorkerData;
}(WebGL1LocationDataCommon));

var WebGL1ProgramWorkerData = (function (_super) {
    __extends(WebGL1ProgramWorkerData, _super);
    function WebGL1ProgramWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1ProgramWorkerData;
}(WebGL1ProgramDataCommon));

var WebGL1ShaderWorkerData = (function (_super) {
    __extends(WebGL1ShaderWorkerData, _super);
    function WebGL1ShaderWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL1ShaderWorkerData;
}(WebGL1ShaderDataCommon));

var WebGL2DirectionLightWorkerData = (function (_super) {
    __extends(WebGL2DirectionLightWorkerData, _super);
    function WebGL2DirectionLightWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGL2DirectionLightWorkerData.positionArr = null;
    return WebGL2DirectionLightWorkerData;
}(DirectionLightWorkerData));

var WebGL2PointLightWorkerData = (function (_super) {
    __extends(WebGL2PointLightWorkerData, _super);
    function WebGL2PointLightWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    WebGL2PointLightWorkerData.positionArr = null;
    return WebGL2PointLightWorkerData;
}(PointLightWorkerData));

var GBufferWorkerData = (function () {
    function GBufferWorkerData() {
    }
    GBufferWorkerData.gBuffer = null;
    GBufferWorkerData.positionTarget = null;
    GBufferWorkerData.normalTarget = null;
    GBufferWorkerData.colorTarget = null;
    GBufferWorkerData.depthTexture = null;
    return GBufferWorkerData;
}());

var DeferAmbientLightPassWorkerData = (function (_super) {
    __extends(DeferAmbientLightPassWorkerData, _super);
    function DeferAmbientLightPassWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeferAmbientLightPassWorkerData;
}(DeferAmbientLightPassDataCommon));

var DeferDirectionLightPassWorkerData = (function (_super) {
    __extends(DeferDirectionLightPassWorkerData, _super);
    function DeferDirectionLightPassWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeferDirectionLightPassWorkerData;
}(DeferDirectionLightPassDataCommon));

var DeferPointLightPassWorkerData = (function (_super) {
    __extends(DeferPointLightPassWorkerData, _super);
    function DeferPointLightPassWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeferPointLightPassWorkerData;
}(DeferPointLightPassDataCommon));

var WebGL2GLSLSenderWorkerData = (function (_super) {
    __extends(WebGL2GLSLSenderWorkerData, _super);
    function WebGL2GLSLSenderWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2GLSLSenderWorkerData;
}(WebGL2GLSLSenderDataCommon));

var WebGL2LocationWorkerData = (function (_super) {
    __extends(WebGL2LocationWorkerData, _super);
    function WebGL2LocationWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2LocationWorkerData;
}(WebGL2LocationDataCommon));

var WebGL2ProgramWorkerData = (function (_super) {
    __extends(WebGL2ProgramWorkerData, _super);
    function WebGL2ProgramWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2ProgramWorkerData;
}(WebGL2ProgramDataCommon));

var WebGL2ShaderWorkerData = (function (_super) {
    __extends(WebGL2ShaderWorkerData, _super);
    function WebGL2ShaderWorkerData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WebGL2ShaderWorkerData;
}(WebGL2ShaderDataCommon));

var getCanvas$1 = function () {
    return getCanvas(getState(DirectorData));
};
var setCanvas$1 = function (canvas) {
    setCanvas(canvas, getState(DirectorData));
};
var getCanvasLeft = function (canvas) {
    return getX(canvas);
};
var setCanvasLeft = function (canvas, x) {
    setX(x, canvas).run();
};
var getCanvasTop = function (canvas) {
    return getY(canvas);
};
var setCanvasTop = function (canvas, y) {
    setY(y, canvas).run();
};
var getCanvasWidth = function (canvas) {
    return getWidth$1(canvas);
};
var setCanvasWidth = function (canvas, width) {
    setWidth$1(width, canvas).run();
};
var getCanvasHeight = function (canvas) {
    return getHeight$1(canvas);
};
var setCanvasHeight = function (canvas, height) {
    setHeight$1(height, canvas).run();
};
var getCanvasStyleWidth = function (canvas) {
    return getStyleWidth(canvas);
};
var setCanvasStyleWidth = function (canvas, width) {
    setStyleWidth(width, canvas).run();
};
var getCanvasStyleHeight = function (canvas) {
    return getStyleHeight(canvas);
};
var setCanvasStyleHeight = function (canvas, height) {
    setStyleHeight(height, canvas).run();
};

var initData$72 = initData$14;

var initData$73 = initData$44;

var isCached$2 = isCached$1;
var addActiveTexture$2 = addActiveTexture$1;

var bowser = createCommonjsModule(function (module) {
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */

!function (root, name, definition) {
  if ('object' != 'undefined' && module.exports) module.exports = definition();
  else if (typeof undefined == 'function' && undefined.amd) undefined(name, definition);
  else root[name] = definition();
}(commonjsGlobal, 'bowser', function () {
  /**
    * See useragents.js for examples of navigator.userAgent
    */

  var t = true;

  function detect(ua) {

    function getFirstMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[1]) || '';
    }

    function getSecondMatch(regex) {
      var match = ua.match(regex);
      return (match && match.length > 1 && match[2]) || '';
    }

    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()
      , likeAndroid = /like android/i.test(ua)
      , android = !likeAndroid && /android/i.test(ua)
      , nexusMobile = /nexus\s*[0-6]\s*/i.test(ua)
      , nexusTablet = !nexusMobile && /nexus\s*[0-9]+/i.test(ua)
      , chromeos = /CrOS/.test(ua)
      , silk = /silk/i.test(ua)
      , sailfish = /sailfish/i.test(ua)
      , tizen = /tizen/i.test(ua)
      , webos = /(web|hpw)os/i.test(ua)
      , windowsphone = /windows phone/i.test(ua)
      , samsungBrowser = /SamsungBrowser/i.test(ua)
      , windows = !windowsphone && /windows/i.test(ua)
      , mac = !iosdevice && !silk && /macintosh/i.test(ua)
      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)
      , edgeVersion = getFirstMatch(/edge\/(\d+(\.\d+)?)/i)
      , versionIdentifier = getFirstMatch(/version\/(\d+(\.\d+)?)/i)
      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)
      , mobile = !tablet && /[^-]mobi/i.test(ua)
      , xbox = /xbox/i.test(ua)
      , result;

    if (/opera/i.test(ua)) {
      //  an old Opera
      result = {
        name: 'Opera'
      , opera: t
      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      };
    } else if (/opr|opios/i.test(ua)) {
      // a new Opera
      result = {
        name: 'Opera'
        , opera: t
        , version: getFirstMatch(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/SamsungBrowser/i.test(ua)) {
      result = {
        name: 'Samsung Internet for Android'
        , samsungBrowser: t
        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      };
    }
    else if (/coast/i.test(ua)) {
      result = {
        name: 'Opera Coast'
        , coast: t
        , version: versionIdentifier || getFirstMatch(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      };
    }
    else if (/yabrowser/i.test(ua)) {
      result = {
        name: 'Yandex Browser'
      , yandexbrowser: t
      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      };
    }
    else if (/ucbrowser/i.test(ua)) {
      result = {
          name: 'UC Browser'
        , ucbrowser: t
        , version: getFirstMatch(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      };
    }
    else if (/mxios/i.test(ua)) {
      result = {
        name: 'Maxthon'
        , maxthon: t
        , version: getFirstMatch(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      };
    }
    else if (/epiphany/i.test(ua)) {
      result = {
        name: 'Epiphany'
        , epiphany: t
        , version: getFirstMatch(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      };
    }
    else if (/puffin/i.test(ua)) {
      result = {
        name: 'Puffin'
        , puffin: t
        , version: getFirstMatch(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      };
    }
    else if (/sleipnir/i.test(ua)) {
      result = {
        name: 'Sleipnir'
        , sleipnir: t
        , version: getFirstMatch(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      };
    }
    else if (/k-meleon/i.test(ua)) {
      result = {
        name: 'K-Meleon'
        , kMeleon: t
        , version: getFirstMatch(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      };
    }
    else if (windowsphone) {
      result = {
        name: 'Windows Phone'
      , windowsphone: t
      };
      if (edgeVersion) {
        result.msedge = t;
        result.version = edgeVersion;
      }
      else {
        result.msie = t;
        result.version = getFirstMatch(/iemobile\/(\d+(\.\d+)?)/i);
      }
    }
    else if (/msie|trident/i.test(ua)) {
      result = {
        name: 'Internet Explorer'
      , msie: t
      , version: getFirstMatch(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      };
    } else if (chromeos) {
      result = {
        name: 'Chrome'
      , chromeos: t
      , chromeBook: t
      , chrome: t
      , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      };
    } else if (/chrome.+? edge/i.test(ua)) {
      result = {
        name: 'Microsoft Edge'
      , msedge: t
      , version: edgeVersion
      };
    }
    else if (/vivaldi/i.test(ua)) {
      result = {
        name: 'Vivaldi'
        , vivaldi: t
        , version: getFirstMatch(/vivaldi\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (sailfish) {
      result = {
        name: 'Sailfish'
      , sailfish: t
      , version: getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/seamonkey\//i.test(ua)) {
      result = {
        name: 'SeaMonkey'
      , seamonkey: t
      , version: getFirstMatch(/seamonkey\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/firefox|iceweasel|fxios/i.test(ua)) {
      result = {
        name: 'Firefox'
      , firefox: t
      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      };
      if (/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(ua)) {
        result.firefoxos = t;
      }
    }
    else if (silk) {
      result =  {
        name: 'Amazon Silk'
      , silk: t
      , version : getFirstMatch(/silk\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/phantom/i.test(ua)) {
      result = {
        name: 'PhantomJS'
      , phantom: t
      , version: getFirstMatch(/phantomjs\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/slimerjs/i.test(ua)) {
      result = {
        name: 'SlimerJS'
        , slimer: t
        , version: getFirstMatch(/slimerjs\/(\d+(\.\d+)?)/i)
      };
    }
    else if (/blackberry|\bbb\d+/i.test(ua) || /rim\stablet/i.test(ua)) {
      result = {
        name: 'BlackBerry'
      , blackberry: t
      , version: versionIdentifier || getFirstMatch(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      };
    }
    else if (webos) {
      result = {
        name: 'WebOS'
      , webos: t
      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      };
      /touchpad\//i.test(ua) && (result.touchpad = t);
    }
    else if (/bada/i.test(ua)) {
      result = {
        name: 'Bada'
      , bada: t
      , version: getFirstMatch(/dolfin\/(\d+(\.\d+)?)/i)
      };
    }
    else if (tizen) {
      result = {
        name: 'Tizen'
      , tizen: t
      , version: getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/qupzilla/i.test(ua)) {
      result = {
        name: 'QupZilla'
        , qupzilla: t
        , version: getFirstMatch(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || versionIdentifier
      };
    }
    else if (/chromium/i.test(ua)) {
      result = {
        name: 'Chromium'
        , chromium: t
        , version: getFirstMatch(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || versionIdentifier
      };
    }
    else if (/chrome|crios|crmo/i.test(ua)) {
      result = {
        name: 'Chrome'
        , chrome: t
        , version: getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      };
    }
    else if (android) {
      result = {
        name: 'Android'
        , version: versionIdentifier
      };
    }
    else if (/safari|applewebkit/i.test(ua)) {
      result = {
        name: 'Safari'
      , safari: t
      };
      if (versionIdentifier) {
        result.version = versionIdentifier;
      }
    }
    else if (iosdevice) {
      result = {
        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'
      };
      // WTF: version is not part of user agent in web apps
      if (versionIdentifier) {
        result.version = versionIdentifier;
      }
    }
    else if(/googlebot/i.test(ua)) {
      result = {
        name: 'Googlebot'
      , googlebot: t
      , version: getFirstMatch(/googlebot\/(\d+(\.\d+))/i) || versionIdentifier
      };
    }
    else {
      result = {
        name: getFirstMatch(/^(.*)\/(.*) /),
        version: getSecondMatch(/^(.*)\/(.*) /)
     };
   }

    // set webkit or gecko flag for browsers based on these engines
    if (!result.msedge && /(apple)?webkit/i.test(ua)) {
      if (/(apple)?webkit\/537\.36/i.test(ua)) {
        result.name = result.name || "Blink";
        result.blink = t;
      } else {
        result.name = result.name || "Webkit";
        result.webkit = t;
      }
      if (!result.version && versionIdentifier) {
        result.version = versionIdentifier;
      }
    } else if (!result.opera && /gecko\//i.test(ua)) {
      result.name = result.name || "Gecko";
      result.gecko = t;
      result.version = result.version || getFirstMatch(/gecko\/(\d+(\.\d+)?)/i);
    }

    // set OS flags for platforms that have multiple browsers
    if (!result.windowsphone && !result.msedge && (android || result.silk)) {
      result.android = t;
    } else if (!result.windowsphone && !result.msedge && iosdevice) {
      result[iosdevice] = t;
      result.ios = t;
    } else if (mac) {
      result.mac = t;
    } else if (xbox) {
      result.xbox = t;
    } else if (windows) {
      result.windows = t;
    } else if (linux) {
      result.linux = t;
    }

    function getWindowsVersion (s) {
      switch (s) {
        case 'NT': return 'NT'
        case 'XP': return 'XP'
        case 'NT 5.0': return '2000'
        case 'NT 5.1': return 'XP'
        case 'NT 5.2': return '2003'
        case 'NT 6.0': return 'Vista'
        case 'NT 6.1': return '7'
        case 'NT 6.2': return '8'
        case 'NT 6.3': return '8.1'
        case 'NT 10.0': return '10'
        default: return undefined
      }
    }
    
    // OS version extraction
    var osVersion = '';
    if (result.windows) {
      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i));
    } else if (result.windowsphone) {
      osVersion = getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i);
    } else if (result.mac) {
      osVersion = getFirstMatch(/Mac OS X (\d+([_\.\s]\d+)*)/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (iosdevice) {
      osVersion = getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i);
      osVersion = osVersion.replace(/[_\s]/g, '.');
    } else if (android) {
      osVersion = getFirstMatch(/android[ \/-](\d+(\.\d+)*)/i);
    } else if (result.webos) {
      osVersion = getFirstMatch(/(?:web|hpw)os\/(\d+(\.\d+)*)/i);
    } else if (result.blackberry) {
      osVersion = getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i);
    } else if (result.bada) {
      osVersion = getFirstMatch(/bada\/(\d+(\.\d+)*)/i);
    } else if (result.tizen) {
      osVersion = getFirstMatch(/tizen[\/\s](\d+(\.\d+)*)/i);
    }
    if (osVersion) {
      result.osversion = osVersion;
    }

    // device type extraction
    var osMajorVersion = !result.windows && osVersion.split('.')[0];
    if (
         tablet
      || nexusTablet
      || iosdevice == 'ipad'
      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))
      || result.silk
    ) {
      result.tablet = t;
    } else if (
         mobile
      || iosdevice == 'iphone'
      || iosdevice == 'ipod'
      || android
      || nexusMobile
      || result.blackberry
      || result.webos
      || result.bada
    ) {
      result.mobile = t;
    }

    // Graded Browser Support
    // http://developer.yahoo.com/yui/articles/gbs
    if (result.msedge ||
        (result.msie && result.version >= 10) ||
        (result.yandexbrowser && result.version >= 15) ||
		    (result.vivaldi && result.version >= 1.0) ||
        (result.chrome && result.version >= 20) ||
        (result.samsungBrowser && result.version >= 4) ||
        (result.firefox && result.version >= 20.0) ||
        (result.safari && result.version >= 6) ||
        (result.opera && result.version >= 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] >= 6) ||
        (result.blackberry && result.version >= 10.1)
        || (result.chromium && result.version >= 20)
        ) {
      result.a = t;
    }
    else if ((result.msie && result.version < 10) ||
        (result.chrome && result.version < 20) ||
        (result.firefox && result.version < 20.0) ||
        (result.safari && result.version < 6) ||
        (result.opera && result.version < 10.0) ||
        (result.ios && result.osversion && result.osversion.split(".")[0] < 6)
        || (result.chromium && result.version < 20)
        ) {
      result.c = t;
    } else result.x = t;

    return result
  }

  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '');

  bowser.test = function (browserList) {
    for (var i = 0; i < browserList.length; ++i) {
      var browserItem = browserList[i];
      if (typeof browserItem=== 'string') {
        if (browserItem in bowser) {
          return true;
        }
      }
    }
    return false;
  };

  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  function getVersionPrecision(version) {
    return version.split(".").length;
  }

  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  function map(arr, iterator) {
    var result = [], i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i = 0; i < arr.length; i++) {
      result.push(iterator(arr[i]));
    }
    return result;
  }

  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1
   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1
   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0
   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1
   *
   * @param  {Array<String>} versions versions to compare
   * @return {Number} comparison result
   */
  function compareVersions(versions) {
    // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));
    var chunks = map(versions, function (version) {
      var delta = precision - getVersionPrecision(version);

      // 2) "9" -> "9.0" (for precision = 2)
      version = version + new Array(delta + 1).join(".0");

      // 3) "9.0" -> ["000000000"", "000000009"]
      return map(version.split("."), function (chunk) {
        return new Array(20 - chunk.length).join("0") + chunk;
      }).reverse();
    });

    // iterate in reverse order by reversed chunks array
    while (--precision >= 0) {
      // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      else if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === 0) {
          // all version chunks are same
          return 0;
        }
      }
      else {
        return -1;
      }
    }
  }

  /**
   * Check if browser is unsupported
   *
   * @example
   *   bowser.isUnsupportedBrowser({
   *     msie: "10",
   *     firefox: "23",
   *     chrome: "29",
   *     safari: "5.1",
   *     opera: "16",
   *     phantom: "534"
   *   });
   *
   * @param  {Object}  minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function isUnsupportedBrowser(minVersions, strictMode, ua) {
    var _bowser = bowser;

    // make strictMode param optional with ua param usage
    if (typeof strictMode === 'string') {
      ua = strictMode;
      strictMode = void(0);
    }

    if (strictMode === void(0)) {
      strictMode = false;
    }
    if (ua) {
      _bowser = detect(ua);
    }

    var version = "" + _bowser.version;
    for (var browser in minVersions) {
      if (minVersions.hasOwnProperty(browser)) {
        if (_bowser[browser]) {
          if (typeof minVersions[browser] !== 'string') {
            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));
          }

          // browser version and min supported version.
          return compareVersions([version, minVersions[browser]]) < 0;
        }
      }
    }

    return strictMode; // not found
  }

  /**
   * Check if browser is supported
   *
   * @param  {Object} minVersions map of minimal version to browser
   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map
   * @param  {String}  [ua] user agent string
   * @return {Boolean}
   */
  function check(minVersions, strictMode, ua) {
    return !isUnsupportedBrowser(minVersions, strictMode, ua);
  }

  bowser.isUnsupportedBrowser = isUnsupportedBrowser;
  bowser.compareVersions = compareVersions;
  bowser.check = check;

  /*
   * Set our detect method to the main bowser object so we can
   * reuse it to test other user agents.
   * This is needed to implement future tests.
   */
  bowser._detect = detect;

  return bowser
});
});

var bowser_2 = bowser.chrome;
var bowser_4 = bowser.firefox;

var bindToUnit$2 = function (gl, unitIndex, textureIndex, TextureCacheWorkerData, TextureWorkerData, GPUDetectWorkerData) {
    bindToUnit$1(gl, unitIndex, textureIndex, TextureCacheWorkerData, TextureWorkerData, GPUDetectWorkerData, isCached$2, addActiveTexture$2);
};


var needUpdate$2 = needUpdate$1;
var update$5 = function (gl, textureIndex, TextureWorkerData) {
    update$3(gl, textureIndex, _setFlipY$1, TextureWorkerData);
};
var _setFlipY$1 = null;
if (bowser_2) {
    _setFlipY$1 = function (gl, flipY) {
    };
}
else if (bowser_4) {
    _setFlipY$1 = function (gl, flipY) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
    };
}




var _addSource = ensureFunc$$1(function (sourceMap, imageBitmap, TextureWorkerData) {
    it$$1("should not has duplicate one", function () {
        wdet_1(hasDuplicateItems(sourceMap)).false;
    });
    it$$1("sourceMap.length should equal texture count", function () {
        wdet_1(sourceMap.length).equal(TextureWorkerData.index);
    });
}, function (imageBitmap, TextureWorkerData) {
    TextureWorkerData.sourceMap.push(imageBitmap);
    return TextureWorkerData.sourceMap;
});

var setCount = function (count, SepcifyLightDataFromSystem) {
    SepcifyLightDataFromSystem.count = count;
};

var initData$77 = function (_a, DirectionLightWorkerData) {
    var buffer = _a.buffer, bufferCount = _a.bufferCount, lightCount = _a.lightCount, directionLightGLSLDataStructureMemberNameArr = _a.directionLightGLSLDataStructureMemberNameArr;
    setCount(lightCount, DirectionLightWorkerData);
    DirectionLightWorkerData.lightGLSLDataStructureMemberNameArr = directionLightGLSLDataStructureMemberNameArr;
    createTypeArrays$6(buffer, bufferCount, DirectionLightWorkerData);
};

var getColorArr3$9 = getColorArr3$8;
var initData$78 = function (_a, AmbientLightWorkerData) {
    var buffer = _a.buffer, bufferCount = _a.bufferCount, lightCount = _a.lightCount;
    _setCount(lightCount, AmbientLightWorkerData);
    createTypeArrays$11(buffer, bufferCount, AmbientLightWorkerData);
};
var _setCount = setCount;
var isColorDirty$6 = isColorDirty$5;
var cleanColorDirty$6 = cleanColorDirty$5;

var initData$79 = function (_a, PointLightWorkerData) {
    var buffer = _a.buffer, bufferCount = _a.bufferCount, lightCount = _a.lightCount, pointLightGLSLDataStructureMemberNameArr = _a.pointLightGLSLDataStructureMemberNameArr;
    setCount(lightCount, PointLightWorkerData);
    PointLightWorkerData.lightGLSLDataStructureMemberNameArr = pointLightGLSLDataStructureMemberNameArr;
    createTypeArrays$7(buffer, bufferCount, PointLightWorkerData);
};

var initData$76 = function (lightData, AmbientLightDataFromSystem, DirectionLightDataFromSystem, PointLightDataFromSystem) {
    initData$78(lightData.ambientLightData, AmbientLightDataFromSystem);
    initData$77(lightData.directionLightData, DirectionLightDataFromSystem);
    initData$79(lightData.pointLightData, PointLightDataFromSystem);
};

var initData$81 = function (_a, PointLightWorkerData) {
    var buffer = _a.buffer, bufferCount = _a.bufferCount, lightCount = _a.lightCount;
    setCount(lightCount, PointLightWorkerData);
    createTypeArrays$7(buffer, bufferCount, PointLightWorkerData);
};
var computeRadius$2 = computeRadius$1;

var initData$82 = function (_a, DirectionLightWorkerData) {
    var buffer = _a.buffer, bufferCount = _a.bufferCount, lightCount = _a.lightCount;
    setCount(lightCount, DirectionLightWorkerData);
    createTypeArrays$6(buffer, bufferCount, DirectionLightWorkerData);
};

var initData$80 = function (lightData, DirectionLightDataFromSystem, PointLightDataFromSystem) {
    initData$82(lightData.directionLightData, DirectionLightDataFromSystem);
    initData$81(lightData.pointLightData, PointLightDataFromSystem);
};

var getDirectionLightPosition$1 = function (index, DirectionLightDataFromSystem) {
    return _getLightPosition(index, DirectionLightDataFromSystem);
};
var getPointLightPosition$1 = function (index, PointLightDataFromSystem) {
    return _getLightPosition(index, PointLightDataFromSystem);
};
var _getLightPosition = function (index, LightDataFromSystem) {
    return LightDataFromSystem.positionArr[index];
};

var initData$83 = initData$37;

var initData$84 = initData$28;

var initData$85 = initData$53;

var initData$86 = initData$39;

var initData$87 = initData$31;

var initData$88 = initData$38;

var initData$89 = initData$32;

var getMapCount$2 = function (materialIndex, MapManagerWorkerData) {
    var textureCounts = MapManagerWorkerData.textureCounts;
    if (textureCounts === null) {
        return 0;
    }
    return textureCounts[materialIndex];
};
var bindAndUpdate$2 = function (gl, mapCount, startIndex, definedStartTextureUnitIndex, TextureCacheWorkerData, TextureWorkerData, MapManagerWorkerData, GPUDetectWorkerData) {
    bindAndUpdate$1(gl, mapCount, startIndex, definedStartTextureUnitIndex, TextureCacheWorkerData, TextureWorkerData, MapManagerWorkerData, GPUDetectWorkerData, bindToUnit$2, needUpdate$2, update$5);
};

var getSpecularColorArr3$2 = function (index, LightMaterialWorkerData) {
    return getSpecularColorArr3(computeLightBufferIndex(index), LightMaterialWorkerData);
};
var getEmissionColorArr3$2 = function (index, LightMaterialWorkerData) {
    return getEmissionColorArr3(computeLightBufferIndex(index), LightMaterialWorkerData);
};
var getShininess$2 = function (index, LightMaterialWorkerData) {
    return getShininess(computeLightBufferIndex(index), LightMaterialWorkerData);
};

var getLightModel$2 = function (index, LightMaterialWorkerData) {
    return getLightModel(computeLightBufferIndex(index), LightMaterialWorkerData);
};

var getVertices$2 = ensureFunc$$1(function (vertices, index, GeometryWorkerData) {
    it$$1("vertices should exist", function () {
        wdet_1(vertices).exist;
    });
}, function (index, GeometryWorkerData) {
    return GeometryWorkerData.verticesCacheMap[index];
});
var getNormals$2 = ensureFunc$$1(function (normals, index, GeometryWorkerData) {
    it$$1("normals should exist", function () {
        wdet_1(normals).exist;
    });
}, function (index, GeometryWorkerData) {
    return GeometryWorkerData.normalsCacheMap[index];
});
var getTexCoords$2 = ensureFunc$$1(function (texCoords, index, GeometryWorkerData) {
    it$$1("texCoords should exist", function () {
        wdet_1(texCoords).exist;
    });
}, function (index, GeometryWorkerData) {
    return GeometryWorkerData.texCoordsCacheMap[index];
});
var getIndices$2 = ensureFunc$$1(function (indices, index, GeometryWorkerData) {
    it$$1("indices should exist", function () {
        wdet_1(indices).exist;
    });
}, function (index, GeometryWorkerData) {
    return GeometryWorkerData.indicesCacheMap[index];
});



var _setPointCacheData = requireCheckFunc(function (infoList, points, cacheMap) {
    it$$1("infoList should has no invalid value", function () {
        if (infoList === void 0) {
            return;
        }
        for (var _i = 0, infoList_2 = infoList; _i < infoList_2.length; _i++) {
            var info = infoList_2[_i];
            wdet_1(isValidVal(info)).true;
        }
    });
}, function (infoList, points, cacheMap) {
    if (infoList === void 0) {
        return;
    }
    for (var i = 0, len = infoList.length; i < len; i++) {
        var info = infoList[i], dataArr = getSlice(points, info.startIndex, info.endIndex);
        cacheMap[i] = dataArr;
    }
});
var getIndexType$2 = getIndexType$1;
var getIndexTypeSize$2 = getIndexTypeSize$1;
var hasIndices$2 = function (index, GeometryWorkerData) { return hasIndices$1(index, getIndices$2, GeometryWorkerData); };

var getVerticesCount$2 = function (index, GeometryWorkerData) { return getVerticesCount$1(index, getVertices$2, GeometryWorkerData); };
var getIndicesCount$2 = function (index, GeometryWorkerData) { return getIndicesCount$1(index, getIndices$2, GeometryWorkerData); };

var initData$90 = initData$36;

var initData$94 = initData$27;

var getColorArr3$10 = getColorArr3$4;
var getIntensity$4 = getIntensity$1;
var isPositionDirty$4 = isPositionDirty$1;
var isColorDirty$7 = isColorDirty$1;
var isIntensityDirty$4 = isIntensityDirty$1;
var cleanPositionDirty$4 = cleanPositionDirty$1;
var cleanColorDirty$7 = cleanColorDirty$1;
var cleanIntensityDirty$4 = cleanIntensityDirty$1;

var getColorArr3$11 = getColorArr3$6;
var getIntensity$5 = getIntensity$3;
var getConstant$2 = getConstant$1;
var getLinear$2 = getLinear$1;
var getQuadratic$2 = getQuadratic$1;
var getRange$2 = getRange$1;
var isPositionDirty$5 = isPositionDirty$3;
var isColorDirty$8 = isColorDirty$3;
var isIntensityDirty$5 = isIntensityDirty$3;
var isAttenuationDirty$2 = isAttenuationDirty$1;
var cleanPositionDirty$5 = cleanPositionDirty$3;
var cleanColorDirty$8 = cleanColorDirty$3;
var cleanIntensityDirty$5 = cleanIntensityDirty$3;
var cleanAttenuationDirty$2 = cleanAttenuationDirty$1;

var isWebgl1$2 = isWebgl1;

var detect$6 = curry(function (getGL, DeviceManagerWorkerData, GPUDetectWorkerData, state) {
    return detect$3(getGL, DeviceManagerWorkerData, GPUDetectWorkerData, state);
});
var initData$95 = initData$40;

var detect$7 = curry(function (getGL, DeviceManagerWorkerData, GPUDetectWorkerData, state) {
    return detect$2(getGL, DeviceManagerWorkerData, GPUDetectWorkerData, state);
});

var initData$96 = initData$30;

var use$3 = use$1;

var getUniformLocation$2 = getUniformLocation$1;
var isUniformLocationNotExist$2 = isUniformLocationNotExist$1;

var sendMatrix3$2 = function (gl, program, name, data, uniformLocationMap) {
    sendMatrix3(gl, program, name, data, uniformLocationMap, getUniformLocation$2, isUniformLocationNotExist$2);
};
var sendMatrix4$2 = function (gl, program, name, data, uniformLocationMap) {
    sendMatrix4(gl, program, name, data, uniformLocationMap, getUniformLocation$2, isUniformLocationNotExist$2);
};
var sendVector3$2 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendVector3(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$2, isUniformLocationNotExist$2);
};
var sendInt$2 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendInt(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$2, isUniformLocationNotExist$2);
};
var sendFloat1$2 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendFloat1(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$2, isUniformLocationNotExist$2);
};
var sendFloat3$2 = function (gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap) {
    sendFloat3(gl, shaderIndex, program, name, data, uniformCacheMap, uniformLocationMap, getUniformLocation$2, isUniformLocationNotExist$2);
};

var BufferUtilsForUnitTest = (function () {
    function BufferUtilsForUnitTest() {
    }
    BufferUtilsForUnitTest.isRenderCommandBufferDataTypeArrayNotExist = function (RenderCommandBufferDataFromSystem) {
        return RenderCommandBufferDataFromSystem.mMatrices === null;
    };
    return BufferUtilsForUnitTest;
}());

var sendUniformData$5 = function (gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap) {
    sendUniformData$2(gl, materialIndex, shaderIndex, program, drawDataMap, renderCommandUniformData, sendDataMap, uniformLocationMap, uniformCacheMap, buildMaterialDataForGetUniformData$1(getColorArr3$2, getOpacity$2, drawDataMap.MaterialDataFromSystem), buildLightMaterialDataForGetUniformData(getEmissionColorArr3$2, getSpecularColorArr3$2, getLightModel$2, getShininess$2, drawDataMap.LightMaterialDataFromSystem));
};

var render$18 = curry(function (gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, drawDataMap, deferDrawDataMap, initShaderDataMap, bufferData, cameraData) {
    render$4(gl, state, render_config, material_config, shaderLib_generator, DataBufferConfig, initMaterialShader, buildDrawFuncDataMap(sendAttributeData$6, sendUniformData$5, directlySendUniformData, use$3, hasIndices$2, getIndicesCount$2, getIndexType$2, getIndexTypeSize$2, getVerticesCount$2, bindAndUpdate$2, getMapCount$2, getStartTextureIndex, useShader$2, bindGBuffer, unbindGBuffer, getNewTextureUnitIndex), drawDataMap, deferDrawDataMap, buildSendUniformDataDataMap(sendFloat1$2, sendFloat3$2, sendMatrix4$2, sendVector3$2, sendInt$2, sendMatrix3$2, getColorArr3$9, isColorDirty$6, cleanColorDirty$6, getDirectionLightPosition$1, getColorArr3$10, getIntensity$4, isPositionDirty$4, isColorDirty$7, isIntensityDirty$4, cleanPositionDirty$4, cleanColorDirty$7, cleanIntensityDirty$4, getPointLightPosition$1, getColorArr3$11, getConstant$2, getIntensity$5, getLinear$2, getQuadratic$2, getRange$2, computeRadius$2, isPositionDirty$5, isColorDirty$8, isIntensityDirty$5, isAttenuationDirty$2, cleanPositionDirty$5, cleanColorDirty$8, cleanIntensityDirty$5, cleanAttenuationDirty$2, drawDataMap), initShaderDataMap, bufferData, cameraData);
});

var sendAttributeData$6 = function (gl, shaderIndex, geometryIndex, ProgramWorkerData, GLSLSenderWorkerData, GeometryWorkerData, VaoWorkerData) { return sendAttributeData$1(gl, shaderIndex, geometryIndex, ProgramWorkerData, GLSLSenderWorkerData, GeometryWorkerData, VaoWorkerData); };

var initData$97 = initData$50;

var initDataWhenInitGL = function () {
    _initData$2();
    if (isWebgl1$2(WebGLDetectWorkerData)) {
        _initWebGL1Data();
    }
    else {
        _initWebGL2Data();
    }
};
var _initData$2 = function () {
    initData$73(BasicDrawRenderCommandBufferWorkerData, LightDrawRenderCommandBufferWorkerData);
    initData$87(VaoWorkerData);
    initData$63(DeviceManagerWorkerData);
};
var _initWebGL1Data = function () {
    initData$72(WebGL1ProgramWorkerData);
    initData$88(WebGL1LocationWorkerData);
    initData$83(WebGL1GLSLSenderWorkerData);
    initData$85(ArrayBufferWorkerData);
    initData$86(IndexBufferWorkerData);
    initData$90(WebGL1ShaderWorkerData);
    initData$95(GPUDetectWorkerData);
};
var _initWebGL2Data = function () {
    initData$72(WebGL2ProgramWorkerData);
    initData$89(WebGL2LocationWorkerData);
    initData$84(WebGL2GLSLSenderWorkerData);
    initData$94(WebGL2ShaderWorkerData);
    initData$97(DeferAmbientLightPassWorkerData, DeferDirectionLightPassWorkerData, DeferPointLightPassWorkerData);
    initData$96(GPUDetectWorkerData);
};

var initDeviceManagerWorkerData = initData$63;
var initProgramWorkerData = initData$72;
var initWebGL1GLSLSenderWorkerData = initData$83;
var initWebGL2GLSLSenderWorkerData = initData$84;
var initWebGL1LocationWorkerData = initData$88;
var initWebGL2LocationWorkerData = initData$89;
var initWebGL1ShaderWorkerData = initData$90;
var initWebGL2ShaderWorkerData = initData$94;
var initWebGL1LightWorkerData = initData$76;
var initWebGL2LightWorkerData = initData$80;
var initDrawRenderCommandBufferWorkerData = initData$73;
var initArrayBufferWorkerData = initData$85;
var initIndexBufferWorkerData = initData$86;
var initVaoWorkerData = initData$87;
var initWorkerDataWhenInitGL = initDataWhenInitGL;
var getDirectionLightPositionInShaderWorker = getDirectionLightPosition$1;
var getPointLightPositionInShaderWorker = getPointLightPosition$1;
var updateTextureWorker = update$5;

var initThreeDTransformData = initData$11;
var DomQuery$1 = DomQuery;
var fromArray$1 = fromArray;
var initTagData = initData$12;
var initGeometryData = initData$13;
var initMaterialData = initData$41;
var initWebGL1ShaderData = initData$35;
var initWebGL2ShaderData = initData$26;
var initProgramData = initData$62;
var initWebGL1LocationData = initData$69;
var initWebGL2LocationData = initData$70;
var initWebGL1GLSLSenderData = initData$67;
var initWebGL2GLSLSenderData = initData$66;
var initMeshRendererData = initData$7;
var initArrayBufferData = initData$59;
var initIndexBufferData = initData$60;
var initDeviceManagerData = initData$4;
var initCameraControllerData = initData$20;
var initWebGL1LightData = initData$54;
var initWebGL2LightData = initData$57;
var initGameObjectData = initData$10;
var initSceneData = initData$19;
var initRenderCommandBufferData = initData$8;
var initDrawRenderCommandBufferData = initData$43;
var initSendDrawRenderCommandBufferData = initData$24;
var initVaoData = initData$68;
var initDeferLightPassData = initData$71;
var initWebGL1GPUDetectData = initData$64;
var initWebGL2GPUDetectData = initData$65;
var initData$99 = initData$61;
var createState$1 = createState;
var useProgram = use$$1;
var sendWebGL1AttributeData = sendAttributeData$3;
var disableVertexAttribArray$1 = disableVertexAttribArray;
var setGeometryIndices = setIndices;
var setGeometryVertices = setVertices;
var hasGeometryIndices = hasIndices$$1;
var getShaderIndex$1 = getShaderIndex;
var updateSystem$1 = updateSystem;
var getNormalMatrix$1 = getNormalMatrix;
var getWorldToCameraMatrix$2 = getWorldToCameraMatrix$$1;
var getImageData$1 = getImageData;
var hasDiffuseMap$3 = hasDiffuseMap$1;
var hasSpecularMap$3 = hasSpecularMap$1;

export { loadAsset, getAsset, setTextureAsset$$1 as setTextureAsset, AssetDatabaseData, ImageTextureAsset, TextureAsset, getCameraPMatrix, getCameraNear, setCameraNear, getCameraFar, setCameraFar, CameraController, createCameraController, getCameraControllerGameObject, CameraControllerData, CameraData, getPerspectiveCameraFovy, setPerspectiveCameraFovy, getPerspectiveCameraAspect, setPerspectiveCameraAspect, PerspectiveCameraData, Component, getComponentIdFromClass, getComponentIdFromComponent, ComponentData, getTypeIdFromClass, getTypeIdFromComponent, BoxGeometry, createBoxGeometry, setBoxGeometryConfigData, CustomGeometry, createCustomGeometry, setCustomGeometryVertices, setCustomGeometryNormals, setCustomGeometryTexCoords, setCustomGeometryIndices, Geometry, getDrawMode$$1 as getDrawMode, getVertices$$1 as getVertices, getNormals$$1 as getNormals, getTexCoords$$1 as getTexCoords, getIndices$$1 as getIndices, getGeometryConfigData, initGeometry$$1 as initGeometry, getGeometryGameObject, GeometryData, AmbientLight, createAmbientLight, getAmbientLightGameObject, getAmbientLightColor, setAmbientLightColor, AmbientLightData, DirectionLight, createDirectionLight, getDirectionLightGameObject, getDirectionLightPosition, getDirectionLightColor, setDirectionLightColor, getDirectionLightIntensity, setDirectionLightIntensity, DirectionLightData, Light, checkLightShouldAlive, PointLight, createPointLight, getPointLightGameObject, getPointLightPosition, getPointLightColor, setPointLightColor, getPointLightIntensity, setPointLightIntensity, getPointLightConstant, setPointLightConstant, getPointLightLinear, setPointLightLinear, getPointLightQuadratic, setPointLightQuadratic, getPointLightRange, setPointLightRange, setPointLightRangeLevel, PointLightData, SpecifyLightData, BasicMaterial, createBasicMaterial, initBasicMaterial, getBasicMaterialColor, setBasicMaterialColor, getBasicMaterialOpacity, setBasicMaterialOpacity, getBasicMaterialAlphaTest, setBasicMaterialAlphaTest, setBasicMaterialMap, BasicMaterialData, ELightModel, EShading, LightMaterial, createLightMaterial, initLightMaterial, getLightMaterialColor, setLightMaterialColor, getLightMaterialOpacity, setLightMaterialOpacity, getLightMaterialAlphaTest, setLightMaterialAlphaTest, getLightMaterialSpecularColor, setLightMaterialSpecularColor, getLightMaterialEmissionColor, setLightMaterialEmissionColor, getLightMaterialShininess, setLightMaterialShininess, getLightMaterialShading, setLightMaterialShading, getLightMaterialLightModel, setLightMaterialLightModel, setLightMaterialDiffuseMap, setLightMaterialSpecularMap, LightMaterialData, Material, getMaterialGameObject, checkShouldAlive$1 as checkShouldAlive, MaterialData, SpecifyMaterialData, MeshRenderer, createMeshRenderer, getMeshRendererGameObject, getMeshRendererRenderList, MeshRendererData, Tag, createTag, addTag$1 as addTag, removeTag$1 as removeTag, findGameObjectsByTag$1 as findGameObjectsByTag, getTagGameObject, TagData, LinkList, LinkNode, ThreeDTransform, createThreeDTransform, getThreeDTransformPosition, setThreeDTransformPosition, getThreeDTransformLocalToWorldMatrix, getThreeDTransformLocalPosition, setThreeDTransformLocalPosition, setThreeDTransformBatchTransformDatas, getThreeDTransformParent, setThreeDTransformParent, getThreeDTransformGameObject, ThreeDTransformData, ThreeDTransformRelationData, getUId, isIndexUsed, getStartIndexInArrayBuffer, CompileConfig, DataBufferConfig, DebugConfig, MemoryConfig, RenderWorkerConfig, Director, isDirectorInit, DirectorData, GameObject, createGameObject, addGameObjectComponent, disposeGameObject, initGameObject$1 as initGameObject, disposeGameObjectComponent, getGameObjectComponent, getGameObjectTransform, getGameObjectMaterial, getGameObjectAllComponents, hasGameObjectComponent, isGameObjectAlive, addGameObject, addRemovedGameObject, removeGameObject, hasGameObject, getGameObjectChildren, getGameObjectParent, setGameObjectParent, GameObjectData, Scene, addSceneChild, removeSceneChild, SceneData, Main$1 as Main, initAllData, Scheduler$1 as Scheduler, GlobalTempData, cache, describe$$1 as describe, it$$1 as it, requireCheck$1 as requireCheck, requireCheckFunc, ensure$1 as ensure, ensureFunc$$1 as ensureFunc, ensureGetter$1 as ensureGetter, execOnlyOnce, registerClass$1 as registerClass, singleton, virtual, root$2 as root, WorkerDetectData, DEG_TO_RAD, RAD_TO_DEG, Matrix3, Matrix4, Quaternion, Vector2, Vector3, Vector4, ArrayBufferData, IndexBufferData, BasicRenderCommandBufferData, LightRenderCommandBufferData, InitConfigData, getDeviceManagerGL, setDeviceManagerGL, getDeviceManagerViewport, getDeviceManagerClearColor, setDeviceManagerViewport, setDeviceManagerClearColor, DeviceManagerData, EScreenSize, GPUDetectData, WebGLDetectData, BasicDrawRenderCommandBufferData, LightDrawRenderCommandBufferData, EBlendEquation, EBlendFunc, EBufferType, EDrawMode, EGeometryWorkerDataOperateType, EGPUPrecision, ELightWorkerDataOperateType, ESide, ETextureFilterMode, ETextureFormat, ETextureTarget, ETextureType, ETextureWrapMode, EVariableType, EWebGLVersion, empty$1 as empty, NULL, common_define, common_fragment, common_function, common_vertex, highp_fragment, lowp_fragment, mediump_fragment, modelMatrix_noInstance_vertex, webgl1_noShadowMap_fragment, webgl1_basic_end_fragment, webgl1_basic_materialColor_fragment, frontLight_common, frontLight_common_fragment, frontLight_common_vertex, frontLight_end_fragment, frontLight_fragment, frontLight_setWorldPosition_vertex, frontLight_vertex, webgl1_normalMatrix_noInstance_vertex, webgl1_basic_map_fragment, webgl1_basic_map_vertex, webgl1_diffuseMap_fragment, webgl1_diffuseMap_vertex, webgl1_noDiffuseMap_fragment, webgl1_noEmissionMap_fragment, webgl1_noLightMap_fragment, webgl1_noNormalMap_fragment, webgl1_noNormalMap_vertex, webgl1_noSpecularMap_fragment, webgl1_specularMap_fragment, webgl1_specularMap_vertex, webgl2_deferLightPass_directionLight_noNormalMap_fragment, webgl2_deferLightPass_pointLight_noNormalMap_fragment, webgl2_noShadowMap_fragment, webgl2_basic_end_fragment, webgl2_basic_materialColor_fragment, webgl2_basic_vertex, ubo_light, ubo_camera, version, webgl2_common_define, webgl2_common_fragment, webgl2_common_function, webgl2_common_vertex, webgl2_basic_map_fragment, webgl2_basic_map_vertex, gbuffer_common_fragment, gbuffer_common_vertex, gbuffer_end_fragment, gbuffer_fragment, gbuffer_setWorldPosition_vertex, gbuffer_vertex, deferLightPass_common, deferLightPass_directionLight_pointLight_common, deferLightPass_end_fragment, deferLightPass_vertex, webgl2_normalMatrix_noInstance_vertex, webgl2_diffuseMap_fragment, webgl2_diffuseMap_vertex, webgl2_gbuffer_noNormalMap_fragment, webgl2_gbuffer_noNormalMap_vertex, webgl2_noDiffuseMap_fragment, webgl2_noSpecularMap_fragment, webgl2_specularMap_fragment, webgl2_specularMap_vertex, deferLightPass_ambientLight_fragment, ubo_ambientLight, deferLightPass_directionLight_common, deferLightPass_directionLight_fragment, ubo_directionLight, deferLightPass_pointLight_common, deferLightPass_pointLight_fragment, ubo_pointLight, webgl2_deferLightPass_noNormalMap_fragment, webgl2_noEmissionMap_fragment, webgl2_noLightMap_fragment, MapManagerData, Texture, createTexture, initTexture$1 as initTexture, disposeTexture, getTextureSource, setTextureSource, getTextureWidth, setTextureWidth, getTextureHeight, setTextureHeight, getTextureIsNeedUpdate, setTextureIsNeedUpdate, TextureCacheData, TextureData, DeviceManagerDataCommon, GPUDetectDataCommon, VaoDataCommon, VaoData, WebGL1DirectionLightData, WebGL1PointLightData, WebGL1GLSLSenderData, WebGL1LocationData, WebGL1ProgramData, WebGL1ShaderData, webgl1_main_begin, webgl1_main_end, webgl1_setPos_mvp, WebGL1GLSLSenderDataCommon, WebGL1LocationDataCommon, WebGL1ProgramDataCommon, WebGL1ShaderDataCommon, WebGL2DirectionLightData, WebGL2PointLightData, GBufferData, DeferAmbientLightPassData, DeferDirectionLightPassData, DeferPointLightPassData, WebGL2GLSLSenderData, WebGL2LocationData, WebGL2ProgramData, WebGL2ShaderData, webgl2_main_begin, webgl2_main_end, webgl2_setPos_mvp, DeferAmbientLightPassDataCommon, DeferDirectionLightPassDataCommon, DeferPointLightPassDataCommon, WebGL2GLSLSenderDataCommon, WebGL2LocationDataCommon, WebGL2ProgramDataCommon, WebGL2ShaderDataCommon, render_config, DeviceManagerWorkerData, ERenderWorkerState, EWorkerOperateType, SendDrawRenderCommandBufferData, ArrayBufferWorkerData, IndexBufferWorkerData, BasicRenderCommandBufferWorkerData, LightRenderCommandBufferWorkerData, InitConfigWorkerData, GPUDetectWorkerData, WebGLDetectWorkerData, BasicDrawRenderCommandBufferWorkerData, LightDrawRenderCommandBufferWorkerData, GeometryWorkerData, initGL, AmbientLightWorkerData, DirectionLightWorkerData, PointLightWorkerData, SpecifyLightWorkerData, BasicMaterialWorkerData, LightMaterialWorkerData, MaterialWorkerData, StateWorkerData, getState$1 as getState, setState$1 as setState, MapManagerWorkerData, TextureCacheWorkerData, TextureWorkerData, VaoWorkerData, webgl1_material_config, webgl1_shaderLib_generator, WebGL1DirectionLightWorkerData, WebGL1PointLightWorkerData, WebGL1GLSLSenderWorkerData, WebGL1LocationWorkerData, WebGL1ProgramWorkerData, WebGL1ShaderWorkerData, webgl2_material_config, webgl2_shaderLib_generator, WebGL2DirectionLightWorkerData, WebGL2PointLightWorkerData, GBufferWorkerData, DeferAmbientLightPassWorkerData, DeferDirectionLightPassWorkerData, DeferPointLightPassWorkerData, WebGL2GLSLSenderWorkerData, WebGL2LocationWorkerData, WebGL2ProgramWorkerData, WebGL2ShaderWorkerData, Color, RectRegion, getCanvas$1 as getCanvas, setCanvas$1 as setCanvas, getCanvasLeft, setCanvasLeft, getCanvasTop, setCanvasTop, getCanvasWidth, setCanvasWidth, getCanvasHeight, setCanvasHeight, getCanvasStyleWidth, setCanvasStyleWidth, getCanvasStyleHeight, setCanvasStyleHeight, initDeviceManagerWorkerData, initProgramWorkerData, initWebGL1GLSLSenderWorkerData, initWebGL2GLSLSenderWorkerData, initWebGL1LocationWorkerData, initWebGL2LocationWorkerData, initWebGL1ShaderWorkerData, initWebGL2ShaderWorkerData, initWebGL1LightWorkerData, initWebGL2LightWorkerData, initDrawRenderCommandBufferWorkerData, initArrayBufferWorkerData, initIndexBufferWorkerData, initVaoWorkerData, initWorkerDataWhenInitGL, getDirectionLightPositionInShaderWorker, getPointLightPositionInShaderWorker, updateTextureWorker, initThreeDTransformData, DomQuery$1 as DomQuery, fromArray$1 as fromArray, initTagData, initGeometryData, initMaterialData, initWebGL1ShaderData, initWebGL2ShaderData, initProgramData, initWebGL1LocationData, initWebGL2LocationData, initWebGL1GLSLSenderData, initWebGL2GLSLSenderData, initMeshRendererData, initArrayBufferData, initIndexBufferData, initDeviceManagerData, initCameraControllerData, initWebGL1LightData, initWebGL2LightData, initGameObjectData, initSceneData, initRenderCommandBufferData, initDrawRenderCommandBufferData, initSendDrawRenderCommandBufferData, initVaoData, initDeferLightPassData, initWebGL1GPUDetectData, initWebGL2GPUDetectData, initData$99 as initData, createState$1 as createState, useProgram, sendWebGL1AttributeData, disableVertexAttribArray$1 as disableVertexAttribArray, setGeometryIndices, setGeometryVertices, hasGeometryIndices, getShaderIndex$1 as getShaderIndex, updateSystem$1 as updateSystem, getNormalMatrix$1 as getNormalMatrix, getWorldToCameraMatrix$2 as getWorldToCameraMatrix, getImageData$1 as getImageData, hasDiffuseMap$3 as hasDiffuseMap, hasSpecularMap$3 as hasSpecularMap, BufferUtilsForUnitTest, Log$$1 as Log, CommonTimeController, DirectorTimeController, TimeController, WorkerInstanceData };
//# sourceMappingURL=wd.module.js.map
