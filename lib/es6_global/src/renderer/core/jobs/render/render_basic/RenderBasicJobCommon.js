// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as ArraySystem$Wonderjs                      from "../../../../../structure/ArraySystem.js";
import * as GeometryAdmin$Wonderjs                    from "../../../../../ecs/admin/component/GeometryAdmin.js";
import * as MaterialAdmin$Wonderjs                    from "../../../../../ecs/admin/component/material/MaterialAdmin.js";
import * as ProgramSystem$Wonderjs                    from "../../../../shader/program/ProgramSystem.js";
import * as GameObjectAdmin$Wonderjs                  from "../../../../../ecs/admin/GameObjectAdmin.js";
import * as GLSLSenderSystem$Wonderjs                 from "../../../../shader/sender/GLSLSenderSystem.js";
import * as ArrayBufferSystem$Wonderjs                from "../../../../buffer/ArrayBufferSystem.js";
import * as ExceptionHandleSystem$Wonderjs            from "../../../../../exception/ExceptionHandleSystem.js";
import * as ElementArrayBufferSystem$Wonderjs         from "../../../../buffer/ElementArrayBufferSystem.js";
import * as VboBufferGetStateDataUtils$Wonderjs       from "../../../../buffer/VboBufferGetStateDataUtils.js";
import * as GLSLSenderConfigDataHandleSystem$Wonderjs from "../../../../shader/sender/GLSLSenderConfigDataHandleSystem.js";

function _sendAttributeData(gl, shaderIndex, geometryIndex, state) {
  var match = VboBufferGetStateDataUtils$Wonderjs.getVboBufferData(state);
  var vertexBufferMap = match[/* vertexBufferMap */0];
  var elementArrayBufferMap = match[/* elementArrayBufferMap */1];
  return ArraySystem$Wonderjs.reduceState((function (state, param) {
                var buffer = param[/* buffer */2];
                var arrayBuffer;
                switch (buffer) {
                  case "index" : 
                      arrayBuffer = ElementArrayBufferSystem$Wonderjs.getOrCreateBuffer(gl, /* tuple */[
                            geometryIndex,
                            elementArrayBufferMap
                          ], GeometryAdmin$Wonderjs.unsafeGetIndices, state);
                      break;
                  case "vertex" : 
                      arrayBuffer = ArrayBufferSystem$Wonderjs.getOrCreateBuffer(gl, /* tuple */[
                            geometryIndex,
                            vertexBufferMap
                          ], GeometryAdmin$Wonderjs.unsafeGetVertices, state);
                      break;
                  default:
                    arrayBuffer = ExceptionHandleSystem$Wonderjs.throwMessage("unknow buffer:" + (String(buffer) + ""));
                }
                return param[/* sendFunc */3](gl, /* tuple */[
                            param[/* size */1],
                            param[/* pos */0]
                          ], arrayBuffer, state);
              }), state, GLSLSenderConfigDataHandleSystem$Wonderjs.unsafeGetAttributeSendData(shaderIndex, state));
}

function _sendUniformNoCacheData(gl, shaderIndex, transformIndex, state) {
  return ArraySystem$Wonderjs.reduceState((function (state, param) {
                param[/* sendNoCachableDataFunc */2](gl, param[/* pos */0], param[/* getNoCachableDataFunc */1](transformIndex, state));
                return state;
              }), state, GLSLSenderConfigDataHandleSystem$Wonderjs.unsafeGetUniformSendNoCachableData(shaderIndex, state));
}

function _sendUniformCachableData(gl, shaderIndex, materialIndex, state) {
  return ArraySystem$Wonderjs.reduceState((function (state, param) {
                param[/* sendCachableDataFunc */4](gl, param[/* shaderCacheMap */0], /* tuple */[
                      param[/* name */1],
                      param[/* pos */2]
                    ], param[/* getCachableDataFunc */3](materialIndex, state));
                return state;
              }), state, GLSLSenderConfigDataHandleSystem$Wonderjs.unsafeGetUniformSendCachableData(shaderIndex, state));
}

function render(gl, uid, state) {
  var transformIndex = GameObjectAdmin$Wonderjs.unsafeGetTransformComponent(uid, state);
  var materialIndex = GameObjectAdmin$Wonderjs.unsafeGetMaterialComponent(uid, state);
  var shaderIndex = MaterialAdmin$Wonderjs.unsafeGetShaderIndex(materialIndex, state);
  var geometryIndex = GameObjectAdmin$Wonderjs.unsafeGetGeometryComponent(uid, state);
  var program = ProgramSystem$Wonderjs.unsafeGetProgram(shaderIndex, state);
  var state$1 = _sendUniformNoCacheData(gl, shaderIndex, transformIndex, _sendAttributeData(gl, shaderIndex, geometryIndex, ProgramSystem$Wonderjs.use(gl, program, state)));
  var data = GLSLSenderSystem$Wonderjs.getGLSLSenderData(state$1);
  var lastSendMaterial = data[/* lastSendMaterial */10];
  var state$2;
  var exit = 0;
  if (lastSendMaterial && lastSendMaterial[0] === materialIndex) {
    state$2 = state$1;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    data[/* lastSendMaterial */10] = /* Some */[materialIndex];
    state$2 = _sendUniformCachableData(gl, shaderIndex, materialIndex, state$1);
  }
  return /* tuple */[
          state$2,
          shaderIndex,
          geometryIndex
        ];
}

export {
  _sendAttributeData       ,
  _sendUniformNoCacheData  ,
  _sendUniformCachableData ,
  render                   ,
  
}
/* ArraySystem-Wonderjs Not a pure module */
