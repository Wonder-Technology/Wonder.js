// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as Curry                      from "../../../../../node_modules/bs-platform/lib/es6/curry.js";
import * as Js_option                  from "../../../../../node_modules/bs-platform/lib/es6/js_option.js";
import * as Log$WonderLog              from "../../../../../node_modules/wonder-log/lib/es6_global/src/Log.js";
import * as GPUStateUtils$Wonderjs     from "../device/gpu/GPUStateUtils.js";
import * as GlslHandleSystem$Wonderjs  from "../../data/render/shader_lib/glsl/GlslHandleSystem.js";
import * as ShaderChunkSystem$Wonderjs from "./glsl/ShaderChunkSystem.js";
import * as ShaderStateCommon$Wonderjs from "./ShaderStateCommon.js";

var webgl1_main_begin = "void main(void){\n";

var webgl1_main_end = "}\n";

function _generateAttributeSource(shaderLibDataArr) {
  return shaderLibDataArr.reduce((function (result, param) {
                var variables = param[/* variables */2];
                if (variables) {
                  var match = variables[0][/* attributes */1];
                  if (match) {
                    return result + match[0].reduce((function (result, param) {
                                  var type_ = param[/* type_ */2];
                                  var name = param[/* name */0];
                                  if (name && type_) {
                                    return result + ("attribute " + (String(type_[0]) + (" " + (String(name[0]) + ";\n  "))));
                                  } else {
                                    return result;
                                  }
                                }), "");
                  } else {
                    return result;
                  }
                } else {
                  return result;
                }
              }), "");
}

function _isInSource(key, source) {
  return +(source.indexOf(key) > -1);
}

function _generateUniformSourceType(type_) {
  if (type_ === "float3") {
    return "vec3";
  } else {
    return type_;
  }
}

function _generateUniformSource(shaderLibDataArr, sourceVarDeclare, sourceFuncDefine, sourceBody) {
  return shaderLibDataArr.reduce((function (result, param) {
                var variables = param[/* variables */2];
                if (variables) {
                  var match = variables[0][/* uniforms */0];
                  if (match) {
                    return result + match[0].filter((function (param) {
                                    var name = param[/* name */0];
                                    if (_isInSource(name, sourceVarDeclare) || _isInSource(name, sourceFuncDefine)) {
                                      return /* true */1;
                                    } else {
                                      return _isInSource(name, sourceBody);
                                    }
                                  })).reduce((function (result, param) {
                                  var type_ = _generateUniformSourceType(param[/* type_ */2]);
                                  return result + ("uniform " + (String(type_) + (" " + (String(param[/* name */0]) + ";\n"))));
                                }), "");
                  } else {
                    return result;
                  }
                } else {
                  return result;
                }
              }), "");
}

function getPrecisionSource(state) {
  var match = GPUStateUtils$Wonderjs.getGpuDetectData(state);
  var match$1 = Js_option.getExn(match[/* precision */1]);
  switch (match$1) {
    case 0 : 
        return ShaderChunkSystem$Wonderjs.getChunk("highp_fragment", state)[/* top */0];
    case 1 : 
        return ShaderChunkSystem$Wonderjs.getChunk("mediump_fragment", state)[/* top */0];
    case 2 : 
        return ShaderChunkSystem$Wonderjs.getChunk("lowp_fragment", state)[/* top */0];
    
  }
}

function _setSource(sourceChunk, param) {
  var sourceTop = sourceChunk[/* top */0];
  var sourceDefine = sourceChunk[/* define */1];
  var sourceVarDeclare = sourceChunk[/* varDeclare */2];
  var sourceFuncDeclare = sourceChunk[/* funcDeclare */3];
  var sourceFuncDefine = sourceChunk[/* funcDefine */4];
  var sourceBody = sourceChunk[/* body */5];
  var top = param[/* top */0];
  var define = param[/* define */1];
  var varDeclare = param[/* varDeclare */2];
  var funcDeclare = param[/* funcDeclare */3];
  var funcDefine = param[/* funcDefine */4];
  var body = param[/* body */5];
  sourceChunk[/* top */0] = sourceTop + top;
  sourceChunk[/* define */1] = sourceDefine + define;
  sourceChunk[/* varDeclare */2] = sourceVarDeclare + varDeclare;
  sourceChunk[/* funcDeclare */3] = sourceFuncDeclare + funcDeclare;
  sourceChunk[/* funcDefine */4] = sourceFuncDefine + funcDefine;
  sourceChunk[/* body */5] = sourceBody + body;
  return /* () */0;
}

function _buildBody(param, webgl1_main_end) {
  var body = param[/* body */5];
  return body + webgl1_main_end;
}

function _buildVarDeclare(param, shaderLibDataArr) {
  var varDeclare = param[/* varDeclare */2];
  var funcDefine = param[/* funcDefine */4];
  var body = param[/* body */5];
  return varDeclare + ("\n" + _generateUniformSource(shaderLibDataArr, varDeclare, funcDefine, body));
}

function _addAlllParts(param) {
  var top = param[/* top */0];
  var define = param[/* define */1];
  var varDeclare = param[/* varDeclare */2];
  var funcDeclare = param[/* funcDeclare */3];
  var funcDefine = param[/* funcDefine */4];
  var body = param[/* body */5];
  return top + (define + (varDeclare + (funcDeclare + (funcDefine + body))));
}

function _execHandle(name, state) {
  var handleFunc = GlslHandleSystem$Wonderjs.getHandle(name, state);
  return Curry._1(handleFunc, state);
}

function buildGLSLSource(_, shaderLibDataArr, state) {
  var match = ShaderStateCommon$Wonderjs.getGLSLData(state);
  var precision = match[/* precision */0];
  var vs = /* record */[
    /* top */"",
    /* define */"",
    /* varDeclare */"",
    /* funcDeclare */"",
    /* funcDefine */"",
    /* body */""
  ];
  var fs = /* record */[
    /* top */"",
    /* define */"",
    /* varDeclare */"",
    /* funcDeclare */"",
    /* funcDefine */"",
    /* body */""
  ];
  vs[/* body */5] = vs[/* body */5] + webgl1_main_begin;
  fs[/* body */5] = fs[/* body */5] + webgl1_main_begin;
  var precision$1 = Js_option.getExn(precision);
  vs[/* top */0] = precision$1 + vs[/* top */0];
  fs[/* top */0] = precision$1 + fs[/* top */0];
  shaderLibDataArr.forEach((function (param) {
          var glsls = param[/* glsls */1];
          if (glsls) {
            glsls[0].forEach((function (param) {
                    var name = param[/* name */1];
                    var type_ = param[/* type_ */0];
                    switch (type_) {
                      case "fs" : 
                          return _setSource(fs, ShaderChunkSystem$Wonderjs.getChunk(name, state));
                      case "fs_function" : 
                          return _setSource(fs, _execHandle(name, state));
                      case "vs" : 
                          return _setSource(vs, ShaderChunkSystem$Wonderjs.getChunk(name, state));
                      case "vs_function" : 
                          return _setSource(vs, _execHandle(name, state));
                      default:
                        return Log$WonderLog.fatal(Log$WonderLog.buildFatalMessage("buildGLSLSource", "unknown glsl type: " + (String(type_) + ""), "", "", "name: " + (String(name) + "")));
                    }
                  }));
            return /* () */0;
          } else {
            return /* () */0;
          }
        }));
  vs[/* body */5] = _buildBody(vs, webgl1_main_end);
  fs[/* body */5] = _buildBody(fs, webgl1_main_end);
  vs[/* varDeclare */2] = "\n" + (_generateAttributeSource(shaderLibDataArr) + vs[/* varDeclare */2]);
  vs[/* varDeclare */2] = _buildVarDeclare(vs, shaderLibDataArr);
  fs[/* varDeclare */2] = _buildVarDeclare(fs, shaderLibDataArr);
  return /* tuple */[
          _addAlllParts(vs),
          _addAlllParts(fs)
        ];
}

export {
  webgl1_main_begin          ,
  webgl1_main_end            ,
  _generateAttributeSource   ,
  _isInSource                ,
  _generateUniformSourceType ,
  _generateUniformSource     ,
  getPrecisionSource         ,
  _setSource                 ,
  _buildBody                 ,
  _buildVarDeclare           ,
  _addAlllParts              ,
  _execHandle                ,
  buildGLSLSource            ,
  
}
/* Log-WonderLog Not a pure module */
